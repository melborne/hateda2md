<?xml version="1.0" encoding="UTF-8"?>
<diary>
<day date="2005-12-19" title="">
<body>
*1134973128*マリオカートDS with WiFiは楽し過ぎる件について
拝啓　任天堂様。マリオカートDSは楽しすぎます。WiFiすると心臓がドキドキします。今後ともよろしくお願いいたします。　敬具

asin:B0002FQD7M:image:small
asin:B0002FQD7M:title

*1134973129*世界のみんなが速すぎる件について
拝啓　WiFiでマリオカートDSを楽しんでいる世界の皆様。とにかく速すぎます！君たちはどこでどういった訓練を積んでいるのですか？教えてください。　敬具

asin:B000BX7YRI:image:small
asin:B000BX7YRI:title
</body>
</day>
<day date="2005-12-20" title="">
<body>
*1135046820*Canon IXY Digital L3に惑わされている件について

拝啓　キヤノン様。　美しさでいって、あなた以外の選択肢はありません。しかし、望遠端の開放F値が5.4というのはどうなんだろう。料理は苦手ということか。とにかく僕を惑わせないでください。　敬具

http://arena.nikkeibp.co.jp/rev/20051124/114391/index.shtml


asin:B000BGEAR2:image:small
asin:B000BGEAR2:title

*1135087026*ちず窓がなかなかよいかも？な件について

拝啓　昭文社ちず窓制作委員会様。　古くて新しいGoogle様のGoogle localやGoogle Earthには随分と驚かされました。しかし、あなたもなかなかやるじゃないですか。男というものは、何故か地図が大好きなのです。　敬具


[http://local.google.co.jp/maps?q=%E6%98%AD%E6%96%87%E7%A4%BE&amp;near=%E5%8D%83%E4%BB%A3%E7%94%B0%E5%8C%BA%E9%BA%B9%E7%94%BA%EF%BC%93&amp;btnG=%E6%A4%9C%E7%B4%A2&amp;sll=36.562600,136.362305&amp;sspn=23.257402,31.684570&amp;t=&amp;hl=ja&amp;cid=35684108,139738742,6343705222926448571&amp;li=lmd&amp;z=0:title]
Google local


[http://earth.google.com/:title]


&lt;a href=&quot;http://chizumado.jp/view?position_id=332845&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://chizumado.jp/RasterMap?position_id=332845&quot; border=&quot;1&quot; alt=&quot;昭文社&quot;/&gt;&lt;/a&gt;
ちず窓
</body>
</day>
<day date="2005-12-21" title="">
<body>
*p1*日経平均が専門家の予想を超えたレベルにある件について
拝啓　ウォーレン・バフェット様。


日経平均株価が専門家の年内予想株価レベルを超えて16,000円に限りなく近づいています。これはちょっとしたバブルなのでしょうか。あなたはMr.Marketは気まぐれだから、そんなものは気にせずに企業の内在価値に注目しなさい、そして、株価が内在価値に対して十分に割安にあるときにその企業に投資をなさいとおっしゃいます。その努力はします。しかしよく分からないというのが正直なところです。


最近、Wal-Mart Storesに投資をされたそうですね。あなたの賭けに乗るのが安全なのは分かっているのですが、私は、自立するために、私のホーム・カントリーで今後も投資をしていきたいと思います。

敬具


ISBN:4939103218:detail
</body>
</day>
<day date="2005-12-22" title="">
<body>
*p1*ある言語に対するコンプレックスが増幅している件について
拝啓　金田一春彦様。


正確な日本語すら操れない自分ですが、新たな言語に対するコンプレックスが以前にも増して日々増幅しています。それは、世界の公用語である英語に対してではなくて、プログラミング言語に対してです。自分の生活におけるネットへの依存度を考えると、この言語に対して、将来におけるディジタル・デバイドならぬ言語デバイドの恐怖すら覚えます。大袈裟ですか？


折角やるのだったら、新しくてクールなものに挑戦してみたいと思いますが、Rubyというのはどうですか？日本人の方（まつもと　ゆきひろさん）が発明されていますから、日本語に近いのですよね？そして、Ruby on Railsと進めばよいのですよね？リアルの世界で家を建てるのは難しそうなので、是非ともこの言語を習得して、将来ネットの世界に自分の家を建てたいと思います。

敬具


[http://www.ruby-lang.org/ja/:title]


[http://blog.livedoor.jp/zep716/archives/24182409.html:title]


ISBN:4756132545:detail
</body>
</day>
<day date="2005-12-23" title="">
<body>
*p1*音楽が音楽を超えてメッセージを発する件について
拝啓　小田和正様。


「クリスマスの約束」を拝見しました。すばらしい番組でした。あなたの作り出したメロディはあなた自身のセンスと努力の産物なのでしょうけれども、あなたのその歌声はまさに天からのギフトだと思います。５８歳になった今でもその歌声を維持しながら精力的に音楽活動を続けているあなたに、どれだけの人が感謝しているか分かりません。


私は必ずしもあなたのファンというわけではないのですけれども、妻に付き合って毎年この番組を拝見しています。２年前には現地にも伺いました。私はおそらくあなたと異なって、音楽が音楽の枠を超えてメッセージを発するということはないと考えていますが、この番組を拝見するたびに、そのような可能性を垣間見る気がしています。それくらいにあなたの歌には力があると思います。

敬具


asin:B00006591F:detail
</body>
</day>
<day date="2005-12-25" title="">
<body>
*p1*ローンがふくらんでしまっている件について
拝啓　たぬきち様。


先日私はローン全額を確かにあなたにお支払いしましたよね？それでまたゼロからというのはどういうことなんですか？はい、確かに新しい家を建て替えていただきましたよ。でも、土地の所有権は私にあるのではないのですか？あのローンは家の建て替え費用だったのですか？それともコピーマシンのリース契約のような新しいタイプの契約なのですか？あいまいな口約束であなたと契約してしまいましたが、もっとよく考えるべきでした。今日だってクリスマスというのに、果物（オレンジと梨）の収穫に追われています。


そんな状況ですから私がカブで一発当てようと考えてしまうのも仕方の無いことと分かっていただけますよね。私のどうぶつの森に平和が訪れるのはいつなのでしょうか。


敬具


asin:B0002FQD8G:detail
</body>
</day>
<day date="2005-12-26" title="">
<body>
*p1*小売業というものが今後どうなっていくのか分からない件について
拝啓　鈴木敏文様。


御社セブン＆アイHLDGS.が西武百貨店とそごうの持ち株会社であるミレニアムリテイリングを完全子会社化するという今日のニュースには正直びっくりさせられました。想定の範囲外です。御社のロゴが発表になったときにその図柄を見て、まさか今の時流に乗っちゃってＴＢＳを買収するつもりなのでは？とちょっと心配しましたが、稀有に終わりました。百貨店の買収というのは正道なのでしょう。


それにしても時代の流れというものを感じます。この１５年間で国民の消費は都市部の百貨店から郊外の総合スーパーへそして更に小商圏のコンビニエンスストアやアパレル専門店へと流れていきました。そして、御社においては、最後の勝者であるセブン-イレブンがイトーヨーカ堂を飲み込んで、更に今回ミレニアムリテイリングを飲み込みました。３０年前のあなたの仮説・判断が今検証されたのだと思います。競合（内側）ではなく消費者（外側に行く人）を見ろと常にあなたが仰っているのは、このような時代背景を身を持って感じておられるからなのですね。


買収によるシナジー効果というものが存在するのかは私には分かりませんが、この買収が適正な価格によって行われておりかつこれが次の時代に対するあなたの新たな仮説に基づく行動であるならば、私はこれを支持したいと思います。

敬具


[http://www.7andi.com/:title]


ISBN:4062120984:detail

ISBN:4334012213:detail

*p2*GameCubeが売れていないのは致し方がないと思っている件について
拝啓　岩田聡様。


NintendoDSが国内販売で500万台を超えたという記事を読みました。この成功はあなたをはじめとする任天堂の方々の論理的な戦略の勝利であると思います。ユーザの嗜好を読みづらい現在のこの業界において、これはほんとうにすばらしい快挙です。あなたの仰るようにこの成功はTouch! Generations戦略における新たなユーザ層の獲得によるものなのでしょう。


一方で私には一つ気になることがあります。それはGameCubeの不振です。もちろんその主因は他社据え置き機の台頭にあるのですが、私はNintendoDSが３Ｄ描画機能を持ったということにもその原因があると考えています。美しく描けるということも大事なことなのでしょうけれども、描けなかったものが描けるようになることのインパクトに勝るものは無いでしょう。NintendoDSにおける最大の功績は携帯機で３Ｄ描画を成し遂げたことだと私は思います。その結果、３Ｄのマリオが外に持ち運べるようになりました。つまり私から見てGameCubeの真の後継機というのは来年に発売を控えているレボリューションではなくて、このNintendoDSであると思うのです。であるならばGameCubeの不振は致し方がないことなのです。


御社はレボリューションにおいて新たなコントローラを導入する予定です。３ＤをNintendoDSに譲った以上、次世代据え置き機においては３Ｄでは勝負できないと考えた、そうなのですね？そして導いた答えが３Ｄを画面の中から今度はユーザの側へ持ち出した、そういうことなのですね？３Ｄのゼルダを操るのではなく、私自身がゼルダになれるのですね？すばらしい！まったくその発想の柔軟性には驚かされます。この新たな挑戦がうまくいくか私には分かりませんが、本当にこれは高く評価されることだと思います。

敬具


レボリューション:[http://www.nintendo.co.jp/n10/tgs2005/index.html:title]


asin:B00005QDJQ:detail


asin:B000AFVHZ2:detail
</body>
</day>
<day date="2005-12-28" title="">
<body>
*p1*やはり任天堂のCMはあなたのような人でなければ務まらない件について
拝啓　松嶋菜々子様。　NintendoDSの特設サイトであなたのTV-CMを見ました。何度も繰り返し見ました。すばらしいです。あの短い時間の中であなたはそこに喜怒哀楽のすべてを表現しました。ナチュラルにそういう表現をこなせるところに、力量だけではない天性のものを感じます。ゲーム機(これをゲーム機と呼ぶのは適切ではないと思いますが)を通して人々に喜怒哀楽をもたらす、これこそがスポンサーである任天堂さんの望むところでしょうから、あなたはまた一つすばらしい仕事をしましたね。ですから安心してください。あなたの脳が老化していたなんていう事実はあなたの魅力を損なう何ものにもなり得ないことを！このCMを見て本作品「もっと脳を鍛える大人のDSトレーニング!」の購入を決意する人が多く現れると思います。前作で２０歳にまで達してしまった私の脳には今作は必要ないと考えていましたが(自慢)、どうやらまた私もその一人になりそうです。最後に、あなたのことですから心配はしていませんけれども、XBOXのイベントには近づかないようにしてくださいね。　敬具


[http://touch-ds.jp/mfs/mottotraining/index.html:title]


asin:B000BRYNUU:detail
</body>
</day>
<day date="2006-03-01" title="">
<body>
*p1*NHK「プロフェッショナル:仕事の流儀」はよい番組だ
NHK 「プロフェッショナル:仕事の流儀」を毎回見ている。録画しておいた2月28日放送分を先ほど見終えた。WHOの医師、進藤奈邦子さん。自分の子供に、「仕事は楽しいものなのよ。楽しくなかったら人生辛いじゃない。」と言っていたのが印象的だった。人間の強さを感じた。自分を少し恥じる。

[http://www.nhk.or.jp/professional/backnumber/060228/index.html:title]

*p2*いよいよ発売、ニンテンドーDS Lite!
ニンテンドーDS Liteがいよいよ発売されます。池袋ビックカメラには既に50人はならんでるそうな。任天堂によれば3月中にLite45万台以上、旧DS20万台以上の発売を予定。ちょっとたらんだろうね。僕も新しいのを早くほしいけど、もう少し我慢します。みんな風邪をひかんようにね。

http://www.nintendo.co.jp/index.html
</body>
</day>
<day date="2006-03-02" title="">
<body>
*p1*ニンテンドーDS Liteが発売されました!
なんとビックカメラ有楽町店には600人(!)も並んだそうな｡みんな気合入ってるね。他の2色が発売される3月11日もすごいことになりそう｡この日は土曜日だから小学生、中学生、高校生も並べるし｡おそらく男子に人気となるネイビーが発売されるしね。任天堂びいきな僕としてはうれしい限りです。当日が晴れますように。

[http://www.famitsu.com/index.html:title]
</body>
</day>
<day date="2006-03-03" title="">
<body>
*p1*WindowsのMac化計画進行中!
Windows の見た目Mac化計画が進んでいます。FlyakiteOSX3.5､Multi-pluginをInstallして､ObjectDockを Launcherとして使っています。やあ､ぐっとよくなりましたよ。マシンがDellの非力なモデルなのでちょっと重くなりましたが、そんなことはぜんせん気にしません。それで今日は昨日注文したApple Keyboard(US)が届いたので早速接続。DriverのInstallに手惑いましたが何とかうまくいきました｡なかなかいいですね｡ AppleStoreで3,570円(送料なし）って､ちょっと安くないですか?これで次はMｉghtyMouseといきたいところですが､直ぐには予算が下りそうにありません。最初に買ったApple製品がAirMacExpress､次いでiPod Shuffle､で今回のKeyboard｡なんか周りから攻めてる感じです。本丸にたどり着くのはいつの日か.....｡

参考にしたサイト

[http://osx.portraitofakite.com/:title]
[http://www.wwwwww.tv/mac/extreme.html:title]
[http://neoblog.blog6.fc2.com/:title]
[http://www.diatec.co.jp/support/details/wxp-101usbsetup.html#nops2:title]
</body>
</day>
<day date="2006-03-04" title="">
<body>
*p1*真理を追究すること
おそらくよい仕事をするというのは、その仕事の真理を追究するということなんだろう｡例えば、株式投資で言えば､目標とする投資家の投資を通じて、株式投資というのはいったいどういうことなのか､なぜ投資家が利益を得ることができるのか､ということを考え続けることなのだと思う。目標とする投資家はあくまでもその媒体であって真理ではない｡ということを考えていたら、棋士の米長邦雄さんが同じことを言っていた。


ISBN:4877120386:title
</body>
</day>
<day date="2006-03-05" title="">
<body>
*p1*WebCalendar '30 Boxes'はよさげだ
[http://money.cnn.com/popups/2006/biz2/next_net/frameset.exclude.html:title=http://money.cnn.com/popups/2006/biz2/next_net/frameset.exclude.html:title=The Next Net 25というCNNの記事]で紹介されていた[http://30boxes.com/:title=30 Boxes]というWeb Calendarを使ってみました｡


トップの入力ボックスに予定を日時と共に入力すればスケジュールが入ります。
&gt;&gt;
会議 3/8 2-3pm repeat weekly
&lt;&lt;
などとします｡また､
&gt;&gt;
会議 tag ビジネス
会議 tag red
 *会議
&lt;&lt;
でタグ付けができます｡red, blueなどで色付けができ､[*]でImportantのタグになります｡

日本の休日設定がまだなようなので､自分は'春分の日 4/21 tag red'などととりあえず今年分を手入力しました｡家族との共有設定もできます｡動作もUIも快適です。

[http://www.netjaxer.com/:title=NetJaxer]と共に使えば、ローカルアプリのように使うことができます。

今までMozillaプロジェクトの[http://www.mozilla-japan.org/projects/calendar/sunbird.html:title=Sunbird]というカレンダーを共有設定にして使っていたのだけれど、今ひとつなじめないでいたところ､よいものを紹介してもらいました。
</body>
</day>
<day date="2006-03-08" title="">
<body>
*p1*GoogleのCalendar
先日､[http://30boxes.com/:title=30Boxes]というCalendarはよさげだということを書きましたが、Googleも「CL2」というAjax対応Calendarを作っていたんですね。[http://www.techcrunch.com/:title]というサイトにスクリーンショットと概略の情報がアップされています。

QuickAddという30Boxesと同様の簡易入力機能を持っており、またGmailとの統合も計画されているようです｡なんか最強のCalendarになりそうですね｡身の回りがどんどんGoogleで固められていきます｡Google Search,Desktop,Gmail,Google Talk,Google Earth,Picasa,CL2...ちょっとこわい｡
</body>
</day>
<day date="2006-03-11" title="">
<body>
*p1*はてなには色がない｡
はてなのサービスを使い始めてからまだ数ヶ月しか経っていないので､まだそのDeepな部分は見えていないのだけれども､なんとなくはてなのサービスには色がないのかなあと感じた。AppleやNintendoなどにはとても濃い色を感じるし、AmazonやGoogleやlast.fmなどのWebサービス会社にも色を感じる。Googleを関数電卓に例えればきっと僕はその四則演算機能ほどしか使っていないのだろうけれども､その色は感じられる。でもはてなにはどうもそれが感じられないのだ。企業の色というのがなんなのかは分からないけれども､ふとそう思った。
</body>
</day>
<day date="2006-03-13" title="">
<body>
*p1*人は相対的な存在である。
人は絶対的な存在ではなく、相対的な存在である。
だから「私はこういう人である｣とか「自分のアイデンティティは何だ｣とかを公言してもしようがない｡
自分は対峙する人の数だけ存在する。
自分探しの旅は永遠に終わらないのだ｡
それが見つかるような気がするのは対峙する人間が似ているからに過ぎないのだろう｡

*p2*はてなは集合知だ｡

[http://d.hatena.ne.jp/keyesberry/20060311:title=3月11日の日記]で「はてなには色がない｣ということを書いた。その理由が､はてな近藤さんの[http://d.hatena.ne.jp/jkondo/20060312/1142098012:title=「正しい」って何だろう]における以下の記述から少し分かった気がする。

&gt;&gt;
自分が一番知識が多いから正しいはずだ、とか、自分が一番長い時間考えたから正しいはずだ、みたいな人の話は眉に唾を塗って聞くのが良い対処法でしょう。あと、「この人の意見は必ず正しい」みたいに特定個人を神みたいに崇めるのも自分の思考が停止していて危険だと思います。「天才」とか「専門家」とか「権威ある」みたいな言葉は自分の思考にフィルターをかけるので注意が必要です。

一方で、議論の結論を導くのに必要な全体的なレベルの正しさと言うのは、「いかに多くの人の意見を代弁しているか」という事なのだと思います。「進む」ボタンは右が自然だと思う人が6割、左だと思う人が4割いるとして、もはやセオリーも常識も天才もへったくれもないわけです。6割が自然だと思うならば、結論としては右が「正しい」でしょう。
&lt;&lt;
ここで言っているのは､多数決という集合知の結論ですから､「正しさのこと｣ではなくて「合理性のこと｣なのでしょう｡しかしながらこの合理性が常に正しいとは限らない。

証券投資の世界では､株価に影響を与えるようなニュースや材料は市場参加者が多いために直ぐに株価に織り込まれてしまい､株価は常に合理的な価格にある｡従って市場平均を超えるような運用成績を長期間に亘って残せる人はいないと言われている(効率的市場仮説)。しかし40年以上にも亘って年率平均20%以上の成績を残したウォーレン・バフェットのような人間が存在する。30年前のスーパー全盛の時代に､社内や社外の専門家の反対を押し切って鈴木敏文氏はセブン-イレブンを設立し､現在のようなネットワークを完成させた｡

集合知からは導き出せない正しさがここにはあるのではないか｡不確定なものに対する正しさは､何か信仰的な要素も無視できない｡それが組織の色なのかもしれない｡
</body>
</day>
<day date="2006-03-15" title="">
<body>
*p1*もうちょっと複雑かもな
http://d.hatena.ne.jp/jkondo/20060314/1142377289
想像してみよう｡大好きな人が毒殺された｡10年掛けてその人のことを思い出として消化していった｡あるブログに出会った。直ぐにその知性に魅了されてファンになった｡そして過去との関わりを知った。
過去の事実は現在とは切り離せない。一生背負っていかなければならないことだってある｡それによって現在の行動が制限を受けることもあるだろう｡それはしょうがないんだろう｡才能をつぶしてはならないと言うのは､才能がなければ死んでもよいと言っている。それも差別だろう。なんらかの制限を受けるのはしょうがないんだよ｡

*p2*Googleの未来
Googleの経営者が言っていること
[http://d.hatena.ne.jp/umedamochio/20060223:title=「世界中の情報を整理し尽くす｣]

Googleの経営者がやっていること
[http://b.hatena.ne.jp/entry/http://japan.cnet.com/special/story/0,2000050158,20096559,00.htm:title=グーグル経営陣、大量の株式売却]

僕の机の中の情報は彼らには整理できないから言っていることは現実的ではないよね｡
彼らがまだ大量の自社株を保有しているということが重要なんではなくて､さしあたり必要とは思われないほどの大量の現金を手にしたということが重要だよね。これらの事実だけで、僕はGoogleには投資できないんだよ。
</body>
</day>
<day date="2006-03-18" title="">
<body>
*p1*自由
不自由ゆえに自由を求め
自由を得て不自由となる

*p2*仕合せ
自分の外に仕合せを求め
自分の中に仕合せを見つける
</body>
</day>
<day date="2006-03-19" title="">
<body>
*p1*そして最後にレボリューション(仮称)が勝利するのだ！
任天堂ファンの皆様。もうシナリオは決まっております。そう我が軍の完全勝利です！

[http://gonintendo.com/?p=1546:title=Ninten Wars Revolution]

</body>
</day>
<day date="2006-03-20" title="">
<body>
*p1*現代の資本主義経済は本質的にバブル型経済なのだろう
累進税は富を再配分する。資本主義もまた新しい資本家を生み出すからそれと同様の機能を持っている。したがって税の構図と同様に資本家と企業家の間でも資本を巡って綱引きが行われる。この綱引きは企業の適正な価格を導き出す。
しかしながら現代の資本家は労働者により組成されるファンドである。ファンドには自らの資産をリスクから保全する管理者がいない。管理者なき市場。バブルおよびその崩壊の土壌が出来上がった。
</body>
</day>
<day date="2006-03-25" title="">
<body>
*p1*床屋
床屋に行く前に鏡の前に立つ。髪の毛が思いのほか整っていて今日は床屋に行かなくてもいいんじゃないかと一瞬思う。
それでも意を決して床屋に行く。
床屋から帰ってきて鏡の前に立つ。さっぱりした自分を見てやっぱり床屋に行ってきてよかったと心から思う。
床屋が教えてくれる自分の中の心のバイアス。

*p2*ヘアドライヤー
温泉に行ってヘアドライヤーを使う。たいてい噴出し口が横向きの形で置いてある。
噴出し口を縦に回して髪を乾かす。噴出し口を横向きに戻して温泉をあとにする。
今度行ったときほかの人の使い方を観察してみようと思う。

*p3*Googleはギミックがすごいんだ。
Googleの何がすごいのかっていうことに関してはいろんな意見があるけれども、僕の中ではそのギミックがすごいんだよ。直感的で効果的なんだ。ギミックはユーザ(こちら側)とコンピュータ(あちら側)の間の壁を低くして、その仲をうまく取りもつんだ。写真管理ソフト[http://picasa.google.co.jp/:title=Picasa]をいじってもらえれば僕が言っていることがわかるよ。ねっ？今まで使っていた写真管理ソフトにもう戻れなくなりそうだろ？[http://earth.google.com/:title=Google Earth]は言うまでもないよね。地球をDoubleClickしたときに一瞬遠ざかってそれからダイブしていく。おおっ！って感じだよね。
早々[http://finance.google.com/finance:title=Google Finance]も使ってみたけど、やっぱりGoogleは裏切らなかったよ。長期短期でシームレスのチャート表示はほんとにすばらしい。Microsoftの株価を検索するのに「microsoft」も許してくれる。[http://finance.yahoo.com/:title=Yahoo!Finance]では蹴られちゃうけどね。こういう細かい部分に対するこだわりがGoogleには垣間見れるんだよね。よく分からないけど、こういうのってGoogleにしかできない特別な技術じゃないよね？
僕の中ではね、コンピュータ関連の会社ではApple Computerと任天堂がギミックがいいなあって思ってるんだ。結局ね、ユーザは自分の目の前にある情報をその五感を使ってコントロールできればよくって、その情報が自分の足元にあるものなのか地球の裏側にあるものなのかには興味がないんと思うんだ。その観点からするとね、この3つの会社は僕の中では競合するんだよ。ギミックに対する関心はその企業のDNAなのかもしれないね。そうだとすると、そういうギミックを持った会社に打ち勝つのは意外と難しいんじゃないかな。
</body>
</day>
<day date="2006-03-27" title="">
<body>
*p1*無知は仕合せ
知らないことを知ることは喜び
既知は人の虚栄心を満たすだけ
だから無知は仕合せ

</body>
</day>
<day date="2006-03-28" title="">
<body>
*p1*Webとモラルハザード
モラルは思考を停止する。
Webはモラルハザードを加速する。
モラルハザードは時に再考を促す。
でもコントロールは最終的に創作者の元にあることを忘れてはならない。

*p2*矛盾
将来が分からないから人は不安を覚える。
将来が分かってしまったら生きる喜びが失われる。
この矛盾に自分は苦笑いせずにはいられない。

</body>
</day>
<day date="2006-04-09" title="">
<body>
*p1*Web2.0は非ビジネスになる
梅田望夫(id:umedamochio)氏の「Web進化論」を読んだ。良い本だ。Webにそれなりの密着度を持って接しており氏のブログの読者でもあるから、新しい情報が得られるということは無かったのだけれども、情報革命という時間軸におけるこれまでの史実、現在地および近未来がこの本には明瞭に示されている。そして現在の自分のWebに対する立ち位置を見たときに、これからの生き方を改めて考えさせられるものとなった。

Webは第２の地球である。おそらくそこは非ビジネスつまり営利を目的としない組織が中心となって運営されることになる。利用者との間に緩い関係を望むお金に欲のない若者たちが新しい大地を支える。Web2.0の進化と共に人々はそこにアバタでない自分を開放するだろう。人々はこの大地ではどこかに帰属することなく無数に繋がるだけである。その結果大地はリアルとなり人々のわが家となる。第２の地球の出現は第１の地球の在り様に影響を与え、その主従関係は逆転する。

そんな夢想が許されそうだ。

やはり読んでよかった。


ISBN:4480062858:detail
</body>
</day>
<day date="2006-04-12" title="">
<body>
*p1*Web2.0はパンドラの箱か
新たな価値の創造は古い価値を破壊する。創造された新たな価値の総量から古い価値の総量を差し引いた残りが人類にとっての意味である。Web2.0は新たな価値を創造するであろう。果たしてその価値の総量は古い価値の総量を超えられるのだろうか。Webの進化を誰も止めることはできない。人類はパンドラの箱を開けてしまったのかもしれない。

[http://www.pandora.com/:title=PANDORA]
</body>
</day>
<day date="2006-04-14" title="">
<body>
*p1*Radio 2.0はWeb 2.0を凌駕するのか

Webの進化のスピードは凄まじくその表層に付いていくのにも苦労する。今日もまた新たなWeb2.0が生まれた。そうGoogle Calendar([http://www.google.com/googlecalendar/overview.html:title=リンク])だ。Googleは僕たちの机の引き出しから次々と情報を引き出そうとしている。僕にはGoogleが神であるというよりも、光をも飲み込もうとするブラックホールであるかのように感じるときがある。

しかし僕は今日、別のすごいものを見つけた。

STOP THE SMAPレポ([http://blog.goo.ne.jp/smapcafe/e/b5b9ce253c7425ded48d83b294d64dbb:title=リンク])

Radioの進化である。Webの凄まじい進化の影に隠れてRadioがここまで進化していたとは。迂闊だった。そうだ、これはきっとRadio 2.0に違いない。2.0がテクノロジーではない何かによって既に実現されていたのだ。SMAP恐るべし。もこみち恐るべし。

今日僕が見た２つの進化は融合することなくそれぞれが僕らの未来を築いていくことになるんだろうか。

*p2*SNSはWebの規模といずれ一致する

[http://d.hatena.ne.jp/keyesberry/20060409:title=4月9日の日記]でWebの未来を夢想した。しかし夢想で終わらないかもしれない。アメリカではその兆候が既に現れている。

[http://www.future-planning.net/x/modules/news/article.php?storyid=1334:title=ネット・コミュニティ史上最大の危機！！ＳＮＳマイスペースの文化モラル問題]

米国では既にWebへの自分の開放が始まっている。マイスペースやmixiなどのSNSはいずれWebの規模に拡大するかまたは壊れてそれと一致する。Webへの自分の開放はWebの信頼を高め結果人々は無数に繋がる。年齢、職業、趣味、性別、地域、国籍を問わずにまさにWebの如くに繋がる。相手に対する信頼だけを頼りに繋がる。そこにいるだけで圧倒的多数の友が生まれる。そうなったとき既存の何かが破壊され新しい何かが生まれるのだろう。その進化が避けられないものならばそこに不安よりも希望を持とうと思う。
</body>
</day>
<day date="2006-04-16" title="">
<body>
*1145165271*世界ドミノ大会開催！

全体として製作者のすごい気合を感じます。

-&lt;span style=&quot;font-weight:bold;&quot;&gt;おっ、すげー編&lt;/span&gt;
まずは、日本が誇るMr.インクレダブル！ピタゴラスイッチ、まとめ版。

Incredible Machines - Google Video (http://video.google.com/videoplay?docid=6176491654107670145&amp;pl=true)


まだあるぞ。

YouTube - Pythagoraswitch part19 (http://www.youtube.com/watch?v=XLaSq1cARXc&amp;search=domino)

YouTube - Pythagoraswitch part22 (http://www.youtube.com/watch?v=OKcXnzT5C-o&amp;search=domino) 

YouTube - Pythagoraswitch part23 (http://www.youtube.com/watch?v=n-mliztiyCY&amp;search=domino) 


まだまだあるぞ。

YouTube - Pythagoraswitch part25 (http://www.youtube.com/watch?v=Eb57Zw7Yovw&amp;search=domino)

YouTube - Pythagoraswitch part26 (http://www.youtube.com/watch?v=fVhye3_T6YU&amp;search=domino)

YouTube - Pythagoraswitch part27 (http://www.youtube.com/watch?v=vvM4ikex8ZI&amp;search=domino) 


さすがホンダの車は走りが違う！

pub - honda accord domino - Google Video (http://video.google.com/videoplay?docid=-4341945450931442754)


これもいいねぇ。

YouTube - Domino effect (http://www.youtube.com/watch?v=_W007_TMHb8&amp;search=domino)


ん？最後失敗？

YouTube - Die Skateboard &quot;Dee Skateboard&quot; (http://www.youtube.com/watch?v=qF3xzHm9pHw&amp;search=domino) 


ドイツから？大掛かりでドイツぽくないけど、これはすごいよ。ワイルドで繊細だよ。30分あります。

Def Lauf Der Dinge - Google Video (http://video.google.com/videoplay?docid=3812507039888532441&amp;pl=true) 


オランダから大規模ドミノ。50分。いきなりミスるんだけど、そのおかげでスタータの美しい人拝めます。ラストもすごい。ミス・オランダだよあの人、絶対。

Domino Day 2004 - Google Video (http://video.google.com/videoplay?docid=6233517002767330133&amp;q=domino&amp;pl=true)


-&lt;span style=&quot;font-weight:bold;&quot;&gt;ハハハッ、笑う編&lt;/span&gt;

人です。人の列です。

domino - Google Video (http://video.google.com/videoplay?docid=-8470492421673675585&amp;q=domino&amp;pl=true)


意外と盲点。

YouTube - domino (http://www.youtube.com/watch?v=Biys943JmgU&amp;search=domino) 


ボッカーン！って。

YouTube - The Contraption (http://www.youtube.com/watch?v=Zn0G92k4yes&amp;search=domino)


-&lt;span style=&quot;font-weight:bold;&quot;&gt;へぇ、ゲームでできるんだ編&lt;/span&gt;

A Half-Life 2 Domino effect to kill Breen - Google Video (http://video.google.com/videoplay?docid=4787247949216613776&amp;q=domino&amp;pl=true)

A Half-Life 2 Domino effect to drown a Zombie - Google Video (http://video.google.com/videoplay?docid=4049365580674350429&amp;q=domino&amp;pl=true)

Halflife2 domino map - Google Video (http://video.google.com/videoplay?docid=3314607377572205485&amp;q=domino&amp;pl=true) 


以上。



asin:B000CR8PP8:detail

ISBN:4804703233:detail

*p1*任天堂は金のなる器を手に入れた！

ニンテンドーDS Liteが売れ続けている。
岩田社長と宮本さんはウハウハだ。
証拠写真(音が出ます)↓
[http://dsisprintingcash.ytmnd.com/:title]

アメリカの人たちはすごいの作りますね。ほんとに。



asin:B000EM0M4I:detail
</body>
</day>
<day date="2006-04-17" title="">
<body>
*p1*ゲームボーイは現代アートのキャンバスだ！

f:id:keyesberry:20060417155119j:image:w200


渋谷パルコで開催中の任天堂&quot;bit Generations&quot;アート展を本日見てきたぞ。下手な写真を以下にアップしたので見ておくれ。

[http://postagie.blogspot.com/:title]


まあ商売としてはあれだが、携帯ゲーム機をアートのプラットフォームとするという発想は発展性があるかもしれないぞ。要するにアーティストたちのゲームに対する関心が高まれば、将来、文化としてのゲームのステージが1UPするかもしれん。地道だが必要だ。5年後くらいに期待しよう。


asin:B000ASA7L4:detail
</body>
</day>
<day date="2006-04-18" title="">
<body>
*p1*Hello,world!
f:id:keyesberry:20060418105933j:image:smallf:id:keyesberry:20060418105931j:image:smallf:id:keyesberry:20060418105930j:image:smallf:id:keyesberry:20060418105930j:image:smallf:id:keyesberry:20060418105928j:image:smallf:id:keyesberry:20060418115023j:image:small
f:id:keyesberry:20060418105927j:image:smallf:id:keyesberry:20060418105928j:image:smallf:id:keyesberry:20060418110034j:image:smallf:id:keyesberry:20060418105930j:image:smallf:id:keyesberry:20060418110039j:image:smallf:id:keyesberry:20060418115012j:image:small
</body>
</day>
<day date="2006-04-19" title="">
<body>
*p1*ブログリーダーは金門橋、僕はペンキ塗り

f:id:keyesberry:20060419180748j:image


ブログリーダーの更新ボタンを押す。


$ 端から順に読み始める。
最後まで読み終わって、また更新ボタンを押してみる。
読んでる間にまた新しい投稿があったようだ！


端から順に読み始める。
最後まで読み終わって、また更新ボタンを押してみる。
読んでる間にまた新しい投稿があったようだ！
D.S.($に戻って繰り返し)


読み終わったらまた最初から。
ブログリーダーはまるで金門橋(Golden Gate Bridge)のようだ｡
塗り終わったらまた最初から。
そして僕はWebのペンキ塗り。


---------------------------------------------------------
&gt;&gt;
　1930年代に作られたゴールデンゲートブリッジは鉄で出来ていて、潮風による錆びから橋を守るために、毎年ペンキを塗り直さないといけない。なにしろ全長3kmの長い橋で、しかも強風下での高所作業である。大勢の塗装職人が橋の一端から塗装を始めて、全部ペンキを塗り終わるのに一年かかる。その頃には最初に塗った部分は塗り直しの時期を迎え、職人団はまた最初に戻ってペンキ塗りを続ける。かくして無限ループのペンキ塗りが今も続いている。
&lt;&lt;
市民ライター通信　第11号より
http://www2.ocn.ne.jp/~mmwriter/new_ver/contents/backnumber/backnum11.htm


&gt;&gt;
「サンフランシスコのゴールデンゲートブリッジにはペンキ塗り専門のスタッフがおり、一方からもう片方まで、繰り返し繰り返しペンキを塗っている。セキュリティも同じこと。常に改善に改善を重ねていく必要がある」（同氏）。そして、こうした同社の取り組みが、顧客へのコミットメント、すなわち「Unbreakable」につながるとした。
&lt;&lt;
IT media エンタープライズ･ニュースより
http://www.itmedia.co.jp/enterprise/0302/28/epn16.html


でもこれはジョークだったんですね。知りませんでした。
&gt;&gt;
Painting the Bridge is an ongoing task and the primary maintenance job.  The Bridge paint protects it from the high salt content in the air, which rusts and corrodes the steel components.  Many misconceptions exist about how often the Bridge is painted.  Some say once every seven years, others say from end to end each year.  Actually, the Bridge was painted when it was originally built with a red lead primer and a lead-based topcoat.  For the next 27 years, only touch up was required.  By 1968, advancing corrosion sparked a program to remove the original paint and replace it with an inorganic zinc silicate primer and vinyl topcoats.  The topcoat was changed to acrylic emulsion in 1990 to meet air quality requirements.  The original program was completed in 1995 with continuous touch up on areas with the most severe erosion.  
&lt;&lt;
Golden Gate Bridge, Highway and Transportation Districtより
http://goldengatebridge.org/research/factsGGBIntOrngPaint.php

こんな風にペンキを塗っています。
http://goldengatebridge.org/multimedia/index.php

</body>
</day>
<day date="2006-04-20" title="">
<body>
*p1*みんなでビデオゲームのはじまりを見よう！
本日MOTHER3発売でみなさん、それどころではないでしょうが.....


Google Videoにポストされているディスカバリーチャンネルの番組「[http://video.google.com/videoplay?docid=3637639460474263178:title=Early History of Video Games]」を見たぞ([http://blog.outer-court.com/:title]経由)。


アメリカにおけるビデオゲームの初期。前半はアタリ社、後半(26分頃～)は任天堂だ。中国語字幕の付いた英語版だが雰囲気だけでも味わってくれ。


アタリの最初の成功はアーケード型のポン(Pong､1972年)だ。ポンをバーに置いたら直ぐに壊れたとクレームが来た。行ってみたらコインボックスがコインで一杯でそれが故障の原因だった。みんな需要の大きさにびっくりした。


任天堂の最初の成功はアーケード型のドンキーコング(1981年)だ。日本で成功したアーケード型のレーダースコープというゲームを10年前のアタリと同じようにバーに置いた。しかしアメリカでは人気がなかった。そこで宮本茂に白羽の矢が立った。宮本はゲームにも映画のようなストーリーがあっていいと考え、そのようなストーリーを持ったゲーム「ドンキーコング」を開発した。これが米国で見事に当たった。同じようにコインボックスがコインで溢れた。


任天堂は1985年に入って米国版ファミリーコンピュータ「Nintendo Entertainment System:NES」の発売を開始する。周囲はみんな&quot;クレイジー”といった。しかし任天堂には秘密兵器があった。またも宮本氏による「スーパーマリオブラザーズ」だ。ドンキーコングに登場していたジャンプマンがマリオとして生まれ変わったのだ。2年後、マリオはアメリカの子供たちにとってミッキーマウスよりも身近な存在になった。


1987年、宮本はまたも新たな傑作を世に出した。ゼルダだ。ゼルダには宮本が子供の頃に裏山で遊んで経験したことがたくさん詰め込まれている。


任天堂から次にリリースされたゲームボーイは、ロシア人研究者のアレクシー・パジノフ(Alexey Pajitnov)とオランダ人ゲームパブリッシャーのヘンク・ロジャース(Henk Rogers)によって大成功を収める。1984年に人工知能と音声認識技術を研究していたパジノフは、新しいコンピュータの動作試験のためにビデオゲームを作った。それがテトリスだ。ラスベガスの展示会でテトリスに出会ったロジャースは、日本でテトリスをゲームボーイ用ソフトとして発売するために奔走する。テトリスは1988年に発売されその後大成功を収める。



4月27日はテトリスＤＳの発売だ。
5月25日はNew スーパーマリオブラザーズの発売だ。


20年経っても同じ形で生きていけるもの。そんな普遍なものにほんとうの価値を見るのだ。宮本茂。アレクシー・パジノフ。僕は彼らに最大の敬意を表します。


asin:B000EPRX56:detail


asin:B0002FQD7C:detail
</body>
</day>
<day date="2006-04-21" title="">
<body>
*p1*人生はつまらないもの
人生はつまらないもの。
だからやることがあればそれは仕合せ。
だからやりたいことがあればもっと仕合せ。
だから愛する人がいれば最高に仕合せ。

*p2*Googleは最終的に勝利できるのか

[http://headlines.yahoo.co.jp/hl?a=20060421-00000012-inet-sci:title]


絶好調だ。しかし僕はGoogleの最終勝利を疑っている。それは彼らが扱っている商品 －もちろんサーチエンジンだ－ が既にコモディティ化、すなわち一般消費者に対して差別化できないものになっているからだ。僕は確かにGoogleを使っている。だけどそれは何となくGoogleが好きだしここにGoogleがあったからだ。そこにYahoo!やWindows Liveしかなければそれを使うだろう。僕が探したいものは同じように見つかるのだから。


僕はAppleが好きだ。iPodもAirMac Expressも、Apple Keyboardだって持ってる。[http://www.amazon.co.jp/exec/obidos/ASIN/4492501479/ref=pd_rhf_p_1/503-6519151-6927951:title=iCon]だって読んでいるし、白状すると[http://b.hatena.ne.jp/entry/http://news-service.stanford.edu/news/2005/june15/jobs-061505.html:title=スティーブ・ジョブスの祝賀スピーチ]((日本語訳:http://pla-net.org/blog/archives/2005/07/post_87.html))を読んで泣いてしまったくらいだ。だけど悲しいかなMacは使ったことがない。パソコンはずっとWindowsだ。それは今までそうせざるを得なかったからだ。僕には選択肢がなかった(これからは違うと思うけど)。Microsoftはパソコンの世界で有料ブリッジを築いてきた。僕はいやだったけど、あちら側の世界に行くためにはそこを通るしかなかった。ミッキーマウスに会うには、高い入場料を払ってディズニーランドに行くしかないのと同じことなんだ。


だけどWebの世界では、僕があちら側に行くには必ずしもGoogleブリッジを通る必要はない。Googleが１検索当り１円を僕に要求するなら迷わず僕はYahoo!ブリッジを通る。Yahoo!がダメなら別のWeb2.0ブリッジを通る。Googleがどんなすごい技術を持っているか僕には分からない。それによってGoogleは他の企業が生み出せないような利益を生み出せるのかもしれない。だけど僕は技術やパテント －それらは企業にとってはとても大事だけれども－ だけで勝利した企業をほとんど知らない。レバー式蛇口を発明したマスコ･コーポレーションくらいしか知らない。


コモディティを扱う限りGoogleはデルやウォルマートにならなければならない。経営者はリモの代わりにワゴン車に、ビジネスの代わりにエコノミーに乗らなければならない。Googleがそういう企業文化を持っているのか僕には分からないけど、普通の人には難しい。


ウォーレン・バフェットは自らの航空機会社に対する投資の失敗を省みてこう語っている。

&gt;&gt;
航空機の技術は人類にとっては偉大な一歩かもしれませんが、資本主義にとっては大きな後退なのです。((引用：ウォーレン･バフェット　自分を信じるものが勝つ！　ダイヤモンド社))
&lt;&lt;

その言葉から10年経った今も航空機産業の現状は変わっていない。


WebからGoogleから僕はどれほどの驚きと恩恵を受けているのだろう。彼らは無知だった僕を少し賢くしてくれたし、僕の世界を広げてくれた。これからもそうだろう。だから彼らに感謝しているし期待している。だけど僕には彼らが資本主義の未来をほんとうに開いてくれるのかは今はまだわからないんだ。


ISBN:4822244873:detail

ISBN:4478360448:detail
</body>
</day>
<day date="2006-04-27" title="">
<body>
*p1*マリオはみんなのアイドルだ！
来月25日はNew スーパーマリオブラザーズの発売です。準備はできてますか？
アメリカの人たちはどうやら準備万端のようです。

[http://video.google.com/videoplay?docid=-2139555376132383479:title]

すごいよ、この盛り上がり。うらやましいよ。
彼らの国ではビデオゲームは文化でありマリオはみんなのアイドルです。


asin:B0002FQD7C:detail
</body>
</day>
<day date="2006-05-06" title="">
<body>
*p1*さあ、E3が始まるぞ！
今年もE3(エレクトロニック・エンターテインメント・エキスポ)が、米国はロサンゼルス・コンベンションセンターで今月１０日から開催されます。


公式サイトはこちら。
[http://www.e3expo.com/:title=E3 2006:home]
今年は日本語サイトもありますね。
[http://biz.knt.co.jp/pm/e3/:title=E3 2006:日本語サイト]


やあ、楽しみですね。何がって？もちろん「Wii」ですよね。まだ隠し球があるということですが何でしょうね？僕は素直に「DS Station 機能 +α」つまりニンテンドーDSとのコネクティビティを予想しておきます。もしこの機能が搭載されるなら、僕は次世代コンソール戦争における任天堂の勝利を確信します。


E3開催までには今少し時間があります。E3の応援Flash(？)「Wake me Up, when we're at E3」を見て、心の準備をしておきましょう。なんか微妙な音程。応援歌なのに哀愁が漂ってるぞ。


[http://www.fredthemonkey.com/cartoons/wakemeupatE3.html:title]
(http://gonintendo.com/より)

*p2*共通のプラットフォームを意識することが大事なんだ
限りなく昔の話。サーフィンで地元サーファーとクラッシュした。彼の波に無理に乗ろうとしたからだ。地元サーファーの波に乗るのは自殺行為だ。「てめぇ、どこのやつだ！？」「ふざけてんじゃねぇぞ！」凄まれた。簡単に怒りは収まりそうにない。しばらく罵倒が続いた後「てめぇ、名前を言え」と。自分は「岩田(仮称)だ」と答えた。相手は「はぁ？岩田？！...俺も岩田ってんだよ...ふざけるな...」。それから彼の怒りは収まっていった。そして僕を許した。


彼は僕が名前を言ったとき -その名前はそんなにレアじゃないけれども- 「僕らが共通のプラットフォームに立っている」ということを意識したんだ。二人の間にコミュニケーションは成立していない。だけど彼は僕とのつながりを意識したために僕を許せたんだ。共通のプラットフォームは精神的なつながりなんだ。コミュニケーションの大切さが語られるとき、僕はこの一件を思い出す。名前だけでも人はつながれる。大事なのはコミュニケーションではなく精神的なつながりだ。共通のプラットフォームを意識することなんだ。
</body>
<comments>
<comment>
<username>dwrkfh pkogcbt</username>
<body>wqyntd ftpiya jtodm jhol fukneomzg mvehpb rfecaivk</body>
<timestamp>1173427820</timestamp>
</comment>
</comments>
</day>
<day date="2006-05-07" title="">
<body>
*p1*良質のプラットフォームはアイディアを刺激する
セブン-イレブンは小売りの新しいプラットフォームであった。この新しいプラットフォームによって、食品メーカーは新商品の開発を刺激された。その結果、新たな消費市場が生まれた。 


インターネットはプログラム技術の新しいプラットフォームである。この新しいプラットフォームによって、プログラマはWebサービスという新しい技術開発を刺激されている。その結果、新たな消費市場が生まれつつある。


任天堂はゲームの新しいプラットフォームを構築しようとしている。この新しいプラットフォームによって、ゲームクリエータは新しいビデオゲームの開発を刺激されるだろう。その結果、新たな消費市場が生まれることになる。



ISBN:4641162328:detail
</body>
</day>
<day date="2006-05-14" title="">
<body>
*p1*人生
人は最後は一人になる。
人生とは一人で生きてゆくための精神修行だ。
人はその生を通して精神の自立を目指しているのだ。
それを支えるのが、思い出であり、心のつながりであり、愛である。

*p2*Where are you going?
PS3の価格とコントローラ。
それは、
Sonyファンに失望を与えた。
そして、
任天堂ファンに失笑を与えた。

*p3*あちらでもテトリスが熱い！

４月２７日に発売になったテトリスＤＳの売れ行きが好調です。米国では５月２０日に発売です。しかし、それを待てないファンが街で暴れています。誰かテトリスを送ってやってください...。


[http://video.google.com/videoplay?docid=-1738616917936225619:title]



asin:B000EPRX56:detail
</body>
</day>
<day date="2006-05-15" title="">
<body>
*p1*知識
知識は未開の地に行くためのツールである
そこに留まるなら知識はいらない
しかしそこに留まるのはきっと難しいだろう
川は流れているのだから
</body>
</day>
<day date="2006-05-16" title="">
<body>
*p1*マリオはあなたを待っている！

ニュー・スーパーマリオブラザーズ。今更、購入を躊躇している人はいないと思われますが、そんな人がいたなら是非ともこのサイトでやられてください。


[http://mario.nintendo.com/:title]
（任天堂アメリカ公式サイト）



asin:B0002FQD7C:detail
</body>
</day>
<day date="2006-05-18" title="">
<body>
*p1*目標設定は人を仕合わせにしない
目標とはその達成に価値を持たせる思考法である
人生は時の流れによる自らの変化でありその過程こそが人生である
従って目標は人生の価値を毀損する
過程こそが人生でありそれを楽しめるほうが仕合わせである
その結果何らかの果実が伴っていればそれはそれでいい


*p2*いいまつがいは人を仕合わせにする
「あそこに立っているのが主人です」
を
「あそこが立っているのが主人です」
と言ってしまいました。
ｂｙ三宅裕司の妻


*p3*もう忙しいと言わないようにしよう！
忙しいと言う人の脳内
　忙しい＝有能な人（世の中から必要とされている人）
忙しいと言われた人の脳内
　忙しい＝無能な人（コントロールができない人）


*p4*うなぎ文はめし屋の革新的アブリビエーションだ
「はい、一番奥にヒレ座ります！」
ｂｙ待ち客に注文とった洋食屋の店主
</body>
</day>
<day date="2006-05-21" title="">
<body>
*p1*怠け者は思考する
人の能力には大した差がなさそうだ

だから何かを成すためにそれに掛ける量を増やそうとするのは合理的な発想だ

成果を得るためには思考と行動が必要だ

思考は行動を適切に導き、行動は思考にフィードバックされる

だから思考と行動はそれが組織であれ、できるだけ分離しないほうがよいのだろう

常に思考が行動に先んずるということは強く認識すべきことかもしれない

時間的な制約が行動を焦らせ思考を中断させるということはよくある

経営はスピードだ！などと言ったりもする

人間は本質的に思考が苦手なのかもしれない

そこで怠け者としては思考の量を増やして、掛ける総量を減らすことなく行動の量を減らそうとするのだ



*p2*運
宝くじに当たった人は運がよかったという

しかし宝くじではその仕組みとして誰かが当たる

当選番号の人は当選者として割り当てられ、当選番号と１つ違いの人は非当選者として割り当てられるに過ぎない

１億回の結果を元に当選者を決定する宝くじがあったら、全員が同じ賞金の当選者として割り当てられる

しかし一生のうち人生を左右する機会というのはそれほど多くはない

統計のばらつきが収束する前に人は一生を終える

運とはそういうものだと思う

*p3*Albert Einstein says;
Do not stop to think about the reason for what you are doing. about why you are questioning . The important thing is not to stop questioning.

Curiosity has its own reason for existence. One cannot help but be in awe when he contemplates the mysteries of eternity, of life, of the marvelous structure of reality. It is enough if one tries merely to comprehend a little of this mystery, each day.

Never lose a holy curiosity. Try not to become a man of success but rather try to become a man of value. He is considered successful in our day who gets more out of life than he puts in. But a man of value will give more than he receives.



自分がしていることの意味について考えつづけなさい。なぜ自分が不思議に思っているのかについて考えつづけなさい。大事なことは疑問を持ち続けることだ。

好奇心というのはそれだけで存在意義がある。永遠の神秘、生命や現実世界の驚くべき構造の神秘について深く考えれば畏敬の念にとらわれずにはいられないだろう。毎日この神秘の僅かでも理解しようと努めればそれで十分である。

神聖なる好奇心を失ってはいけない。成功者になろうとするのではなく価値ある人になろうと努めなさい。現代では彼が与えたものよりも多くを世の中から得ている人間が成功者とみなされている。しかしながら価値ある人は彼が受けるよりも多くのものを世に与えようとするのである。－アルバート・アインシュタイン

</body>
</day>
<day date="2006-05-25" title="">
<body>
*p1*ブログはマスメディアである
ブログは新聞やテレビと同様にマスメディアである
メディアの役割はあちら側の事実をこちら側に伝達することである
メディアによる感想や感情はその賛同者か反対者を募るある種のエンタテインメントである
しかし感想や感情は本来受け手の特権である
こうして僕は僕のブログに対する感想を皆様にお伝えします

*p2*事実はエンタテインメントである
マスメディアによって伝達される大半の事実は視聴者に無縁である
無縁の事実でも視聴者は感想や感情を持つ
しかし多くの場合その感想や感情は行動を呼び起こさない
残酷にもそのときマスメディアはエンタテインメントになる
</body>
</day>
<day date="2006-05-29" title="">
<body>
*p1*仕事
仕事とは依頼人の要望に応えることである
報酬の有無とも継続性とも関係がない
仕事をビジネスすなわち経済的利益と結びつけるのはビジネスマンの役割である
最終的に経済的利益を得たければ、まず依頼人の要望を見つけ出さなければならない

*p2*仕事人と依頼人
仕事人は依頼人の真の要望を引き出さなければならない
一方で依頼人は仕事人の真の力を引き出さなければならない
そうでなければ良い結果は得られない
これが仕事を始める前に多くの議論が必要とされる所以である

*p3*大衆を相手にするビジネス
大衆を依頼人とする仕事は依頼人を見失いがちである
このようなビジネスでは十分すぎるほどに依頼人を明確にしその真の要望を探らなければならない
そうでなければ大衆に無視される
</body>
</day>
<day date="2006-06-04" title="">
<body>
*p1*投資
何かを生み出す力があなたに無いのなら
そのお金はそれができる誰かに託したほうが
世の中のためにもあなたのためにもなるのです。
しかしあなたが何かを生み出せるかどうかは
やってみないと分からないのですから
それを簡単にあきらめてはいけないと思います。
</body>
</day>
<day date="2006-06-05" title="">
<body>
*p1*経営者とグリーンメーラーの間柄
玄関を開け放しにしていたら泥棒に入られた
「そりゃ開け放しにしてたあなたが悪いよ」
と友達に言われるなら分かるけど
泥棒に言われてもねぇ
</body>
</day>
<day date="2006-06-07" title="">
<body>
*p1*サラリーマンの会話
「亀さんのところに泥棒が入ったんだって？」
「そうらしいね。物騒な世の中になったもんだよ」
「ほんとに。僕たちも戸締りをしっかりして気をつけておかないとね」
「でもあれだな、泥棒のおかげでセキュリティ意識が高まって世の中よくなる気もするなぁ」
「それもそうだな。日本は平和ボケなんて言われてるしなぁ」
「なんか気が引き締まっていいかもしれんよ」
「泥棒もうっかり入っちゃったってこともあるだろうしね」
「やっぱり、泥棒も社会の必要悪ってことなんだろうね」
「そうね。泥棒の活動もそれなりに評価すべきなんだろうね、今の世の中は」

</body>
</day>
<day date="2006-06-08" title="">
<body>
*p1*You are ニート(neat)!
非労働を悪という人にとって
元気な老人や子供たちは悪魔に違いない
日曜日は悪魔の日に違いない
人間は怠惰な動物たちとは違って
国家が前に進むための機械エンジンであると信じているに違いない


*p2*日本はアルカトラス島
日本の地理と言語が国民を小さい四角に軟禁する
その高い生活コストと国債が国民を労働させる
その高齢化した社会の声が若者から希望を奪う
窓の外にはサンフランシスコが見える
手を伸ばせば届きそう
でも届かない
ここはアルカトラス島
僕らはここの住人
</body>
</day>
<day date="2006-06-09" title="">
<body>
*p1*オブジェクト指向スクリプト言語Ruby
Rubyの作者まつもとゆきひろさん/石塚圭樹さん共著「オブジェクト指向スクリプト言語Ruby」を読み始める。プログラム経験が殆どないのにRubyという言語に何故か魅力を感じる。この言語を使って何か作れたらと思う。敷居はかなり高そうだ。まずは挫折しないでどこまで読めるか。


ISBN:4756132545:detail


*p2*理解
経験者が新たな概念を理解するにはその差分を知ればよい
未経験者が新たな概念を理解するにはそうはいかない
その概念が、
-ルールが少ない
-例外が少ない
-ルールが直感に反しない
ものならば未経験者にとっても理解が容易になる
Rubyにはそういうにおいがする
正規表現にはぜんぜんしない
</body>
</day>
<day date="2006-06-10" title="">
<body>
*p1*オブジェクト思考
関数指向は自分でデータを処理する
オブジェクト指向は処理がパッケージングされたデータへ処理を依頼する
古き良き日本は奥さんが魚を買ってきて煮付ける
グローバルスタンダードは料理屋でいけすの魚を指して煮付けてと依頼する
そんな解釈でよろしいでしょうか？
</body>
</day>
<day date="2006-06-11" title="">
<body>
*p1*オブジェクト生成に悩む
－すべての値は例外なくオブジェクトである－
－オブジェクトは自分に適用できる処理を知っている－ Ruby本 P.21
&lt;pre&gt;
str = &quot;abc&quot;
=&gt; &quot;abc&quot;
&lt;/pre&gt;
を
&lt;pre&gt;
str = String.new(&quot;abc&quot;)
=&gt;&quot;abc&quot;
&lt;/pre&gt;
で理解した気がした。でも
&lt;pre&gt;
num = 123
=&gt;123
&lt;/pre&gt;
が
&lt;pre&gt;num = Fixnum.new(123)
=&gt;NoMethodError
&lt;/pre&gt;
で分かってない気がした。加えて
&lt;pre&gt;
num = Numeric.new(123)
=&gt;ArgumentError
&lt;/pre&gt;
もダメで
&lt;pre&gt;num = Numeric.new
=&gt;#&lt;Numeric:0x29e7798&gt;
&lt;/pre&gt;
がErrorでなくて(これは何？)困った。

*p2*代入でも悩む
－Rubyの代入は左辺の変数に右辺の計算の結果のオブジェクトを指し示すように指示するもの－by Ruby本 P.52
&lt;pre&gt;
1 + 2
=&gt; 3
&lt;/pre&gt;を
&lt;pre&gt;1.+(2)
=&gt; 3
&lt;/pre&gt;で理解した気がした。でも
&lt;pre&gt;sum = 3
=&gt; 3
&lt;/pre&gt;が
&lt;pre&gt;3.=(&quot;sum&quot;)
=&gt;SyntaxError
&lt;/pre&gt;で分かってない気がした。加えて
&lt;pre&gt;－代入は変数の値を変える操作です。Rubyは変数そのものをオブジェクトとして取り扱う機能がありませんから、代入をメソッドとして定義することはできません。－ by Ruby本 P.56
&lt;/pre&gt;で深みに入った。

*p3*入出力でも考え込む
－入出力にはIOクラスまたはそのサブクラスのオブジェクトが使われます。IOオブジェクトは関数openで作ることができます。－ by Ruby本 P.85

&lt;pre&gt;file = File.open(&quot;test.txt&quot;)
=&gt; #&lt;File:test.txt&gt;
file.close
=&gt; nil
file
=&gt; #&lt;File:test.txt (closed)&gt;
&lt;/pre&gt;もうまくいったし
&lt;pre&gt;
file = File.new(&quot;test.txt&quot;)
=&gt; #&lt;File:test.txt&gt;
file.close
=&gt; nil
file
=&gt; #&lt;File:test.txt (closed)&gt;
&lt;/pre&gt;でもうまくいった。でも
&lt;pre&gt;File.open(&quot;test.txt&quot;)
=&gt; #&lt;File:test.txt&gt;
File.close
NoMethodError: undefined method `close' for File:Class
&lt;/pre&gt;では閉じれないし
&lt;pre&gt;File.new(&quot;test.txt&quot;)
=&gt; #&lt;File:test.txt&gt;
File.close
NoMethodError: undefined method `close' for File:Class
&lt;/pre&gt;でも閉じれなかった。IOクラスでは
&lt;pre&gt;IO.open(&quot;test.txt&quot;)
TypeError: cannot convert String into Integer
&lt;/pre&gt;でも
&lt;pre&gt;IO.new(&quot;test.txt&quot;)
TypeError: cannot convert String into Integer
&lt;/pre&gt;でもうまくいかず
&lt;pre&gt;IO.new(1)
=&gt; #&lt;IO:0x2c811f0&gt;
&lt;/pre&gt;は
&lt;pre&gt;IO.close
NoMethodError: undefined method `close' for IO:Class
&lt;/pre&gt;で閉じれなかった。また
&lt;pre&gt;
file = IO.new(1)
=&gt; #&lt;IO:0x2c67378&gt;
&lt;/pre&gt;としたら
&lt;pre&gt;
file.close
in `write': Bad file descriptor (Errno::EBADF)
&lt;/pre&gt;こんなんでました。きっとはちゃめちゃやってるんでしょうね。

*p4*配列でも困る
－配列とはオブジェクトを順番に並べたもので、これもまたひとつのオブジェクトです。－ by Ruby本 P.91
&lt;pre&gt;
array = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

array = Array.new([&quot;A&quot;,&quot;B&quot;,&quot;C&quot;])
=&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]

array[0]
=&gt; &quot;A&quot;

array.[](0)
=&gt; &quot;A&quot;

array[0] = &quot;AA&quot;
=&gt; &quot;AA&quot;

array[0] = [&quot;AAA&quot;,&quot;BBB&quot;]
=&gt; [&quot;AAA&quot;, &quot;BBB&quot;]
&lt;/pre&gt;
までで分かったような気になっていた。でも
&lt;pre&gt;
array.[](0) = &quot;AA&quot;
SyntaxError: compile error

array.[](0) = [&quot;AAA&quot;,&quot;BBB&quot;]
SyntaxError: compile error
&lt;/pre&gt;
でやっぱり分かってなかったことを知った。
</body>
</day>
<day date="2006-06-14" title="">
<body>
*p1*所得税法がニートを注目の的にする
仕事とは依頼人の要望に応えることである
需要がなければ仕事はない
需要がない人は本来社会から無視される
美男美女はその存在が既に社会的な需要である
普通の人はそうはいかない
だから無視されないよう皆自ら需要を作る
でもそれが健全なことかはわからない
一方でニートは無視されてもいいと言っている
それは現ルールの中の一つの選択である
人の２倍働く人が許されるのと同様に働かない人も許されるべきである
だから放っておけばよい
所得税は本来需要の高い人に期待すべきである
</body>
</day>
<day date="2006-06-24" title="">
<body>
*p1*Mac は早い
Windows から Mac に乗り換えて一週間が過ぎました。何でも２つ用意しなければ決済がおりないという我が家の特殊な事情(？)により、Mac mini solo * 2 となりましたが、今のところ大変に満足しています。おそらく、Duo + 1MB が安全確実な選択なのですが、* 2 + amazon での4%割引 + 最大10%還元を加味するとこれはもう「えいやぁ！」で決済できない差額になってきますので、安全余裕度無し、コストパフォーマンス重視、で上記の選択となりました。何しろ、Dell celeron + 512MB に Flyakite3で疑似Macをやっていた身からすればこれはもう快適この上ありません。確かに最初に Dashboard を起動したときや、iPhoto を起動したときのもたつきは気になりますが、全体としてのパフォーマンスは比較になりません。

速度に関して特に改善されたのは、PCの起動時間とインターネットです。startup に何もないということもありますが、30秒ほどで起動が終わるというのはかなり快適です。電源を入れた後、他の用事をしてからPCの前に座るという習慣は不要のものとなりました。また、これはあまり予期していなかったのですが、インターネットがかなり快適になりました。先日光に乗り換えたので、goo のスピードテストサイトで速度を比較したところ、以前のマシンでは7Mbps程度であるのに対して Mac mini では20Mbps以上の数値が出ました。体感的にはこれほどの差はないのですが、やはりはっきりとした差はあります。なお、browser は何れも Firefox ですが、Mac 上で Safari を使うと、50Mbps以上の数字がでます。


asin:B000BRXXCO:detail


*p2*Mac へのデータ移管
Windows から Mac へ乗り換えるための障害は数年前に比べるとかなり少なくなってきたのですが、我が家における最後の問題は、家計簿とExcelデータでした。Windows ではもう６年くらい Master Money というプラトの家計簿ソフトを使っていましたが、この Mac universal 版が出ているということを知って乗り換えに踏み切りました。問題は Excel ですが、これについてはまだ解決していません。そのうち[http://www.openoffice.org/:title=OpenOffice]を試してみるつもりですが、難しい関数は使っていないものの、対数で２軸別のデータをプロットしたグラフを使っているのでこれが表現できればよいのですけれども。もちろん、Mac 版 Excel を買うというのは考慮の外です(Microsoft への年貢納めはもう終わりにしたい)し、Excel のためだけにBootCamp はあまり気乗りがしません。Excel は Microsoft の最後の牙城となるのではという話がありますが、自分の状況を見る限り僕もそう思います。

ところで、Master Money のほうなんですけれども、[http://www.plato-web.com/:title=プラトのHP]上にWindows 版からMac 版へのデータ変換ツールがアップされていましたので、すっかり安心していましたが、これが意外に鬼門となりました。変換ツールは我が家の家計簿データをうまく読み込んでくれない。サポートはデータを送ってもらえれば対応できるというが、我が家の厳しい財政があからさまになるのもまずい。それで、アドバイスをもとに自分で原因を探すことにしました。結果、入力データ中の半角「&amp;」が犯人と突き止め無事データ移管に成功しました。管理口座名の中に「&amp;」を使ったものがあってこれを見つけるのに丸１日を費やしました。どなたかの参考になれば幸いです。


asin:B000EBCBGQ:detail


*p3*Mac は Safari
Windows では Firefox を使っていたのですが、Mac ではとりあえず標準添付の Safari を使ってみることにしました。理由は速度が速いということもありますが、Mac 版の Firefox ではペイジが少し間抜けてしまい表示エリアが狭くなるということがあったからです。自分の環境において Mac では Display にWindows と同じ解像度を設定する(17inch で 1280*1024)と随分と文字が小さく表示されてしまいます。そのため表示エリアを多くしつつ文字を小さくしないで済むのは Sarfari のほうということでこちら側を現在使っています。

Safari はその拡張性において Firefox に劣りますが、[http://hetima.com/safari/stand.html:title=Safari Stand] という有名な extension があります。Safari Stand には多数の機能があるのですが自分はその中の Stand Search が気に入っています。Stand Search は一発で Bookmark と履歴をサーチして開いてくれます。この機能は標準で F4 に割り当てられ incremental search に対応しているので、例えば gmail を開きたいときには、F4 → gm → enter でOKです。以前はタブの上の領域に Bookmark をいっぱい並べてマウスで選択していたのですが、F4 → [search] → enter が気持ちよくて、もう戻れそうにありません。それと自分は Livedoor Reader を使っているのですが、Firefox には Greasemonkey 上の script で j, k キーで画面遷移できるものがあり重宝していましたが、Safari にも同様のものが作られていましたので、これを使っています。
[http://8-p.info/Creammonkey/:title=Creammonkey] + [http://ka2hiro.dyndns.org/weblog/2006/05/safarijkcreammonkey.html:title=ldr_keyhack_jk_for_safari.user.js]


</body>
</day>
<day date="2006-06-28" title="">
<body>
*p1*bit Generations あなどるなかれ


f:id:keyesberry:20060628191728j:image


任天堂GAMEBOY Advance用ゲーム「bit Generations」の体験モニターに当選したぞ！早々、サンプル(といっても完成品のよう)が届けられたので写真をアップします。僕は、COLORISとDIALHEXでした。


他の写真は[http://postagie.blogspot.com/:title=こちら]


パッケージが大変にクールです。物欲をそそられます。Apple にも負けていません。箱からいちいち出して遊びたい気持ちにさせられます(しないと思いますが)。７パッケージすべてを揃えて本棚に並べたい衝動に駆られます(決済はおりないと思いますが)。


COLORISとDIALHEXは、いずれも色パネルを揃えて消していくというテトリスライクなゲームです。音と映像がなかなかおしゃれで、遊んでいると独特な世界への没入感を味わえます。一方で、戦略性もあり連鎖の爽快感もあります。ちょうどエレクトロプランクトンとテトリスが融合したような感じです。テトリスほど戦闘的ではないけれどもエレクトロプランクトンほど平和的でない世界。僕にはちょうどよさそうです。


関連記事：[http://d.hatena.ne.jp/keyesberry/20060417:title=ゲームボーイは現代アートのキャンバスだ！]

[http://www.bit-g.jp/:title=bit Generations 掲示板サイト]
</body>
</day>
<day date="2006-06-30" title="">
<body>
*p1*The Little Book of Rubyは良書
まつもとさんのRuby本は１、２、４、１０章を読んだ。他は敷居が高く保留。で、[http://www.sapphiresteel.com/:title=こちらのサイト]で公開されているThe Little Book of Rubyをさきに読んでみた(Matzの日記で紹介されていた)。感想は、
1. 解説が平易で読みやすい。
2. １つの例に沿ってRubyの各機能が説明されており実践的(もちろん入門者にとってのですが)。
3. クラスなどの概念も実際のコードに則して説明されているので理解できる。
4. 解説されているコードも公開されているので読みながら試せるしいじれる。
5. 他の言語や周辺環境の前提知識がいらずプログラミング入門者(Ruby入門者でなく)にやさしい。
6. 英語が平易で僕にも読める。
7. pdfファイルなのでコードと並べてディスプレイに表示でき、手元が本で邪魔になることがない。
ということで僕にとっては大変に価値があった。ただRuby本の残りの章に行くにはもう１、２ステップ必要そうだ。次はうさぎ本と呼ばれるやつかな。
</body>
</day>
<day date="2006-07-01" title="">
<body>
*p1*TextMateはすてきだ
Rubyの勉強をするのにMac上のエディタを探している。[http://macromates.com/:title=TextMate]が評判になっていたので日本語が通らないことを知りつつも試用してみた。で、そのすばらしさに気持ちはRegistrationに向かっている。

1. 強力な入力補完機能はeditingを楽しくする
2. 関連ファイルをいっぺんに
3. そこからすぐ実行できる
4. ブロックを示す矢印が目安
5. 奥はどこまで？

**1. 強力な入力補完機能はeditingを楽しくする
TextMateにはさまざまな入力補完機能がある。その１つがAuto-Pairingという機能で、括弧やクオートの一方を入力するとその対を自動補完してくれる。例えば、
&gt;&gt;
print(&quot;hello
&lt;&lt;
と入力すれば、
&gt;&gt;
print(&quot;hello&quot;)
&lt;&lt;
が入力済みとなる。入力した括弧を消すと自動補完された相手も消える。閉じ側の括弧を自分で入力すれば自動補完は上書きされてダブらない。さらに、上記の入力に続けて command + return でカーソルは括弧を抜けて次行に移る。control + E で指がつりそうな僕にはこの括弧抜けは気持ちがいい。また、先に括弧でくくりたい文字列を範囲指定してから一方の括弧を打つと他方の括弧を補完した後にカーソルは括弧の外に出る。
別の入力補完機能としてBundlesというものがある。これは言語ごとに定義された定型入力を支援するもので編集も可能なようである。操作はキーワードを入力した後に Tab を打って実現する。例えば、Rubyでは、classと入力した後に Tab を打つと、
&gt;&gt;
class ClassName
  
end
&lt;&lt;
と補完され、続けてクラス名を入力し、さらに Tab を打つと、ClassNameが入力したクラス名に置き換えられて、カーソルはインデントされたclassとendの間の行に飛ぶ。claと入力して Tab を打つと、クラスのテンプレートメニューがでる。また、ifeと入力した後に Tab を打つと、
&gt;&gt;
if condition
  
else
  
end
&lt;&lt;
と補完され、続けて条件、Tab、第１実行文、Tab、第２実行文、Tab、と入力すれば、if else節の入力が完了してカーソルはその外にでる。each、Tab と入力すれば、
&gt;&gt;
each { |element| element. }
&lt;&lt;
となって、次いで i と入力すると、
&gt;&gt;
each { |i| i. }
&lt;&lt;
となってドットの後にカーソルがくる。とにかくキーワード、Tab だ。また、メソッド名(myMethod)を打ってからshift + return で
&gt;&gt;
def myMethod(args)
  
end
&lt;&lt;
が補完され、カーソルはargsの書き換え位置にくる。引数が要らなければDelキーを押す。他にも初期設定で多数のキー割当がなされている。bundleメニューでそれが簡単に確認できる。
TextMateには ESCキーでの入力補完機能もある。同じドキュメント内で使用されたワードの先頭文字を入力し ESC で残りを補完する。選択肢が複数ある場合は ESC を繰り返すことで置き換える。
また、複数行に対する同時編集機能もある。例えば、
&gt;&gt;
print &quot;hello world&quot;
print &quot;yellow world&quot;
print &quot;follow world&quot;
&lt;&lt;
を、
&gt;&gt;
print &quot;hello Japan/n&quot;
print &quot;yellow Japan/n&quot;
print &quot;follow Japan/n&quot;
&lt;&lt;
に修正したい場合、範囲指定して、alt + command + A で同時編集モードに入ることができる。10本の指で100以上のキーを相手にする身としてはTextMateの強力な入力補完機能は非常に助かる。簡潔な記述のRubyによるプログラミングがいっそう楽しくなりそう。

**2. 関連ファイルをいっぺんに
TextMateでは複数のファイルをフォルダごとまとめて開ける。DrawerにフォルダをDragすれば終わり。今回僕はThe Little Book of Rubyを読むにあたってTextMateを試用した。The Little Book..には、各章ごとにフォルダ分けされたサンプルコードが添付されていた。僕はそれを、TextMateのDrawerにドラッグするだけで対象ファイルをすべて開けるようになった。

**3. そこから実行できる
command + R で開いているコードを即時実行できる。コードの中で入力が求められる場合、入力ボックスが現れる。打ったものをすぐ試せるというのがScriptingの醍醐味だろうからTextMateはそれをより快適にする。

**4. ブロックを示す矢印が目安
入力エリアの左のガータに、コードのブロック単位(def..end, begin..end, {}など)の矢印が自動表示される。これでブロックの起点と終点マーカのペアリングを迷うことがなくなる。また、矢印を操作することで対象のブロックの表示上のオープン/クローズを制御できる。

**5. 奥はどこまで？
初期状態でこれだけの利便性を感じさせてくれるエディタはすごい。センスの良さを感じる。まだまだこのエディタは奥が深そうだ。使い込むほどに味がでるのではと期待させる。


一方で問題点はやはり日本語だ。日本語が通らないどころか、誤って日本語モードで入力するとしばらく入力が利かなくなる。これはちょっと困るので回避策がほしい。それを差し引いてもTextMateは僕にとってのプログラミングの勉強における最良のMateになりそうだ。
</body>
</day>
<day date="2006-07-03" title="">
<body>
*p1*先走って自分 on Rails
[http://locomotive.raaum.org/:title=Locomotive]とSQLiteで簡単にRailsの世界が覗けた。


1. Locomotiveを起動。command+Nで新規プロジェクト(mycdとする)作成。
2. Finderから対象フォルダmycdをTextMate(エディタ)のiconにドラッグして開く。なにやらいろいろできてるのがわかる。
3. dbフォルダ内にschema.sqlという名で以下のようなファイルを作る。
    create table mycds (
	id integer primary key,
	album varchar(64),
	artist varchar(64),
	genre varchar(64),
	numtracks integer,
	buydate date
	);

4. Locomotiveに戻って、command+Tでターミナルを開き以下を打つ。
    /usr/bin/sqlite3 db/mycd &lt; db/schema.sql
5. TextMateに戻って、configフォルダ内のdatabase.ymlを開き、development, test, productionの項をそれぞれ以下に書き換える。
    adapter: sqlite3
    database: db/mycd
6. ターミナルに戻って以下を打つ。
    ruby script/generate scaffold mycd
7. Locomotiveに戻ってRunボタンを押す。
8. ブラウザで以下を開く。器ができてる。
http://localhost:3000/mycds/ 
9. CDデータを入れてみる。
10. TextMateで /app/views/mycds/list.rhtmlの＜table＞を＜table border=&quot;1&quot;＞とかして変化を楽しむ。
11. Rubyの勉強が必要なことを改めて知る。off Rails, on Ruby。


以下のサイトを参考にしました。
http://www.jadetower.org/muses/archives/000475.html
http://wiki.rubyonrails.org/rails/pages/RailsOnOsx




ISBN:4756147739:detail
</body>
</day>
<day date="2006-07-06" title="">
<body>
*p1*HP12C  それは清く正しく美しい
f:id:keyesberry:20060706105253j:image


HP12C　それは古くて新しい計算機
HP12C　合い言葉はドンラーポ
(12+23)*(34+(45*56))-(67*78) を知りたけりゃ
12 enter 23 + 34 enter 45 enter 56 * + * 67 enter 78 * - と叩けばいい
HP12C　それはとっても日本風
12に23を足し、34に(45に56を掛けたもの)を足し、これらを掛け、67に78を掛けたものを引く
ドンラーポ　ドンラーポ　それが合い言葉


HP12C　MBAの必需品
株に賭けた100万円。年率20の運用で30年後を夢見るなら
1000000 PV 20 i 30 n FV と叩けばいい
結果はなんと２億円！現実の銀行金利はどうかしら
1000000 PV 0.5 i 30 n FV と叩けばいい
利子はたったの16万！暗い未来におめでとう
HP12C　捕らぬ狸の皮算用。友はやっぱりあなただけ
ドンラーポ　ドンラーポ　それが合い言葉


HP12C　もう15年もここにいる。電池を替えたのいつかしら？
HP12C　正しい作法は両手で持って親指で
HP12C　プチプチやればあ～快感
HP12C　どんなに技術が進んでもあなたの価値は変わらない
HP12C　清く正しい製品の姿。でも普通の人にはわからない
ドンラーポ　ドンラーポ　それが合い言葉
ドンラーポ　ドンラーポ　それが合い言葉


～HP12C検索者へのお詫びにかえて～
</body>
</day>
<day date="2006-07-14" title="">
<body>
*p1*Agile Web Development with Rails がRailsの、そしてRubyへの門戸を開く
[http://www.pragmaticprogrammer.com/title/rails/:title=こちらのサイト]で、Agile Web Development with Rails -Second Edition-のPDF版を少し前に買った。Second Editionは、新しいRailsに対応したFirst Edition のリニューアル版である。書籍版はまだ発売されていない(秋の予定)。PDF版は未完成のベータ版であり、First Editionをベースに、Second Editionとして新たに作られ又は書き換えられた頁がこれに差し替えられて出来ている。差し替え分には赤い帯が、差し替え前の分にはグレーの帯が付されて、これらの区別がなされている。購入したPDF版ではPartIII Chapter16 Migrations(P272)までがほぼ書き換えられている。TutorialのDepot Applicationを自分でも試しながらなんとか書き換え分までをだいたい読み終えた。

最初、PDFに$23.50を出すのに躊躇していた。でもTutorial形式のこの種の本は、所有価値ではなく利用価値のみに着目すれば、極めてお買い得だ。なぜなら、
+キーボード周りがスペースフリーであり、かつ、editorとの視線移動が最小で済むので(PDFとeditorを横に並べる)、サンプルコードのコーディングが極めて容易である。
+意味の取れない単語を選択してショートカットで簡単に辞書を引ける。自分はDictionaryと[http://www.apple.com/jp/downloads/macosx/home_learning/eview.html:title=英辞郎ビューワ]の二刀流で。Dictionaryのショートカット割当ては[http://www.macosxhints.com/article.php?story=20030406004351266&amp;query=Services%2Bshortcut:title=こちら]を参照。
+読むのに両手がフリーであり、頁めくりもspace又はshift+spaceででき、同時に目次も参照でき、参照頁への移動も簡単だ。参照Webサイトへのリンクも張られている。
+各頁のフッダに Prepared exclusively for [僕の名前]などと、所有欲を少しだけ満たす心憎い演出(不正コピー防止のためだろうけど)。
+にも関わらず、書籍版($39.95)よりも安い。

この本を読んでいると僕でもWebに家を建てられるんじゃないかと錯覚する。Ruby(すばらしい言語)+Rails(すばらしいツール)＋この本(すばらしい解説書)は、未来に何を引き起こすのだろう。それが見える処に早く行きたい。
</body>
</day>
<day date="2006-07-15" title="">
<body>
*p1*メンテナンスフリーが鍵
組織活動の大半はルーチンワークである
組織に変化を求めるならばルーチンワークを極小にして組織が思考する時間を作らなければならない
そのためにはサービスをできるだけメンテナンスフリーにする必要がある
つまりメンテナンスフリーは変化の時代に生き抜くための鍵である

*p2*SizzlingKeysはさらに音楽を身近にする
音楽を聴きながらMacを使うのが好きだ
そのための最高のツールが[http://yellowmug.com/sk4it/:title=SizzlingKeys]だ
キーボードショートカットでiTuneを自在にコントロールできる
僕は、command+F14, F15, F16 にそれぞれ前の曲、再生(停止)、次の曲を割り当てた
control+F14, F15, F16 にそれぞれiTuneの表示(非表示)、プレイリスト表示、曲サーチを割り当てた
プレイリスト表示、曲サーチから対象の曲を直ぐに再生できる
曲が変わるたびに曲情報がフロート表示される。これはF16でいつでも呼び出せる
表示のギミックがそつなくおしゃれだ
Mac立ち上げ時に起動するようセットすればiTuneの立ち上げはいらない
Easy Install, Easy Setup, Easy Use and it's FREE!
もう手放せません
</body>
</day>
<day date="2006-07-17" title="">
<body>
*p1*暇なときはGoogle Earth（かYouTube）に限る！
Google Earthはキーボードでコントロールできる。
検索でひとっ飛びもいいが、自分でコントロールしてゆっくりと飛ぶのもいい。
成田空港からサンフランシスコ国際空港まで飛んでみよう。
操縦桿は、shift, command + 矢印キーだ。Zoom,Tilt,旋回をうまく使おう。離着陸時はaltを加えてスムーズな飛行を心がけよう。
1.先ずは検索で「成田空港」へ。滑走路に入って航空機の列に並ぼう。
f:id:keyesberry:20061209174540j:image
f:id:keyesberry:20061209174612j:image
2.管制塔からの指令が来たと感じたら、上矢印キーで助走してcommand+下矢印キーで飛び立とう。少し後ろ向きに上昇しているように感じるがきっと錯覚だ。
3.十分な高度を確保したと感じたら、進路を東に向けて太平洋を横断しよう。さようなら日本。
f:id:keyesberry:20061209174633j:image
f:id:keyesberry:20061209174711j:image
f:id:keyesberry:20061209174732j:image

4.天気がよく海は静かだ。途中ハワイや小さな島々が見える。少し高度を上げて先を急ごう。あっ、アメリカ大陸が姿を現した。
f:id:keyesberry:20061209174754j:image
f:id:keyesberry:20061209174815j:image
f:id:keyesberry:20061209174841j:image

5.メキシコとアメリカ合衆国の国境が見える。ロサンジェルスが、ビバリーヒルズが見える。高度を下げて億万長者たちの家を覗き見しよう。
f:id:keyesberry:20061209175324j:image
f:id:keyesberry:20061209175343j:image
f:id:keyesberry:20061209175357j:image
f:id:keyesberry:20061209175411j:image
6.モントレーが、サンタクルーズが見える。ネットの聖地シリコンバレーだ。Googleキャンパスが、Stanfordキャンパスが見える。
f:id:keyesberry:20061209175458j:image
f:id:keyesberry:20061209175511j:image
f:id:keyesberry:20061209175527j:image
f:id:keyesberry:20061209175546j:image
7.サンフランシスコの町並みが見えた。ゴールデンゲートブリッジに寄って行こう。
f:id:keyesberry:20061209175643j:image
f:id:keyesberry:20061209175658j:image
8.そろそろサンフランシスコ国際空港に降りようか。慎重に高度を下げて........無事着陸。
f:id:keyesberry:20061209175714j:image
f:id:keyesberry:20061209175801j:image
f:id:keyesberry:20061209175819j:image
f:id:keyesberry:20061209175843j:image
9.あっ、ヨセミテ公園によるのを忘れた。Google様、連れてってください。やっぱりヨセミテはきれいだなあ。
f:id:keyesberry:20061209180539j:image
</body>
</day>
<day date="2006-07-18" title="">
<body>
*p1*情報は食物と等価である
現代人は情報を食べないでは生きてゆけない
情報は食物と同様にそれが体内(脳内)に入れられたときにその本来の使命を全うしている
だから既読の情報も未読の情報もそれらを手元に蓄積する価値の大半は室内デコレーションとしてのものしかない
脳内メモリの低性能を蓄積した情報で補うことはできないのだ
「情報の整理に時間を掛けてはならない」のではなく、情報は整理してはならないのである
情報はそれが脳内に入れられたときに食品トレーのようにゴミ箱に破棄されるべきものである
</body>
</day>
<day date="2006-07-21" title="">
<body>
*p1*偉大なることの難しさ
偉大なことを達成したいと思うことは強欲的だ
しかし偉大なことを達成することは禁欲的だ
だから時として無欲から偉大なことが生まれる
その意思とは対極の境地に結果が宿る
偉大なることの難しさ
NHKプロフェッショナル仕事の流儀「第20回 ～棋士・羽生善治～」を見てそんなことを思った

*p2*プログラミングそれは芸術的技術
芸術創作には資本はいらない
だから芸術は多様になる
多様性は時間を経ると文化になる


技術開発には資本が必要だ
しかしプログラミングは資本がいらない技術開発である
だからその成果物も多様になる
そして芸術と同様にいずれ文化になるのだろう
</body>
</day>
<day date="2006-07-23" title="">
<body>
*p1*AWDwR update
Agile Web Development with Rails -Second Edition-のPDF版が昨日updateされた。新版ではThe Rails FrameworkのActive Recordの章まで(P.400)が書き終えられている。旧版ではActive RecordはBasicsとMore ...だったのが、新版ではBasics, Relationships Between Tables, Object Lifecycleの3章に増えていた。自分はもう少し先のAction Viewのところを現在読んでいるのでこのまま旧版を読み進めるつもりだ。自分はこの本の理解に必要となる前提知識がかなり不足しているので少しつらいけれども、なんとか一通り目を通してから再度tutorialをやってみたい。この本のtutorialを通して使っていたTextMateをかなり好きになったのでRegistした。

*p2*オタキング恐るべし！

[http://netcity.or.jp/OTAKU/okada/library/books/bokusen/mokuzi.html:title=ぼくたちの洗脳社会]をネットで読んだ。1995年12月初版。昨日書かれた本のようだ。現在の自分の行動原理に対する自らの疑問が氷解した。パラダイムシフトは確実に進んでいる。変化を見るのにもはや若者の行動を注視するまでもない。各年代層においてEarly Adoptersは無意識のうちに変化に対応している。これから50年くらいを掛けて世の中は大きく変わっていくのだろう。


情報革命によるカルチャーショックの波が最初に訪れる。日本人にとっては現在の自分たちの立ち位置に対する失望、これからの可能性に対する希望、背負ってしまった負債に対する絶望が錯綜する。人間の属地的要素の希釈化が進む。人は地域社会、国境を超えて広範につながる。属地主義に基づいた現在の法域を超えたところで人々の現実的活動が成立する。第２の地球の誕生だ。過去の資産・文化に対する情報が共有され、無数の評価・再構築がなされる。新しく生まれたつながりから新しい資産・文化が生まれ、無数の評価・構築がなされる。人間は本来動物であると同時に社会的な生き物であるという二層性を持っている。情報革命は肉体とは独立した精神体としての第三層目の自分を作る。


ぼくたちの洗脳社会を読み終わったとき、僕の思考はDisplay上の活字の向こうに見えたそんな妄想に沈んでいった。


ISBN:402256928X:detail

*p3*パラダイムシフトと負債
なぜ変化に対応できないのか
それは過去の負債があるからだ
負債は変化を許さない


パラダイムシフトが起きやすいのは負債がない社会である
守るべき資産が負債を生みそれが人を動けなくする
戦後の日本は守るべき資産を失った
守るべき資産がなければ負債は生まれない
だから日本は時代の変化にいち早く対応して復興した


今の日本には膨大な負債がある
それがパラダイムシフトを嫌がる
しかしパラダイムシフトは進む
そこにギャップが生まれその谷間に人は落ちる
だからまずは負債をなくさなければならない
そのためには資産を捨てなければならない
そうして負債から解放されて初めて変化に対応できるようになる
</body>
</day>
<day date="2006-08-09" title="">
<body>
*p1*RailsでFlickrを遊ぼう! (Putting Flickr on Rails)

Ruby on Railsサイトには、Flickrのインタフェースを５分で作ってしまうというデモビデオがあります([http://www.rubyonrails.org/screencasts:title=screencasts])。ちょっと感動したので自分でも同じものを作ってみました。手順を書いておきます。


まず、自分はRailsの環境としてLocomotiveを使っていたのですが、flickr libraryの取得がうまくできなかったので、AWDwRで紹介のあった[http://hivelogic.com/articles/2005/12/01/ruby_rails_lighttpd_mysql_tiger:title=こちらのサイト]で環境を再構築しました。


-1. Flickr API keyの取得
Flickr APIを利用するためには、[http://www.flickr.com/services/:title=flickrのサイト]よりAPI keyを取得する必要があります。簡単な必要事項を入力すれば直ちにkeyが発行されます。公開サーバーでAPIを利用する場合はconfigurationが必要になりますが、ローカルで遊ぶだけなら必要ありません。

-2. flickrプロジェクトの作成
flickrという名前でrailsのプロジェクトを作成します。
&gt;||
  &gt;rails flickr
||&lt;

-3. flickr libraryのインストール
rubyでflickr APIを使うためのライブラリFlickrをインストールします。
&gt;||
  &gt;sudo gem install flickr
||&lt;

-4. 環境設定
flickr libraryを使えるように、configディレクトリにあるenvironment.rbの最後に以下を追加する。
&gt;||
  require 'flickr'
||&lt;

-5. application.rhtmlの作成
viewのlayoutディレクトリ内に、以下のapplication.rhtmlファイルを作成する。
&gt;||
  &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;
	&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
  &lt;html&gt;
	&lt;head&gt;
		&lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
		&lt;title&gt;Flickr&lt;/title&gt;
		&lt;%= javascript_include_tag :defaults %&gt;
		&lt;%= stylesheet_link_tag 'flickr' %&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;%= yield %&gt;
	&lt;/body&gt;
  &lt;/html&gt;
||&lt;

-6. flickr.cssの作成
public/stylesheetsディレクトリにflickr.cssを作成し、application.rhtmlのスタイルを記述する。
&gt;||
  body {
	background-color: #888;
	font-family: Lucida Grande;
	font-size: 11px;
	margin: 25px;
  }
||&lt;

-7. flickr controllerの作成
flickrという名前でcontrollerを作成する。
&gt;||
  &gt; ruby script/generate controller flickr
||&lt;

-8. index.rhtmlの作成
views/flickrディレクトリにindex.rhtmlを作成し、以下を記述する。
&gt;||
  &lt;%= form_remote_tag :url =&gt; {:action =&gt; 'search'}, :update =&gt; 'photos' %&gt;
	
	&lt;fieldset&gt;
		&lt;label for=&quot;tags&quot;&gt;Tags:&lt;/label&gt;
		&lt;%= text_field_tag 'tags' %&gt;
		&lt;%= submit_tag 'Find' %&gt;
	&lt;/fieldset&gt;

	&lt;div id=&quot;photos&quot;&gt;&lt;/div&gt;

  &lt;%= end_form_tag %&gt;
||&lt;

-9. index.rhtmlに対するスタイルをflickr.cssに記述する。
&gt;||
  form {
	margin: 0;
	margin-bottom: 10px;
	background-color: #eee;
	border: 5px solid #333;
	padding: 25px;
  }

  fieldset {
	border: none;
  }
||&lt;

-10. サーバーの起動
サーバーを起動し、http://localhost:3000/flickrにアクセスして表示を確かめる。
&gt;||
  &gt;ruby script/server
||&lt;

-11. search methodの実装
controllersディレクトリ内のflickr_controller.rbにsearch methodを記述する。1.で取得したFlickr API keyをFlickr.newのパラメータとして渡す。
&gt;||
  def search
    flickr = Flickr.new 'your flickr API key'
    render :partial =&gt; &quot;photo&quot;, :collection =&gt; flickr.photos(:tags =&gt; params[:tags], :per_page =&gt; '24')
  end
||&lt;

-12. _photo.rhtmlの作成
indexのpartial viewとして、views/flickrディレクトリに_photo.rhtmlを作成し、以下を記述する。
&gt;||
  &lt;img class=&quot;photo&quot; src=&quot;&lt;%= photo.sizes[0]['source'] %&gt;&quot;&gt;
||&lt;

-13. _photo.rhtmlに対するスタイルをflickr.cssに記述する。
&gt;||
  #photos img {
	border: 1px solid #000;
	width: 75px;
	height:75px;
	margin: 5px;
  }
||&lt;

-14. 表示の確認
ブラウザをリロードし、検索ワード'rubyconf'を入れて表示を確かめる。
-15. index.rhtmlの修正
(1)表示エフェクトの追加,(2)spinner.gif(データロード待ちの間くるくる回っているやつ)の表示のためにindex.rhtmlを以下のように修正する。
&gt;||
  &lt;%= form_remote_tag :url =&gt; {:action =&gt; 'search'}, :update =&gt; 'photos',
 	:complete =&gt; visual_effect(:blind_down, 'photos'),
	:before =&gt; %(Element.show('spinner')),
	:success =&gt; %(Element.hide('spinner')) %&gt;
	
	&lt;%= image_tag 'spinner.gif', :id =&gt; 'spinner', :style =&gt; 'display: none' %&gt;
	
	&lt;fieldset&gt;
		&lt;label for=&quot;tags&quot;&gt;Tags:&lt;/label&gt;
		&lt;%= text_field_tag 'tags' %&gt;
		&lt;%= submit_tag 'Find' %&gt;
	&lt;/fieldset&gt;

	&lt;div id=&quot;photos&quot; style=&quot;display: none&quot;&gt;&lt;/div&gt;

  &lt;%= end_form_tag %&gt;
||&lt;
-16. spinnerのスタイルをflickr.cssに記述する。
&gt;||
  #spinner {
	float: right;
	margin: 10px;
  }
||&lt;
-17. spinner.gifの入手
[http://trac.turbogears.org/turbogears/attachment/ticket/274/spinner.gif:title=こちら]などからspinner.gifを入手し、public/imagesディレクトリにコピー。

-18. 完成
ブラウザをリロードし試してみてください。僕の環境ではちょっと動作が重いですが、なかなか楽しめそうです。enjoy!


関連記事：[http://d.hatena.ne.jp/keyesberry/20060810/p1:title=Flickr on Railsをいじる(その１)]
　　　　　[http://d.hatena.ne.jp/keyesberry/20060811/p1:title=Flickr on Railsをいじる(その２)]


追記(2006/10/28)：flickrライブラリ(flickr.rb)の仕様が変わったようで、現時点(2006/10/28)では上記はうまく動きませんね。今の仕様ではflickr api keyはflickr.rb内に記述するようになっていますので、以下を試してください。
1./usr/local/lib/ruby/gems/1.8/gems/flickr-1.0.0にあるflickr.rb内の仮のapi keyを取得したapi keyに書き換える。
2.flickr_controller.rbではapi keyを書かずに、flickr = Flickr.newのみとする。 
追記(2007/5/21)：flickr.rbの在処は環境によって異なります。上記を試して表示されるエラーの内容で場所を確認してください。

</body>
<comments>
<comment>
<username>yoshi</username>
<body>非常に参考になりました。追記の変更もためしてみましたが、うまく動きませんでした。Brian Leonard氏の以下のサイトに従い、再度ためすとうまく動きましたのでご参考まで：&lt;br&gt;http://weblogs.java.net/blog/bleonard/archive/2007/03/building_a_ruby.html</body>
<timestamp>1179363409</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>yoshiさん、コメントありがとうございます。こちらでも再検証してみます。</body>
<timestamp>1179666694</timestamp>
</comment>
</comments>
</day>
<day date="2006-08-10" title="">
<body>
*p1*Flickr on Railsをいじる(その１)
昨日Railsで作ったFlickrインタフェースを少し改良してみました。改良点は以下の通り。
+flickrの特定ユーザを検索し、そのコレクションを表示できるようにする。
+１つの検索インタフェースを使って、タグおよびユーザの両方の検索が切り替えでできるようにする。
+表示レイアウトにタイトルバーナーを追加する。
手順は以下の通り。


-1. select_tagの追加
検索の対象を選択するために、select_tagをindex.rhtmlの＜fieldset＞に追加する。選択肢はoptions_for_selectで記述する。
&gt;||
  &lt;fieldset&gt;
     &lt;label for=&quot;tags&quot;&gt;Tags:&lt;/label&gt;
     &lt;%= select_tag 'kind', options_for_select({'tag' =&gt; 'search_tag','user' =&gt; 'search_user'}) %&gt;
     &lt;%= text_field_tag 'tags' %&gt;
     &lt;%= submit_tag 'Find' %&gt;
  &lt;/fieldset&gt;
||&lt;

-2. form_remote_tagの修正
select_tagで選択した対象(tag or user)をsearch methodに渡せるようにform_remote_tagを修正する。
&gt;||
  &lt;%= form_remote_tag :url =&gt; {:action =&gt; 'search', :params =&gt; params[:kind]},
                :update =&gt; 'photos',
   	        :complete =&gt; visual_effect(:blind_down, 'photos'),
	        :before =&gt; %(Element.show('spinner')),
	        :success =&gt; %(Element.hide('spinner')) %&gt;
||&lt;

-3. search methodの修正
select_tagでの選択肢によって処理を切り分けるためにcase文を使う。[http://redgreenblu.com/flickr/:title=こちら]にあったFlickr.rbのmethodを参照にしてsearch_user内の処理を記述する。
&gt;||
  def search
    flickr = Flickr.new 'your flickr API key'
    
    case params[:kind]
    when &quot;search_tag&quot;
      render :partial =&gt; &quot;photo&quot;, 
                 :collection =&gt; flickr.photos(:tags =&gt; params[:tags], :per_page =&gt; '30')
    when &quot;search_user&quot;
      user = flickr.users(params[:tags])
      render :partial =&gt; &quot;photo&quot;, :collection =&gt; user.photos    
    end
  end
||&lt;

-4. application.rhtmlの修正
タイトルバナーを表示するように、application.rhtmlの&lt;body&gt;を修正する。
&gt;||
  &lt;body&gt;
	&lt;div id=&quot;banner&quot;&gt;
		My Flickr
	&lt;/div&gt;
	&lt;div id=&quot;main&quot;&gt;
		&lt;%= yield %&gt;
	&lt;/div&gt;
  &lt;/body&gt;
||&lt;

-5. flickr.cssの修正
application.rhtmlに追加したbanner, mainのスタイルをflickr.cssに記述する。
&gt;||
  #banner {
    background: #C0C0C0;
    padding-top: 10px;
    padding-bottom: 10px;
    border-bottom: 2px solid;
    font: small-caps 40px/40px &quot;Times New Roman&quot;, serif;
    color: #A52A2A;
    text-align: center;
  }

  #main {
    margin-left: 0em;
    padding-top: 2ex;
    padding-left: 2em;
    background: white;
  }
||&lt;

-6. 完了
ブラウザでhttp://localhost:3000/flickrにアクセスし表示を確認。タブでtagまたはuserを選択し検索ワードを入れて検索。動いているようです。select_tagで選択した対象をsearch methodに渡す方法が分からずに悩みました。入力した検索ワードがヒットしない場合に、画面上にrailsのエラーメッセージが出てしまいます。これも直したいです。

</body>
</day>
<day date="2006-08-11" title="">
<body>
*p1*Flickr on Railsをいじる(その２)
Flickrインタフェースをさらに少し改良してみました。改良点は写真をオーバーレイ表示する機能の追加です。ネットを検索したらLightbox JSというスクリプトを使って既にこれを実現しているサイトがありましたので利用させて頂きました。

[http://seb.box.re/articles/2006/06/11/add-lightbox-zoom-on-the-flickr-ajax-rails-tutorial:title]

手順は以下の通り。

-1. Lightbox JSを入手
[http://www.huddletogether.com/projects/lightbox2/:title=こちらのサイト]からLightbox JS v2.0をダウンロードする。
-2. 必要ファイルをflickrプロジェクトにコピー
以下のファイルをプロジェクトの対応ディレクトリにコピーする。
lightbox.css =&gt; public/stylesheets/
lightbox.js   =&gt; public/javascripts/
image-1.jpg, thumb-1.jpg以外のすべてのイメージファイル =&gt; public/images/
-3. application.rhtmlの修正
lightbox.css, lightbox.jsを参照するようapplication.rhtmlの対応箇所に追加する。
&gt;||
 &lt;%= javascript_include_tag :defaults, 'lightbox' %&gt;
 &lt;%= stylesheet_link_tag 'flickr', 'lightbox' %&gt;
||&lt;

-4. Lightboxリンクの作成
表示される写真にLightboxのリンクが貼られるように_photo.rhtmlを修正する。
&gt;||
&lt;a href=&quot;&lt;%= photo.sizes[3]['source'] %&gt;&quot; rel=&quot;lightbox&quot;&gt;&lt;img class=&quot;photo&quot; src=&quot;&lt;%= photo.sizes[0]['source'] %&gt;&quot;/&gt;&lt;/a&gt;
||&lt;

-5. index.rhtmlの修正
Lightboxが初期化されるようにindex.rhtmlにおけるform_remote_tagのcompleteオプションを修正する。
&gt;||
 :complete =&gt; visual_effect(:blind_down, 'photos') + %(new Lightbox())
||&lt;

個々の写真を拡大して見れるようになりました。すばらしいですね。

</body>
</day>
<day date="2006-08-14" title="">
<body>
*p1*自らを律して自立せよ
ニートとは生活の根拠を親に依存している者のことである
動物としての最低限の親の役割は子を自立させることである
なぜなら親は先に死ぬからである
植物にはその必要性がない故に植物は高等生物である
多くのニートの問題は親のこの役割放棄にある
現代の一部の親は自分が動物であることを忘れて植物と化している
我々はそれほど高等な生き物でないことを知るべきである
その文脈において亀田のオヤジは最低限の役割を果たしているじゃないか！


*p2*組織のパラドックス
組織は個の自立の否定であり他者に対する依存がその基礎にある
しかし組織構成員の依存意識はその組織を弱くする
目的を達成するためには組織構成員の固い結束が必要だが
それが組織に対する依存意識を助長する
一方で組織構成員の緩い結合が依存意識を弱めるが目的意識までも弱くする
組織は組織の必要性を今一度考える必要があるかもしれない

*p3*組織のパラドックス～実践編
「君に期待しているよ」上司は言った。
「はい、がんばります」と答えた。
しかしがんばったけど、うまくいかなかった。
「君に期待したんだけどな。裏切られたよ」上司は言った。
「期待したあなたが悪い。期待しなければ裏切られなかった」と答えた。
「...」
「なぜ僕に期待したんですか」と聞いた。
「君なら僕の右腕になれると思ったからだ」上司は答えた。
『僕はあなたのパーツじゃない』と答えた。
「...」
「あなたの仕事はあなたがやるしかない。僕に依存すべきでない」と答えた。
「それなら君は君の仕事を見つけるしかないな。私に依存すべきでない」上司は言った。
「...」
「...」
「...」
「別のプロジェクトがあるんだが、やってみる気はないか」上司は言った。
「はい、やらせて頂きます。」と答えた。
「今度は期待しているよ」上司は言った。
「がんばります」と答えた。

*p4*生きる故に生きられない
人間は死が突然にやってくるということは知っている
だから今を生きることが大切だということも知っている
しかし未来が不安故に今を生きられない
死が不安なのではなく生きるということが不安なのだ
人は生きる故に今を生きられない
</body>
</day>
<day date="2006-08-24" title="">
<body>
*p1*まず自分を疑うのが最良の解決策だ！
確率に関するあるクイズがある。
「３つの箱の何れかに賞品が１つ隠れています。１つを選んでください。
そちらの箱でよろしいですね？では、私が残りの箱を確かめてみましょう。
なるほど。もう一度あなたにチャンスをあげます。
私が確かめた箱のうち、こちらの箱には賞品はありません。さあ、答えを変えますか？それともそのままでいいですか？」
あなたならどうする？

[http://d.hatena.ne.jp/keyesberry/20060827/p2:title=答え]


*p2*being digital：ディジタルに生きる
AWDwRに続き[http://pragmaticprogrammer.com/titles/ruby/index.html:title=こちらのサイト]でProgramming Ruby 2nd edition(Pickaxe)のpdf版を買った。
注文から2、3分で手元に届いた。$25.0(およそ2900円)であった。
同サイトにて書籍版は$44.95+送料で買えるが、Amazon.comなら$28.32+送料で買える。
日本語版は近々分冊本が3990円+4410円で出る([http://www.cbook24.com/bm_browsing.asp?product%5Fgroup%5Fid=3D51ED79%2D4A8C%2D425E%2DA527%2D7CC0BF24A02B&amp;page=0&amp;browsing%5Ftype=browsing:title=こちら])。
1st editionはAmazon.co.jpで4677円で買えるが、[http://www.ruby-doc.org/docs/ProgrammingRuby/:title=こちら]でWeb版を無料で読める。
日本語版は[http://www.7andy.jp/books/detail?accd=30875260:title=セブンアンドワイ]にて5040円で買える。


今、being digitalを読み直している。ネグロポンテは「アトムからビットへの変化に後戻りはない」と10年前に言った。
自分たちはディジタルの時代に生きている。現時点で情報革命は多様性を生み出している。
しかしネグロポンテの予言に従えばいずれはビットに収束する。
being digital(日本語版)はbook-offにて105円で再購入した。Amazon.co.jpでなら中古を225円+送料で買える。
英語版はその一部を[http://archives.obs-us.com/obs/english/books/nn/bdcont.htm:title=こちら]で読むことができるが、Amazon.comなら中古を$0.01+送料で買える。


ISBN:4756139655:detail
</body>
</day>
<day date="2006-08-25" title="">
<body>
*p1*オブジェクトはキノコである
オブジェクト指向プログラミングは、オブジェクトを中心としてプログラムを組成する手法である。
オブジェクトはメッセージを理解するので、プログラマにとってオブジェクトが何者であるかは重要ではない。
でもオブジェクトが何者であるのかはすごく気になる。
オブジェクトはメッセージを理解するので生物なんだろう。
しかし自発的に行動しないから動物ではないんだろう。
また植物ほど静的でもない。
オブジェクトは他発的・他動的にのみ行動する中間生物なんだ．．．。
そうか、わかったぞ！オブジェクトはキノコだったんだ！

*p2*電子公共図書館は社会資本としてはうまく機能しない
資本主義をその国家の基調とする限り、公共サービスの存在価値はその不便性にある
不便故にその存在を許される
公共サービスの利便性はその独占を意味し、それは資本主義社会における悪である
電子図書館はそのサービスにおける利便性の究極のかたちである
それは著作者の経済的権利をすべて飲み込むブラックホールである
著作物の電子的頒布は特権的地位のない何かに早々委ねるべきである
</body>
</day>
<day date="2006-08-27" title="">
<body>
*p1*株式投資と統計学
統計学は対象の傾向を知るための学問である
株式投資にはおいて統計学は適切なリスク回避に役立つ
しかし株式投資の目的はリスクを回避することではない
リターンを得ることである
そしてその違いは大きい
統計学ひいては金融工学に従う限り
敗者になる者はいないが
確たる勝者になる者もいないのだろう
顧客のリスク回避が富の源泉となる証券会社を除いては

*p2*あなた、それは直感に反するあるよ！
[http://d.hatena.ne.jp/keyesberry/20060824/p1:title=8月24日]のクイズはモンティーホール問題(Monty Hall Problem)として知られているものだ。


[http://en.wikipedia.org/wiki/Monty_Hall_problem:title]


戦略としては「答えを変える」のが正しい。
最初の選択で賞品を引き当てる確率は3分の1。
残りの２つに賞品が入っている確率は3分の2。
答えを変えるというのは確率3分の2の方を選ぶことに帰するので、こちらの方が確率的に有利。
しかも2倍も有利！

そんなぁ～という方は実践あるのみ！

[http://www.decisionhelper.com/montyhall.htm:title]



ISBN:4873112710:detail
</body>
</day>
<day date="2006-08-30" title="">
<body>
*p1*私はピロソポス（知恵を愛する人）です
同じことが人生についても言えましょう。ある者は富への愛によって動かされ、ある者は権力と支配を欲する情熱に盲目的に引きずられています。しかし最も優れた人間は、人生の意味と目的とを見いだすことに専心するのです。自然の神秘のヴェールを剥ごうと努力するのです。これこそが私が、知恵を愛する人と呼ぶ人間です。というのも、あらゆる点で非の打どころなく賢い人間などおりませんが、知恵を愛する人は、自然の神秘への鍵としての知を愛することができるからです。

by ビュタゴラス～フェルマーの最終定理：サイモン・シン


ISBN:4105393014:detail
</body>
</day>
<day date="2006-09-01" title="">
<body>
*p1*知るべきか、愛するべきか、それが問題だ！
&gt;&gt;
知識は人間に与えられた最高の資質の一つですよ。
しかし知識を求める心が、愛情を求める心を排除してしまうことがあまりに多いんです。
&lt;&lt;
by Charlie Gordon~アルジャーノンに花束を


ISBN:4151101012:detail
</body>
</day>
<day date="2006-09-06" title="">
<body>
*p1*過ぎたるはなお及ばざるが如し
世の中の出来事は
皆が言うほど悪くはない
しかし皆が言うほど良くもない

*p2*教え(Output)と学び(Input)
教えは人のためになる
教えは金になる
教えは自尊心を満たす
教えは学びにもなる


学びからは金も自尊心も得られない
人のためにもならない
しかし教えは学びからしか得られない
つまり学びは教えの出発点である
</body>
</day>
<day date="2006-10-05" title="">
<body>
*p1*本当にオープンソースこそがテクノロジーの未来なのかもしれないぞ
&gt;&gt;
今日の特許のシステムは、核兵器ではなく知的財産権を使った冷戦の戦場なのだ。それはあまり素敵なものじゃない。防空壕に身を寄せ合っているのは発明家で、彼らは常軌を逸したシステムを相手にしなくちゃならず、１万２０００人もの弁護士を雇う金もない。
&lt;&lt;
by Linus Torvalds ~それがぼくには楽しかったから


ISBN:4796880011:detail
</body>
</day>
<day date="2006-10-09" title="">
<body>
*p1*Web 2.0、それは楽しい未来
すごい！でも、未来は一歩も進んでないよ！
[http://www.youtube.com/watch?v=topeBoB-ApQ:movie]


[http://www.leobridlefilms.co.uk/index.html:title]
</body>
</day>
<day date="2006-10-11" title="">
<body>
*p1*YouTubeの買収はGoogleの敗北
Google、技術のチカラを世間に見せつける会社
Google、技術のチカラで世界を再構築しようとする会社
Google、その買い物は未来を作る技術者と技術
Google、それは技術屋による技術屋のための会社
Google、壮大な構想でみんなをわくわくさせる会社
みんなそう思っていた


YouTubeの買収
YouTubeは技術ではなく商品である
Googleは技術や技術者ではなく商品を買ってしまった
商品はそれが商品ゆえに価値がある
だからGoogleには統合できないのだ


このような買収は本来スーツの仕事である
スーツはコングロマリットを目指す
Googleもスーツの会社になってしまった
この買収はGoogle思想の敗北を意味するのだ
Googleにとってハシタガネかもしれないけれど
それは明らかなる敗北の証なのだ
Googleの技術者はプライドを示せなかった
社内のスーツ族に支配されたのだ


未来は明るくない
第２期ＩＴバブルのはじまりを予感させる
僕は圧倒的に正しくない戦略が今更ながら執行されたのだと評価します
</body>
</day>
<day date="2006-10-12" title="">
<body>
*p1*我が家にもWii(TV)リモコン
















 
</body>
</day>
<day date="2006-10-14" title="">
<body>
*p1*対抗するより、一緒にやろう！
&gt;&gt;
work with each other rather than against.
&lt;&lt;
by Richard Stallman 
~オープンソースがなぜビジネスになるのか


イノベーションは企業にとっての利益の源泉である。イノベーションと企業の利益は、人類にとっても利益である。ゆえに知的財産法は、イノベーションの企業への帰属を保証する。


一方で、オープンソース・プロジェクト(GNU)は、「自由こそが、イノベーションを加速するものである」ということを証明しつつある。この次世代のための新たな試みは、人類にかつてないほどの利益をもたらす可能性を秘めている。この新しいイノベーションのかたちを減退させてはならないのだろう。


企業の権利を認めつつ、このような自由が保証される道を作ることが、われわれに課せられた新たな難題である。この課題は人類に課せられた地球レベルのものなのだ。そう、われわれはもはや地球市民なのだ！


ISBN:4839920788:detail
</body>
</day>
<day date="2006-10-15" title="">
<body>
*p1*Googleだって、ついていくのにやっとなんだよ
Googleが支払う16億ドルは高いのか安いのか
少なくとも、これを相対価値で量っても意味はない
Googleの株価やイージス艦との比較でそれが正当化されるわけではない
投資は本来、絶対価値で量るべきである
彼らの買った有料ブリッジが、投資した16億ドルを結局いくらにしてくれるかを問題とすべきである
それは難しい問題なのだけれども、期待される収益の確からしさを追求することをもってその行為が投資としてはじめて正当化されるのだ


いろいろな期待や可能性は十分すぎるほどにある
それに比べれば著作権問題は小さく見える
しかし現行の知的財産法の枠組みにおいて、YouTubeの将来価値は不定のものである
むしろ権利者が牙を剥かないようにするネゴシエーション能力が鍵なのだ(YouTubeもGoogleもそのことは理解しているはずだ)


GoogleによるYouTubeの買収が正当化される唯一の事由は、保険である
GoogleはYouTubeに恐怖し、その思想において敗北を認めざるを得なかった
そして、連合の道をとった
これはGoogleにとってNegative Decisionなのだ
具体的対応は異なるけれども、MicrosoftがNetscapeに恐怖したと同じように、かれらもYouTubeに恐怖したのだ
僕はここに、Googleの弱さを見た気がする
わずか2年でこのような巨大なメディアハブが出来上がるWebの世界に、Google自身もついていけないのだ
彼らにとって恐怖となる新たなる巨人が、短期間のうちに出現して成長することはない、と誰が言えようか
Webというのは誰も未来を断言できない、そういう世界なのだろう


関連記事：[http://d.hatena.ne.jp/keyesberry/20061011:title=YouTubeの買収はGoogleの敗北]
</body>
</day>
<day date="2006-10-16" title="">
<body>
*p4*TextMateで日本語入力
TextMateは最高なのですが、日本語が入力できません。
入力するとフリーズします。
[http://www.akatombo.com/en/comments/entering_japanese_in_textmate/:title]
この方は、space + escape + enterキーでフリーズから抜ける技を紹介しています。また、サーチダイアログでは日本語が入力できるから、そこで入れてコピペしてはどうかといってます。

これに対して、仮の文字列を英語で入れておいて、日本語に置換する方法もあるなぁなどと、考えながらキーをガチャガチャやってたら、一つ、発見しましたよ。
&gt;&gt;
日本語入力して、
ctrl + shift + return
または、
ctrl + option + return
&lt;&lt;
ね？連文節変換しないで、単語変換してくださいね。そうすれば変換候補を選べますから。完全ではないですけど、少し使えそうですね。日本語入力に、[http://aquaskk.sourceforge.jp/:title=AquaSKK]を使えば、もっと良くなるかもしれませんね。

*p3*UNIXとFirefoxのパッケージ販売始まる！
今日は先日オープンしたばかりのららぽーと豊洲にいってきましたよ。東京ベイに規模では劣りますけど、広くて気持ちのいい空間でしたね。で、早々目的のUNIXとFirefoxのお店を覗いてきました。

[f:id:keyesberry:20061016132830j:image]


UNIXのお店は個室風になっていてちょっと入りづらかったのですが、外から見ると意外にも女性客が多くてびっくりしました。ビジネスの世界ではWindowsがデファクトスタンダードですが、流行に敏感な女性の間ではすでにUNIXが浸透してるのですね。僕も&lt;del datetime=&quot;2006-10-16T18:20:15+09:00&quot;&gt;おばさん&lt;/del&gt;彼女たちに負けないようにがんばらないと。Perm Program、treatment Program、お客様満足200%プログラムもあるし、スタイル保証システムもあるので安心ですね。あっ、もしお店の方が見てらっしゃったら、お店の看板を直した方がいいですよ。「m」取れちゃってますよぉ。

[http://www.unix.co.jp/:title]


[f:id:keyesberry:20061016133756j:image]


Firefoxのダウンロード件数が１億を超えたというニュースは聞いていましたが、まさか、ららぽーと豊洲でパッケージ販売されるとはびっくりですね。時代の変化を感じます。ざっと見たところ、Tシャツなどの関連グッズだけでなく、フィッシングウェアやレインウェアなどのセキュリティ関連グッズも充実してて、これならビジネスとして成り立ちそうですね。あっ、もしお店の方が見てらっしゃったら、お店の看板を直した方がいいですよ。「Fox」はあとですよぉ。

[http://www.foxfire.jp/:title=Foxfire]


とにかく今日は勉強になりました。Webにばかり張り付いていると、世の中の変化が分からなくなるということを痛感しましたよ。これからはできるだけ街に出ようと思います。


[http://toyosu.lalaport.jp/index.shtml:title]



ISBN:4274064069:detail


ISBN:477780139X:detail


*p1*踊るアホウに見るアホウ、同じアホなら...
祭りは楽しいし、みんなが祭りが好きなことは分かっているよ
でもね、祭りはコストなんだということを忘れてはいけないよ
15年間掛けてやっとコストを払い終えたことを忘れてはいけないよ


僕だって、そりゃわくわくするよ
みんなと踊りたいよ
でもね、回りを良く見てみなよ
大人(スーツ)はみんな片足しかそこに入れてないじゃないか！
祭りが終わったとき、大人はトットと自分の仕事に戻って
後片付けは僕らがすることになるんだよ


ネットがDog yearだからって、僕たちは犬じゃないんだから
よく考えて行動しようよ、それが知性ってもんだろ
そして知性こそが人間を人間足らしめてるって、みんな知ってるじゃないか


目の前のキャンパスノートに無限大の創造をかき立てられるのはすばらしいことだけど
キャンパスノートを買うのにその夢の代金まで払わされるのは変だよね
夢や可能性というのはお店で売っているものではなくて、自分たちで作るものなんだよ


ISBN:4839902259:detail

*p2*YouTubeは16億ルピー～株式交換による買収には気をつけろ！
株式交換による買収だから損はしないと思うのは早計である
その株価が将来10倍、すなわちテンバガーになることが期待されるとき
買収金額はそれがテンバガーになったときから見たその現在価値である
16億ルピーは16億ドルのコストではなくて、160億ドルのコストになるリスクがある


つまり、株主からの資本運用の委託を受けた経営者として、株式交換による買収が正当化されるのは、
自社株式の将来価値が現在よりも(現在価値にして)低くなると予想されるときのみである
合理的にはこれは、経営者による自社株バブル宣言である
そうでなければただのアホかお人好しである
Googleに対する期待が高ければ高いほど
このやり方には批判があるべきである


asin:B000FJ37WY:detail
</body>
<comments>
<comment>
<username>通りすがり</username>
<body>自分も同じこと思いましたｗ&lt;br&gt;釣り（”魚”を釣るほう）しないのでfoxfireってブランド知らなかったんですが、最近なぜかオレンジのロゴに変えたようですよ。</body>
<timestamp>1161542405</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>コメントありがとうございます。言われてみれば、色も同じだったんですね。</body>
<timestamp>1161556386</timestamp>
</comment>
</comments>
</day>
<day date="2006-10-17" title="">
<body>
*p1*ゼロサムゲームと生き残りゲーム
ゼロサムゲームが嫌いだ
勝利は敗者の存在の上に成り立っているからだ
当事者の視線は相手に向かっている
勝者が敗者を作っている
それは公平なことなんだけれども罪でもある


early retirementとかexit strategyとか勝ち組負け組とか
売り抜けとか損切りとか企業戦士とかゲーム理論とか
できればそんなセコいことは考えたくない


ゲームをしなければならないなら
僕はゼロサムゲームよりも生き残りゲームをしたい
生き残るために知恵を使いたい
生き残りゲームの相手は環境の変化であり自然である
視線をそこに向け、知恵を使ってその順応性を高めたい
</body>
</day>
<day date="2006-10-20" title="">
<body>
*p1*Wii will rock you!
今日有楽町に行ったとき、ビックカメラのゲームコーナーをちょっとのぞいてきたんですよ。そしたら、XBOX360で卓球やってた人がいて、グラフィックがきれいで、その人うまくてラリーしてて、なんか面白そうな感じがしたんですよ。でね、その人がやめたので、自分やろうかなと思ったんですけど、でもどうやって操作するのかな、難しいのかなって感じて、躊躇してたら、他の人がコントローラを手にしたのであきらめたんですね。で、思ったんですけれども、ゲームを全くやらない人は、毎度こんな調子なんだろうなと。


でね、この視点からいくと、任天堂のWiiっていうのは、きっとその躊躇がないんですね。同じように卓球ゲームのようなもの（Wiiの場合はテニスですね）が試遊台として置かれていて、誰かがやってるのをゲームをやらない人が見ても、どうやればいいかすぐ分かる。一目瞭然。このチカラは凄いんじゃないかと。人っていうのは、自分ができそうだと認識して初めて面白そうと感じるのじゃないかって。一般の人がゲームに対する今までの遅れを取り戻せる（任天堂は同じスタートラインに立てるといってますね）と感じるのじゃないかって。そうすると、ゲームは本当の意味で市民権を得られるのじゃないかと思うんですね。


コンピュータが一般の人にここまで普及したのは、そのインタフェースがＣＵＩ（キャラクタベースのユーザインタフェース）からＧＵＩ（グラフィックベースのユーザインタフェース）に変わったことが大きな理由だと思うんですね。誰かがキーボードをカチャカチャやるのを見ても自分にはできそうに見えない。それがマウスで操作するようになって、自分でもできそうだな、面白そうだなと思えるようになる。そんなことが大きいと思うんです。


でね、任天堂のWiiっていうのは、更に進んだインタフェース、こういう言葉があるのかわかりませんが、ＡＵＩ（アクション・ユーザ・インタフェース）なんですね。ＧＵＩの世界では誰かがそれを操作しているとき、画面上のカーソルとマウスが同じ動きをしてるのを見て、それを知らない人でも大抵は、あっなるほどね、ってなるんですけど、でも動きは完全に一致してないんですよ。随分昔ですけれど、義理のお母さんにパソコン初めて触らせたときに、「お母さん、上（カーソルを上に移動させるっていう意味で）」っていったら、マウスを宙に持ち上げたことがあったんですね。そりゃ確かに上だと。でもね、Wiiではね、そういうことはあまりおこらないんじゃないかと思うんです。もちろんゲームの設計に掛かっているんですけれども、設計が正しくなされていれば、自然界の常識に従って、あるいは今までの人生経験に従って、Wiiリモコンを振ればいい。ボールを画面の向こうに向けて打ち返したければ画面に向けて振ればいい。只無心に振ればいい。


DSが一般の人にこれだけ普及した要因の一つはやっぱりタッチペンにあると思うんですね。考えてみればね、タッチペンっていうのは画面をタッチすればいいから分かりやすいというよりも、タッチするアクションが端から見て分かりやすいということなのかも知れませんね。DSは、ＧＵＩ＋ちょっとＡＵＩって感じですか。でね、Wiiの場合は分かりやすさでは更にその上をいくんですね。指先だけじゃなくて、腕全体、体全体を使って操作するんですから。DSのちょっとＡＵＩを見て、なるほど、なんですから、WiiのフルＡＵＩを見せたら、なあ～るほど、となるんじゃないかと。子供の下手なゴルフスイングを見てお父さんが、どれ、俺に貸してみろ！なんて言うんじゃないでしょうかね。


今日はね、あと、ユニクロとスタバにも寄ったんですよ（まあ、しょっちゅう行ってるんですけど）。でね、改めてね、いろんな年齢層のお客さんが来てるなと思ったんですけど、これがね、市民権を得てるという状況だと思うんですね。スタバにはお年寄りがうじょうじょ（ちょっと大げさ）いるんですよ。ユニクロにはおしゃれな子（まあ銀座店ですから）も来てるんですよ。おしゃれな子と同じ服をおばさんが試着したりして。確かにDSによってゲームコーナーの客層は変わったと思うんですけど、DSからは出ない。一般の人はゲームを買いに来てるんじゃなくてDSを買いに来てるんですね。


その意味でね、僕はね、Wiiの発売を楽しみにしているんですよ。もちろん自分がゼルダをやるのが楽しみなんですけれども、（もしかしたら）それ以上に一般の人がWiiリモコンを振る姿を見れるのが楽しみなのかもしれません。スタバによってカフェ文化ができたように、ユニクロが老若男女にファストファッション（ファストフードの洋服版ですね）を根付かせたように、任天堂のWiiを通して、ゲームがみんなに認められる日が来るのを楽しみにしたいと思います。

&lt;table style=&quot;width:auto;&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://picasaweb.google.com/postagie/Wii061020/photo#4987900440126947346&quot;&gt;&lt;img src=&quot;http://lh6.google.com/postagie/RTiVBfTIABI/AAAAAAAACSk/i6Ui-poKARU/s288/R0011769.JPG&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</body>
</day>
<day date="2006-10-24" title="">
<body>
*p1*Why 37signals
ほんとにあなたたちは格好良すぎます
そのすべてをサルまねしたくなっちゃいます
Macを買いましたよ(DisplayはDellですけれど)
RubyもRailsもインストールしましたよ
TextMateもレジストしましたよ
やっぱりCinemaDisplayを買わないとだめですか？
机の上の本は買った方がいいですか？(日本語版がありますね！)
そのキーボードはなんですか？
椅子はやっぱりHermanMillerですか？
その机はIKEAで買えますか？
そのシャツはユニクロで売ってますか？

[http://www.apple.com/education/whymac/compsci/video.html:title]

[http://www.apple.com/education/whymac/compsci/:title]

[http://www.37signals.com/:title]


ISBN:4839916063:detail
</body>
</day>
<day date="2006-10-28" title="">
<body>
*p1*企業のあり方
企業の第一の目的は利益を上げることである
しかし人類に価値を与えられなければ利益は得られない
人類の価値は常に変化する
だから企業は顧客にすがりつくしか生きられないのだ


*p2*バランス、そうすべてはバランスなんだ！
&gt;&gt;
もしリソースが競合的なら、そのリソースが取り尽くされないように、コントロールのシステムが必要となる。つまりそのシステムは、リソースが生産されると同時に過剰消費されないように保証しなければならない。もしリソースが非競合的なら、コントロールのシステムは、単にリソースが生産されることを保証するために必要となる。＝＞われわれが競合リソース（土地や車やコンピュータ）のために作るコントロールのシステムは、非競合的リソース（アイディア、音楽、表現）には必ずしも適切ではない。それどころか両方のリソースに同じコントロールのシステムを適用すると、実害があるかもしれない。
&lt;&lt;
&gt;&gt;
技術は法と結びついていて、いまやコンテンツとその配信に対してほぼ完璧なコントロールを約束している。そしてこの完全なコントロールこそがインターネットの約束するイノベーションの可能性をつぶそうと脅かすものだ。
この脅威に対抗すべく、コントロールと創造性のバランスを再確立するために具体的な変化が必要だ。ねらいは、アーティストたちが生産を行うのに十分なインセンティブを与えるに足るだけのコントロールを持ち、一方ではなるべくフリーな部分を残してほかの人がそれを下敷きに創造できるようにするようなシステムだ。
&lt;&lt;
by Lawrence Lessig ~コモンズより


本書の基本的な考え方にはほぼ全面的に同意できる
現行の知的財産法はコモンズを脅かす
確かに健全さを保つためには知的財産法が必要だと思う
一アーティストの作品はそれが物理的に独占できないからといって
公共財だというのはアンフェアだ
しかしその無断借用が全面的に悪であるとするルールは
脳を使わずに考えよと言うに等しい
だからその中間のバランスのとれたところに答えがある
ということははっきりしている


レッシグはそのバランスの取り方の一方法として
コントロールできる期間を見直すことを提案している
期間によりバランスを取る方法は曖昧さがないからその点では優れている
だけど僕はその方法にはあまり賛成できない
期間が過ぎれば自由がはっきりする
しかし、一方で期間中は権利者のコントロールは一層厳しくなるかもしれない
一体、どの権利がいつ始まっていつ終わるのかわからないような状況で
クリエータはいつ、ほら穴から出てくればいいんだろう
また、確かに一旦約束された期間が延びるのはフェアではないけれども
Micky Mouseは年を取っていないということも考えなくちゃならない
それはもしかしたらDisneyのお陰なのかもしれない
つまりMickyがみんなの自由になったらMickyは死んでしまうかもしれないということだ


残念ながら有力な代替案があるわけではない
でも一つの方向性は示せる
それは柔らかい運用のためのシステムだ
Disneyの海賊版を売ってる人と
YouTubberのビデオをリミックスしてYouTubeに投稿した人
主製品を大企業にデッドコピーされたベンチャーの人と
LinuxやRubyなどのオープンソースウェアにソフトウェア特許を行使する人
現行ではこれらは何れも違法であり正当な権利行使だ
でも、それってないよね
だから柔らかい運用のためのシステムが必要なんだ
つまり、その権利は相対的なものであって
誰が、誰に行使するかによってその強さが変わる
その権利や製品の社会的価値によって強さが変わる
ノブレス・オブリージュのようなものをシステムとして組み込む
もしかしたらネット上の投票システムがその役割を果たせるかもしれない
過去の判例に頼らずに自由に投稿できる仮想例示集サイトがバランスを作るかもしれない


コモンズ、そう僕らのコモンズは創造を絶するスピードで進化し
さらに僕らを誰も体験したことのない世界へ迎え入れようとしている
こんなにわくわくさせられることはなかったと思う
現在の知的財産法はみんなの期待を大きな落胆に変えるかもしれない
そのためにはこの問題のうまいバランスを探さなけりゃいけない


ISBN:4798102040:detail
</body>
</day>
<day date="2006-10-29" title="">
<body>
*p1*岩田っちがすごいのはプレゼンだけじゃない！
[http://www.nintendo.co.jp/kessan/index.html:title=任天堂の中間決算]をざっと見たので、ここに残しておくよ。
任天堂中間決算(19年3月期)
&lt;table style=&quot;margin: 0pt 3em; width: 258px; height: 156px;&quot; border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;
&lt;/th&gt;&lt;th style=&quot;text-align: center;&quot;&gt;金額&lt;/th&gt;&lt;th style=&quot;text-align: center;&quot;&gt;前年比&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;売上&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;2988億&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;70%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;営業利益&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;671億&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;242%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;経常利益&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;947億&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;66%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;当期利益&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;543億&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;48%&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


販売実績(単位は万台または万本)
&lt;table style=&quot;width: 414px; height: 595px;&quot; border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;
&lt;/th&gt;&lt;th&gt;
&lt;/th&gt;&lt;th style=&quot;text-align: center;&quot;&gt;今中間期&lt;/th&gt;&lt;th style=&quot;text-align: center;&quot;&gt;前中間期&lt;/th&gt;&lt;th style=&quot;text-align: center;&quot;&gt;変化率&lt;/th&gt;&lt;th style=&quot;text-align: center;&quot;&gt;前期&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;GBA&lt;/td&gt;&lt;td&gt;JP&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;8&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;57&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;-86%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;100&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;/td&gt;&lt;td&gt;US&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;100&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;168&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;-40%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;472&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;/td&gt;&lt;td&gt;EU&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;58&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;100&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;-42%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;261&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;GBAsoft&lt;/td&gt;&lt;td&gt;JP&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;170&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;353&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;-52%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;728&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;/td&gt;&lt;td&gt;US&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;1355&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;1758&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;-23%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;3534&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;/td&gt;&lt;td&gt;EU&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;455&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;665&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;-32%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;1674&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;DS&lt;/td&gt;&lt;td&gt;JP&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;461&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;150&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;207%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;478&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;/td&gt;&lt;td&gt;US&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;240&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;68&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;253%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;292&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;/td&gt;&lt;td&gt;EU&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;309&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;139&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;122%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;376&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;DSsoft&lt;/td&gt;&lt;td&gt;JP&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;2064&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;531&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;289%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;2152&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;/td&gt;&lt;td&gt;US&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;1194&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;456&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;162%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;1608&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;/td&gt;&lt;td&gt;EU&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;1059&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;343&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;209%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;1235&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;GC&lt;/td&gt;&lt;td&gt;JP&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;2&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;4&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;-50%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;20&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;/td&gt;&lt;td&gt;US&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;27&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;63&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;-57%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;172&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;/td&gt;&lt;td&gt;EU&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;6&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;14&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;-57%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;44&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;GCsoft&lt;/td&gt;&lt;td&gt;JP&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;30&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;134&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;-78%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;298&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;/td&gt;&lt;td&gt;US&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;788&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;975&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;-19%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;2388&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;/td&gt;&lt;td&gt;EU&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;80&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;213&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;-62%&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;592&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

僕なりのトピックスを挙げておくよ。
-とにかく売上の延びがすごいよね。任天堂の売上はここのところずっと5000億前後で横ばいだったんだ。それが前期比70%増。成熟したと言われていたこの業界で前期比70％はすごいとしかいいようがないよ。
-前期の中間営業利益は少なめだったので、これと比較して240％！というのは適当じゃないだろうね。本来的には売上と同程度の伸び率と見るのが適当じゃないかなと思う。それでも凄いけどね。
-DSはこの上半期に世界で1000万台売れ、世界累計で2700万台となったそうだよ。
-上半期に世界でスーパーマリオは680万本、脳トレは460万本(累計850万本！)。Touch Generationシリーズは世界累計2500万本！。もうびっくり！
-海外売上比率が１年前の71%から60%に下がっているね。日本でのDSの売上増ほど海外(特に米国)では売上は伸びていない。だけど、これはきっとDS Liteのリリース時期などDSの展開が日本より遅れているためだね。販売数の伸び率で見ると日本よりも高いんだね。海外売上比率が下がっているので為替の影響も以前よりは少し小さくなっているけど、ただ、海外でのDSの売上増はこれからなので、また元に戻っちゃうんじゃないかな。
-GBAは国内では急減速するも、海外では依然GBAのソフトが売れているんだね。でもDSの浸透により今後は日本と同様になるんじゃないかな。
-DSの延びはすさまじいよ。この上半期のソフト販売数はすでに前期の１年間の本数に迫ってるよ。今期が終わった時点でいったいどうなってるんだろうね。
-GameCubeは国内ではほとんど売れてないね。でも、海外ではソフトはまだ結構売れてる。Wiiがこれらのユーザをうまく引き継げればいいね。


さて、今期末の会社予想は、売上7400億、経常1700億となっている。過去の傾向からいって下半期は上半期の売上の1.5倍くらいなんだ。上半期が3000億だから、下半期は4500億、これを足すとだいたい会社予想になる。だけど、これはWiiが発売されない状況で想定される範囲内のものだと思う(もちろん会社はWiiの予想販売台数を加味してこの数字を出しているはずなんだけれども)。下半期もDSを買う人の勢いが衰えないで、さらに、GameCubeのユーザ以外の人たち(PS2のユーザやいままでゲームをやらなかったような人たち)がWiiに関心を示したら、その分はこの数字に上乗せされるように思うんだ。Wiiが一体どれくらい売れるかなんていうのは僕にはもちろん分からないけれども、この上乗せ分はそれなりに期待できるんじゃないかな。とにかくね、今の任天堂からは全く目が離せないよ！


分かってると思うけど、僕は君に任天堂の株を買うことを勧めてるんじゃないからね。いくら今年咲いたチューリップがきれいだからって、それに100万円も払うことがおかしいとわかるように、買い物はその値段と君の財布次第だからね！


ISBN:4270000708:detail
</body>
</day>
<day date="2006-11-01" title="">
<body>
*p1*悪魔的経済学
&lt;a href=&quot;http://blog.goo.ne.jp/ikedanobuo/e/e99994e9d6e0dd27745abe18eb7bd2b7&quot;&gt;プリンタのカートリッジはなぜ高いのか ~ 池田信夫 blog&lt;/a&gt;
&lt;blockquote&gt;
この問題は法的には係争中であり、判例もわかれているが、経済学的に重要なのは、これはサラ金と同じく近視眼バイアスを利用した「悪魔的ビジネスモデル」だということである。上にリンクを張ったForbesの記事の例では、エプソンの純正カートリッジは30ドルなのに、再生品は5ドルだ。1ヶ月に2回インクを換えるとすると、差額は1年で600ドル。中級のプリンタが1台買える値段である。
&lt;/blockquote&gt;

&lt;a href=&quot;http://blog.goo.ne.jp/ikedanobuo/e/aedb536c459aa60520b6fa95f70db9e7&quot;&gt;悪魔的ビジネスモデル ~ 池田信夫 blog&lt;/a&gt;
&lt;blockquote&gt;
このトリックのポイントは、元金というストックの大きさを隠し、金利というフローだけを見せるところにある。行動経済学的にいえば、近視眼バイアスをうまく利用しているわけだが、ストックとフローの関係を混乱させて消費者を欺く悪魔的ビジネスモデルは、サラ金だけではない。携帯電話の端末が0円で買えるのは、その価格（ストック）が通話料（フロー）に上乗せされるからだし、ゲーム機の価格が安いのもゲームソフトのライセンス料で回収するからだ。プリンタは安いがインクカートリッジが高いとか、エレベーターは安いが修理費用が高いなど、ストックの価格をフローに分散して安く見せかけるトリックは多い。
&lt;/blockquote&gt;


サラ金の問題は、むしろその商品を正しく認知させないでロックアップを掛ける(掛かってしまう)ことにあると思われる。後にそれが自分の欲したものではないことを認知したときに、その取引から離脱できないことが問題だ。住宅ローンや生命保険だって、長期計画は示すけれども支払総額、すなわち商品選別にあたってもっとも重要と思われる商品の値段は積極的に示されない。ロックアップを掛けられたユーザにとって、あとでその金額を認識することは問題であろう。


プリンタやビデオゲームのビジネスモデルでは、ロックアップは掛からない。カートリッジの値段が高ければその取引から離脱し、そのメーカーのプリンタやゲーム機をもう買わないと誓えば良い。この場合における本体価格の安さは寧ろユーザにとっての救いである。更にゲーム機の場合は、ユーザにとってそれはただの箱であり別途ゲームソフトをすぐに(通常は同時に)買わなければならないことを認知しているのであり、従って本体購入時にフローの問題を認識していると考えるのが妥当だ。


一方で、本体価格を高くして(それで採算が取れるようにして)、カートリッジに転嫁しないビジネスモデルにおいても、その期待される機能(例えばはがき印刷)の説明がはっきりとされていない場合には問題が生じる。商品返品が認められない限り(問題を知るまで使ってしまった)、ユーザはその価値に見合わない対価を支払わされる。


他のプリンタメーカーが、安いカートリッジを使用できる高いプリンタの販売が自由にできない、というのなら不公正競争であろう。しかしその事実はない。もっとも、カートリッジ再生業者の行為がプリンタメーカーの特許を侵害しているか否かというのは別問題である。仮にその行為が特許権を侵害しておらず違法でないと判断される場合、それはそのビジネスモデルの崩壊を意味するのであって、プリンタメーカーは他のビジネスモデルを模索しなければならない。ただそれだけである。


間口を広くするこの種のビジネスモデルは、ユーザとの継続的取引を必要とするビジネスで多くみられるけれども、それがすなわちユーザを欺く悪魔的なものであるというのであれば、世界は全くつまらないものになってしまう。ユーザが初期コストに見合う価値をその時点で正しく判断できなければ事を起こせないような世界は、ほんとうに天使の世界なのだろうか。


今こうして無料で投稿した記事について、将来的にはてなから保管料を請求されることになるかもしれない。そうしない保証をおそらくどこのWebサービスもやっていないし、その可能性を否定もしないだろう。つまりWebサービスは氏言うところの悪魔になりうる。果たしてWebは悪魔だろうか。その時点でユーザにロックアップが掛かっていない以上、それは健全なるビジネスモデルだ。ユーザはデータを持ってほかに移ればいい。もっとも、データの簡単なエクスポート機能を持たないWebサービスは実質的なロックアップであり将来問題を引き起こすかもしれない。


ちなみにインク代の差額では、悪魔のビジネスモデルにおけるプリンタしか買えない。
</body>
</day>
<day date="2006-11-11" title="">
<body>
*p1*QuickSilver、君はランチャーなんかじゃない、実行統合環境だ！
[http://blacktree.com/?quicksilver:title=QuickSilver] 君は最高だよ
だって僕がやりたいことをすぐさせてくれるし
僕が行きたいところにすぐ連れて行ってくれる
僕が少し喋りだしただけで
君には僕のやりたいことがすべて分かるんだね
Media Labのネグロポンテが鹿内信隆氏の通訳にびっくりしたように
僕は君にびっくりしているよ
日本ではねこれは”あうんの呼吸”といって
夫婦間の究極のコミュニケーションとされているんだ
外国人である君が会ったこともない日本人の僕のことを
どうしてそんなによく分かるのか不思議でならないよ
でもね僕はね君のことを理解するのに正直苦労しているんだよ
君は難しい人だよ
とても君のことをすべて理解したなんて思えないよ
それでも君は僕にとっては最高の存在なんだよ
離れられそうにないよ
だからみんなにも君のことを紹介するよ

**ネット・検索関係
+'LivedoorReader'を開きたい
++QSを起動
++'lr'と打ってLivedoor Readerを確認してリターン((Firefox/Mozilla moduleが必要。bookmarkでLivedoorReaderのサイトを'LReader'と登録している))
+'任天堂'のサイトに行きたい
++QSを起動
++'ni'と打ってnintendo.co.jpを確認してリターン((Firefox/Mozilla moduleが必要。bookmarkで任天堂サイトを登録している))
+'米国任天堂'のサイトにも行きたい
++QSを起動
++'nintendo.com'でリターン
+'任天堂 wii'をググりたい
++QSを起動
++'go'と打ってGoogle Searchを確認してリターン
++３つ目のペインで'任天堂 wii'と打ってリターン((Web search moduleが必要))
+'ruby on rails'をアマゾりたい
++QSを起動
++'am'と打ってamazon.jpを確認してリターン
++３つ目のペインで'ruby on rails'と打ってリターン((Web search moduleが必要))
+'iPhone'をgoogleとyahooとamazonでいっぺんに検索したい
++QSを起動
++'go,ya,am'と打ってGoogle Search, Yahoo Seach, Amazon Searchを確認してリターン
++３つ目のペインで'iPhone'と打ってリターン((Web search moduleが必要))
+blogラベル付きで'wii'の語を含むメールをgmailから抽出したい
++QSを起動
++'gs'と打ってGmail Searchを確認してリターン
++３つ目のペインで'label:blog wii'と打ってリターン((Web search moduleが必要))
+del.icio.usにブクマした'rails'タグのサイトを開きたい
++QSを起動
++'ra'と打って★マークのrailsを確認
++'/' と打ってサブペインを下りる
++spaceまたは^nで対象を選びリターン((Social Bookmark pluginが必要。設定で,catalog-custom画面下の+でdeliciousのlogin情報をセット))
**アプリケーション関係
+Finderを開きたい
++QSを起動
++'f'と打ってFinderを確認してリターン
+Numbersで作成した'financial.numbers'を開きたい
++QSを起動
++'n' と打ってNumbersを確認
++'/' と打ってサブペインを下りる
++'fi' と打ってfinancial.numbersを選びリターン
+'Ingrid Michaelson'の'The Way I Am'を聞きたい
++QSを起動
++'ing'と打ってIngrid Michaelsonを確認
++'/'と打ってサブペインを下りる
++'way'と打ってThe Way I Amを確認してリターン((iTunes moduleとiTuneのplaylistにIngrid Michaelsonのアルバム登録が必要))
+ジャズが聞きたい
++QSを起動
++'bg'と打ってBrowse Genreを確認
++'/'と打ってサブペインを下りる
++'ja'と打ってjazzを確認してリターン((iTunes moduleが必要))
+宮本さんにgmailしたい
++QSを起動
++'.ゼルダの利き腕の件について'と打つ
++tabで２つ目のペインに移動して'm'と打ってEmail to...(Compose)を確認
++tabで３つ目のペインに移動して'miya'と打ってshigeru miyamotoを確認してリターン
++立ち上がったgmailでメールの内容を書いて送信((Apple Mail Module, Apple AddressBook Module, Gmail Moduleが必要。Preference-Handlers-EmailでGoogle notifierを選択。gmail English(US)versionではうまく機能しない))
+Google Calendarに予定を入れたい
++QSを起動
++'.岩田さんとランチ 1pm 12/2'と打つ
++tabで２つ目のペインに移動して'g'と打ってGoogle Calendar Eventを確認してリターン((Gmail Moduleが必要))
+英単語'diehard'の意味を知りたい
++QSを起動
++'.diehard'と打つ
++tabで２つ目のペインに移動して'dic'と打ってdictionaryを確認してリターン((dictionary moduleが必要))
+ルート5の答えを知りたい
++QSを起動
++'=sqrt(5)'と打ってリターン((calculator moduleが必要))
+man bcをTerminalで実行したい
++QSを起動
++'.man bc'を打つ
++tabで２つ目のペインに移動して'r'を打ってRun a Text Command in Terminalを確認してリターン((Terminal moduleが必要))
+hello.rbをTextMateで開きたい
++QSを起動
++'hel'と打ってhello.rbを確認
++tabで２つ目のペインに移動して'o'を打ってopenを確認してリターン((.rbファイルが別のeditorにセットされている場合はopen withを選ぶ))
+TextMateでdemo projectを開きたい
++QSを起動
++'demo'と打ってdemoフォルダを確認
++tabで２つ目のペインに移動して'w'と打ってOpen withを確認
++tabで３つ目のペインに移動して't'と打ってTextMateを確認してリターン
**メモ関係
+'歯ブラシを買う'をちょっとメモりたい
++QSを起動
++'.歯ブラシを買う'と打つ
++tabで２つ目のペインに移動して'put'と打ってPut on Shelfを確認してリターン((shelf moduleが必要))
+今開いてるurlをちょっとメモリたい
++QSを起動
++'cuw' と打ってCurrent Web Pageを確認
++tabで２つ目のペインに移動して'pu' と打ってPut on Shelfを確認してリターン((User Interface Access pluginが必要))
+今選択している文字列をちょっとメモりたい
++QSを起動
++'cus' と打ってCurrent Selectionを確認
++tabで２つ目のペインに移動して'pu' と打ってPut on Shelfを確認してリターン((User Interface Access pluginが必要))
+shelfに保存したurlをアドレスバーにペーストしたい
++QSを起動
++'she'と打ってshelfを確認
++'/' と打ちサブペインを下りて対象のurlを選択
++tabで２つ目のペインに移動して'p' と打ってPasteを確認してリターン
+Shelf上のメモをファイルに保存したい
++F6を押してshelfを開く
++対象のメモを^+マウスクリック(又はマウス右クリック)
++現れたリストからCreate Fileを選ぶ((F6にshelfを割り当てた場合。DefaultではQSを起動した後に&amp;#8997;+&amp;#8984;+s))
+Shelf上のメモを削除したい
++F6を押してshelfを開く
++対象のメモをマウスでドラッグしてゴミ箱に移動((F6にshelfを割り当てた場合。DefaultではQSを起動した後に&amp;#8997;+&amp;#8984;+s))
+'hello,world!'をテキストファイルに保存したい
++QSを起動
++'.hello,world!'と打つ
++tabで２つ目のペインに移動して'cr'と打ってCreate Fileを確認してリターン
+'nintendo wii'をwants_list.txtに追加したい
++QSを起動
++'.nintendo wii'と打つ
++tabで２つ目のペインに移動して'ap'と打ってAppend toを確認
++tabで３つ目のペインに移動して'wants'と打ってwants_list.txtを確認してリターン((Text Manupulation Moduleが必要))
+ブログのコンテンツと画像とurlを自分のブログにコピペして使いたい
++コンテンツと画像とurlをctrl+cで順次コピー
++自分のブログのペーストしたい場所にカーソルを合わせる
++F5を押してclipboardを開き対象データの先頭番号を押す
++ペーストする場所を変えて2,3を繰り返す((clipboard moduleが必要。F5にclipboardを割り当てた場合。DefaultではQSを起動した後に&amp;#8984;+l))
+clipboardのデータをshelfに移したい
++F5,F6を押してclipboardとshelfを開く
++clipboard上の対象データをマウスでダブルクリック((F5にclipboardを、F6にshelfを割り当てた場合。DefaultではQSを起動した後に&amp;#8984;+l,&amp;#8997;+&amp;#8984;+s))
+'hello,world!'と画面にでかく表示したい
++QSを起動
++'.hello,world!'と打って２つ目のペインのlarge typeを確認してリターン
+3分後にカップヌードルを食べたい
++'.食べてよし！'と打つ
++tabで２つ目のペインに移動しctrl + returnを打ち更に'd'と打ってRun after Delayを確認
++tabで３つ目のペインに移動し'3m'と打ってリターン((30秒は30s,２時間半は2h30s))
+15:30にamazon.co.jpにアクセスしたい
++QSを起動
++'a'と打ってamazon.co.jpを確認
++tabで２つ目のペインに移動しctrl + returnを打ち更に'ti'と打ってRun at Timeを確認
++tabで３つ目のペインに移動し'15:30'または'3:30pm'と打ってリターン
**システム関係
+ComputerをSleep, Restart, Shutdownしたい
++QSを起動
++'sl'または're'または'sh'と打ってSleep, Restart, Shutdownを確認してリターン((Extra Scripts pluginが必要))
+hello.rbのある場所を知りたい
++QSを起動
++'hel'と打ってhello.rbを確認
++tabで２つ目のペインに移動して'l'を打ってGet File Locationを確認してリターン
+’hello'をspotlightしたい
++QSを起動
++'.hello'と打つ
++tabで２つ目のペインに移動して's'と打ってSpotlight in Finder又はS.. in Windowを確認してリターン((Spotlight moduleが必要))
+アカウント環境設定パネルを開きたい
++QSを起動
++'sys'と打ってシステム環境設定を確認
++'/'と打ってサブペインを下がる
++'a'と打ってアカウント環境設定パネルを確認にしてリターン
**設定関係
+QuickSilverの設定画面を開きたい
++QSを起動
++&amp;#8984;+'?'、又は &amp;#8984;+','、又は &amp;#8984;+'''、又は &amp;#8984;+'&quot;'を打つ
+QuickSilverを&amp;#8984;のシングルアクションで開きたい
++QSを起動
++&amp;#8984;+','でPreference設定画面を開く
++Command-Modifier-only Activationをチェックして'Single', 'Command'を選択
+QuickSilverにmoduleを追加したい
++QSを起動
++&amp;#8984;+'&quot;'(ダブルクオーティション)でplug-ins設定画面を開く
++対象のmoduleにチェックをつける
+google.co.jpで検索できるようにしたい
++google.co.jpで'***'(3つのアスタリスク)を検索し、そのURLをコピー
++QSを起動
++&amp;#8984;+';'でCatalog設定画面を開く
++Custom-Web Search Listを選択して、右下のiでdrawerを開く
++左下の+でリストを追加し、そのnameをgoogle searchとし、URLに先のURLをペースト
+clipboardをF5に割り当てたい
++QSを起動
++&amp;#8984;+'でtrigger設定画面を開く
++画面下の+(Hotkey)を選ぶ
++１つ目のペインで'cli'と打ってClipboard Historyを確認
++tabで２つ目のペインに移動して'sh'と打ってshowを確認してリターン
++Trigger項目のnoneをクリックしF5を押して完了

追記((2006.11.17にtimer関連のものを追記しました。2007.1.23に一部を修正しました。2008.1.20に追記、修正および整理をしました。))
</body>
<comments>
<comment>
<username>Ninaaaa</username>
<body>昨晩入れてみました。&lt;br&gt;まだ手探り状態ですが、がんばって早く慣れるよう試行錯誤中です。</body>
<timestamp>1193699000</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>慣れれば最高のものになると思います。</body>
<timestamp>1193700855</timestamp>
</comment>
</comments>
</day>
<day date="2006-12-03" title="">
<body>
*p1*待つわ~We will wait Wii!
12月2日午後2時過ぎ、Wiiが来ました
Amazonさん発売日に出荷ありがとう
12月3日午前11時過ぎ、Wiiソフト((ゼルダ、はじめてのWii、Wii Sports))がまだ来ません
Amazonさん少し苦しくなってきました
でも、私、待つわ...もう少し待つわ...

[f:id:keyesberry:20061203113022j:image]

(追記)同日午後６時頃、無事ソフトも到着しました。ありがとうございます。

</body>
</day>
<day date="2006-12-05" title="">
<body>
*p1*Wii are SMAP! with Mii

なかいくん/中居正広
f:id:keyesberry:20061206104514j:image:w200


たくや/木村拓哉
f:id:keyesberry:20061205121828j:image:w200


ごろー/稲垣吾郎
f:id:keyesberry:20061205121900j:image:w200


つよし/草彅剛
f:id:keyesberry:20061205121922j:image:w200


しんご/香取慎吾
f:id:keyesberry:20061205121936j:image:w200



キムタクとなかいくんは、むずかしいなぁ～。
(10/6追記)なかいくんを差し替えました。いくらかまし？


Wiiをまだ入手できてない人は、[http://www.joystiq.com/media/2006/10/mii.swf:title=joystiqのサイト]で挑戦してね！




asin:B000KFDO3A:detail
</body>
</day>
<day date="2006-12-06" title="">
<body>
*p1*Wii are the Beatles! with Mii
今度はビートルズだ！


ジョン/John Lennon
f:id:keyesberry:20061206104913j:image


ポール/Paul McCartney
f:id:keyesberry:20061206104932j:image


ジョージ/George Harrison
f:id:keyesberry:20061206104955j:image


リンゴ/Ringo Starr
f:id:keyesberry:20061206105013j:image



asin:B000KFDO3A:detail

*p2*Wii News from the World!
海外のメディアでもクリスマスシーズンに向けて任天堂Wiiが紹介されているよ！やっぱりWiiリモコンは話題性十分だね。

The Nintendo Wii is the BIG Headline（たぶんアメリカ）
[http://www.youtube.com/watch?v=1BOl1shBP0M:movie]


Wii on Channel 7（たぶんオーストラリア）
[http://www.youtube.com/watch?v=Ba4EFmTwRtw:movie]


RTL2 News Nintendo Wii Event in London（たぶんドイツ）
[http://www.youtube.com/watch?v=sHElImFTVqE:movie]


Wii Pre Launch - KING 5 News Report（たぶんアメリカ）
[http://www.youtube.com/watch?v=iqHu4-H-dfc:movie]


Tech Segment Global News（たぶんカナダ）
[http://www.youtube.com/watch?v=Yq6psuuLbEU:movie]


Tech Segment Global News（たぶんカナダ）
[http://www.youtube.com/watch?v=Q9rSDoVqceI:movie]


Wii Featured on Channel 4 News（たぶんイギリス）
[http://www.youtube.com/watch?v=yVlVFNhZAvw:movie]


Wii on Channel Ten TV Australia（たぶんオーストラリア）
[http://www.youtube.com/watch?v=o8AzWuAhjZc:movie]


Wii on Today Show（たぶんオーストラリア）
[http://www.youtube.com/watch?v=2efs78aEjqE:movie]


asin:B000KFDO3A:detail
</body>
</day>
<day date="2006-12-09" title="">
<body>
*p1*Wii are 24ers! with Mii
FOXテレビドラマ「24」から。


トニー/Tony Almeida
f:id:keyesberry:20061209170347j:image:w200


クロエ/Chloe O'Brian
f:id:keyesberry:20061209170431j:image:w200


シェリー/Sherry Palmer
f:id:keyesberry:20061209170507j:image:w200



asin:B000KFDO3A:detail
</body>
</day>
<day date="2006-12-13" title="">
<body>
*p1*Wii are 24ers! with Mii その２

同じく、FOXテレビドラマ「24」から。


ミッチェル/Michelle Dessler 
f:id:keyesberry:20061213172942j:image:w200


ニーナ/Nina Myers 
f:id:keyesberry:20061213172959j:image:w200


ウェイン/ Wayne Palmer
f:id:keyesberry:20061213173016j:image:w200


asin:B000KFDO3A:detail
</body>
</day>
<day date="2006-12-15" title="">
<body>
*p1*クリスピー・クリーム・ドーナツ[http://www.krispykreme.jp/:title=日本１号店]が大変なことになっている件
f:id:keyesberry:20061215190800j:image:w300

ドーナツを買うのに1～2時間待ちという凄い事態になっています
前日から並んだ人もいるそうです
任天堂DSの列と間違えて並んじゃう人がいそうです
出てくる人出てくる人ドーナツじゃなくてピザボックスを持っています
訳が分かりません
f:id:keyesberry:20061215190820j:image:w300
この週末に出かける人は相当覚悟してください
覚悟ができない人は三越でDoughnut Plant食べてください
僕は今日あきらめてスタバでドーナツ食べました
スタバのドーナツもう少しおいしくなりませんか？
f:id:keyesberry:20061215190836j:image:w300
そういえばこの行列で思い出します
シナモンロールの[http://www.cinnabon.com/flash.html:title=シナボン]を
吉祥寺１号店の行列は1月続きました
一時は30店舗まで増えたそうです
だけどみんなリピートしてくれませんでした
いまではお台場店だけのようです
「あまぁ～い！でもおいし～い！」
あのときと同じ感想が今飛び交っているのが少し気になります
f:id:keyesberry:20061215190847j:image:w300
[http://www.krispykreme.com/:title=Krispy Kreme Doughnuts]は本国(米国)では一時の勢いを失い
売上は減少傾向にあるようです
経営上のトラブルもありました
今、日本だけでなく、韓国、フィリピン、香港、ジャカルタなど
アジアでのフランチャイズ展開を計画しているようです
日本では[http://www.revamp.co.jp/press/20060706.html:title=ロッテと再生事業会社のリヴァンプ]がフライチャイジーです
５年で40店舗。計画通りに行くでしょうか
難しいという意見もある中、果敢な挑戦です
f:id:keyesberry:20061215190906j:image:w300



[http://today.reuters.com/news/articleinvesting.aspx?view=CN&amp;symbol=&amp;storyID=2006-12-12T095550Z_01_T116030_RTRIDST_0_ASIA-KRIPSYKREME-PICTURE.XML&amp;pageNumber=2&amp;WTModLoc=InvArt-C1-ArticlePage2&amp;sz=13:title=Krispy Kreme rolls further into Asia on sweet hopes]

[http://www.risingsunofnihon.com/2006/12/8_reasons_why_krispy_kreme_wil.html:title=8 Reasons why Krispy Kreme will fail in Japan]

[http://www.japanprobe.com/?p=790:title=Krispy Kreme comes to Japan]
[http://www.youtube.com/watch?v=RpPElKqoSCA:movie]



</body>
</day>
<day date="2007-01-11" title="">
<body>
*p1*Wii are Nintendo Stars! with Mii
今度は任天堂のスターたちを。ありがとう、すばらしい製品を！


岩田聡/Satoru Iwata
[f:id:keyesberry:20070111181124j:image:w200]


宮本茂/Shigeru Miyamoto
[f:id:keyesberry:20070111181125j:image:w200]


レジー/Reggie Fils-Aime
[f:id:keyesberry:20070111181122j:image:w200]


asin:B000KFDO3A:detail
</body>
</day>
<day date="2007-01-23" title="">
<body>
*p1*alt+shift+k = &amp;#63743;

知らなかったよ！
</body>
</day>
<day date="2007-01-24" title="">
<body>
*p1*[http://www.tuaw.com/2007/01/18/melman-quicksilver-users-guide/:title=Melman Quicksilver User's Guide]
知らなかったよ！
</body>
</day>
<day date="2007-01-25" title="">
<body>
*p1*ウェブ人間論 ～求めているのは人間愛なんだ！


ウェブ人間論を読んだ。


ウェブにおける匿名の意味、著作の扱われ方、ウェブによる人間の進化と話題は進む。主として平野氏が見えないウェブの未来に対しての恐れを表明し、全体としてウェブに対して希望的観測をもつ梅田氏が答えていく。その過程を通して、平野氏は、梅田氏の楽観論がかならずしも明確な根拠に基づくものでないことを悟っていき、表現の違いはあれど、ウェブに対する互いの認識にはそれほどの差異がないことを知る。梅田氏は、「何か革命的なことが起ころうとしている。先がどうなるかは誰にも予想はできないし、それは避けられないものなのだから、不安を持つより希望をもったほうがいいじゃないか」と言っているに過ぎないのだ。そのことが平野氏に理解された以上、書くことに生きる平野氏の不安は消えることはない。


平野氏が問題にしているのは、そしてみんなが知りたいと思っているのは、ウェブによって人間がどう変わっていくかという意味のウェブ・人間論ではなくて（ましてやウェブ人間・論ではない）、ウェブ自体の人間性という意味におけるウェブ＝人間論なのではないか、と僕は思う。


梅田氏はグーグルに代表される検索システムがインターネットの中核技術だと語るけれども、flickr, youTube, del.icio.us, diggなどに代表されるWeb2.0型プラットフォームの出現は僕に違うものを垣間見せる。検索技術は１つのアルゴリズムがすべてを決するという意味において中央集権的であり、これはすなわちWeb1.0的なものに見える。中央集権的技術は、機械的であり、断定的であり、どこか非人間的である。そのアルゴリズムに最適化されたページが結果を飾る。


これに対して、Web2.0型プラットフォームは、人間の手作業により支えられ、個々の人間という多様なアルゴリズムの集積が事を決するという意味において分散的である。その結果の裏には少なからず人間の同意が見える。結果は、刹那的であり、意図的であり、感傷的であり、合理的でもあり、従って極めて人間的である。明確なキーワードを備えた明確なターゲットが存在する場合、検索システムは一番の近道を与えてくれるけれども、人間にとって必要なターゲットはそうでないもののほうが圧倒的に多い。Web2.0的なものにはそれらに辿り着く新しい道が垣間見える。グーグルはターゲットに対する信頼をそれに対するリンクで仮定しているけれども、Web2.0的なものでは、ターゲットに対する直接的な投票によってその信頼を作る。無記名性の投票がバーチャルなものでないのと同様に、これは極めてリアルな世界の一事象である。


僕はここに希望を持つ。ウェブ上の匿名性の問題（負の意味での）も、著作物に対するバランスのとれた解決も、人間的であるWeb2.0型プラットフォームが、これらをリアルな世界の問題として解決してくれることを。ウェブを支える世代が反エスタブリッシュメントであるのは、現在の商業主義や資本主義が非人間的に映るからであろう。かれらは、ウェブによって人間が人間らしさを取り戻せる可能性を予感しているのかもしれない。あるいは、価値の創造や富の再配分を、国家や資本主義よりも効率的かつ合理的にするシステムが、ウェブで構築される可能性を予感しているのかもしれない。それが未来への希望であるならば、それほどすばらしいものはない。



asin:4106101939:detail
</body>
</day>
<day date="2007-01-26" title="">
<body>
*p1*世にも不思議なもの
証券会社の出す目標株価
それは株価の変化とともに変わっていく
株価がそれを超えれば
書き直され
市場の期待が高まれば
高く掲げられる
まさに株価連動型!
それはアナリストの願いなのか
それとも工作なのか
はたまた反省なのか
目標株価
それは世にも不思議なもの
</body>
</day>
<day date="2007-01-28" title="">
<body>
*p1*ウェブは21世紀の自動車産業なのか

ウェブの未来に期待や不安が交錯する
僕らには未来が見えないからだ
でも僕らは過去を知っている
はたしてウェブは20世紀の自動車産業ほどのものなのだろうか
自動車が人の往来や物流を革命的に変えたように、ウェブの世界も拡大するのだろうか
関連産業が大量に生まれて、膨大な雇用を創出するようになるのだろうか
車で旅をするように、グーグルは僕らをまだ見ぬ土地へ連れて行ってくれるのだろうか
ブログシステムはT型フォードほどのものなのだろうか、それとも幌馬車程度のものなのだろうか
作家はF1レーサーになることを夢見るべきなのだろうか
織機を作ることを止めて、自動車を作るべきなのだろうか
馬具を売ることを止めて、高級鞄を売るべきなのだろうか
それとも今の商売を続けるべきなのだろうか
運転ができなくても生活はできるように、ウェブを利用できなくても生活ができていくのだろうか
人類の歴史というものを顧みて、人々が今もこうして生きつづけていることを知れば、僕の気持ちはすこしは楽になる


asin:4106101939:detail
</body>
</day>
<day date="2007-01-30" title="">
<body>
*p1*労働生産性の罠
肉体労働の生産性は、時間関数である
知識労働の生産性は、アイディアの質の関数である
投資の生産性は、資本×アイディアの質の関数である
アイディアの質は、天才の特権であり、希に凡人の運である
じゃあ、明日からどうしろって言うんだい！

*p2*人名しりとり名人

先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　あさだまお&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　おだむどう&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　うえのじゅり&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　りゅうらいた&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　たけうちまりや&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　やすだなるみ&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　みずきありさ&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　さとうたまお&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　おうさだはる&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　るーおおしば&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　ばんちゅうた&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　たくはちろう&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　うただひかる&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　るいじゅうよんせい&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　いまいくよ&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　よしだてるみ&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　みらくるひかる&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　る、...るーらいた！&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　たむらまさかず&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　ず、...ずーとるび！&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　びーとるず&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　....ずーとるび&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　びーとるず&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　....ずーとるび&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　びーとるず&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　ずーとるび&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　びーとるず&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　ずーとるび&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　びーとるず！&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　ず、...ずわいよくちゅーるまき！&lt;/span&gt;




先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　きりんじ&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　じんないたかのり&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　りんごすたー&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　たわらこうたろう&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　うがんだとら&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　らいおねるあすか&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　かとうろーさ&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　さかもといっせい&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　いまくるよ&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　よこみねさくら&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　らいおねるりっち&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　ちかだはるお&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　おかだなな&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　なかいまさひろ&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　ろ、...ろみやまだ！&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　だいたひかる&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　る、...るみやまだ！&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　だんふみ！&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　み、...みみやまだ！&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　だんいけだ！&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　だ、...だんこがい！&lt;/span&gt;




後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　いでらっきょ&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　よきみこ&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　こんどうまさひこ&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　こばやしさちこ&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　こんのみさこ&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　こたにみかこ&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　こんようこ&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　こたにまおこ&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　こさかきょうこ&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　こさかあきこ&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　こっこ！&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　ここりこ！&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　こけこっこ！&lt;/span&gt;




先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　こくぶんたいち&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　ちねんりな&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　なかまゆきえ&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　えがわしょうこ&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　こーじーとみた&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　たまるみすず&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　ず、...ずーとるび！&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　びーとるず&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　....ずーとるび&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　びーとるず&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　....ずーとるび&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　びーとるず&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　ずーとるび&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　びーとるず&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　ずーとるび&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　びーとるず！&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　ず、...ずんこさくらだ！&lt;/span&gt;




後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　だんしんや&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　やくみつる&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　る、...るいるいたがわ&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　わくいえみ&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　みなみはるお&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　おかべまり&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　りきいしとおる&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　る、...るびこ！&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　こひるいまきかほる&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　るぱんさんせい！&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　いわきこういち&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　ちばしんいち&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　ち、ちんけんいち！&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　ちばすず！&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　ず、...ずーとるび&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　びーとるず&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　....ずーとるび&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　びーとるず&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　....ずーとるび&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　びーとるず&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　ずーとるび&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　びーとるず&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　ずーとるび&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　びーとるず！&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　ず、...ずろーす！&lt;/span&gt;
先手:&lt;span style=&quot;font-size:large;color:#0000CC;&quot;&gt;　　すずきすず！&lt;/span&gt;
後手:&lt;span style=&quot;font-size:large;color:#990033;&quot;&gt;　　ず、...ずぜっとん！&lt;/span&gt;


&lt;span style=&quot;font-size:large;&quot;&gt;以上、108手にて先手の勝利。&lt;/span&gt;
</body>
</day>
<day date="2007-02-10" title="">
<body>
*p1*QuickSilver+Adium
[http://blog.codahale.com/2007/01/22/send-as-im-adium-quicksilver/:title]

最新版QuickSilverからAdiumにメッセージを送るスクリプトを書いてくれているぞ。

（設定）
1.上記サイトのスクリプトをスクリプトエディタに貼り付けし、Send As IM.scptとかのファイル名で、~/Library/Application Support/Quicksilver/Actions以下に保存（Actionsフォルダが無ければ作成）。
2.QuickSilverを再起動（起動してcommand+control+Q）。
（使い方）
1.QSを起動
2.&quot;.suzuki: こんにちは。暇ですか？&quot;とタイプ(ピリオドでテキストモードに入る)。
3.tabで2つめのペインに移り、&quot;send as im&quot;の先頭をタイプしてリターン。


やあ、助かる。
</body>
</day>
<day date="2007-02-16" title="">
<body>
*p1*Flock+Gresemonkeyでどうでぇ
del.icio.us、Flickr、Blogger使いなら無視できんだろ
ソーシャルWebブラウザ「[http://www.flock.com/:title=Flock]」
しかしMac版ではGreasemonkeyがどうもだめだな
[http://la.ma.la/blog/diary_200604261407.htm:title=LivedoorReader]だけならがまんもできるが
[http://kengo.preston-net.com/archives/003066.shtml:title=Going My Way経由]で[http://googlesystem.blogspot.com/2007/02/keyboard-shortcuts-for-google-search.html:title=Keyboard Shortcuts for Google Search]なんてものを知らされた日にゃ
我慢も限度ってもんだ
ところが神はいるもんだね
[http://www.flock.com/node/4690:title=ここで]答えを教えてくれたさ
ライブラリ以下にあるgm_scripts/config.xmlのアクセス権限を755にすりゃいいとさ

*p2*Flock+Keyboard Shortcutでどうでぇ
QuickSilverやってると、Mouseってのは、ほんとにしゃらくせぇなぁ
|*Command |*Shortcut|
|タブの切替|Ctrl + tab|
|タブの選択(1 to 9)|Cmd 1,Cmd 2,etc.|
|新規タブ|Cmd + T|
|タブを閉じる|Cmd + W|
|新規ウィンドウ|Cmd + N|
|新規タブに開く|Option + Return|
|||
|Web検索|Cmd + K|
|URL入力|Cmd + L|
|ページ内検索|Cmd + F|
|次を検索|Cmd + G|
|||
|ブログエディタ|Cmd + B|
|現在の頁をbookmark|Cmd + D|
|bookmarkおよびtagging|Cmd Shift + D((自分の環境では動かなかった))|
|Bookmark管理を開く|Cmd + Shift + M|
|Photo Uploader|Cmd + Shift + U|
|||
|戻る|Cmd + [|
|進む|Cmd + ]|
|||
|.com補完|Cmd + Return|
|頁情報表示|Cmd + I|
|頁ソース表示|Cmd + U|
（Mac版抜粋）
</body>
</day>
<day date="2007-02-17" title="">
<body>
*p1*カツカレーに望むこと
カツカレーに望むこと
それは、カツ on カレーライス
カツ between カレー and ライス、じゃ
カツの下がごはんじゃない～


カツカレーに望むこと
贅沢言うなら、カレー on カツ on カレーライス
カツ between カレー and ライス、じゃ
カツ定食カレーじゃない～


カツカレーに望むこと
カツ beside カレーライス、でもかまわない
カツ between カレー and ライス、じゃ
カレーの行き場がないじゃない～


恋人たちはカツカレーとカレーライスを頼んで
カツを仲良く二人で分ける～
彼女にカツを渡したら
僕の皿から白いごはんが顔を出し
その空間に泪する～
彼女の皿に目をやれば
そこには理想のカツカレー
あ～あ～あ～


カツカレーに望むこと
それは、カツ on カレーライス
カツカレーに望むこと
それは、カツ on カレーライス
あ～あ～あ～

*p2*苦役
労働が苦痛であれば
自らにコンプリメントが必要である
コンプリメントはコストである
コストの補填は労働である
労働が苦痛であれば....
無限ループに落ちる
&gt;|
while life
  work
end
|&lt;
</body>
</day>
<day date="2007-03-11" title="">
<body>
*p1*TextMateはすてき過ぎる

[http://d.hatena.ne.jp/keyesberry/20060701:title=TextMateはすてきだ]ということを、少し前に言っていたんですが、[http://macromates.com/screencast/math_and_column_selections.mov:title=ここ]とか[http://projects.serenity.de/textmate/tutorials/basics/:title=ここ]とか見てまた感動しました。忘れてしまわないうちに、[http://macromates.com/:title=TextMate]のKeyboard Shortcutをまとめておきます。これで日本語に対応したらきっと泣きます。絶対に。もう一つ買っちゃうかもしれません。なお、以下で、「All」というのは、いわゆる全部のせ「Ctrl + Alt + &amp;#8984;」を指しています。

**カーソル移動 with Modifier
Ctrl + F, B, N, P : 一文字づつの移動
Ctrl + A, E :ラインエンドへ移動
Ctrl + V : 一頁下へ移動
&amp;#8984; + J : カーソル位置をセンターへ移動

**カーソル移動 with 矢印キー
Left, Right :一文字づつの移動
Ctrl (or Alt) + Left(Right) : 単語ごとの移動
&amp;#8984; + Left(Right) : ラインエンドへ移動
Up, Down : 一ラインづつ移動
Ctrl + Up(Down) : スクロール（カーソルはそのまま）
Alt + Up(Down) : コラム単位で移動
&amp;#8984; + Up(Down) : ドキュメントエンド（トップ／ボトム）へ移動

**コピーとペースト with &amp;#8984;
&amp;#8984; + C, X, V : コピー、カット、ペースト
Shift + &amp;#8984; + V : 遡ってペースト
 (Alt + &amp;#8984; + V : 逆送り)
All + V : クリップボード・ヒストリ

**削除 with Delete or backspace((DeleteはF14の下、backspaceはF13の下のキー))
Delete (or Ctrl + D) : 右一文字を削除
Alt + Delete : 右一単語を削除
&amp;#8984; + Delete : カーソル右ラインを削除
backspace : 左一文字を削除
Alt + Delete : 左一単語を削除
&amp;#8984; + Delete : カーソル左ラインを削除

**キルとヤンク
Ctrl + K : カーソル右ラインをキル
Shift + Ctrl + K : 一ラインキル
Shift + Ctrl + D : 一ライン複製
Ctrl + Y : キルしたものをヤンク

**検索と置換
&amp;#8984; + F : 検索／置換ダイアログの表示
&amp;#8984; + E : 選択単語を検索対象にセット
Shift + &amp;#8984; + E : 選択単語を置換対象にセット
Ctrl + &amp;#8984; + F : 一括置換
Alt + &amp;#8984; + F : 順次置換
Ctrl + S : インクリメンタル・サーチ（降順）
(Shift + Ctrl + S : 昇順)

**文字の選択
Ctrl + W : 単語の選択
Shift + &amp;#8984; + L : ラインの選択
Shift + &amp;#8984; + B : ブラケットの選択

**コラム操作
コラムの選択 :
   (1)Shift + Alt + 下矢印キー
   (2)Alt
   (3)Shift + Alt + 右矢印キー
コラムの移動 :
   Ctrl + &amp;#8984; + 矢印キー
コラムへサフィックス :
   (1)Shift + Alt + 下矢印キー
   (2)Alt + &amp;#8984; + A

**スワップ
Ctrl + T : カーソル位置の一文字を前後に入れ替え(文字選択時は文字リバース)
Ctrl + G : カーソル位置の一文字を大文字／小文字に変換（文字選択時は全入れ替え）
Ctrl + U : カーソル位置の単語を大文字に変換
(Shift + Ctrl + U : 小文字に変換)
Ctrl + Alt + U : カーソル行の各単語をキャピタライズ
Ctrl + &amp;#8984 + 上下矢印キー : カーソル行を上下で入れ替え（行選択時はその行の移動）

**ミニツール
Shift + Ctrl + C : カーソル行の式を計算(ex. 12*34-45と打ち実行)
Ctrl + R : Shellコマンドの実行(ex. calやdateと打ち実行)
Alt + &amp;#8984; + R : コマンドダイアログの表示
Shift + Ctrl + &amp;#8984; + D : ドキュメントの比較(Diff)
Shift + Ctrl + N : ワードカウント(wc)
F5 : ソート(対象範囲を選択して実行)
Tab + isoD, c), lorem : Text Bundle(isoDと打ってTab)
Shift + Ctrl + E : Rubyの実行(ex. 10.times{|i| puts i*i}と打って実行)
All + P : Web表示
All + K : Keyboard Shortcut Listの表示
All + B, T, S, L : Bundle Editorの表示
All + D : ドロワーの開閉

*p2*プロフェッショナルとは
プロフェッショナルとは
プロフェッショナルと言われた人のことを言い
その人の職業とも心持ちとも関係がない
プロフェッショナルとはと
プロフェッショナルに聞くのは失礼であり
それに答えるのは愚かである
</body>
</day>
<day date="2007-03-12" title="">
<body>
*p1*ネットの実名と匿名

そこに入るのにパンツを脱ごうが
脱ぐまいが
それは個人の勝手だよ
だってそこが銭湯なのか
プールなのか
誰も分かってないじゃない

*p2*ウェブはコミュニケーション・バッファ

コミュニケーションは本来リアルタイムである
リアルタイム処理で重要かつ困難なのは同期である
同期の困難性は自由で公汎なコミュニケーションを阻害する
ウェブはバッファとなってそれを緩和する

*p3*Prince of Tides

大通りを走る車の騒音で朝目が覚める
目を閉じながらその音に集中すると
それが潮騒に変わる
通りの両側の信号が同時に赤になって
突然潮が凪いだように静寂が訪れる
静寂の中から微かな音を探す自分に気づく
暫くして再び潮が動きそれに身を委ねる
さて、そろそろ起きようか

*p4*Macのキーバインドをいじる
[http://d.hatena.ne.jp/keyesberry/20070311:title=TextMateはすてき過ぎる]に書いたように
TextMateには便利なショートカットが満載だ
でも足りないものや変えたいものもある
そんなときはMacのキーバインドをいじろう


~/Library/KeyBindings/フォルダに
DefaultKeyBinding.dict
というファイルを作ってここで定義する
そうすればすべてのCocoaアプリで機能する

&lt;pre&gt;
{    /* home */
    &quot;\UF729&quot;  = &quot;moveToBeginningOfLine:&quot;;
    &quot;$\UF729&quot; = &quot;moveToBeginningOfLineAndModifySelection:&quot;;

    /* end */
    &quot;\UF72B&quot;  = &quot;moveToEndOfLine:&quot;;
    &quot;$\UF72B&quot; = &quot;moveToEndOfLineAndModifySelection:&quot;;

    /* page up/down */
    &quot;\UF72C&quot;  = &quot;pageUp:&quot;;
    &quot;\UF72D&quot;  = &quot;pageDown:&quot;;
    &quot;^V&quot;  = &quot;pageUp:&quot;;

    /* move */
    &quot;~f&quot; = &quot;moveWordForward:&quot;;
    &quot;~b&quot; = &quot;moveWordBackward:&quot;;
    &quot;^h&quot; = &quot;deleteBackward:&quot;;

    &quot;^F&quot; = &quot;moveForwardAndModifySelection:&quot;;
    &quot;^B&quot; = &quot;moveBackwardAndModifySelection:&quot;;
    &quot;^~f&quot; = &quot;moveWordForwardAndModifySelection:&quot;;
    &quot;^~b&quot; = &quot;moveWordBackwardAndModifySelection:&quot;;
}
&lt;/pre&gt;

僕はWindowsからの移行組なので
Home, end, pageup, pagedownなどをwindows仕様に
それからTextMateになかった
Ctrl + Shift + V : 一頁もどる
Shift + F : 一単語進む
Shift + B : 一単語もどる
Ctrl + h  : 前一文字削除
Ctrl + Shift + F : 範囲選択しつつ一文字進む
Ctrl + Shift + B : 範囲選択しつつ一文字もどる
Ctrl + Alt + F : 範囲選択しつつ一単語進む
Ctrl + Alt + B : 範囲選択しつつ一単語もどる
を定義した


書式は&quot;key&quot; = &quot;action:&quot;;だ
actionのあとのコロンを忘れないように


以下のサイトが本当に参考になる
emacsのようなマルチバインドもできるみたいだね

[http://www.lsmason.com/articles/macosxkeybindings.html:title]
[http://www.hcs.harvard.edu/~jrus/site/cocoa-text.html:title]
[http://macromates.com/blog/archives/2005/07/05/key-bindings-for-switchers/:title]
[http://journal.mycom.co.jp/column/osx/103/:title]

(関連記事)
[http://d.hatena.ne.jp/keyesberry/20070313/p2:title=オートペアリングをキーバインドしようよ]
[http://d.hatena.ne.jp/keyesberry/20070313/p3:title=グリフをキーバインドしようよ]
</body>
</day>
<day date="2007-03-13" title="">
<body>
*p1*Cocoaでインクリメンタル・サーチしようよ
[http://www.hcs.harvard.edu/~jrus/site/cocoa-text.html:title]経由で
CocoaアプリでIncremental Searchを可能とするツール[http://leverage.sourceforge.net/wiki/index.php/Main_Page:title=i-Search Plugin]を知った
TextMateは独自にIncremental Searchを実装していて
Ctrl + Sで起動できるのだけれど
日本語文章を作成するときには
[http://www.aynimac.com/p_blog/files/article.php?id=41:title=CotEditor]などを使わせてもらっているので
そこでIncremental Searchができるようになる
日本語サーチも問題ない


インストールは
1.[http://michael-mccracken.net/software/ISearchPlugin.html:title=ここ]からバイナリをダウンロードして
2.中にある&quot;IncrementalSearchInputManager&quot;フォルダを ~/Library/InputManagers/に移して(フォルダがなければ作ってね)
3.中にある DefaultKeyBinding.dictの内容を ~/Library/KeyBindings/DefaultKeyBinding.dictに追加(なければそれをコピーしてね)


これで
Ctrl + S : Incremental Search(前方一致)
Ctrl + R : Incremental Search(後方一致)
Ctrl + G : キャンセル
がCocoaアプリで機能する


(追記)[http://journal.mycom.co.jp/column/osx/104/:title]で紹介されてたのね

*p2*オートペアリングをキーバインドしようよ
[http://d.hatena.ne.jp/keyesberry/20070312/p4:title=Macのキーバインドをいじる]の続きだよ


~/Library/KeyBindings/フォルダの
DefaultKeyBinding.dict の書式は基本的に
&quot;key&quot; = &quot;action:&quot;; だけど
&quot;key&quot; = (&quot;action1:&quot;,&quot;action2:&quot;,&quot;action3&quot;,...); とリストにすると
１つのキー操作に対して複数のアクションを実行できるんだ


で僕は、[http://d.hatena.ne.jp/keyesberry/20060701:title=TextMateでできるようなAuto-Paringの機能]をバインドしてみたよ

&lt;pre&gt;
  &quot;(&quot; = ( &quot;insertText:&quot;, &quot;()&quot;,
          &quot;moveBackward:&quot;
        );
  &quot;[&quot; = ( &quot;insertText:&quot;, &quot;[]&quot;,
          &quot;moveBackward:&quot;
        );
  &quot;{&quot; = ( &quot;insertText:&quot;, &quot;{}&quot;,
          &quot;moveBackward:&quot;
        );
&lt;/pre&gt;
全角カッコにも対応できればいいんだけど
やり方が分からないんだ。もう少し勉強してみるよ

(追記)TextMateのparingとコンフリクトしているようなので、上記設定は止めました。
(追記:2007/3/19) 代りに、TextMateの&amp;#8963;&amp;#8679;w(ワードセレクト)、&amp;#8963;&amp;#8679;k(ラインキル)、&amp;#8963;&amp;#8679;d(ラインデュプリケート)を定義しました。
&lt;pre&gt;
	&quot;^w&quot; = &quot;selectWord:&quot;;
	&quot;^K&quot; = ( &quot;moveToBeginningOfLine:&quot;,
	 	     &quot;deleteToEndOfLine:&quot;
		    );
	&quot;^D&quot; = ( &quot;moveToBeginningOfLine:&quot;,
	 	     &quot;deleteToEndOfLine:&quot;,
		     &quot;yank:&quot;,
		     &quot;insertNewline:&quot;,
		     &quot;yank:&quot;			
		    );
&lt;/pre&gt;
*p3*グリフをキーバインドしようよ
[http://d.hatena.ne.jp/keyesberry/20070312/p4:title=Macのキーバインドをいじる]の続きだよ


キーボードショートカットをブログに書くとき
CommandとかControlとかAltとかShiftとかのModifierを
できれば&amp;#8984;&amp;#8963;&amp;#8997;&amp;#8679;みたいなGlyphで書ければうれしいよね


これらをマルチストロークにバインドしてくれた人がいるよ
[http://pastie.caboo.se/4011:title]
これを例のDefaultKeyBinding.dictに書けば
&amp;#8963;mとの組み合わせでGlyphが書けるようになるんだ


&amp;#9251;&amp;#8965;&amp;#8677;&amp;#8676;&amp;#9003;&amp;#8998;&amp;#8984;&amp;#8997;&amp;#8963;&amp;#8679;&amp;#8682;←→↑↓&amp;#8672;&amp;#8674;&amp;#8673;&amp;#8675;&amp;#8598;&amp;#8600;&amp;#8670;&amp;#8671;&amp;#9099;&amp;#9167;


&amp;#8984; : &amp;#8963;m + &amp;#8963;a
&amp;#8963; : &amp;#8963;m + &amp;#8963;c
&amp;#8997; : &amp;#8963;m + &amp;#8963;o
&amp;#8679; : &amp;#8963;m + &amp;#8963;s
&amp;#9099; : &amp;#8963;m + &amp;#8963;x
&amp;#9167; : &amp;#8963;m + x


もちろんよく使いそうなものは
シングルストロークにバインドしてもいいよね


マルチストロークのバインドの書式は
&quot;^x&quot; = {&quot;u&quot;  = &quot;undo:&quot;};のように
辞書のかたちになるんだね
emacsに慣れている人たちは
これを使えばいいんだね

経由：[http://macromates.com/blog/archives/2006/07/10/multi-stroke-key-bindings/:title]
</body>
</day>
<day date="2007-03-21" title="">
<body>
*p1*目的なんてない
お金はツールであり目的ではない
知識はツールであり目的ではない
では人生の目的は何?
目的なんてない
あるのは納得だけ
</body>
</day>
<day date="2007-03-29" title="">
<body>
*p1*サクラサク
昼に図書館に本を返しにいってみたら、御苑の桜がもう満開だった。半袖でもいいくらいの陽気なので、桜も時期を間違えたのだろう。桜の幹は黒くてごつごつしていて、景観を損ねると思うけど、その花が一年に一度、一瞬にして美しく咲くさまを知っている人間たちは、それだからその存在を許しているんだろう。桜がその期待を裏切って花を咲かせなくなったら、その途端に切られてしまうんだろうな。桜の美しさにはそういう憂いを感じる。
</body>
</day>
<day date="2007-04-03" title="">
<body>
*p1*知識社会のジレンマ
知識社会における序列は知識の質量できまる
知識の質量を高める最良の方法は専門化である
一方で知識社会は知識の多様性を与える
専門性と多様性は相対立する
この矛盾が全ての人に劣等感を与える
知識社会におけるジレンマがここにある


*p2*未来は存在しない
未来とは
昨日から見た今日が存在したから
明日も存在するだろうという仮定の延長に過ぎない
未来が存在するのは
実在としての人がそこに立ったとき
すなわち現在になったときである
よって未来は存在しない


今不幸な人にとっては
未来は希望であり
今幸福な人にとっては
未来は不安（リスク）である
現代人はその両側面を持っているので
未来に希望と不安を同時に覚える


しかし未来が存在しない以上
それを予想することもできない
できるのは単なる統計的帰結である
統計的帰結であれば希望や不安は無意味であり
無為に生きるのが良い


未来とは本来
人が明日を想像する行為のことであり
それ以上でも以下でもないのだろう
</body>
</day>
<day date="2007-04-22" title="">
<body>
*p1*βは死
何かを成したとき
それはその瞬間に過去になる
よって成したものの維持管理は停滞である
生きるということが欲の追求であるならば
停滞は死である


完成を待たずにリリースされるβ版Webサービスは
完成の決定を放棄してユーザに委ねる行為である
それがうまく行く場合もあるけれども
大抵は死への近道切符になる


飽くなき欲求の猛者たちが
こぞってβ好きというのは
面白いパラドックスだ
そこにはM&amp;AかIPOという
自己中心的で矮小なプランが見え隠れする
</body>
</day>
<day date="2007-04-24" title="">
<body>
*p1*アンテナ人間求む！
二種類の人間がいる
アンテナが立っている人と
立っていない人


アンテナが立っている人は
新たな課題に直面したときに
そのアンテナを使って
材料を収集し、分析し、適用して
自分で問題解決をする


アンテナが立っていない人は
新たな課題に直面したときに
誰かが答えを教えてくれるのを待って
問題を解決するか
場合によっては
課題に直面していることにすら気づかない


課題が多様化・複雑化した現代社会においては
アンテナは新しいことを学ぶときの必要条件になりつつある
その人の行為様式において
アンテナが立っている人は常にそれを活用する
一方で、アンテナが立っていない人は常にアンテナが立っていない
それは老いてなお真理である


組織とは永続的なものであり
またそうあるべきである
従って組織に必要なのは無論
アンテナが立っている人である
</body>
</day>
<day date="2007-06-01" title="">
<body>
*p1*クリエータの著作権とみんなの所有権を量ることなんてできないよ！
~イメージシティ事件（著作権侵害差止請求権不存在確認請求事件）を知って~

[http://www.j-cast.com/2007/05/28007968.html:title=ネット上に音楽データ保存 携帯で聴くと著作権侵害？ ~J-CASTニュース]
&gt;&gt;
 音楽データの「オンラインストレージ」サービスについて、サービス運営者は著作権侵害にあたるとの判決が下された。音楽データを個人が保存し、ネット上にアップして携帯電話にダウンロードする。こんな個人的な行為に対しても「私的複製」が認められないという驚きの判決だ。単にデータを「仲介」しているだけのサービス運営者もとんだとばっちりだ。 
&lt;&lt;
（以下の文は、現行の法解釈や判例には必ずしも従っていません。本判決で争われた事実も当事者の主張も精査しておらず、またその能力もないので、これを批判するものではありません。この事件を契機に浮かんだ単なる個人的な雑感に過ぎません。）

**著作物
著作物は、「もの」であって、「物(有体物)」ではない。
観念的なもの、すなわちコンテンツである。
音楽CDを買ったとき、音楽著作物はそのCD自体ではなくて、そのCDに乗っている音楽コンテンツである。
同様に、音楽データを買ったとき、音楽著作物はそのデータ自体ではなくて、そのデータに乗っている音楽コンテンツである。
すなわち、著作権者から見ると、CDやデータは、その音楽著作物の一具象(実現例)に過ぎない。


**所有権
一方で、音楽CDは有体物である。
よって、これを正規に購入した者は、その物の所有権を獲得する。
所有者は、自由にその物の使用、収益及び処分ができる。
公益的な見地からそれが制限される場合もありうるけれども、これは所有物に対する絶対的な支配権を意味している。
その使用の仕方は所有者に委ねられており、その制作者が意図しない方法で使用することも自由である。
所有権の観点からは、音楽CDの所有者は、これをお風呂の中で再生することが当然にできるし、屋外で再生することもできる。
音楽プレイヤーで聴くこともできるし、その再生能力を持ったコンピュータで聴くこともできる。
国外で聴くこともできる。
一の再生機の複数のスピーカを各部屋に設置して何れの部屋で聴くこともできる。
遠隔地にデータ転送して出先からこれを聴くこともできる。
これを第三者に聞かせてその対価を請求することもできる。
これは、プロゴルファが自分のゴルフクラブを携行しこれを使って世界中で賞金を稼ぐことができるのと同じであり、大学教授が他者が書いた書籍を使って授業を行うことができるのと同じである。
所有権の処分には、当然に、その物の破壊、改良が含まれる。
所有者は改良した所有物を他者に転売することも自由である。


物の上の処分権はその所有者に委ねられているから、一つの物の上に複数の所有権は成立し得ない。
しかし、音楽CDなどの著作物の複製品には、その物の所有権の他に、その音楽の著作権者の権利が依然として宿っている。
つまり、一つの音楽CD上に、一つの所有権と一つの著作権が同時に宿っている。
複数の著作権が宿っている場合もある。
特許権などの他の無体財産権といわれるものが更に同時に宿っている場合もある。
このことが問題を複雑にする。


**権利の衝突
特許法によれば、特許のアイディアに係る物(発明品)を使ったり、売ったりする行為は、特許権者の独占行為である。
よって、特許権者がそれを許さない限り、他者はそれらの行為をしてはならない。
これはまさに、所有権に類似の権利である。
一方で、発明品を正規に購入した場合には、その物には購入者の所有権が宿る。
所有者は、その所有権に基づいて、当然に、購入物の使用ができ、転売ができる。
このことは、特許法による先の制限規定と完全に競合／矛盾する。
つまり、発明品の正規購入者が、これを使用したり、転売しようとする場合に、一方の神(民法)は「どうぞ自由に」と言い、他方の神は(特許法)は「いやダメだ」と言っている。
この矛盾を解決するために、裁判所は、所有権による絶対支配権の原則を貫いて、この場合の特許の効力を消滅化させている。


著作権法でも、著作物の複製品の特定の使用や販売が、著作権者の独占行為として規定されている。
しかし、特許の場合では、あらゆる態様の使用が禁止されているのに対して、著作権の場合には、特定の態様における使用、すなわち、「公衆に対して行う」、上演、上映、送信、口述、展示、頒布などに限っての使用が禁止されている。
よって、著作物に係る音楽CDを、公衆に対してではなく、自分たちに対して再生する行為においては、権利の衝突はおこらず、特許の場合のような問題は生じない。


**複製権
では、正規に購入した音楽CDを複製する行為はどうなるか。
音楽CDを複製する行為は、その音楽CD(これはその音楽コンテンツの一複製物である)を基に、音楽コンテンツの複製物を新たに生産する行為である。
音楽CDの購入者が獲得するのは、その所有権であり、その購入によって、その音楽コンテンツの支配権が得られる訳ではない。
音楽コンテンツを生産する権利は、依然として、著作権者に留保されている。
著作権者に著作物を複製する権利を留保したことと、所有者に所有権を認めたこととは競合しない。
つまり、音楽CDを正規に購入したとしても、その購入品に宿っている著作権者の権利は生きており、従って、その購入者が権利者の意に反してこれを複製することは原則、違法である。


しかし、私的使用のために著作物を複製する行為は、例外的に許容されている。
音楽CDの購入者が、自らが聴く用のために生じうる複製行為は許される。
もっとも、公共の場に設置された複製能力をもった装置での複製は、たとえそれが自らが聴く目的のものであっても、この例外は適用されない。
そして、その装置の設置者はその違法行為の幇助者として賠償責任を負うだろう。


一方で、所有権の対象となる所有物が音楽CDである場合、所有物の使用とはその音楽CDを再生して聴くことであるから、音楽CDの購入者は、所有権に従って、これを、いつでも、どこでも、何度でも、自由に聞ける。
コンピュータおよびそのネットワークの関連技術は、この購入者の自由をより広範に顕在化させるものである。
つまり、購入者はこのような新たな環境化における使用の自由を元々持っている。
購入したカメラは、それが可能ならば水中での撮影に使ってもよい。
購入した車のハンドルを、レースゲームに使ってもよい。
スタンドアロンのプリンタを、可能ならばネットワークに繋いで使ってもよい。
同様に、購入した音楽CDを、コンピュータ・ネットワークを介して、別の場所で聞いてもよい。


**ネットワーク送信
しかし、購入した音楽CDを、コンピュータ・ネットワークを介して、別の場所で(および|または)別のデバイスで聴く場合、その過程において技術的に音楽コンテンツの複製が作られる。
普通、そのコンテンツは、他者が用意したサーバ上に永続的または一時的に置かれる。
他者は、自らがそれを使用することはないが、そこにコンテンツの複製物が作られることを許容し、またはそれを商業的／非商業的にサポートしている。
ここで、このような過程で行われる音楽コンテンツの複製が、著作権法で禁止されている複製に当たるか否かが問題となる。


「複製」とは同じ物を製造することである。
著作権法では、「有形的に再製すること」と定義している。
しかし、著作物が物自体ではなくそのコンテンツにあることに鑑みれば、複製というのは、再製というよりも、コンテンツを人が知覚できるように具象する行為、つまり、著作物に基づいてその一形態を社会に新たに生み出す行為である。
すなわち、生産、上演、録音、筆記、建築などは、複製であろう。
著作権法は、著作物を複製する行為を著作権者に独占させることによって、著作権者が自ら望む時に、自ら望む形および数量で、社会に出て行くようにコントロールする権利を、著作権者に留保した。
これはそれを生み出したものの当然の権利とも言える。
法は第三者による複製が無制限に行われることによって、著作権者に与えられるべきこのコントロール権が侵されることがないようにした。


果たして、上記過程で生じる複製行為は、この著作権者の上記コントロール権を侵す、あるいはそれを脅かすものなのだろうか。
自ら購入したCDの音楽を携帯電話で聴くという目的行為が著作権者のどんな不利益となるのであろうか。
正規に購入した商品の使用、収益、処分の権限は購入者にあり、このCDの著作権者(販売者)にとっても、それが売り渡された以上、「お買い上げありがとうございます。ご自由にお楽しみください。」ということであろう。
このような自ら使用する目的で、コンピュータおよびそのネットワーク関連技術を利用したときに、その過程において生じる複製行為は、それが実際に誰の手で行われるかに拘らず、その最終目的である使用を全うするためには不可避のことである。
そうである以上、それは使用の実現のための付帯的作用(行為ではない)であるとみるべきだ。
著作権法21条の「複製する権利」が、著作権者に流通のコントロール権を留保したとものであると考えるならば、行為者をして複製にはそれに結びつけるための積極的な意思、または、少なくとも複製を「する」という能動的な意思が必要であろう。
サーバ上のこれらの複製行為には、流通をコントロールしたりその一部を担ったりしようとする積極的な意思は見当たらない。
複製を「する」という能動的な意思も見当たらない。
あるのは、購入者がその音楽を別のデバイスで聴けるようにするという意思だけである。
スーパーで包丁を買った帰路、危険物を所持しているとして銃刀法違反になることはない。
これをスーパーの配送係に依頼しても同様である。
自分の音楽を別の場所で聴くために、不可避的に生じてしまう複製は、著作権法が予定している複製とは言えない。


**公衆送信
著作権者以外の者は、その許諾が無い限り、著作物を公衆送信してはならない。
公衆送信とは、みんなに向けての送信であり、そのみんなというのが、特定の多数者であってもよい。
仮に、送信者が特定または不特定の多数者に向けて、一つの著作物を、同時または非同時に、送信する行為は、公衆送信である。
ちなみに放送は、公衆送信の下位概念である。
公衆送信は、著作物の一形態を、同時並行的に、新たに社会に生み出す行為であり、これは複製に類似の行為と捉えることができるかもしれない。


一方、特定の一人に向けての送信は公衆送信とは言わない。
従って、一つの著作物を特定の一人が受け取るように送信する行為は、公衆送信ではない。
しかし、複製と言ってもいいかもしれない。
この場合に、送信者と受信者が同じ場合は、当然に、公衆送信でもないし、複製と言うこともできないだろう。


音楽CDの所有者が、ネットワークの他者管理下のサーバを介して、自分にその音楽データを送信する場合、サーバ管理者はそのデータの送信者になるのであろうか。
サーバ管理者による送信行為は、常に、音楽CDの所有者の操作または命に従ってなされるものである。
サーバ管理者が、CDの所有者から独立して、すなわち自己判断により、音楽データを送信することはない。
つまり、サーバ管理者はCD所有者の手足に過ぎない。
従って、サーバ管理者をデータ送信の幇助者ということはできるけれども、主体的な送信者ということはできない。


参考：[http://law.e-gov.go.jp/cgi-bin/idxselect.cgi?IDX_OPT=1&amp;H_NAME=%92%98%8D%EC%8C%A0%96%40&amp;H_NAME_YOMI=%82%A0&amp;H_NO_GENGO=H&amp;H_NO_YEAR=&amp;H_NO_TYPE=2&amp;H_NO_NO=&amp;H_FILE_NAME=S45HO048&amp;H_RYAKU=1&amp;H_CTG=1&amp;H_YOMI_GUN=1&amp;H_CTG_GUN=1:title=著作権法]、[http://law.e-gov.go.jp/cgi-bin/strsearch.cgi:title=特許法]、[http://law.e-gov.go.jp/cgi-bin/idxselect.cgi?IDX_OPT=4&amp;H_NAME=&amp;H_NAME_YOMI=%82%a0&amp;H_NO_GENGO=H&amp;H_NO_YEAR=&amp;H_NO_TYPE=2&amp;H_NO_NO=&amp;H_FILE_NAME=M29HO089&amp;H_RYAKU=1&amp;H_CTG=10&amp;H_YOMI_GUN=1&amp;H_CTG_GUN=1:title=民法]
</body>
</day>
<day date="2007-06-14" title="">
<body>
*p1*Railsでブログを作ろう！(Creating a Weblog in 15 minutes)
Ruby on Railsのサイトで紹介されている有名なscreencastデモ&quot;[http://www.rubyonrails.org/screencasts:title=Creating a Weblog in 15 minutes]&quot;を自分の勉強を兼ねて勝手にドキュメント化してみました(解説はこちらで適当にしました。DHHさんのものではありません)。デモは、Mac OSXの環境で、[http://www.mysql.com/:title=MySQL], [http://iterm.sourceforge.net/:title=iTerm], [http://macromates.com/:title=TextMate], [http://cocoamysql.sourceforge.net/:title=CocoaMySQL]を使って行われています。

**1. brablogプロジェクトの作成
iTerm(Terminal)を立ち上げて、brablogという名前でプロジェクトを作ります。
&gt;||
 $ rails brablog
||&lt;
作成されたbrablogのフォルダに移動し、webrickサーバーを起動して、プロジェクトが立ち上がっているか確認します。
&gt;||
 $ cd brablog
 $ ./script/server
||&lt;
ブラウザで、 http://localhost:3000/ へアクセス。RailsのWelcomeページが表示されましたね？

**2. Blogコントローラの作成
iTermで別セッションを開き(command+T)、そこからBlogプロジェクトの関連ファイルをTextMate上にオープンします。
&gt;||
 $ cd brablog
 $ mate .
||&lt;
既に多数の関連ファイルが作成されているのがわかりますね。
次に、script/generateコマンドを使って、Blogコントローラを作成します。
&gt;||
 $ ./script/generate controller Blog
||&lt;
http://localhost:3000/blog にアクセスすると、indexに対するactionが定義されていないとのエラーメッセージが出ました。
では、indexを定義しましょう。TextMateに移って、app-controllerフォルダにあるblog_controller.rbをオープンし、以下を加えます。
&gt;||
 def index
   render :text =&gt; &quot;Hello World!&quot;
 end
||&lt;
http://localhost:3000/blog にアクセスすると、今度は&quot;Hello World!&quot;の文字が表示されましたね？
今度は、def index endの定義だけを残して、中身のrender :text...を削除します。代わりに、app-views-blogフォルダ内に、index.rhtmlを作成して、そこに以下を打ち込みましょう。
&gt;||
hello from the template
||&lt;
同様にブラウザでアクセスして、上の文字が表示されましたか？
では、blog_controller.rb内のdef index endを削除して、どうなるか見てみましょう。これでもindex.rhtmlの内容が同じように表示されましたね。

**3. データベースへの設定
次に、blogのデータを格納するデータベースの準備します。最初に、若干の設定をします。configフォルダにあるdatabase.ymlを編集しましょう。developmentのデータベースをblog_development,testのものをblog_testとします。usernameなど他の設定はご自身の環境に合わせてください。
&gt;||
development:
  adapter: mysql
  database: blog_development
  username: root
  password: 
  socket: /tmp/mysql.sock

test:
  adapter: mysql
  database: blog_test
  username: root
  password: 
  socket: /tmp/mysql.sock

production:
  development
||&lt;
**4. データベースの作成
次に、CocoaMySQLを立ち上げて、blog_developmentデータベースを作成し、postsテーブルを作成します。テーブル名は複数形(posts)にします。コラムは、id(auto_increment, primary key), title(varchar 255)を作成します。なお、後述しますが、現行バージョンのRailsではmigrationというデータベースのスキーマ管理機能があるので、テーブルの作成はそちらを使う方が便利です。

**5. Postモデルの作成
script/generateコマンドを使って、モデルを作成します。
&gt;||
 $ ./script/generate model Post
||&lt;

**6. scaffoldメソッド
次に、blog_controller.rbのBlogControllerクラス内に以下の一行を記述します。
&gt;||
 scaffold :post
||&lt;
データベースの設定を変更したので、サーバを立ち上げ直しましょう。
&gt;||
 $ ^C
 $ ./script/server
||&lt;
http://localhost:3000/blog にアクセスしましょう。うまく表示されましたか？では、New Postボタンを押して、タイトル(&quot;Hello Brazil!&quot;)を入力してみましょう。
**7. コラムの追加
次に、CocoaMySQLに移り、コラムbody(text)を追加します。
ブラウザをリロードすれば、bodyの入力エリアが現れました。bodyにも入力してみましょう(&quot;Yes, yes, hello indeed!&quot;)。
どうですか？うまく動いていますか？
では、更に、作成日時を記録するようにもしましょう。CocoaMySQLで、コラムcreated_at(datetime)を追加します。
ブラウザをリロードしてみましょう。入力したデータをエディットしてみてください。作成日時が追加されますね。
では、CocoaMySQL上で、コラムcreated_atをマウスでドラッグしてbodyコラムの上に移動してみてください。ブラウザをリロードするとどうなりますか？
これらの一連の作業において、サーバーの再起動も、再コンパイルも必要ありません。
Railsの名前規約に従っていれば、Railsアプリケーションは簡単にデータベースへアクセスすることができるようになります。

&gt;&gt;
**~Migration~
なお、デモからは外れますが、現行のRailsバージョンではmigrationが使えるので、上記の代わりにこれを使った方が便利です。CocoaMySQLでblog_developmentデータベースを作成した後、db-migrateフォルダにある001_create_posts.rbを編集します。このファイルはモデルの作成時に同時に作成されます。
&gt;||
class CreatePosts &lt; ActiveRecord::Migration
  def self.up
    create_table :posts do |t|
      t.column :title, :string
      t.column :body,  :text
      t.column :created_at :datetime
    end
  end

  def self.down
    drop_table :posts
  end
end
||&lt;
雛形が出来上がっているので、create_tableのブロック内を追加するだけです。このときidコラムは自動生成されるためここでの追加は不要です。
次いで、migrationを実行すれば、上記upメソッドが実行されて、postsテーブルが生成されます。
&gt;||
 $ rake db:migrate
||&lt;
&lt;&lt;

次に、タイトル入力に対する検証をするようにします。app-modelsフォルダ内のpost.rbに、以下を追加します。
&gt;||
 validate_presence_of :title
||&lt;
タイトルを入れないで投稿して見てください。エラーメッセージが出ますね？
では、ちゃんと投稿してみましょう(title &quot;Better fill it in, then!&quot;, body &quot;Aye, aye, sir&quot;)。

**8. scaffoldジェネレータ
先のscaffoldメソッドはワンラインで便利なんですけど、コードが変更できない問題があります。ですので、他の方法をやってみましょう。scaffoldジェネレータを使います。
&gt;||
 $ ./scrip/generate scaffold Post Blog
||&lt;
途中、blog_controller.rbを上書きしてよいか聞かれますので、a を押して上書きしてください。
TextMateでblog_controller.rbを見てみると、いろいろなコードが生成されているのが分かります。add-viewsフォルダ内には各アクションに対応したビューも自動生成されています。ブラウザをリロードしてみてください。同じ表示が維持されていると思います。

自動生成された表示はブログに適したものになっていないので、list.rhtmlをブログに適したものに編集してみましょう。
&gt;||
&lt;h1&gt;My wonderful weblog&lt;/h1&gt;

&lt;% for post in @posts %&gt;
   &lt;div&gt;
	&lt;h2&gt;&lt;%= link_to post.title, :action =&gt; 'show', :id =&gt; post %&gt;&lt;/h2&gt;
	&lt;p&gt;&lt;%= post.body %&gt;&lt;/p&gt;
	&lt;p&gt;&lt;small&gt;
	   &lt;%= post.created_at.to_s(:long) %&gt;
	   (&lt;%= link_to 'Edit', :action =&gt; 'edit', :id =&gt; post %&gt;)
	&lt;/small&gt;&lt;/p&gt;
   &lt;/div&gt;
&lt;% end %&gt;

&lt;%= link_to 'New post', :action =&gt; 'new' %&gt;
||&lt;
ブラウザをリロードしてみてください。体裁が良くなりました。新たにデータも追加しましょう(title &quot;Let's just add a third, for good measure&quot;, body &quot;Oh yeah&quot;)。
最新投稿が一番上に来るように、表示されるリストの順序を逆にしましょう。先ほどのlist.rhtmlの
&gt;||
&lt;% for post in @posts %&gt;
||&lt;
を、以下に修正してください。
&gt;||
&lt;% for post in @posts.reverse %&gt;
||&lt;
次に、textilizeメソッドを使って、表示をリッチにします。先に、bodyに入力した、&quot;Aye, aye, sir&quot;を以下のように修正します。
&gt;||
 Aye, *aye*, _sir_
||&lt;
そして、list.rhtmlの、
&gt;||
 &lt;p&gt;&lt;%= post.body %&gt;&lt;/p&gt;
||&lt;
を、
&gt;||
 &lt;p&gt;&lt;%= textilize(post.body) %&gt;&lt;/p&gt;
||&lt;
のように修正します。このメソッドにはRedClothモジュールが必要です。
&gt;||
 $ sudo gem install redcloth
||&lt;
ブラウザをリロードして、リストが逆順になったことと、bodyの表示がリッチになった点を確認してください。

**9. partialの使用
同様の表示をpartialを使ってやってみましょう。app-views-blogフォルダ内に _post.rhtmlというファイルを作成し、先のlist.rhtmlにおける、以下の部分を移動します。
&gt;||
 &lt;div&gt;
   &lt;h2&gt;&lt;%= link_to post.title, :action =&gt; 'show', :id =&gt; post %&gt;&lt;/h2&gt;
   &lt;p&gt;&lt;%= post.body %&gt;&lt;/p&gt;
   &lt;p&gt;&lt;small&gt;
      &lt;%= post.created_at.to_s(:long) %&gt;
      (&lt;%= link_to 'Edit', :action =&gt; 'edit', :id =&gt; post %&gt;)
   &lt;/small&gt;&lt;/p&gt;
 &lt;/div&gt;
||&lt;
そして、list.rhtmlの内容は以下のようにします。
&gt;||
 &lt;h1&gt;My wonderful weblog&lt;/h1&gt;

 &lt;%= render :partial =&gt; &quot;post&quot;, :collection =&gt; @posts.reverse %&gt;

 &lt;%= link_to 'New post', :action =&gt; 'new' %&gt;
||&lt;
ブラウザをリロードすれば、表示に変化がないことがわかります。
次いで、showビューでもこの_post.rhtmlのテンプレートを使いましょう。app-views-blogフォルダのshow.rhtmlを以下のようにします。
&gt;||
 &lt;%= render :partial =&gt; &quot;post&quot;, :object =&gt; @post %&gt;

 &lt;%= link_to 'Edit', :action =&gt; 'edit', :id =&gt; @post %&gt; |
 &lt;%= link_to 'Back', :action =&gt; 'list' %&gt;
||&lt;
これでshowビューもきれいになりました。

**10. Commentデータの管理
さて、次に、ブログにはコメントが必要ですので、これを作ります。まずは、Commentモデルを作ります。
&gt;||
 $ ./script/generate model Comment
||&lt;
生成されたComment.rb(Commentモデル)に、Postモデルとの関係性を示す以下を追加します。
&gt;||
 belongs_to :post
||&lt;
一方、Post.rb(Postモデル)にもCommentモデルとの関係性を記述します。
&gt;||
 has_many :comments
||&lt;
１つのPostが複数のcommentを持ち得るので、&quot;:comments&quot;と複数形になります。
次いで、CocoaMySQLで、commentsテーブル(複数形)を作成し、コラムid(auto_increment, primary key), body(text), post_id(int11)を追加します。
&gt;&gt;
現行バージョンではmigrationを使うことができます。002_create_comments.rbを以下のようにします。
&gt;||
class CreateComments &lt; ActiveRecord::Migration
  def self.up
    create_table :comments do |t|
      t.column :body, :text
      t.column :post_id, :integer
    end
  end

  def self.down
    drop_table :comments
  end
end
||&lt;
そして、migrateします。
&gt;||
 $ rake db:migrate
||&lt;
&lt;&lt;
CocoaMySQLにおいて、commentデータを１件入力してみましょう(body &quot;Yes, I agree with the Hello!&quot; post_id &quot;1&quot;)。
さて、次に、show.rhtmlに以下を追加して、コメントがそこに表示されるようにしましょう。
&gt;||
&lt;h2&gt;Comments&lt;/h2&gt;

&lt;% for comment in @post.comments %&gt;
   &lt;%= comment.body %&gt;
   &lt;hr /&gt;
&lt;% end %&gt;
||&lt;
さらに、コメントをこのページで投稿できるようにしましょう。show.rhtmlにさらに以下の入力フォームのコードを追加します。
&gt;||
&lt;%= form_tag :action =&gt; &quot;comment&quot;, :id =&gt; @post %&gt;
	&lt;%= text_area &quot;comment&quot;, &quot;body&quot; %&gt;&lt;br&gt;
	&lt;%= submit_tag &quot;Comment!&quot; %&gt;
&lt;%= end_form_tag %&gt;
||&lt;
そして、このフォームに応答するcommentアクションを、blog_controller.rbに定義します。
&gt;||
 def comment
   Post.find(params[:id]).comments.create(params[:comment])
   flash[:notice] = &quot;Added your comment.&quot;
   redirect_to :action =&gt; &quot;show&quot;, :id =&gt; params[:id]
 end
||&lt;
ブラウザをリロードして、コメントを投稿してみてください(&quot;Me too, me too!&quot;)。うまく行きましたか？ページの上部にはコメントが追加されたことを示すフラッシュが表示されます。これで、コメント付きのブログができました。

**11. テスト他
さて、これまでにどれだけのコードを書いたのでしょうか。調べてみましょう。
&gt;||
 $ rake stats
||&lt;
たった58行のコード！
次に、ログからrailsの挙動を見ることもできます。
&gt;||
 $ tail -f log/development.log
||&lt;
上のコマンドを実行してから、投稿や画面遷移をしてみてください(ctrl+Cで終了)。
Railsではunitテストやfunctionalテストも簡単にできるようになっています。
まず、CocoaMySQLでblog_testデータベースを作成します。そして、以下を実行します。
&gt;||
 $ rake test:units
||&lt;
test-unitフォルダを見ると、既に2つのunitテストが用意されており、これをパスしたようです。
post_test.rbを編集して、別のテストをしてみましょう。
&gt;||
require File.dirname(__FILE__) + '/../test_helper'

class PostTest &lt; Test::Unit::TestCase
  fixtures :posts

  def setup
    @post = Post.find(1)
  end

  def test_adding_comment
    @post.comments.create :body =&gt; &quot;My new comment&quot;
    @post.reload
    assert_equal 1, @post.comments.size
  end
end
||&lt;
再度、テストします。
&gt;||
 $ rake test:units
||&lt;
簡単ですね。
また、Railsにはconsoleという優れたツールがあります。
これを使えばWebインタフェースを介さずにデータの操作ができます。
&gt;||
 $ ./script/console
||&lt;
でconsoleを立ち上げて、
&gt;||
 p = Post.find :first
 p.title = &quot;Hello Denmark&quot;
 p.save
||&lt;
などとします。ブラウザをリロードして変化を確かめてください。
&gt;||
 p.comments.create :body =&gt; &quot;Greeting to the cold north!&quot;
 p.comments.create :body =&gt; &quot;Greeting to the super, super cold north!&quot;
 p.comments
||&lt;
最初の投稿に対してコメントを追加しました。
&gt;||
 p.destroy
||&lt;
これで投稿が削除されます。

</body>
</day>
<day date="2007-06-24" title="">
<body>
*p1*集うということ
人は死ぬ。必ず死ぬ
それは生まれた瞬間に人に約束されたこと
死は残された者に悲しみを呼ぶ
人が集うのは
この悲しみを和らげるための本能なのかもしれない
しかしそれは同時に
喜びを薄めてしまうかもしれない
喜びも悲しみも生まれた瞬間に人に約束されたことであり
人はそれをただ待つしかないのかもしれない
そう思うと、僕の中で生きる喜びと生きる悲しみがミックスした
</body>
</day>
<day date="2007-08-01" title="">
<body>
*p1*常識と社会

常識とは社会のコンセンサスのことであり
正しさとは関係がない
此処での常識は向こうでの常識とはならない
今日の常識は明日の常識足り得ない
常識は寧ろ
恐怖から来る変化への抵抗である


非常識は時として社会に利益を与える
それは当然に起こりうることだ
社会はそれを何度も何度も経験しているのに
それを受け入れることができない
なぜなら常識は社会のコンセンサスだからだ
民主主義における致命的な欠陥がここにあるのだろう


一方で資本主義における企業の源泉は差異である
つまり起業家による超常識への挑戦が資本主義を形成する
非常識が社会に利益を与えるなら
個によるリーダーシップが社会には必要であろう
それは民主主義の先の欠点を補完し得る


これからの社会つまり情報化社会は
リーダーと民衆との間の新たなパワーバランスを模索している
それは危ういものにも見える
しかしそれも明日には昨日の常識となるのだろうか
そう信じるのがきっと正しい選択なのだろう
</body>
</day>
<day date="2007-08-22" title="">
<body>
*p1*我々はエコノミストである！
ムダなことをしない
ムダな財貨を持たない
ムダな栄養をとらない
エコノミストとはeconomise-istであり
本来はこのような効率性信者のことである
したがって
太ったエコノミストや
収集癖のあるエコノミストは
エコノミストではなくエゴノミストである
寧ろ我々がどうみてもエコノミストなのだ！
よってここにエコノミスト宣言をする！

*p2*KeyboardはUSであるべきである！
なぜなら
Modifierが一列に並んでいるから
returnを小指で打てるから
Quatation markが良い位置にあるから
そしてなによりも
Beautifulだから


昨日、渋谷Apple Storeに新しいApple US Keyboardを買いに出かけたら、在庫がなく3-4週間待ちになるとのことでした。滅多にこんなことはしないのに。代わりという訳ではないですが、iWorkを買いました。+2000円でファミリーパックというのは素晴らしいアイディアですね。

*p3*Apple NumbersはNintendo Wiiである！
Numbersがその機能においてExcelに敵わないのはわかっています。
僕にとっても足りない機能がいくつかあります。
したがって僕はExcelを捨てることができません。
Excelを使うために今後もWindowsを立ち上げるでしょう。


しかしその一方で、
Excelを捨ててNumbersを使いたい僕がいることは明らかです。
Excelを使っているとフラストレーションが溜まります。
でもNumbersを使っていると楽しい気分になります。
Numbersは僕の需要の90%、いや95%を満たすでしょう。
だから僕はNumbersに移行できるものは移行するでしょう。


Excel=表計算であるとすると、
Numbersは表計算ではないのかもしれません。
無限に続く行と列の地平が表計算におけるプラットフォームであるならば、
Numbersは明らかに表計算ではありません。
Numbersでは表は僕らが良く知っている白紙の上の一オブジェクトに過ぎないのです。
それが僕が表計算に対して持っていた不安を消してくれます。
もう僕の指先が成層圏を一気に超えて宇宙の果てに葬られる心配はないのです！
Numbersのプラットフォームが表でないことの利点は小さくはないと思うのです。


任天堂はNintendo Wiiで新たなゲームのかたちを示しました。
それはコントローラ、つまり入力インタフェースの再定義でした。
新しいコントローラによって開発者は刺激を受け、
そこに新種のゲームが生まれました。
AppleはNumbersで新たな表計算のかたちを示しているように僕には見えます。
表計算において入力インタフェースを定義するのはユーザですが、
この新たなプラットフォームがユーザを刺激して、
今までにない、使い勝手の良い入力インタフェースが生み出されていくことになるのでしょう。
</body>
</day>
<day date="2007-09-17" title="">
<body>
*p1*経営者の役割
経営者の役割は2つある
一つは組織に経済的利益をもたらすことであり
もう一つは組織構成員に学ぶ機会を与えることである
二つ目の役割は無視されがちだけれども
人が生きる上で学ぶことが必要とされる限り
その機会を奪うことはその人の人生を奪うことでもある
経営とは組織構成員に対するこのような責任を内在している
経営者はこのことを理解した上で難しい舵取りをしなければならない
評論家はこのことを理解した上で発言しなければならない
</body>
</day>
<day date="2007-09-19" title="">
<body>
*p1*Webは最強のコンテンツ生成媒体なのだ！
メディアは媒体、コンテンツの流通媒体に過ぎない
人が興味のあるものはコンテンツでありメディアではない
つまりメディアの優劣はコンテンツの優劣で決まる


一方でメディアはコンテンツを規定する
メディアの規定に従ってコンテンツが生成される
新種のメディアが登場すると
そのメディアによって規定された新種のコンテンツが生まれる
つまりメディアはコンテンツ生成媒体である


Webは新種のメディアを作り出すためのプラットフォームである
SNS, blog system, YouTube, Flickr, Digg, Del.icio.us, wikipedia, ニコニコ動画, Second Life...
これらは新種のメディアであり、Webの強みはこれら多様なメディアを受容するオープン性にある
Web上では資本家でも労働者でも区別なく
また国籍、性別、年齢、学歴、人脈を問われることなく
新種のメディアを作り、コンテンツを公表し、これらに対する意見を表明する機会が与えられている
既存メディアの比較にならないおびただしい数の人間がこの作業に参加しており
しかもすさまじい流動性をもって常時移動している


つまりWebは人類史上例を見ない、圧倒的多数の参加者を抱えた最強のコンテンツ生成媒体なのだ！
Webの登場によって既存メディアの社会的位置づけが変わるのは明らかである
メディアに係わる人間はこのことをもっと深く考察しなければならない
何しろこのメディア革命はまだ始まったばかりなのだから

*p2*劣等感は社会的コストである！
劣等感は厄介である
知識だったり経験だったりお金だったり健康だったりする「それ」を持っていないという思いを
一生頭の隅に負のものとして抱えるからだ


劣等感は「それ」を持っている人との相対で生まれる
「それ」を持っている人が目の前に現れると
劣等感が生まれる
知識や経験やお金や健康を持っていることを自慢して
他人に劣等感を与えた人が
「それ」をより多く持っている人の前に立ったとき
その人にも劣等感が生まれる


一方で他人を評価する指標は唯一つ
その人が成した社会的価値だけである
他人が社会的に価値のあることを成したとき
その人に対する称賛の気持ちは生まれるが
劣等感は生まれない


知識や経験やお金や健康を持っているということが
それだけで社会的価値になることはない
それらの能力が生かされて社会に価値をもたらしたとき
はじめて人は社会的評価の対象になるのだ


さらには知識や経験やお金や健康というものは
単に「それ」を持つ人の人生における安全率を高めるだけのものであり
社会的価値を生み出せる可能性を高めるものですらないのだ
「それ」を持たない多くの人間がこのことを証明している


劣等感や優越感は社会的には無価値であり
それが社会に歪みを与えているとすれば社会的コストでもある
社会における人生の安全率が低下すると
持つ者の優越感が蔓延して社会的コストが大きくなる


故に政治は市民の人生における安全率を高めるよう努めなければならないし
個人は劣等感が無価値であることを悟って
社会的価値の創造に気持ちを振り向けるほうがいい
</body>
</day>
<day date="2007-10-23" title="">
<body>
*p1*オープンソースはウェブの成果
オープンソースはその作成の過程において他者のレビューを繰り返す
レビューの結果は直ちにソースに反映される
その繰り返しがきわめて完成度の高いものを生み出す


コミュニケーションは本来リアルタイムである
リアルタイム処理で重要かつ困難なのは同期である
同期の困難性は自由で公汎なコミュニケーションを阻害する
ウェブはバッファとなってそれを緩和する
そしてまた人々の感情をも緩和する
ウェブを通した他者の出力を理解しその応答をするとき
感情は整理され吟味されそしてその多くは緩和されるか消滅する


自由で広汎で感情が緩和されたコミュニケーションは最良のものである
オープンソースは最良のコミュニケーションの結果として生まれ
それはウェブのバッファ機能の副産物なんだと思う


関連：[http://d.hatena.ne.jp/keyesberry/searchdiary?word=%A5%D0%A5%C3%A5%D5%A5%A1&amp;.submit=%B8%A1%BA%F7&amp;type=detail:title=ウェブはコミュニケーション・バッファ]
</body>
</day>
<day date="2007-10-24" title="">
<body>
*p1* 2つのコード～コンピュータプログラムと法律
コンピュータプログラムはコンピュータを動作させるためのコードである
コンピュータは計算機であり数字しか解釈しない
よってコンピュータプログラムも数字のみで構成されなければならない
数字のみで構成されたコードには曖昧さがない
ある要求に対するコンピュータの答えは常に一定であり
それは資源としてのコンピュータに変化がないことを前提としている
コンピュータに期待されているのはこの不変性である


一方法律は国家／社会を動作させるためのコードである
国家／社会は人間の集合であり文字数字の組み合わせからなる言語を解釈する
よって法律も文字数字で構成されなければならない
文字を含んだコードには曖昧さがある
ある要求に対する国家／社会の答えは不定であり
それは資源としての国家／社会が変わりゆくことを前提としている
国家／社会に期待されているのはこの変化に対応する柔軟性である


ある場面でコンピュータプログラムが無力なのはこの不変性故である
ある場面で法律が無力なのはこの柔軟性故である


人知の結晶としてのこれら2つのコードの重要性は増すばかりである
2つのコードの違いは重大であり
それは正しく理解されなければならない
</body>
<comments>
<comment>
<username>oliza</username>
<body>その他にね。ひとりの独立した人間には良心というコ－ドがはいっているんですよ。宗教観の希薄な日本では見えにくいんですけどこのコ－ドがないと,コンピュ－タや社会で何をしたらいいかも分からないんです。</body>
<timestamp>1195213249</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;olizaさん&lt;br&gt;なるほど。人間自体を形成しているコードということですね？それが最も重要であることは疑いがありませんね。</body>
<timestamp>1195258346</timestamp>
</comment>
</comments>
</day>
<day date="2007-11-18" title="">
<body>
*p1*被コントロールは人間の本能に反する

国民であれ部下であれ子供であれ
それが人間である限り
これをコントロールしようとしてはいけない
人は個の自立を目指して成長するのであるから
コントロールはその阻害要因の最たるものになる
コントロールに対する人の拒絶反応は人間の本能である


一方国家であれ企業であれ社会コミュニティであれ家族であれ
組織を組織足らしめるのはその目的の存在である
組織の構成員である人を特定の目的に向けさせることができなければ
組織は組織足りえない
人を目的に向けさせるための最も安易な方法はコントロールである
しかしそれはもううまく機能しないし
そのような組織はもはや組織ではなく
部品から構成される機械と呼ぶべきものである


被コントロールは人間の本能に反する
だからいかなる場合にも組織はそれをしてはならない
組織は時間を掛けて各構成員にその目的を理解させ
一つひとつ同意を得るしか道はない
</body>
</day>
<day date="2007-11-27" title="">
<body>
*p1*好きでないことをしないことを貫け！
好きなことを貫ければ
よい人生が送れるだろうことはわかる
しかし好きなことを貫くためには
まず好きなことを見つけなければならない
しかしそれは誰にでも見つけられるものではないだろうし
もともと自分にとっての好きなことというものが存在しないのかもしれない


そんなときはどうすればいいのか
そんなときは好きではないことをしなければよいのではないか


自分が今やっていることで好きではないことは簡単に見つかるはずだ
まずはそれを止めてみる
それが簡単には止められないものであるなら
その好きではないことと真剣に向き合って
なぜ好きでないのかなぜ止められないのかを考えてみる
好きではないことをやめられないのは往々にして
それを止めれば別の好きではないことを強いられるという恐れがあるからだ
それでもまずはそのような恐れに目をつむって止めてみる
そして止めたら実際にどうなるか確かめてみる
それから次に起こりうる好きではないことを避ける方法を模索してみる
そうして好きではないことの総量を減らしていく


好きではないことを止められれば心は軽くなり前向きになる
そうすれば好きなことに出会ったときそのことに気付く
こんなふうにして僕も好きなことを見つけられればと思う
</body>
</day>
<day date="2007-12-10" title="">
<body>
*p1*既存顧客は顧客ではない
ビジネスで最も大切なことそれは継続することである
なぜなら継続していなければ顧客からの信用は得られず
信用を得られなければビジネスは成立しないからである


ビジネスを継続するためには新規顧客の獲得が必須である
新規顧客の獲得のみがビジネスであるといっていい
なぜなら既存顧客は減少するしかなくビジネスの継続を保証してはくれないからである
よって既存顧客はもはや顧客とは呼べず新規顧客のみが顧客と呼ぶに値する


ポイントカード、お得意様便宜などの顧客囲い込み戦略が
ビジネスにおける要諦を明らかに見誤った戦略であることに経営は早く気付くべきである

*p2*匿名こそが仮想世界の本質
仮想世界の活動において実名を用いることは
現実世界における自分を引用することである
現実世界の自分と仮想世界の自分にリンクを張ることである
仮想世界から見れば明らかにそれは他者の信用を利用することである
そういう人は仮想世界に生きるなどと言ってはいけない
そういう人は仮想世界に生きてなどいない
</body>
</day>
<day date="2007-12-11" title="">
<body>
*p1*専門家と一般
 一般人は対象の全体像すなわち森を概観することはできる
その外観に基づいて対象を評価することはできる


しかし森は多数の木の集まりで構成されている
そして専門家は木を見ている
専門家がすべての木を見終えて
そこから浮かび上がる全体像こそが真の森の姿である


真の森の姿はときとして一般人が見る森の概観とは一致しない
そのとき一般人による評価は的外れになる
専門家の価値が顕在化するのはこのようなときである
専門家は一般人に正しい道を教示できる


ところが現実には森を構成するすべての木を見終えた専門家はほとんどいない
大半の専門家は一部の木しか見ていない
一般人が見ている森の概観すら見えなくなっている専門家もいる
このような専門家は一般人に正しい道を教示しえない
大半の専門家は専門家の名に値しない


これが現実であり一般人は自らのアンテナを磨かなければならない
自分の身に起きている問題が何であり適切な対処は何かを
最終的に判断できるのは自分でしかない
無知は仕合わせだが危険でもあることを認識しなければいけない
</body>
</day>
<day date="2008-01-18" title="">
<body>
*p1*MacBook AirにMac miniも嫉妬

Macworld 2008におけるJobsのkeynoteを聞き終えた
Time Capule
iPhone + iTouchの追加services
iTune Movie Rental + new &amp;#63743;TV
そしてMacBook Air
革新的なproductsとservicesに暫し思いを馳せる


そしたら愛機Mac mini core soloがhungした
再起動で&amp;#63743;の替わりに現れる?マーク
Install Discを取り出してrestoreを試みるも途中でerror
Install DiscよりDiskUtilityを起動して
Disk修復を試みるもerror
Diskデータを消去して再度restoreを試みるもerror
Diskに0データを書き込んで再度の試みもerror


諦め気分で別機で換装用HDDの情報を収集開始
日立のTravelstar当たりがよいのかな
最後にと思ってパーティションを再作成
そしたら…
restore成功！
linux機にhome/以下を丸ごとbackupしていたのを戻して復元
ごめんなさいそしてありがとう


教訓

+投げたらあかん！（最後まで諦めない）
+backup重要！（丸ごとに限る）
+Mac miniはメス！（浮気心はヤケドの元）
</body>
</day>
<day date="2008-01-19" title="">
<body>
*p1*QuickSilver + gmailで問題発生そして解決

ブログへの投稿を頻繁に行うとき
QuickSilverを通してgmailを使うのが便利だ
QSを起動、タイトル入力、e、送信先指定で
gmailの作成画面が開くから
そこで内容だけを入力すればいい


QSを起動、gsと入力してGmail Searchを起動して
投稿した内容を検索したり
&quot;label:blog quicksilver&quot;として
ラベル付き投稿を対象に検索をするという使い方もある


ところが数日前からQSからgmailの作成画面が開かない
調べたらgmailのEnglish(US)バージョンに問題があるようで
Google Notifierからのcompose Mailでも動かないことがわかった
日本語バージョンではその問題は生じない
gmailのEnglishバージョンはNew versionがあって
カラーラベルなどが使えて重宝していたのにちょっと残念だ
それに英語の方が見た目もいいのにな
でもQSが使える便利さにはやはり敵わないから
gmailは日本語バージョンを暫く使おうと思う



参考：[http://groups.google.com/group/Gmail-ABCs/browse_thread/thread/78382b7f1d3e4e65/973e059de5760ece:title=Compose Mail does not load in Gmail Newer Version - The ABCs of Gmail | Google グループ]
</body>
<comments>
<comment>
<username>通りすがり</username>
<body>ＳＳＬでログインしてみたら。&lt;br&gt;https://mail.google.com/mail/</body>
<timestamp>1201006391</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;通りすがりさん&lt;br&gt;アドバイスありがとうございます。ただ、やってみましたが同じようにうまくいきませんでした。</body>
<timestamp>1201008289</timestamp>
</comment>
</comments>
</day>
<day date="2008-01-23" title="">
<body>
*p1*&lt;span style=&quot;font-weight:bold;&quot;&gt;MacBook Air&lt;/span&gt;それは美の追求

Jobs、いやAppleが追求しているのは便利なToolではない
彼らが追求しているのは情報機器における美である
美の追求の基本的な姿勢は
極力不要なものを省くことである


Computerを繋ぐコード類は美しくない
稀にしか使わないDVD-DriveやPort類は美しくない
携帯Computerにマウスは美しくない
携帯Computer専用のバッグは美しくない


そうして&lt;span style=&quot;font-weight:bold;&quot;&gt;MacBook&lt;/span&gt; Airのような美しい作品が生まれる


彼らは技術を美の実現のために用いる
利便性と美とは本来相対立する概念ではない
どこかにそれらの交点が存在する
しかし多くの企業がその交点を追い求めることなく
利便性を優先して美を大きく犠牲にしている
それがどれだけ企業価値を棄損し
顧客を失っているのかも分からずに


Appleはそのような交点を追い求める
数少ない情報機器メーカーの一つである
残念なことに
Geekたちにそれが理解されるのはもう少し先のことなのだろう

*p2*暴落は安心の証

株式は通貨と同様に信用をベースにした一社会システムである
信用の膨張や収縮によってその価値は変動する
株価の暴落は集中的な信用収縮の事象である


ここで見ておかなければならない事実は
そのようなときでも株式の売買は成立し
株式を売っている人たちがいる一方で
ほぼ同数の買っている人たちがいるということである


つまり市場参加者の少なくとも半数は
このような事態にあっても株式というものが
依然信用に足るシステムであると考えているということである
これは株式を持つものにとっては
まさに安心の材料と言えるものである


待っていれば喧嘩した妻はいずれ帰ってくるということなのだ

*p3*知的財産法の役割

知的財産主義は20世紀における壮大なる実験であり
社会主義と同様にそれは失敗であった
岩礁が波によって少しづつ削られていくように
知的財産主義はこれから長い終焉のステージに入っていく


しかしその終わりの先には
自由主義者たちが夢想したパラダイスは無く
大企業による一層の独占を生む社会があると思う
なぜなら現代の大企業にとって知的財産法は
独占を後押ししてくれるものではなく
むしろその活動の足かせに過ぎないものだからである


つまりこのパラドックスを理解し受け入れるのが現代の知恵であると思う

*p4*知性の価値
知性とは元来
肥大化した人間の脳の
ひまつぶしの結果に過ぎない


それは
時計の針が進んでいるように見えて
一歩も前に進んでいないのと同じようなものなのだ


それなのに残念なことに
現代では知性は
競争や他人を攻撃するための
武器になってしまっている
</body>
</day>
<day date="2008-01-24" title="">
<body>
*p1*常識は通じない！それが人間だ～けんかの原因と対策～
80円の商品を買うのに100円を出したら
10円しかおつりをもらえなかった
店主はそれでも平然としている
常識では理解ができない
だから店主に尋ねるか文句を言う
店主は何も答えない


常識に従って
100引く80は20でしょと説明する
それでも店主はおつりは10円だという
こうなると普通
人は腹を立てる
高々10円のことで腹を立てる
当たり前すぎることが通らないことに
いらだち腹を立てる


この理解の隔たりがけんかとなる
溝が埋まらないことでけんかをする
けんかは余計に溝を深くする
それが分かっていても
けんかをやめることはできない


暫くけんかを続けていると
レジ袋が10円掛かると目の前に書いてあることに気付く
最初にそれに気付くべきであったのかもしれないし
店主が説明すべきことだったのかもしれない


けんかとは多かれ少なかれ
こういった種類のものなんだろう


つまりけんかは
問題の大小とは全く関係がなく起こり
その原因は事象に対する両者の理解の隔たりにある
そして相手の考えが理解できればけんかは収まる
相手のそのときの行動が適切ではないと思っても
しょうがないとあきらめがつく
しかし相手の考えをあらかじめ理解することは難しい


だから結論として…
けんかが無くならない！
つまり
平和はやってこない！
</body>
</day>
<day date="2008-02-04" title="">
<body>
*p1*Gmail問題、暫定解決
Gmailのnew English versionでは
QuickSilverやGoogle Notifierからの投稿がうまくいかない
ただ開いたURLに '&amp;ui=1' を追加するとうまくいくことが分かった
ちょっとお手数ですが
やっぱりnew English versionを使いたいので
お手数をかけてみよう


参考：[http://groups.google.to/group/Gmail-Problem-solving/msg/deaa183694ac82d8:title=Cannot use mailto links to compose - Problem-solving | Google グループ]


関連：[http://d.hatena.ne.jp/keyesberry/20080119/p1:title=QuickSilver + gmailで問題発生そして解決 - hp12c]
</body>
</day>
<day date="2008-02-13" title="">
<body>
*p1*Intel Mac mini 7,500円で生還！～HDD換装レポート
[http://d.hatena.ne.jp/keyesberry/20080118:title=MacBook AirにMac miniも嫉妬]のときには
なんとか復活したHard Disk Driveも
結局その3週間後に力尽きた
購入して20月少し早くないか？


暫しの調査の後、Intel Mac miniのHDD換装についての素晴らしい投稿発見
[http://www.soledadpenades.com/2007/11/01/diy-replace-your-intel-mac-minis-hard-disk-drive/:title=DIY: Replace your intel mac mini's hard disk drive - soledad penad&amp;#233;s]
写真も豊富、動画まである！
どうやらPowerPC版よりも楽なようだ
よ～し、いってみようじゃあないか！


秋葉原にて[http://www.hitachigst.com/portal/site/jp/menuitem.4afe41246e0efb6f4415a653eac4f0a0/:title=日立GST Travelstar 5K250 120G]を7,500円ほどで購入し
お好み焼き返しとドライバセットで用意万端
[f:id:keyesberry:20080213175231j:image]


端から順にぎりぎりと開いていけば
[f:id:keyesberry:20080213175229j:image]


2つに割れるMac mini
[f:id:keyesberry:20080213175227j:image]


アンテナを下からプチッと外した後
四隅のねじと前にあるジャンパー外せば
またしても2つに割れるMac mini
[f:id:keyesberry:20080213175225j:image]


遂に登場HDD
壊れたばかりのHDD
[f:id:keyesberry:20080213175223j:image]


4つのねじを外してから
指先で後ろにずらせばほら取れた
[f:id:keyesberry:20080213175429j:image]


T字のクッション付け替えて
逆をたどれば元通り
[f:id:keyesberry:20080213175221j:image]


後はInstall Discに含まれる
ディスク・ユーティリティでパーティション切って完了だ
容量倍で速度も増して快適だ
もしも挑戦するのなら
くれぐれも自己責任で願います
</body>
</day>
<day date="2008-02-14" title="">
<body>
*p1*Folderを変えて気分転換でもするか
[http://www.ironicsoftware.com/leap/index.html:title=Leap]というのを使ってみるのもよさそうだけど…
もちろんLeopardにupgradeというのが正道なんだろうけど…


今しばらくはトラで行きますわ…
気分転換でもしながらね…
[f:id:keyesberry:20080213175759j:image]
</body>
</day>
<day date="2008-02-15" title="">
<body>
*p1*Gmail New Version Fixed!
[http://d.hatena.ne.jp/keyesberry/20080204:title=Gmail問題、暫定解決]のときには
GmailのEnglish New VersionではQuickSilverからの投稿がうまくいかないという問題を
URLに&amp;ui=1を追加することによって回避していたけど
今日、QuickSilverからGmailを作成してみたら
そのまま開けたので問題はFixされたようだ
よかったよかった


(追記)と、安心したのも束の間、2008/2/18現在、また再発中です
(追記)と、落胆したのも束の間、2008/2/21現在、またfixされてます
</body>
</day>
<day date="2008-02-18" title="">
<body>
*p1*マリオもピカチュウもブルーマンもヨーダもみんな走ったよ！～東京マラソン2008
[f:id:keyesberry:20080218164839j:image]
[f:id:keyesberry:20080218164840j:image]
[f:id:keyesberry:20080218164841j:image]
[f:id:keyesberry:20080218164914j:image]
[f:id:keyesberry:20080218164916j:image]
[f:id:keyesberry:20080218164915j:image]
[f:id:keyesberry:20080218164842j:image]
[f:id:keyesberry:20080218164837j:image]
</body>
</day>
<day date="2008-02-19" title="">
<body>
*p1*友人の定義
「暇だからたまには会わないか」
と誘えば
「今月は忙しいから来月にしてくれ」
と答え
「クラプトンのチケットがあるんだけど…」
と付け加えれば
「何とか都合をつける」
と平然と答える
それが現代における友人の定義なのだ


注）これは実話ではありません!
</body>
</day>
<day date="2008-02-21" title="">
<body>
*p1*不公平というときに
言うまでもなく世の中は不公平だ
自分というものを知覚したとき
少なくともその半分は
もう既に作られてしまっている


だけどそれを「不公平だよ」というときに
自分が世の中の不公平のヒエラルキの中の
どこらへんにいるのかちょっと考えてみる


1億3千万人の中の
どこに自分がいるのか考えてみる
66億人の中の
どこに自分がいるのか考えてみる


そうすれば
もしかしたら
その気持ちを少しは飲み込めるかもしれない

*p2*IQ lightは魔法のライト
[http://www.iqlight.com/:title=IQ light]という世にも美しい照明がある
デンマーク人デザイナーHolger Str&amp;#248;mによる作品だ
同じ形の樹脂製モジュールを組み合わせることによって
この美しい形が維持されている
モジュールの枚数および組み方を変えることによって
20以上の異なる形状を表現できるそうだ


リビングの照明がしばらく保留になっている
欲しい…
でも、ちょっと予算が足りない
少し調べてみる
すると…


このライトを手作りした人がいる！
[http://kaffe.exblog.jp/4725964:title=＊ほっこり北欧ノート＊ : ＊組み立て方＊]
型紙を作った人もいる！
[http://horirium.blog7.fc2.com/blog-entry-102.html:title=horirium | ＩＱライト]
組立説明書まである！
[http://www.iqlight.jp/:title=IQ light Japan]


これを僕はお告げと理解した！


まずはコピー用紙で試してみる
紙のカットは大変だけど組立は簡単だ
紙でも十分に美しかった
紙でもそれなりの強度になることを知った


ハンズでポリプロピレン(Pセーム)の白い板を二枚買う
450×580×0.38mmのサイズで一枚375円
表面にはうっすらと紋様が入っていて好適だ
[f:id:keyesberry:20080221170343j:image]


拡大してプリントアウトした型紙をPP板の上に糊で仮止めする
[f:id:keyesberry:20080221170342j:image]


一枚ずつに分離する
[f:id:keyesberry:20080221170339j:image]


糊付けが甘かったのでクリップを使おう
[f:id:keyesberry:20080221170338j:image]

切り出しが大変なので
奥さんを借り出す


なんとか30枚を切り出した
二人でこの作業に2時間くらい掛かったかな
[f:id:keyesberry:20080221170337j:image]


次は組立だ
30枚の円形ランプは5 5 10 5 5と組んでいく
表裏を間違えないで
モジュールの曲線部分が直線部分の上にくるように組んでいけば
むずかしくはない


まずは最初の5枚
[f:id:keyesberry:20080221170336j:image]


次も5枚
[f:id:keyesberry:20080221170335j:image]


次は10枚
[f:id:keyesberry:20080221170331j:image]


次は5枚
[f:id:keyesberry:20080221170329j:image]


そして最後の5枚を組んで
シェードが完成した
[f:id:keyesberry:20080221171009j:image]


今まで使っていたIKEA製のコードセットをそのまま使おう
これはたしか1,200円くらい
[f:id:keyesberry:20080221171008j:image]


コードの金属パイプが少し太いので
それに合わせて上の5枚のモジュールを加工する
[f:id:keyesberry:20080221171007j:image]


電球をつけて
その先端をシェードに収めれば…


完成だ！
あ～なんて美しいんだ！
[f:id:keyesberry:20080221171005j:image]


夜になって明かりをつければ
それはもう
息を飲むような美しさなんだ！
[f:id:keyesberry:20080221171004j:image]
[f:id:keyesberry:20080221170344j:image]


参考にさせてもらったサイトのみなさん
ありがとう！
</body>
<comments>
<comment>
<username>horirium</username>
<body>こんにちは、hoririumと申します。&lt;br&gt;うわーっ、びっくりするほど綺麗にできていますね！すごいです。&lt;br&gt;もしかして私の型紙で作ったんですか？切るのがたいへんだったでしょう？&lt;br&gt;私もPP板で作りましたが、切るのにギブアップでもう少し小さなものになりました。&lt;br&gt;これを見ていたら、またトライしてみたくなりました！！</body>
<timestamp>1203606862</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;hoririumさん&lt;br&gt;型紙、使わせていただきました。これがなければ作る気にはならなかったと思います。ありがとうございます！&lt;br&gt;PP板の厚さが0.38と比較的薄いものを購入できたので、腱鞘炎にならずにすみました。是非とも再トライしてください！</body>
<timestamp>1203635123</timestamp>
</comment>
<comment>
<username>なまえ</username>
<body>Mac mini の HDD 交換記事からたどり着きました。&lt;br&gt;&lt;br&gt;これを僕はお告げと理解した！&lt;br&gt;&lt;br&gt;（お告げはネットワークを伝わって伝染する！）&lt;br&gt;&lt;br&gt;近日作ってみます。あ、IKEA にも行かなくちゃ。</body>
<timestamp>1214391273</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;なまえさん&lt;br&gt;それはきっとお告げです。是非とも作ってみてください。</body>
<timestamp>1214432095</timestamp>
</comment>
<comment>
<username>トモ</username>
<body>こんな前の記事にコメントしてすいません！&lt;br&gt;&lt;br&gt;こちらで自作IQライトを見て、私もトライしてみました。&lt;br&gt;0.75mmのポリシートはあちこちで見つかるのですが、使われた0.38のPセームシートは発見できません（泣）&lt;br&gt;0.75mmって、結構な厚さに感じます。売っている照明器具でPP使用のモノはもっと薄いんですよね・・・（0.38くらい？）&lt;br&gt;0.75mmでつきすすむか、思案中です。&lt;br&gt;画用紙で造ったのは、すごくステキにできて、これだけでかなり満足してしまいました（笑）</body>
<timestamp>1264598095</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;トモさん&lt;br&gt;コメントどうもです&lt;br&gt;0.75でもきっといい作品ができると思います&lt;br&gt;でも相当困難な切り出しが予想されます..&lt;br&gt;もう少し薄いのが見つかるといいですね&lt;br&gt;ちなみに僕はこの当時新宿高島屋のハンズで購入しました&lt;br&gt;トモさんが無事完成されるのを祈っています:)</body>
<timestamp>1264627598</timestamp>
</comment>
<comment>
<username>silverbelch</username>
<body>オレは0.75mmで強行突破しましたｗｗ&lt;br&gt;型紙を1つだけ作りあとはトレースするやり方で&lt;br&gt;切り出しは1人で2時間でしたｗ&lt;br&gt;強度が出て組むのも少し苦労しますｗ&lt;br&gt;&lt;br&gt;青と白の2色コラボですｗ&lt;br&gt;&lt;br&gt;あとは明るさだけかと</body>
<timestamp>1323370722</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt; silverbelchさん&lt;br&gt;強行突破ww</body>
<timestamp>1323384237</timestamp>
</comment>
</comments>
</day>
<day date="2008-02-25" title="">
<body>
*p1*&amp;#8984;(command)+タイトルをクリック
偶然出現！こんな技知らなかったよ！


Folderでやれば親ディレクトリにいける！
[f:id:keyesberry:20080225184613p:image]


Applicationでやればファイルの場所が分かる！
[f:id:keyesberry:20080225184610p:image]


Browserでやればトップに戻れる！
[f:id:keyesberry:20080225184928p:image]


常識？
</body>
<comments>
<comment>
<username>hp15c</username>
<body>おお！これは便利だ。有用な情報をありがとう！</body>
<timestamp>1259329032</timestamp>
</comment>
</comments>
</day>
<day date="2008-03-02" title="">
<body>
*p1*玄関の蛍光灯を外してIQ Lightを付けようじゃあないか！
味を占めまして…


ハンズでPP板とコード類を買い足して


今度は 4 4 8 4 4 で


こんな形、でました
[f:id:keyesberry:20080302175145j:image]


カップに浮かぶ IQ Lightというのも乙なもので…
[f:id:keyesberry:20080302175142j:image]


関連：[http://d.hatena.ne.jp/keyesberry/20080221/p2:title=IQ lightは魔法のライト - hp12c]
</body>
</day>
<day date="2008-03-03" title="">
<body>
*p1*人生は本質的に切ないものなんだよ
人間は社会的生き物であるから
人に仕合せを与えられれば
それがフィードバックされ
自らも仕合せになれるという
(id:fromdusktildawn:20080302)


しかし人の価値は多様であり
100人の仕合せは
同時に1人の不仕合わせになり得る


仕合せの実感は
その数量で決まるものでも
大きさで決まるものでも
比重で決まるものでもない


100の好意的なフィードバックは
1の悪意のフィードバックで打ち消されることもある
100の他人の仕合せは
1の身内の不仕合せに譲る


仕合せの実感には継続的なイベントが必要な一方で
不仕合わせは単一のイベントで深く心に刻まれる
仕合せの継続が失われれば
それは儚くも消えていくのに
一度の不仕合わせは
いつまでもいつまでも心にこびりついて消えてくれない


そこには明らかなる脳の非対称性が存在する
人間の無意識は常に不仕合わせを多く見積もる
そして人間の意識はそれを克服できない


だから人生というものは
本質的に切ないものなんだと思う
</body>
</day>
<day date="2008-03-05" title="">
<body>
*p1*Cocoaアプリ用Rubyのロードパスを設定しよう
requireでロードされるライブラリファイルは
Rubyのロードパスに置かれる必要がある


現在のロードパスは以下で調べられる
&gt;&gt;
ruby -e 'puts $:'
&lt;&lt;


独自のパスを追加したいときは
環境変数RUBYLIBに設定する
例えば、.zshrcに以下を記述する
&gt;&gt;
export RUBYLIB=&quot;$HOME/mylib&quot;
&lt;&lt;


CotEditorでは編集中のファイルに対して
Rubyスクリプトを実行できるけど
そのスクリプトで独自パスにあるライブラリをrequireするときは
上記の設定は生きない


CotEditorなどのCocoaアプリでRubyのロードパスを通すには
~/.MacOSX/environment.plistでRUBYLIBにパスを設定する必要がある
environment.plistが存在しなければ作成する
&gt;&gt;
&lt;key&gt;RUBYLIB&lt;/key&gt; 
&lt;string&gt;~/mylib&lt;/string&gt;
&lt;&lt;
設定を有効にするには再ログインが必要となる
</body>
</day>
<day date="2008-03-08" title="">
<body>
*p1*人生力を判断する６つのファクターを考えてみた
ググってみたら「人生力」なる言葉があるらしい
ここではこれを「人生を生き抜く力」と定義して
以下の等式を考えてみたよ
&gt;&gt;
人生力 ＝資産×スキル×学ぶ意欲×健康×生活の規律×1/年齢
&lt;&lt;
各ファクターの重みづけはできないので
客観的評価はできないけれど
主観的評価はできそうだ
5年前の自分と現在の自分の変化を評価して
人生力がアップしていれば
この5年には意味があったと言えるのかもね
</body>
</day>
<day date="2008-03-13" title="">
<body>
*p1*あとから一行追加したいときもある
TextMateやCotEditorでテキストを打っていて
カーソル行の一行前にテキストを追加したい
という状況がよくある


OSXのショートカット表をよく見たら
&gt;&gt;
&amp;#8963;o(ctrl + o) : split the current line
&lt;&lt;
というのがあるのを知った
これはカーソル位置で文を分割するもので
カーソルの移動を伴わないようだ


だからこのショートカットを行の先頭で実行すれば
上記の目的は一応達成できる
でもこれを少し直して DefaultKeyBindings.dict に登録すれば
もう少し便利になる
&gt;&gt;
	&quot;^O&quot; =	(moveToBeginningOfLine:, insertNewlineIgnoringFieldEditor:, moveBackward:);
&lt;&lt;
こうすればカーソルが行の先頭になくても一行追加ができる
&amp;#8963;o(ctrl + o) はそのまま残して &amp;#8963;O(ctrl + shift + o)に割り当てた


そういえばTextMateでRubyのコードを書いていて
いつも不便に思っていたのが
&amp;#8963;H で一文字削除のCocoaアプリ・デフォルトキーバインドが
他のコマンド(Documentation for word)と衝突して使えないことだ
ついでにRuby BundleとShellScript Bundleの&amp;#8963;Hを&amp;#8963;&amp;#8984;Hに変えることによって
この問題も解決できた


参考：[http://www.hcs.harvard.edu/~jrus/Site/System%20Bindings.html:title=Cocoa Text System - Default System Key Bindings]
関連：[http://d.hatena.ne.jp/keyesberry/20070312/p4:title=Macのキーバインドをいじる - hp12c]


*p2*ThinkというのもThinkしてみよう！
[http://d.hatena.ne.jp/t_yano/20080310/1205164488:title=10倍集中できる作業環境をMacに構築する方法 - 矢野勉のはてな日記]で紹介されていた
WriteRoomというエディタは以前に試したことがあった
でも自分の気に入っているTextMateやCotEditorを
やはり使いたいという欲求がある


そこでもう一つ紹介されていた[http://drikin.com/spiritedaway/:title=Sprited Away]というのを試してみる
なかなかいい感じだ
複数のアプリケーションが重なっているのは好きじゃないので
普段使いにはよさそうだ
ただバックグランドは明るいままなので
WriteRoomほどには集中感が得られない


そこでThinkというフリーウェアはどうだろうか
[f:id:keyesberry:20080313185145p:image]
[http://freeverse.com/apps/app/?id=7013&amp;view=overview:title=Think]


これを使えば設定したアプリケーション以外は
黒い背景の後ろに消える
[f:id:keyesberry:20080313185548p:image]


集中したいときにこのアプリケーションを立ち上げて
目的のアプリケーションを選択すればいい
[f:id:keyesberry:20080313185143p:image]


一時的に他のアプリケーションを使いたいときは
&amp;#8984;+TabするかDockから選ぶ


集中作業に戻るときは
&amp;#8963;&amp;#8984;(ctrl + command)+returnを押す


設定するアプリケーションを変えたいときや
背景の濃度を変えたいときやThinkを終了するときは
左上のControl Panelで行えばいい
</body>
</day>
<day date="2008-03-16" title="">
<body>
*p1*日割りよりも時間割りだ！

ものごとを継続させたいと思うなら
日割りでやってはいけない


日割りでやるとリズムが取れない
リズムが取れなければ
継続ができない


だからものごとを継続させたいと思うなら
時間割でやるべきだ


毎日歯を磨くように
毎日同じ時間に同じことをする
その習慣の積み重ねが
時間を経ると偉大なものになる


そんな当たり前のことにやっと気付いた
</body>
</day>
<day date="2008-03-19" title="">
<body>
*p1*Ruby、君はオブジェクト指向なんかじゃない、謎の生命体試行錯誤だ！
いつものようにベッドの中で体がまだ寝ている間に
僕の意識は目覚めた
昨日寝がけに聴いたMr.ChildrenのHEROの歌詞が
まだ頭の中を回っていた
&gt;&gt;
例えば誰か一人の命と
引き換えに世界を救えるとして
僕は誰かが名乗り出るのを待っているだけの男だ…
&lt;&lt;
「いったいぜんたい、どんな状況なんだ？一人の命と引き換えに世界を救えるって！」
「環境破壊の問題でもなさそうだし」
「宇宙人でも襲ってきたんだろうか？」
「まさか」


朝から解決できそうにない疑問が
僕の上にまた積まれた
寝てる間に問題解決ができる人がいるって話を聞いたことがあるけど
こっちはいつもその逆だ


「さて無駄な思索はやめてそろそろ起きようか」
心の中でそう言って体を起こそうとしたちょうどその時
家の外で僅かながらそれでも確実に何かが落ちた音がした
「何だろう？」


気になって外に出て音がしたほうに行ってみると
そこにはまるい石のような
それでいてあきらかに石ではない
不思議な物体が落ちていた


表面は少し赤み掛かっていて
見る角度によってはきらきらと光る
宝石といえばそうだが
それほど高価そうにも見えない


「いったいなんなんだろう？」


空から降ってきたんだろうか？
空を見上げてみてもそこに穴なんか開いていないし
どこから来たのか皆目見当がつかない
でも確かにどこからか降ってきたんだ


試しに近くにある小枝を拾って突いてみた
「 … 」
なんの反応もない
叩いたり蹴っ飛ばしたりもしてみたけど
結果は同じだった


顔を近づけてその外側をよく観察してみると
その表面に「1」という数字が彫ってあるのに気がついた
それだけが差し当たりこの不思議な物体から得られる情報だった


僕はその不思議な物体を部屋に持ち帰って
少し調べてみることにした
「さてどうするか」
腕組みをしながら少し考えて僕は
馬鹿みたいな話だけど
謎の物体に話しかけてみることにした
&gt;&gt;
 $ 1.hello!
  # 謎の物体「1」をちょんと突いて「hello!」と話しかけるのをこう表記しよう
&lt;&lt;
すると、驚いたことにその物体が何かしゃべったのだ！
&gt;&gt;
 $ NoMess...
&lt;&lt;
「な、なんていったんだいま？」
おそるおそる僕は同じ質問を繰り返してみた
&gt;&gt;
 $ 1.hello!
&lt;&lt;
すると今度は確かにはっきりとした口調で答えた
&gt;&gt;
 $ NoMethodError: undefined method `hello!' for 1:Fixnum
&lt;&lt;
僕の問い掛けに何だか分からないけどその物体は答えた


生きてる！生きてるんだ！
こいつは単なる物体なんかじゃなくて
意思を持ったある種の生命体なんだ！
僕はそう確信した


その答えの意味はいまのところ僕にはよく分からないけど
少なくとも彼 ー生きてるんだからそう呼んでもいいだろ？ー は
僕のhello!に答えてhello!と返してきたんだ！
数字の「1」と彫られた石のようで石ではない謎の生命体と
最初にコンタクトした人類
それは僕なんだ！そして今がその歴史的瞬間なんだ
まさに僕は「未知との遭遇」の場面に遭遇してしまった


さてこうなったら彼の答えを分析してみようじゃないか
何しろ僕が最初の人類なんだから
&gt;&gt;
  NoMethodError: undefined method `hello!' for 1:Fixnum
&lt;&lt;
英語はあまり得意じゃないなあ
「NoMethodError:」ってのは「方法エラーなし」…かな？
「undefined method」ってのは「未定義方法」？


ん？何となく分かってきたぞ君の言いたいことは…
…
なるほど…
わかったぞ！
&gt;&gt;
  方法に問題なし: 規定されたやり方じゃないけど。1:Fixnum君`hello!' 
&lt;&lt;
だろ？君の答えは！
おそらく僕の問い掛け方が君たちのルールに従っていなくて
一瞬戸惑ったけどまあ意味は分かるので受け入れてくれたんだね
君は僕の名前が分からないので
差し当たり1:Fixnumを僕の名前としたんだね


あっ待てよ
そうかちがうぞ
FixnumはFixed numberの略だね？つまり固定番号だ
そうか君が最初に出会った人類が僕だから
君は僕に固定番号の1を割り当てたんだね？
そうだね？すごいよ君！


今度は名前を聞いてみようじゃないか
&gt;&gt;
 $ 1.name?
&lt;&lt;
あれ？さっきと同じ答えじゃないか
&gt;&gt;
 $ NoMethodError: undefined method `name?' for 1:Fixnum
&lt;&lt;
でもよく見ると`hello!'のところが`name?’になっている


なあんだ
わかったぞ
彼はただこちらの問い掛けに
おうむ返しをしてただけだったんだ！


それじゃあこうしよう
君らへの規定のやり方ーmethodーとやらを教えてもらおうじゃないか
&gt;&gt;
 $ 1.method
&lt;&lt;
ん？今度はなんだ？
&gt;&gt;
 $ ArgumentError: wrong number of arguments (0 for 1)
&lt;&lt;
「議論に問題あり: 議論の数が違う(0じゃなくて1)」ってこと？
君たちのやり方が分からないから聞いてるのにつれないなあ
そうか
もしかしたら複数形にしろってことだね？
&gt;&gt;
 $ 1.methods
&lt;&lt;
おおっ！ちょ、ちょっとまって！
もっとゆっくり！今紙に書き取るから！
&gt;&gt;
 $ =&gt; [&quot;%&quot;, &quot;inspect&quot;, &quot;&lt;&lt;&quot;, &quot;singleton_method_added&quot;, &quot;&amp;&quot;, &quot;clone&quot;, &quot;&gt;&gt;&quot;, &quot;method&quot;, &quot;round&quot;, &quot;public_methods&quot;, &quot;instance_variable_defined?&quot;, &quot;divmod&quot;, &quot;equal?&quot;, &quot;freeze&quot;, &quot;integer?&quot;, &quot;chr&quot;, &quot;*&quot;, &quot;+&quot;, &quot;to_i&quot;, &quot;methods&quot;, &quot;respond_to?&quot;, &quot;-&quot;, &quot;upto&quot;, &quot;between?&quot;, &quot;prec&quot;, &quot;truncate&quot;, &quot;/&quot;, &quot;dup&quot;, &quot;instance_variables&quot;, &quot;__id__&quot;, &quot;modulo&quot;, &quot;object_id&quot;, &quot;succ&quot;, &quot;|&quot;, &quot;eql?&quot;, &quot;zero?&quot;, &quot;~&quot;, &quot;id&quot;, &quot;to_f&quot;, &quot;singleton_methods&quot;, &quot;send&quot;, &quot;prec_i&quot;, &quot;taint&quot;, &quot;step&quot;, &quot;to_int&quot;, &quot;frozen?&quot;, &quot;instance_variable_get&quot;, &quot;__send__&quot;, &quot;^&quot;, &quot;instance_of?&quot;, &quot;remainder&quot;, &quot;to_a&quot;, &quot;+@&quot;, &quot;nonzero?&quot;, &quot;-@&quot;, &quot;type&quot;, &quot;**&quot;, &quot;floor&quot;, &quot;&lt;&quot;, &quot;protected_methods&quot;, &quot;&lt;=&gt;&quot;, &quot;instance_eval&quot;, &quot;==&quot;, &quot;prec_f&quot;, &quot;quo&quot;, &quot;&gt;&quot;, &quot;display&quot;, &quot;===&quot;, &quot;downto&quot;, &quot;id2name&quot;, &quot;size&quot;, &quot;instance_variable_set&quot;, &quot;kind_of?&quot;, &quot;abs&quot;, &quot;extend&quot;, &quot;&gt;=&quot;, &quot;next&quot;, &quot;to_s&quot;, &quot;&lt;=&quot;, &quot;coerce&quot;, &quot;hash&quot;, &quot;ceil&quot;, &quot;class&quot;, &quot;tainted?&quot;, &quot;=~&quot;, &quot;private_methods&quot;, &quot;div&quot;, &quot;nil?&quot;, &quot;untaint&quot;, &quot;times&quot;, &quot;to_sym&quot;, &quot;[]&quot;, &quot;is_a?&quot;]
&lt;&lt;
これだね
これが君たちの規定のやり方ーmethodーなんだね？


よし早速そのやり方に倣って問い掛けることにしよう
さてどれにしようか…93個もあるのか…
君の名前を知りたいけどそれを示すようなものはないかな…
これはどう？
&gt;&gt;
 $ 1.id
&lt;&lt;
今度はなんだ？
&gt;&gt;
 $ warning: Object#id will be deprecated; use Object#object_id
=&gt; 3
&lt;&lt;
「警告: 物体#idには反対である。物体#object_idを使いなさい」
おいおい警告って物騒なこというなよ
反対するならリストから外しておいてくれよな
わかったよobject_idでいいんだね？
&gt;&gt;
 $ 1.object_id
&lt;&lt;
こんどはうまくいったぞ
&gt;&gt;
 $ =&gt; 3
&lt;&lt;
そうか君の名前はいまだ分からないけど
君の物体idーおそらく社会保障番号のようなものーは3ということだ
リストをよく見ると__id__というのもあるな
&gt;&gt;
 $ 1.__id__
&lt;&lt;
これも同じ結果が出た
&gt;&gt;
 $ =&gt; 3
&lt;&lt;
数字の「1」って書いてあるのにidが3って変なヤツだな君は
でもこれで少し君らのことがわかったよ
君の仲間がまだすくなくとも二人(id=1, 2)はいるってことだ


さて君の社会保障番号が分かったので次は何を教えてもらおうか
年齢とか性別とかどこから来たとかそういう情報はないのかな
classというのは何だろう？彼の職務上の階級か何かかな
聞いてみよう
&gt;&gt;
 $ 1.class
&lt;&lt;
&gt;&gt;
 $ =&gt; Fixnum
&lt;&lt;
あれ？Fixnumって
さっき君は僕のことを固定番号:1って呼んだよね？
もしかしてあれは君自身のことだったの？
そうか君こそが固定番号:1なんだ！
そりゃそうだ「1」って彫ってあるんだから
君は数字の「1」以外ではありえない


そうすると最初に君が答えた
&gt;&gt;
 $ NoMethodError: undefined method `hello!' for 1:Fixnum
&lt;&lt;
というのは
&gt;&gt;
 方法に問題なし: 規定されたやり方じゃないけど。1:Fixnum君`hello!' 
&lt;&lt;
なんかじゃなくて
&gt;&gt;
やり方無しのエラー: `hello!'は私こと固定番号:1に未規定のやり方です
&lt;&lt;
ということなんだ


つまり彼、固定番号:1君は
どこかの誰か(あるいは神)によって創造されて
93個のやり方を教え込まれ
そのやり方に対する問い掛けだけに答えるよう教育されている
彼がいったい何のために存在するのか
現時点では皆目検討がつかないけれども
特殊な教育を受けた未確認の生命体であり
何らかの目的のためにこの地球上に送り込まれた
そういうことなんだろう


さて今日はこれくらいにして
これまでの調査でわかったことを記録しておくとしよう
+名称は「固定番号:1」
+物体#idは「3」。従って他にも仲間がいると思われる
+職務階級は「Fixnum(固定番号)」
+今のところ向こうからアクションを起こすことはなく、こちらからの問い掛けに答えるのみである
+93個の規定のやり方(method)で答えうる。既に6個を試してみた
+オウムのようにこちらから新たなやり方を教え込むことができるかは不明
+こちらが誰であるかということの認識が彼にあるのかは不明。おそらくここがどこであるかということも含めて認識がないのではないだろうか
</body>
</day>
<day date="2008-03-21" title="">
<body>
*p1*Ruby、君はオブジェクト指向なんかじゃない、謎の生命体試行錯誤だ！
やはり僕が話しかけない限り
謎の生命体「固定番号:1」はなにもしない
昨日一日彼を観察してわかったことだ


僕が寝ている間に動き出して
僕を拘束し
遠い彼らの惑星に連れ出す


そんなことは起こらなかった


とはいっても僕には
そのような恐怖心すら正直起きなかったのだ
むしろ昨日は
ある種の安らぎのようなものを感じて眠りにつくことができた


それはもしかしたら
昨日の彼との短い対話から
こちらが彼らのやり方に沿って正しく問い掛けをすれば
揺るぎのない回答を即座に返してくることから得られる
ある種の信頼に基づく結果なのかもしれない


いずれにしても僕は現在
彼「固定番号:1」に昨日以上に強く興味を引かれている


では早々彼の分析を始めようじゃないか


昨日彼らのやり方ーmethodーには93種類あるということがわかった
&gt;&gt;
$ 1.methods
&lt;&lt;
&gt;&gt;
$ =&gt; [&quot;%&quot;, &quot;inspect&quot;, &quot;&lt;&lt;&quot;, &quot;singleton_method_added&quot;, &quot;&amp;&quot;, &quot;clone&quot;, &quot;&gt;&gt;&quot;, &quot;method&quot;, &quot;round&quot;, &quot;public_methods&quot;, &quot;instance_variable_defined?&quot;, &quot;divmod&quot;, &quot;equal?&quot;, &quot;freeze&quot;, &quot;integer?&quot;, &quot;chr&quot;, &quot;*&quot;, &quot;+&quot;, &quot;to_i&quot;, &quot;methods&quot;, &quot;respond_to?&quot;, &quot;-&quot;, &quot;upto&quot;, &quot;between?&quot;, &quot;prec&quot;, &quot;truncate&quot;, &quot;/&quot;, &quot;dup&quot;, &quot;instance_variables&quot;, &quot;__id__&quot;, &quot;modulo&quot;, &quot;object_id&quot;, &quot;succ&quot;, &quot;|&quot;, &quot;eql?&quot;, &quot;zero?&quot;, &quot;~&quot;, &quot;id&quot;, &quot;to_f&quot;, &quot;singleton_methods&quot;, &quot;send&quot;, &quot;prec_i&quot;, &quot;taint&quot;, &quot;step&quot;, &quot;to_int&quot;, &quot;frozen?&quot;, &quot;instance_variable_get&quot;, &quot;__send__&quot;, &quot;^&quot;, &quot;instance_of?&quot;, &quot;remainder&quot;, &quot;to_a&quot;, &quot;+@&quot;, &quot;nonzero?&quot;, &quot;-@&quot;, &quot;type&quot;, &quot;**&quot;, &quot;floor&quot;, &quot;&lt;&quot;, &quot;protected_methods&quot;, &quot;&lt;=&gt;&quot;, &quot;instance_eval&quot;, &quot;==&quot;, &quot;prec_f&quot;, &quot;quo&quot;, &quot;&gt;&quot;, &quot;display&quot;, &quot;===&quot;, &quot;downto&quot;, &quot;id2name&quot;, &quot;size&quot;, &quot;instance_variable_set&quot;, &quot;kind_of?&quot;, &quot;abs&quot;, &quot;extend&quot;, &quot;&gt;=&quot;, &quot;next&quot;, &quot;to_s&quot;, &quot;&lt;=&quot;, &quot;coerce&quot;, &quot;hash&quot;, &quot;ceil&quot;, &quot;class&quot;, &quot;tainted?&quot;, &quot;=~&quot;, &quot;private_methods&quot;, &quot;div&quot;, &quot;nil?&quot;, &quot;untaint&quot;, &quot;times&quot;, &quot;to_sym&quot;, &quot;[]&quot;, &quot;is_a?&quot;]
&lt;&lt;
今日はどれを試してみようか
彼のことがもう少しわかるようなもの…


いいのがあった
&gt;&gt;
$ 1.size
&lt;&lt;
さあ答えてくれたまえ
&gt;&gt;
$ =&gt; 4
&lt;&lt;
あれ？1じゃないのか
sizeといっても身長とか洋服のサイズとかではなさそうだな
でもまあsizeというんだから
それは彼自身のサイズであって
彼の存在が4だけ空間を占有しているってことなんだろう
僕が予想するに「固定番号:2」の空間占有量は8だな


おっ
nextっていうのがあるぞ
&gt;&gt;
$ 1.next
&lt;&lt;
&gt;&gt;
$ =&gt; 2
&lt;&lt;
って
君に聞くまでもないじゃないか
1の次は2に決まってる
まあ確かに暗闇で君に問いかけるとしたら
それも意味があるかもしれないな
君の星じゃ1の次は3なんてことがあるかもしれないし


いいことに気がついた
&gt;&gt;
$ 1.next.size
&lt;&lt;
こうすれば「固定番号:2」のサイズもわかるんじゃないか
&gt;&gt;
$ =&gt; 4
&lt;&lt;
ほら！


君の体をちょん(.)と突いて問い掛けるやり方の応用だよ
ちょんちょんってね
僕はchain smokerならぬchain talkerだ
でも僕の予想は外れた
隣のヤツも同じサイズだった


なるほど
僕はここで極めて重大なことに気がついたよ
要するに君は
君の隣のヤツの情報も持ってるってことだ！
試してみよう
&gt;&gt;
$ 1.next.__id__
&lt;&lt;
ほらね？
&gt;&gt;
$ =&gt; 5
&lt;&lt;
&gt;&gt;
$ 1.next.class
&lt;&lt;
&gt;&gt;
$ =&gt; Fixnum
&lt;&lt;
君の隣のヤツは「固定番号:2」であり
その社会保障番号は5だ
職務階級は同じFixnum
どうやら社会保障番号4は欠番になっているようだ


そうか
同じ職務階級の隣の席のヤツが「固定番号:2」なんだな
だんだんイメージが湧いてきたぞ


ちょちょっと待て
もしかしたら
&gt;&gt;
$ 1.next.next
&lt;&lt;
あ！
&gt;&gt;
$ =&gt; 3
&lt;&lt;
じゃあこれは？
&gt;&gt;
$ 1.next.next.next.next.next.next.next.next.next
&lt;&lt;
&gt;&gt;
$ =&gt; 10
&lt;&lt;
じゃあ
&gt;&gt;
$ 1.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next
&lt;&lt;
来たぞ！
&gt;&gt;
$ =&gt; 100
&lt;&lt;
固定番号:100の職務階級は…
&gt;&gt;
$ 1.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.class
&lt;&lt;
&gt;&gt;
$ =&gt; Fixnum
&lt;&lt;
すごい！
隣のヤツのだけじゃあないんだ！
君が持ってるのは！
脳みそがどこにあるのかもわからない君の
その小さな体のどこに
そんな大量の情報が埋め込まれてるんだ！


ここまでの調査からするとこういうことだな
つまり
職務階級Fixnumには
君らのような固定番号の連中がうじょうじょいる
そしておそらく上官だか上司の命令に従って
いつもは一列に順序正しく並んで座っている
一人分の座席スペースは4だ
君の右隣は「固定番号:2」であり
その隣は3だ
君ら一人一人には飛び番だが社会保障番号が与えられ
独立した活動が保障されている


君の左隣は間違いなく0なんだろう
しかしどういうわけかnextはあるのに
previousとかbeforeとか
前のヤツを調べるmethodがない
ここにも階級的な序列があって
上位のものの情報が覗けないようになっているのかもしれない


今succというmethodを見つけたぞ(suckでなくて何よりだ)
&gt;&gt;
$ 1.succ
&lt;&lt;
やっぱり
&gt;&gt;
$ =&gt; 2
&lt;&lt;
succはsuccessorつまり
「継承者」だ
1は2を自分の継承者に選んでおり
その行動に責任を持つ
1に何かあったときには
2がその職責を継承する
1はさらに2の継承者である3の行動の責任をも持つ
逆に1は0の継承者であり
0の行動に責任を持つ必要はないが
0に何かあったときには
その職責を継承する
そういうシステムなんだろう
社会保障番号に欠番があるのは
そこにいたものの身に何かがあったんだろう
それで合点が行く


さてこれぐらいにして
これまでの調査でわかったことを記録しておくとしよう
+職務階級Fixnumには固定番号:1と同種の生命体がおそらく無数にいる
+各固定番号間にも階級が存在し上位のものは下位のものの情報をすべて持っている
+chain talker方式で下位のものの情報を聞き出すことができる
+一方で下位のものは上位のものの情報を見ることが禁止されている
+各固定番号は固有の社会保障番号を持っておりこれは上位のものがいなくなっても変わることはない
</body>
</day>
<day date="2008-03-23" title="">
<body>
*p1*Ruby、君はオブジェクト指向なんかじゃない、謎の生命体試行錯誤だ！
昨日の調査では謎の生命体「Fixnum:1」ー固定番号:1と呼ぶのは止めたこっちのほうが謎めいた名前でいいだろ？ーに関する
いくつかの貴重な発見があった
その中でも特に重要と思われるものは次の２点だ
+「Fixnum:1」が他のFixnumら ーつまりFixnum:2から少なくともFixnum:100まで ーの情報をすべて持っているということ
+問い掛けを繰り返すことによって他のFixnumの情報を取得することができるということ


僕は昨日ベッドに入ってからも
これらのことが気になってなかなか寝つけなかった
特に最初の点について
彼がその外観からして
他のものの情報をすべて持っているというのは
僕の常識からみてどうにも納得がいかない
外観で人を判断しちゃいけないってことは僕もよくわかっている
ー子供のときそのことで随分とこっぴどく叱られた記憶があるー
また僕の偏狭な常識でこの問題を判断するのもどうかと思う
けど理解というものはそれを自分の常識の中に持ち込めないと
先に進めないというのもまた事実なんだよ


待てよ…
そうか！
彼が持ってるんじゃないんだ
僕が彼に問い掛けたときに
彼もまた誰かにそれを問い掛けてるんだ
彼は彼の仲間と交信する手段を持っている！
そうに違いない！


この仮説が正しいとすると新たな２つの疑問が首をもたげる
いったい誰と？
そしてどのようにして？
誰と交信しているかという問題に関しては
２つのことが考えられるだろう
１つは当然nextのFixnum:２だ


例えば僕がFixnum:1に
&gt;&gt;
$ 1.next.__id__
&lt;&lt;
としたときに
Fixnum:1は自分ではその問いに答えられないので
1.next =&gt;2に基づいてFixnum:2との交信を開始する
そして彼に以下のようにしてその問いを渡す
&gt;&gt;
$ 2.__id__
&lt;&lt;
Fixnum:2はFixnum:1からのこの問い掛けに対して
&gt;&gt;
$ =&gt; 5
&lt;&lt;
を得てこれを返答する
Fixnum:2からのこの返答を受けたFixnum:1は
これを僕に返答する
こういった仕組みだ


ただこの方式には一つ重大な欠点がある
昨日僕がやったように
Fixnum:1に対してFixnum:100の階級を問い掛けた場合
上の面倒なプロセスを100回も繰り返さなきゃならない
しかももし途中の誰かがさぼったり
不在にしてしたら
この方式ではうまく情報が伝達しない
人間の社会じゃ
そんなシステム設計をしたヤツは即刻クビだ
それとも彼らの社会では「もし…」なんて起きないんだろうか？


もう一つ交信相手として考えられるのは
彼の上官だ
Fixnum:1は職務階級Fixnumに属している
そこで彼はその職務階級に則した特別な訓練を受けている
その訓練を彼らに施しているものが当然存在するはずだ
この場合の情報伝達プロセスは次のようになるだろう
僕がFixnum:1に
&gt;&gt;
$ 1.next.__id__
&lt;&lt;
としたとき
Fixnum:1は自分ではその問いに答えられないので
彼の上官との交信を開始する
そして次の問いを投げる
&gt;&gt;
$ next.__id__
&lt;&lt;
上官は職務階級Fixnumに属するすべての固定番号の情報を保持しており
従ってFixnum:1のnextがFixnum:2であると直ぐにわかる
上官はFixnum:2の社会保障番号を保持しているかもしれないが
保持していないとすればそのときはFixnum:2と交信して問い合わせればいい
こうして得られたFixnum:2の社会保障番号5は
上官からFixnum:1に伝えられ
Fixnum:1はこれを僕に返答する


こういう連絡系統にしておけば
仮に僕がFixnum:1にFixnum:100の情報を問いかけたとしても
彼とFixnum:100との間に介在するのは信頼のおける上官一名だけだ
その結果情報伝達の確実性とスピードは飛躍的に向上するだろう


まあいずれにしても
現段階ではそれを解明する手段を僕は持ちえないし
それがわかったところでこの壮大な謎の解明には
あまり役立ちそうにない


いや
ちょっと待てよ
例のchain talkingを使えば
上官の情報が得られるかもしれないぞ
上官の情報が得られればそれが解決の糸口になるかもしれない


早速やってみよう
おそらくこれが上官にたどり着く問い掛けだろう
&gt;&gt;
$ 1.ceil
&lt;&lt;
あれ？
&gt;&gt;
$ =&gt; 1
&lt;&lt;
ceilというのは当然「天井:ceiling」という意味だ
nextが同級の隣のヤツを指すのだから
ceilは天井ーつまり上ーのヤツー上官ーを指すmethodだろう普通
ちなみにfloorというmethodもあるから
これはceilと対になっていて
下のヤツー下官ーを指すものだと思っていた
&gt;&gt;
$ 1.floor
&lt;&lt;
違うのか？
&gt;&gt;
$ =&gt; 1
&lt;&lt;
いずれも1
自分自身とはいったいどういうことなんだ？


何か他に手だてはないか…


そうだ
職務階級classの方から攻めてみよう
これは有効だろうか？
&gt;&gt;
$ 1.class.__id__
&lt;&lt;
あっ！
&gt;&gt;
$ =&gt; 100420
&lt;&lt;
社会保障番号が返ってきたぞ！
これはどういう意味なんだ？
職務階級に社会保障番号があるって…


そうか
Fixnum:1の職務階級を表すFixnumは
それ自身が上官のことなんだ！
つまりこれは学級で
Fixnum先生のクラスをFixnumと呼ぶようなものだ
ーたぶん上官に愛着を持ってもらおうという意図からー
そういうことに違いない！


よしこうなったら
Fixnum上官のことを少し調べてみようじゃないか
まずは彼の職務階級 ーそれは同時に彼の上官を指すー を聞いてみよう
&gt;&gt;
$ 1.class.class
&lt;&lt;
どうだ
&gt;&gt;
$ =&gt; Class
&lt;&lt;
これは？
問い掛けに失敗したのか？
こちらの問い掛けが戻ってきているようだ


いや違う！
よく見ると大文字から始まっている
classじゃなくてClassだ
つまり
Fixnum上官の上官はClass上官なんだ！


こうなると更に上を調べたくなるのが人情ってもんだ
それっ
&gt;&gt;
$ 1.class.class.class
&lt;&lt;
あれれ？
&gt;&gt;
$ =&gt; Class
&lt;&lt;
Class上官の上官はClass上官？
これはおかしいな
もういっちょいって見るか
&gt;&gt;
$ 1.class.class.class.class
&lt;&lt;
&gt;&gt;
$ =&gt; Class
&lt;&lt;
なんだ行き詰まっちゃったな…


そうか
行き詰まりなんだよ！
つまりClass上官が最上位の上官
最高司令官なんだ！
最高司令官Classの下にFixnumがいる
そしてFixnumの下に彼Fixnum:1がいる
なるほど
割とフラットな組織だな君たちの組織は


命令系統がわかったところで
Fixnum上官のことに戻ろう
彼のサイズはいくつかな？
&gt;&gt;
$ 1.class.size
&lt;&lt;
これはいったい？
&gt;&gt;
$ NoMethodError: undefined method `size' for Fixnum:Class
&lt;&lt;
どういうことだ？！


なるほど…そういうことか
この答えの可能性は２つある
１つはFixnum上官は女性であるということだ
女性特に年ごろの女性はサイズを聞かれるのを嫌う
したがって回答を拒否するということは当然にありうるし
僕が最初からFixnum上官が女性であることがわかっていれば
こんな失礼な質問は投げなかった
そうであればこの問題についてはこれでおしまいだ
僕は紳士としてこれ以上立ち入らない


しかし問題はもう一方の可能性についてだ
もう一つの可能性はこうだ


ーFixnum上官にはサイズがないー


先の回答はそれを意味している可能性がある
仮にこの考え方が正しいとすると
Fixnum上官は社会保障番号を持った実在であると同時に
空間を占有しない観念的な存在であるーつまり実在しないー
これは完全に僕の理解を超える


したがって確定的ではないが
Fixnum上官は女性説が今のところ有力だ


さて
もう少しFixnum上官のことを調べてみよう
彼女 ーとりあえず女性説を採用しようー も
多数の問い掛けmethodを持っているに違いない
&gt;&gt;
$ 1.class.methods
&lt;&lt;
よし！
&gt;&gt;
$ =&gt; [&quot;inspect&quot;, &quot;private_class_method&quot;, &quot;const_missing&quot;, &quot;clone&quot;, &quot;method&quot;, &quot;public_methods&quot;, &quot;public_instance_methods&quot;, &quot;instance_variable_defined?&quot;, &quot;method_defined?&quot;, &quot;superclass&quot;, &quot;equal?&quot;, &quot;freeze&quot;, &quot;included_modules&quot;, &quot;const_get&quot;, &quot;r&quot;, &quot;methods&quot;, &quot;respond_to?&quot;, &quot;module_eval&quot;, &quot;class_variables&quot;, &quot;dup&quot;, &quot;protected_instance_methods&quot;, &quot;instance_variables&quot;, &quot;public_method_defined?&quot;, &quot;__id__&quot;, &quot;object_id&quot;, &quot;eql?&quot;, &quot;const_set&quot;, &quot;id&quot;, &quot;singleton_methods&quot;, &quot;send&quot;, &quot;class_eval&quot;, &quot;taint&quot;, &quot;frozen?&quot;, &quot;instance_variable_get&quot;, &quot;include?&quot;, &quot;private_instance_methods&quot;, &quot;__send__&quot;, &quot;instance_of?&quot;, &quot;private_method_defined?&quot;, &quot;to_a&quot;, &quot;name&quot;, &quot;autoload&quot;, &quot;type&quot;, &quot;ri&quot;, &quot;&lt;&quot;, &quot;protected_methods&quot;, &quot;instance_eval&quot;, &quot;&lt;=&gt;&quot;, &quot;==&quot;, &quot;&gt;&quot;, &quot;display&quot;, &quot;===&quot;, &quot;instance_method&quot;, &quot;instance_variable_set&quot;, &quot;kind_of?&quot;, &quot;extend&quot;, &quot;protected_method_defined?&quot;, &quot;const_defined?&quot;, &quot;&gt;=&quot;, &quot;ancestors&quot;, &quot;to_s&quot;, &quot;&lt;=&quot;, &quot;public_class_method&quot;, &quot;allocate&quot;, &quot;hash&quot;, &quot;class&quot;, &quot;instance_methods&quot;, &quot;tainted?&quot;, &quot;=~&quot;, &quot;private_methods&quot;, &quot;class_variable_defined?&quot;, &quot;induced_from&quot;, &quot;nil?&quot;, &quot;untaint&quot;, &quot;constants&quot;, &quot;autoload?&quot;, &quot;is_a?&quot;]
&lt;&lt;
彼女は77個のmethodを持っていた
ちょっとこれをFixnum:1のmethodと対比してみよう
&gt;&gt;
$ 1.methods
&lt;&lt;
&gt;&gt;
$ =&gt; [&quot;%&quot;, &quot;inspect&quot;, &quot;&lt;&lt;&quot;, &quot;singleton_method_added&quot;, &quot;&amp;&quot;, &quot;clone&quot;, &quot;&gt;&gt;&quot;, &quot;method&quot;, &quot;round&quot;, &quot;public_methods&quot;, &quot;instance_variable_defined?&quot;, &quot;divmod&quot;, &quot;equal?&quot;, &quot;freeze&quot;, &quot;integer?&quot;, &quot;chr&quot;, &quot;*&quot;, &quot;+&quot;, &quot;to_i&quot;, &quot;methods&quot;, &quot;respond_to?&quot;, &quot;-&quot;, &quot;upto&quot;, &quot;between?&quot;, &quot;prec&quot;, &quot;truncate&quot;, &quot;/&quot;, &quot;dup&quot;, &quot;instance_variables&quot;, &quot;__id__&quot;, &quot;modulo&quot;, &quot;object_id&quot;, &quot;succ&quot;, &quot;|&quot;, &quot;eql?&quot;, &quot;zero?&quot;, &quot;~&quot;, &quot;id&quot;, &quot;to_f&quot;, &quot;singleton_methods&quot;, &quot;send&quot;, &quot;prec_i&quot;, &quot;taint&quot;, &quot;step&quot;, &quot;to_int&quot;, &quot;frozen?&quot;, &quot;instance_variable_get&quot;, &quot;__send__&quot;, &quot;^&quot;, &quot;instance_of?&quot;, &quot;remainder&quot;, &quot;to_a&quot;, &quot;+@&quot;, &quot;nonzero?&quot;, &quot;-@&quot;, &quot;type&quot;, &quot;**&quot;, &quot;floor&quot;, &quot;&lt;&quot;, &quot;protected_methods&quot;, &quot;&lt;=&gt;&quot;, &quot;instance_eval&quot;, &quot;==&quot;, &quot;prec_f&quot;, &quot;quo&quot;, &quot;&gt;&quot;, &quot;display&quot;, &quot;===&quot;, &quot;downto&quot;, &quot;id2name&quot;, &quot;size&quot;, &quot;instance_variable_set&quot;, &quot;kind_of?&quot;, &quot;abs&quot;, &quot;extend&quot;, &quot;&gt;=&quot;, &quot;next&quot;, &quot;to_s&quot;, &quot;&lt;=&quot;, &quot;coerce&quot;, &quot;hash&quot;, &quot;ceil&quot;, &quot;class&quot;, &quot;tainted?&quot;, &quot;=~&quot;, &quot;private_methods&quot;, &quot;div&quot;, &quot;nil?&quot;, &quot;untaint&quot;, &quot;times&quot;, &quot;to_sym&quot;, &quot;[]&quot;, &quot;is_a?&quot;]
&lt;&lt;
僕はこの２つのリストを比べてみることにした
アルファベット順に並べ替えて見比べてみる
その結果
２つのリストのうち45個のmethodは共通し
彼女固有のmethodは32個
Fixnum:1に固有のものは48個あるということがわかった


この作業の過程で面白いことに気がついた
それは彼女のリストには
昨日Fixnum:1に問い掛けたnextというmethodが存在しないということだ
これは何を意味するのかというと
彼女Fixnum上官には隣のヤツがいない
そういう意味だ
おそらく左隣ーpreviousーのヤツもいない
彼女は職務階級Classに属するが
寂しいことにClassには彼女の同僚と呼べるようなヤツはいない


一方でFixnum:1のmethodには存在しなかったnameというmethodがある
これを問い掛けてみると
&gt;&gt;
$ 1.class.name
&lt;&lt;
&gt;&gt;
$ =&gt; &quot;Fixnum&quot;
&lt;&lt;
そう
彼女の名前が返ってくる
やはり管理職という立場には
パブリックな名前を通してしかその存在が意識されない
ある種の悲哀のようなものが漂うな
でもまあこれで
君たちの世界がそれほど広大なものではないということがわかったよ


もう一つユニークな問い掛けを彼女のリストに見つけた
ancestors ー祖先ー だ
これほどわかりやすい問い掛けもないな
nameに次ぐわかりやすさだ
&gt;&gt;
$ 1.class.ancestors
&lt;&lt;
むむっ
&gt;&gt;
$ =&gt; [Fixnum, Integer, Precision, Numeric, Comparable, Object, Kernel]
&lt;&lt;


先の調査でFixnum上官の上官はClassであり
Classは最高司令官であることがわかっている
そうするとここに出てきた祖先たちは
命令系統における祖先ということではなくて
Fixnum上官のプライベートな祖先のことなのか？


彼らは現存するのだろうか？
そうだとすると極めて厄介なことになるな…
今はただ
皆さんが既にお亡くなりになっていることを祈るばかりだ…


さて夜も更けてきたので
今日はこれくらいにしよう


っと思った矢先に
superclassという無視できないmethodを
彼女が持っていることに気がついたじゃないか
class ー職務階級ー じゃなくて
superclass ー超職務階級ー だ
はて何が出てくるのだろう
&gt;&gt;
$ 1.class.superclass
&lt;&lt;
ありゃ
&gt;&gt;
$ =&gt; Integer
&lt;&lt;
さて困った…
Integerはプライベートな祖先じゃないのか？
Fixnum上官の職務階級がClassで
超職務階級がIntegerとはどういう意味だ？
わからん…


今日のまとめをして
もう寝たほうがよさそうだな…

+Fixnum:1はFixnum上官と何らかの交信手段を有しておりこれによって他の同僚の情報を取得できる
+Fixnum:1の職務階級名Fixnumは同時に上官の名前である
+Fixnum上官は職務階級Classに属しそのClass上官は組織の最高司令官である
+Fixnum上官はおそらく女性である
+Fixnum上官の祖先はInteger, Precision, Numeric, Comparable, Object, Kernelであるーこの順位にも意味があるものと思われる
+Fixnum上官の超職務階級はIntegerである ーなおIntegerは祖先でもある
</body>
</day>
<day date="2008-03-24" title="">
<body>
*p1*The Pragmatic Bookshelfは出版の近未来だ！
[http://www.pragprog.com/:title=The Pragmatic Bookshelf]で
[http://www.pragprog.com/titles/ruby3:title=Programming Rubyの3rd edition]が売られていたので
そのPDF版を買った


例によってベータ版ということで
現在はPartIIまで改定されたものが入手できる
2nd editionのPDF版を買ったユーザということで
本来$25のPDF版が$12.5およそ1,200円で購入できた
書籍とPDF版のコンボはおよそ$60になる
日本語版はおそらく8,000円前後になるだろうから
1,200円で同じ内容のものが手に入るというのは
すごく得した気分だ


このサイトおよび販売方法は本当によくできていて
出版の近未来というものをここに感じずにはいられない
その特徴は
+PDF版と書籍版あるいはそれらのコンボの何れかを自分の必要に応じて選べる
+書籍版に先行して途中まで書かれたものをPDFの形でダウンロード販売する
+up to dateで改訂版をPDFで細かくリリースする
+PDF版の読者からのエラー投稿やリクエストを容易にする仕組みがあり速やかにそれらを次の版に反映するようになっている
+購入者の専用ページが用意され購入履歴やお薦め情報が見られる
+前バージョンの購入者は大幅なディスカウントを受けられる


ポイントとしては作者と読者の距離が近いということであり
その結果
+インタラクティブに読者の声を次のリリースに反映できる
+価格を安くできる
+販売スタイルを柔軟にできる
というメリットが生まれている


このメリットは確かにこの種の技術書では特に有効だけど
他の書籍例えば小説などでも
作者および読者にとってメリットがあると思う


海外のテレビドラマシリーズ例えばＬＯＳＴや冬ソナでは
オフィシャルサイトを通して
ユーザと製作者との間のインタラクションが
作品の後の行方に影響を与えていたらしいので
書籍の世界にも同様のことが起きるのだろう


現在の日本での作家の取り分は売価の10％程度と聞く
このようなシステムは流通コストを大幅に引き下げ
販売価格を引き下げても
作者に相応の利益をもたらす可能性がある
これこそ作者・読者共に仕合せになれるwin-winの状況だ

*p2*理解のための正道
通常新しい物事を理解するときに取る手法は
その道の先人(エキスパート)に聞くことだ
先人はその全体像を知っており
巧みな言葉を使って
初学者を理解の先に導こうとする


印刷および流通技術が発達した現代では
初学者は書籍という形でその恩恵にあずかれる


書籍を読み進めていく過程で
初学者は先人の言葉に何度も頷き
最後のページを閉じたときに
その物事のすべてを
自分の理解として獲得したと錯覚する


ところが実際にその物事に触れてみると
自分が依然として何もできないという事実に驚愕する


その新しい物事に既にアクセスできる状態にあるならば
そこにアクセスしその挙動を観察し実行してみる
その結果から湧き上がる自然な疑問こそが
真の理解への第一歩に違いない


しかし僕はそのことを直ぐに忘れてしまう
いや
これは僕だけの問題ではなくて
情報化社会におけるリスクの問題なのかもしれない
</body>
</day>
<day date="2008-03-26" title="">
<body>
*p1*Attentionが人生を規定する
社会は人間を
独立した人という存在から
その関係性を主体とした人間という存在に変えた


人間の関係性とはAttentionの問題である
人は他の人からのAttentionを支えとして
はじめて人として生きてゆけるのだ


もちろんAttentionにも質があり
その最高のものは愛である
一方で最低のものは憎悪である
しかしAttentionが憎悪であったとしても
人は人として生きてゆける


しかしAttentionを失うと人は
人として生きてゆけなくなる


現代において家族という最小社会が
Attentionを作る機能を失いつつある


一方でネットは人々のAttentionを作り出し
これを補完しうる存在になりつつある
Attentionを失った人にとって
それは家族以上のものである

*p2*Googleはネット上の小売企業である
消費者が求めているものは結局は消費財である
ネット空間における消費財とは
情報コンテンツである


消費者は情報コンテンツを求めて
ネット上でウィンドウショッピングする
つまりGoogleにキーワードを打ち込む
Googlebotはそれに答えて
消費者に情報コンテンツのリストを提示する
消費者はその１つを選択してGoogleを離れる


Googleがリアル空間の小売企業と異なる点は
消費者から小売マージンを取るのではなく
一部の情報コンテンツの生産者から
流通マージンを取る点である


しかしGoogleがどこから富の源泉を得ようとも
消費財を自ら生産せず
これを最終消費者に提供するを業とする限り
彼らは小売企業なのである

*p3*小売企業の競争力は最終的には価格競争力で決まる
Aの店とBの店で同じ商品が売られている
Aの店はサービスが良質で店舗もきれいである
しかし商品の価格が高い
Bの店はサービスは最低で店舗も汚れている
しかし商品の価格はAの店の半値である


どちらの店舗で買おうか悩む
しかし商品には差がない
Aの店では確かに気持ちよく買い物ができるが
Bの店で買えば別の同質の商品が更にもう一つ買える


商品の価格差が僅かで
それが無視できるものでない限り
価格は購買の決定的要因である
つまり小売の最終的な競争力はサービスにはない


また小売の競争力はその利便性にもない
ネットユーザはAmazonを頻繁に利用する
しかしそれはリアル店舗に比べて利便性が高いからではない
単に価格が安いからか
リアル店舗に比べて価格が高くとも
その差が無視できるものだからである
液晶テレビが定価で売られていたら誰も買わない


小売企業が価格で競争できないとしたら
座して死を待つか
ユニクロやセブン-イレブンのような
製造小売になるしかない
</body>
</day>
<day date="2008-04-12" title="">
<body>
*p1*可哀想な人
その人が「可哀想な人」と
心の底から思うのなら
その人に「可哀想な人」と
言うのは止めた方がいい
その人を「可哀想な人」にするのは
あなたに他ならないのだから
</body>
</day>
<day date="2008-04-20" title="">
<body>
*p1*アロマポッドだってきれいになりたい ~LampshadeのDIY~

リビングのペンダントライトがりっぱになると
[f:id:keyesberry:20080221171004j:image]
[http://d.hatena.ne.jp/keyesberry/20080221/p2:title=IQ lightは魔法のライト - hp12c]


相対的に棚上のアロマポッドが淋しく見える((無印良品ネットストア[ガラスアロマウォーマー直径約７７×１３０ｍｍ]http://www.muji.net/store/cmdty/detail/4548076768630))
[f:id:keyesberry:20080420174436j:image]


天気のさえない日曜日の午後に
[http://www.yasutomo.com/project/paperlampshade.htm:title=こんな記事]と
余ったポリプロピレンと
僅かばかりの暇とがあれば
やるべきことはこれしかない


適当な大きさにPP板をカットして
[f:id:keyesberry:20080420174435j:image]


図面に沿って折り曲げて
[f:id:keyesberry:20080420174434j:image]


折り曲げて
[f:id:keyesberry:20080420174433j:image]


また折り曲げて
[f:id:keyesberry:20080420174432j:image]


水平線を谷折りしてから円筒状にくっつける
[f:id:keyesberry:20080420174532j:image]


電源コードの切り欠き付けてのりが乾けば完成だ
[f:id:keyesberry:20080420174531j:image]


明かりを入れればそれなりに
雑な作りも気にならない
お部屋に一ついかがです？
[f:id:keyesberry:20080420174530j:image]
</body>
</day>
<day date="2008-06-29" title="">
<body>
*p1*色付きコードでブログを投稿しよう!
TextMateには言語のシンタックスに従って
ソースコードを自動で色付けするSyntax Highlighting機能がある
複数のThemeが用意されており
そこから自分の好みのカラーセットを選べる
現在の僕のお気に入りはCobaltだ


Syntax Highlightingはほんとうにソースコードを綺麗にみせる
自分の汚いコードがそれなりの作品に化けたように錯覚する
誰か日本語用Syntax Highlightingを作ってくれないかな
そうしたら自分の日本語ももう少しマシに見えるのに


TextMateを使っていると
このカラーを使った色付きコードでブログの投稿をしたい
という欲求が当然に生じる


幸いなことに
[http://ultraviolet.rubyforge.org/:title=Ultraviolet]というRubyの拡張ライブラリがそれを可能にしてくれる
Ultravioletは[http://textpow.rubyforge.org/:title=TextPow]というTextMateのBundleを解析するライブラリを使い
その解析結果に従ってソースコードをカラーリングする


早々Ultravioletを使って
Haskell、Javascript、Lisp、Perl、Python、Rubyで書いたコードを投稿してみる
(Ruby以外のコードは他のサイトから拝借しました)(([http://pub.cozmixng.org/~the-rwiki/rw-cgi.rb?cmd=view;name=%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8%B8%C0%B8%EC%A4%CE%C8%E6%B3%D3%3A%3A%B4%D8%BF%F4%A4%CE%BA%C6%B5%A2:title=スクリプト言語の比較::関数の再帰]))


&lt;p&gt;fact.hs with espresso_libre&lt;/p&gt;&lt;pre class=&quot;espresso_libre&quot; style=&quot;background-color:#2a211c;color:#bcae9d&quot;&gt;&lt;span class=&quot;line-numbers&quot;&gt;   1 &lt;/span&gt; factorial n
&lt;span class=&quot;line-numbers&quot;&gt;   2 &lt;/span&gt;     | n == 0    = 1
&lt;span class=&quot;line-numbers&quot;&gt;   3 &lt;/span&gt;     | &lt;span style=&quot;font-weight:bold;color:#43A8ED;&quot;&gt;otherwise&lt;/span&gt; = n * factorial (n-1)
&lt;/pre&gt;
&lt;p&gt;fact.js with spacecadet&lt;/p&gt;&lt;pre class=&quot;spacecadet&quot; style=&quot;background-color:#0d0d0d;color:#dde6cf&quot;&gt;&lt;span class=&quot;line-numbers&quot;&gt;   1 &lt;/span&gt; &lt;span style=&quot;color:#9EBF60;&quot;&gt;var&lt;/span&gt;	&lt;span style=&quot;color:#6078BF;&quot;&gt;fact&lt;/span&gt; = &lt;span style=&quot;color:#9EBF60;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color:#596380;&quot;&gt;n&lt;/span&gt;) {
&lt;span class=&quot;line-numbers&quot;&gt;   2 &lt;/span&gt; 	&lt;span style=&quot;color:#728059;&quot;&gt;if&lt;/span&gt;(n==&lt;span style=&quot;color:#BF9960;&quot;&gt;0&lt;/span&gt;) {
&lt;span class=&quot;line-numbers&quot;&gt;   3 &lt;/span&gt; 		&lt;span style=&quot;color:#728059;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#BF9960;&quot;&gt;1&lt;/span&gt;;
&lt;span class=&quot;line-numbers&quot;&gt;   4 &lt;/span&gt; 	} &lt;span style=&quot;color:#728059;&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;line-numbers&quot;&gt;   5 &lt;/span&gt; 		&lt;span style=&quot;color:#728059;&quot;&gt;return&lt;/span&gt; n * arguments.&lt;span style=&quot;&quot;&gt;callee&lt;/span&gt;(n-&lt;span style=&quot;color:#BF9960;&quot;&gt;1&lt;/span&gt;);
&lt;span class=&quot;line-numbers&quot;&gt;   6 &lt;/span&gt; 	}
&lt;span class=&quot;line-numbers&quot;&gt;   7 &lt;/span&gt; }
&lt;/pre&gt;
&lt;p&gt;fact.lisp with brilliance_black&lt;/p&gt;&lt;pre class=&quot;brilliance_black&quot; style=&quot;background-color:#0d0d0d;color:#cccccc&quot;&gt;&lt;span class=&quot;line-numbers&quot;&gt;   1 &lt;/span&gt; (&lt;span style=&quot;background-color:#480227;color:#800043;&quot;&gt;&lt;span style=&quot;color:#FF7900;&quot;&gt;defun&lt;/span&gt; &lt;span style=&quot;color:#FF0086;&quot;&gt;factorial&lt;/span&gt;&lt;/span&gt; (n)
&lt;span class=&quot;line-numbers&quot;&gt;   2 &lt;/span&gt;    (&lt;span style=&quot;background-color:#230248;color:#F800FF;&quot;&gt;if&lt;/span&gt; (&amp;lt;= n &lt;span style=&quot;color:#C6FF00;&quot;&gt;1&lt;/span&gt;)
&lt;span class=&quot;line-numbers&quot;&gt;   3 &lt;/span&gt;      &lt;span style=&quot;color:#C6FF00;&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   4 &lt;/span&gt;      (* n (factorial (- n &lt;span style=&quot;color:#C6FF00;&quot;&gt;1&lt;/span&gt;)))))
&lt;/pre&gt;
&lt;p&gt;fact.pl with amy&lt;/p&gt;&lt;pre class=&quot;amy&quot; style=&quot;background-color:#200420;color:#d1d0ff&quot;&gt;&lt;span class=&quot;line-numbers&quot;&gt;   1 &lt;/span&gt; &lt;span style=&quot;color:#B0FFF0;&quot;&gt;sub&lt;/span&gt; &lt;span style=&quot;color:#50A0A0;&quot;&gt;fact&lt;/span&gt; {
&lt;span class=&quot;line-numbers&quot;&gt;   2 &lt;/span&gt; 	&lt;span style=&quot;color:#B0FFF0;&quot;&gt;my&lt;/span&gt;(&lt;span style=&quot;color:#008080;&quot;&gt;&lt;span style=&quot;color:#805080;&quot;&gt;$&lt;/span&gt;n&lt;/span&gt;) = &lt;span style=&quot;color:#008080;&quot;&gt;&lt;span style=&quot;color:#805080;&quot;&gt;@&lt;/span&gt;_&lt;/span&gt;;
&lt;span class=&quot;line-numbers&quot;&gt;   3 &lt;/span&gt; 	
&lt;span class=&quot;line-numbers&quot;&gt;   4 &lt;/span&gt; 	&lt;span style=&quot;color:#80A0FF;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color:#008080;&quot;&gt;&lt;span style=&quot;color:#805080;&quot;&gt;$&lt;/span&gt;n&lt;/span&gt; == 0) {
&lt;span class=&quot;line-numbers&quot;&gt;   5 &lt;/span&gt; 		&lt;span style=&quot;color:#80A0FF;&quot;&gt;return&lt;/span&gt; 1;
&lt;span class=&quot;line-numbers&quot;&gt;   6 &lt;/span&gt; 	} &lt;span style=&quot;color:#80A0FF;&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;line-numbers&quot;&gt;   7 &lt;/span&gt; 		&lt;span style=&quot;color:#80A0FF;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#008080;&quot;&gt;&lt;span style=&quot;color:#805080;&quot;&gt;$&lt;/span&gt;n&lt;/span&gt; * fact(&lt;span style=&quot;color:#008080;&quot;&gt;&lt;span style=&quot;color:#805080;&quot;&gt;$&lt;/span&gt;n&lt;/span&gt; - 1);
&lt;span class=&quot;line-numbers&quot;&gt;   8 &lt;/span&gt; 	}
&lt;span class=&quot;line-numbers&quot;&gt;   9 &lt;/span&gt; }
&lt;span class=&quot;line-numbers&quot;&gt;  10 &lt;/span&gt; 
&lt;/pre&gt;
&lt;p&gt;fact.py with all_hallows_eve&lt;/p&gt;&lt;pre class=&quot;all_hallows_eve&quot; style=&quot;background-color:#000000;color:#ffffff&quot;&gt;&lt;span class=&quot;line-numbers&quot;&gt;   1 &lt;/span&gt; &lt;span style=&quot;background-color:#000000;color:#FFFFFF;&quot;&gt;&lt;span style=&quot;background-color:#000000;color:#FFFFFF;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;&quot;&gt;fact&lt;/span&gt;&lt;span style=&quot;background-color:#000000;color:#FFFFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;background-color:#000000;color:#FFFFFF;&quot;&gt;&lt;span style=&quot;font-style:italic;&quot;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color:#000000;color:#FFFFFF;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;background-color:#000000;color:#FFFFFF;&quot;&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   2 &lt;/span&gt; 	&lt;span style=&quot;color:#CC7833;&quot;&gt;if&lt;/span&gt;	n &lt;span style=&quot;color:#CC7833;&quot;&gt;==&lt;/span&gt; &lt;span style=&quot;color:#3387CC;&quot;&gt;0&lt;/span&gt;:
&lt;span class=&quot;line-numbers&quot;&gt;   3 &lt;/span&gt; 		&lt;span style=&quot;color:#CC7833;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#3387CC;&quot;&gt;1L&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   4 &lt;/span&gt; 	&lt;span style=&quot;color:#CC7833;&quot;&gt;else&lt;/span&gt;:
&lt;span class=&quot;line-numbers&quot;&gt;   5 &lt;/span&gt; 		&lt;span style=&quot;color:#CC7833;&quot;&gt;return&lt;/span&gt; n &lt;span style=&quot;color:#CC7833;&quot;&gt;*&lt;/span&gt; &lt;span style=&quot;background-color:#000000;color:#FFFFFF;&quot;&gt;fact&lt;span style=&quot;background-color:#000000;color:#FFFFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;background-color:#000000;color:#FFFFFF;&quot;&gt;n &lt;span style=&quot;color:#CC7833;&quot;&gt;-&lt;/span&gt; &lt;span style=&quot;color:#3387CC;&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color:#000000;color:#FFFFFF;&quot;&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;fact.rb with slush_poppies&lt;/p&gt;&lt;pre class=&quot;slush_poppies&quot; style=&quot;background-color:#f1f1f1;color:#000000&quot;&gt;&lt;span class=&quot;line-numbers&quot;&gt;   1 &lt;/span&gt; &lt;span style=&quot;color:#2060A0;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#800000;&quot;&gt;fact&lt;/span&gt;(&lt;span style=&quot;&quot;&gt;n&lt;/span&gt;)
&lt;span class=&quot;line-numbers&quot;&gt;   2 &lt;/span&gt;   (&lt;span style=&quot;color:#0080A0;&quot;&gt;1&lt;/span&gt;..n).&lt;span style=&quot;color:#800000;&quot;&gt;inject&lt;/span&gt; { |&lt;span style=&quot;&quot;&gt;mem&lt;/span&gt;, &lt;span style=&quot;&quot;&gt;var&lt;/span&gt;| mem &lt;span style=&quot;color:#2060A0;&quot;&gt;*&lt;/span&gt; var }
&lt;span class=&quot;line-numbers&quot;&gt;   3 &lt;/span&gt; &lt;span style=&quot;color:#2060A0;&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;


Ultravioletのインストールは以下のようにできるけど(([http://ultraviolet.rubyforge.org/:title=Ultraviolet]))
&gt;|
  $ gem install -r ultraviolet --include-dependencies
|&lt;
TextPowで鬼車(oniguruma)正規表現ライブラリを使っているので(([http://textpow.rubyforge.org/:title=Textpow]))
予めそのインストールが必要になる(([http://www.goodbyehelicopter.com/2008/02/20/install-oniguruma-on-os-x/:title=Install Oniguruma on OS X !]))


Ultravioletでは外部cssファイルを読み出しているので
その出力結果を直接ブログに張り付けるとうまくいかない
だから以下のサンプルコード(hilite.rb)を書いた


&lt;p&gt;hilite.rb with cobalt&lt;/p&gt;&lt;pre class=&quot;cobalt&quot; style=&quot;width:700px;background-color:#002444;color:#e6e1dc&quot;&gt;&lt;span class=&quot;line-numbers&quot;&gt;   1 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt;!/usr/bin/env ruby&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   2 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;require&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;rubygems&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   3 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;require&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;uv&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   4 &lt;/span&gt; 
&lt;span class=&quot;line-numbers&quot;&gt;   5 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color:#FFDD00;&quot;&gt;Hilite&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   6 &lt;/span&gt;   &lt;span style=&quot;color:#CCCCCC;&quot;&gt;BGCOLORS&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;all_hallows_eve&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#000000&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#ffffff&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   7 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;amy&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#200420&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#d1d0ff&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   8 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;blackboard&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#0d1021&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#f8f8f8&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   9 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;brilliance_black&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#0d0d0d&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#cccccc&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  10 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;brilliance_dull&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#0a0a0a&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#cdcdcd&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  11 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;cobalt&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#002444&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#e6e1dc&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  12 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;dawn&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#f9f9f9&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#080808&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  13 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;espresso_libre&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#2a211c&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#bcae9d&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  14 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;idle&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#ffffff&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#000000&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  15 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;iplastic&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#efefef&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#000000&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  16 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;lazy&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#ffffff&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#000000&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  17 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;mac_classic&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#ffffff&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#000000&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  18 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;magicwb_amiga&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#969696&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#000000&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  19 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;pastels_on_dark&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#211e1e&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#dadada&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  20 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;slush_poppies&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#f1f1f1&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#000000&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  21 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;spacecadet&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#0d0d0d&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#dde6cf&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  22 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;sunburst&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#000000&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#f8f8f8&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  23 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;twilight&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#141414&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#f8f8f8&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  24 &lt;/span&gt;               &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;zenburnesque&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#404040&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;#dedede&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  25 &lt;/span&gt;               &lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  26 &lt;/span&gt;   &lt;span style=&quot;color:#CCCCCC;&quot;&gt;FILE_TYPES&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;rb&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;ruby&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;rjs&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;ruby&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;rxml&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;ruby_on_rails&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  27 &lt;/span&gt;                 &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;rhtml&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;ruby_on_rails&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;pl&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;perl&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;pm&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;perl&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  28 &lt;/span&gt;                 &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;html&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;html&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;applescript&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;applescript&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  29 &lt;/span&gt;                 &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;py&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;python&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;js&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;javascript&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;as&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;actionscript&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  30 &lt;/span&gt;                 &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;php&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;php&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;c&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;c&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;h&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;c&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;java&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;java&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  31 &lt;/span&gt;                 &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;markdown&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;markdown&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;sh&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;shell-unix-generic&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  32 &lt;/span&gt;                 &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;bashrc&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;shell-unix-generic&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;sql&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;sql&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  33 &lt;/span&gt;                 &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;txt&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;plain_text&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;textile&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;textile&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  34 &lt;/span&gt;                 &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;xml&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;xml&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;tld&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;xml&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;jsp&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;xml&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  35 &lt;/span&gt;                 &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;rss&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;xml&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;yaml&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;yaml&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;lisp&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;lisp&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  36 &lt;/span&gt;                 &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;hs&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;haskell&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  37 &lt;/span&gt;                 &lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  38 &lt;/span&gt;                 
&lt;span class=&quot;line-numbers&quot;&gt;  39 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#FFDD00;&quot;&gt;initialize&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;file&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  40 &lt;/span&gt;     &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;extention&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#80FFBB;&quot;&gt;File&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;extname&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;file&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;delete&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;.&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  41 &lt;/span&gt;     &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;syntax&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;FILE_TYPES&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;extention&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  42 &lt;/span&gt;     &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;data&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;IO&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;read&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;file&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  43 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  44 &lt;/span&gt; 
&lt;span class=&quot;line-numbers&quot;&gt;  45 &lt;/span&gt;   &lt;span style=&quot;color:#80FFBB;&quot;&gt;Uv&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;themes&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;each&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;theme&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  46 &lt;/span&gt;     &lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;define_method&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;parse_with_&lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;theme&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  47 &lt;/span&gt;       &lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;parse&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;theme&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;true&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  48 &lt;/span&gt;     &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  49 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  50 &lt;/span&gt;   
&lt;span class=&quot;line-numbers&quot;&gt;  51 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#FFDD00;&quot;&gt;parse&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;theme&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; numbering&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  52 &lt;/span&gt;     html &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#80FFBB;&quot;&gt;Uv&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;parse&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;data&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;xhtml&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;syntax&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; numbering&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; theme &lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  53 &lt;/span&gt; 
&lt;span class=&quot;line-numbers&quot;&gt;  54 &lt;/span&gt;     css_file &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#80FFBB;&quot;&gt;File&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;join&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#80FFBB;&quot;&gt;Uv&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;path&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;%w(&lt;/span&gt;render xhtml files css&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;theme&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;.css&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  55 &lt;/span&gt;     styles &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  56 &lt;/span&gt;     &lt;span style=&quot;color:#CCCCCC;&quot;&gt;IO&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;read&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;css_file&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;gsub&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;/&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;pre&lt;span style=&quot;color:#80FF82;&quot;&gt;\.&lt;/span&gt;&lt;span style=&quot;background-color:#223545;color:#FFFFFF;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;theme&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#80FF82;&quot;&gt;\s&lt;/span&gt;+&lt;span style=&quot;color:#80FF82;&quot;&gt;\.&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#80FF82;&quot;&gt;\w&lt;/span&gt;+&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#80FF82;&quot;&gt;\s&lt;/span&gt;*&lt;span style=&quot;color:#80FF82;&quot;&gt;\{&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;.+?&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#80FF82;&quot;&gt;\}&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;/m&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  57 &lt;/span&gt;       styles&lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;$&lt;/span&gt;1&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;$&lt;/span&gt;2&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;gsub&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;/&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;&lt;span style=&quot;color:#80FF82;&quot;&gt;\s&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;/&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  58 &lt;/span&gt;     &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  59 &lt;/span&gt;     styles&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;each&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;key&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;value&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  60 &lt;/span&gt;       html&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;gsub!&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;/&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;class=&amp;quot;&lt;span style=&quot;background-color:#223545;color:#FFFFFF;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;key&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;/i&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;%Q{&lt;/span&gt;style=&amp;quot;&lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;value&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&amp;quot;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  61 &lt;/span&gt;     &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  62 &lt;/span&gt;     html&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;gsub!&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;/&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;class=&amp;quot;&lt;span style=&quot;background-color:#223545;color:#FFFFFF;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;theme&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#80FFC2;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;/&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;{&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;|&lt;/span&gt; match &lt;span style=&quot;color:#FF9D00;&quot;&gt;+&lt;/span&gt; 
&lt;span class=&quot;line-numbers&quot;&gt;  63 &lt;/span&gt;       &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;%Q{&lt;/span&gt; style=&amp;quot;background-color:&lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;&lt;span style=&quot;color:#EDEF7D;&quot;&gt;BGCOLORS&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;theme&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#80FF82;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;bg&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;;color:&lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;&lt;span style=&quot;color:#EDEF7D;&quot;&gt;BGCOLORS&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;theme&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#80FF82;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;fg&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&amp;quot;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  64 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  65 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  66 &lt;/span&gt; 
&lt;span class=&quot;line-numbers&quot;&gt;  67 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;if&lt;/span&gt; &lt;span style=&quot;color:#FF80E1;&quot;&gt;__FILE__&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;==&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;$&lt;/span&gt;0&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  68 &lt;/span&gt;   themes &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#80FFBB;&quot;&gt;Hilite&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;::&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;BGCOLORS&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;keys&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  69 &lt;/span&gt;   &lt;span style=&quot;color:#CCCCCC;&quot;&gt;ARGV&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;each&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;file&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  70 &lt;/span&gt;     theme &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; themes&lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;rand&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;themes&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;length&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  71 &lt;/span&gt;     colored_code &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#80FFBB;&quot;&gt;Hilite&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;new&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;file&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;parse&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;theme&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;true&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  72 &lt;/span&gt;     puts &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&amp;lt;p&amp;gt;&lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;file&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt; with &lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;theme&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&amp;lt;/p&amp;gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;+&lt;/span&gt; colored_code
&lt;span class=&quot;line-numbers&quot;&gt;  73 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  74 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt;  ARGV.each do |file|&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  75 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt;    colored_code = Hilite.new(file).parse_with_cobalt&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  76 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt;    puts &amp;quot;&amp;lt;p&amp;gt;#{file} with cobalt&amp;lt;/p&amp;gt;&amp;quot; + colored_code&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  77 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt;  end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  78 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;


使い方はターミナルで
&gt;|
  $ ruby hilite.rb fact.rb  &gt; fact.html
|&lt;
とすれば
fact.rbを色付けしたコードを含むfact.htmlが得られる
引数として複数のファイルを指定できる
サンプルでは複数のコードに対して
ランダムにThemeを選択し出力している


69～73行をコメントアウトし
74～77行のコメントを外せば
全てのコードをCobalt Themeで色付けしたものが得られる


Hiliteクラスの基本的な使い方は
&gt;|
  theme = 'cobalt'
  code = Hilite.new(filename)
  puts code.parse(theme, true)
|&lt;
ファイル名を引数としてHiliteクラスをオブジェクト化し
ThemeとNumberingの有無を引数としてparseメソッドを呼ぶ
あるいは
&gt;|
  code = Hilite.new(filename)
  puts code.parse_with_espresso_libre
  puts code.parse_with_blackboard
|&lt;
のようにThemeをwithしたメソッドを呼んでもいい


Syntaxはファイルの拡張子から
FILE_TYPESテーブルで一意に判断している
必要なSyntaxがテーブルにない場合は
適宜追加してほしい
使えるSyntaxはirbで
&gt;|
irb&gt; require 'uv'
irb&gt; Uv.syntaxes
|&lt;
などとすれば得られる


ちなみにTextMateに必要なSyntax Bundleがない場合には
Manualの5.7 Getting More Bundles((http://manual.macromates.com/en/bundles))を参照にして
インストールしてほしい


何しろ素人が初めて投稿するコードなので
いろいろとまずい点があると思うけど
使ってくれる人がいたらうれしい


(追記:2009/3/27)　コードは以下にアップしてあります。Shoesによるインタフェースもあります。

[http://gist.github.com/1451:title=gist: 1451 - GitHub]
</body>
</day>
<day date="2008-07-08" title="">
<body>
*p1*Ruby、同じことの繰り返しは君に任せるよ ～ 再帰でハノイの塔を解こう！～
もし問題が同じパターンの繰り返しを含んでいて
その極限の解が明らかならば
その問題の解決には再帰が使えるかもしれない


再帰はある問題の答えの中にその問題自体を含む不思議な構造だ
「GNU」は「GNU's Not UNIX」の頭文字からなる略称だ
ここで「GNU」は問題であり
その答え「GNU's Not UNIX」の中に問題自体が含まれている
だからGNUは明らかに再帰だ


「これじゃ答えになってない」
「つまり再帰は問題解決の役には立たない」
そういう声が聞こえてきそうだ


つまりあなたは「GNU's Not UNIX」が
「(GNU's Not UNIX)'s Not UNIX」になることを知っており
「((((GNU's Not UNIX)'s Not UNIX)'s Not UNIX)'s Not UNIX)'s Not UNIX」になることも知っており
したがって”どこまで行っても望みの答えは得られない”
ということに既に気がついているということだ
その通り！素晴らしい！


確かにGNUの意味はどこまで行っても得られないけど
それは再帰における極限の解が明らかにされていないからだ
仮にGNUの再帰を100回繰り返せば
「GNUはUNIXになる」とでもいう極限条件が与えられれば
答えは一応得られる(釈然とはしないけれども…)


GNUのことは諦めて「階乗」のことについて考えてみよう


「階乗」は自然数nに対する1からnまでの自然数の総乗を言う(([http://ja.wikipedia.org/wiki/%E9%9A%8E%E4%B9%97:title=階乗 - Wikipedia]))
つまり5の階乗5!は
&gt;&gt;
5! = 1 * 2 * 3 * 4 * 5 = 120
&lt;&lt;
となる


これをRuby1.9では以下のように書ける
&lt;pre class=&quot;cobalt&quot; style=&quot;background-color:#002444;color:#e6e1dc&quot;&gt;&lt;span class=&quot;line-numbers&quot;&gt;   1 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color:#FFDD00;&quot;&gt;Integer&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   2 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;!&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   3 &lt;/span&gt;     &lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FF80E1;&quot;&gt;self&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;inject&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt;*&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   4 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   5 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   6 &lt;/span&gt; 
&lt;span class=&quot;line-numbers&quot;&gt;   7 &lt;/span&gt; puts &lt;span style=&quot;color:#FF628C;&quot;&gt;5&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;!
&lt;span class=&quot;line-numbers&quot;&gt;   8 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; 120&lt;/span&gt;
&lt;/pre&gt;


一方
5の階乗は以下のようにも表現できる
&gt;&gt;
5! = 5 * 4!
&lt;&lt;
つまり5の階乗は5に4の階乗を掛けたものとして表現できる


これはGNUの場合と同様に答えになっていない
5!がわからないのと同様に4!なんてものもわからないからだ
でもそう
これこそが再帰のマジックなんだ


幸いなことにGNUの場合と異なって
階乗の極限値ははっきりしている
&gt;&gt;
1! = 1
&lt;&lt;
だから階乗計算は再帰で解くことが出来るんだ


Rubyではこれらの式をそのまま書ける
&lt;pre class=&quot;cobalt&quot; style=&quot;background-color:#002444;color:#e6e1dc&quot;&gt;&lt;span class=&quot;line-numbers&quot;&gt;   1 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color:#FFDD00;&quot;&gt;Integer&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   2 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#FFDD00;&quot;&gt;factorial&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   3 &lt;/span&gt;     &lt;span style=&quot;color:#FF9D00;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;if&lt;/span&gt; &lt;span style=&quot;color:#FF80E1;&quot;&gt;self&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;==&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   4 &lt;/span&gt;     &lt;span style=&quot;color:#FF80E1;&quot;&gt;self&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;*&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#FF80E1;&quot;&gt;self&lt;/span&gt;&lt;span style=&quot;color:#FF9D00;&quot;&gt;-&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;factorial
&lt;span class=&quot;line-numbers&quot;&gt;   5 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   6 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   7 &lt;/span&gt; 
&lt;span class=&quot;line-numbers&quot;&gt;   8 &lt;/span&gt; puts &lt;span style=&quot;color:#FF628C;&quot;&gt;5&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;factorial&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   9 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; 120&lt;/span&gt;
&lt;/pre&gt;


もう少し凝って以下のようにしてもいい
&lt;pre class=&quot;cobalt&quot; style=&quot;background-color:#002444;color:#e6e1dc&quot;&gt;&lt;span class=&quot;line-numbers&quot;&gt;   1 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color:#FFDD00;&quot;&gt;Integer&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   2 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;def&lt;/span&gt; 階乗
&lt;span class=&quot;line-numbers&quot;&gt;   3 &lt;/span&gt;     &lt;span style=&quot;color:#FF80E1;&quot;&gt;self&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;*&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#FF80E1;&quot;&gt;self&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;==&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;?&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#FF80E1;&quot;&gt;self&lt;/span&gt;&lt;span style=&quot;color:#FF9D00;&quot;&gt;-&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;階乗&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   4 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   5 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   6 &lt;/span&gt; 
&lt;span class=&quot;line-numbers&quot;&gt;   7 &lt;/span&gt; puts &lt;span style=&quot;color:#FF628C;&quot;&gt;5&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;階乗
&lt;span class=&quot;line-numbers&quot;&gt;   8 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; 120&lt;/span&gt;
&lt;/pre&gt;


でも
階乗計算なんて
会計用電卓のhp12cにだって簡単にできるんだから
ちっともうれしくない


それじゃあもう一歩進んで
「ハノイの塔」をやってみよう！


「ハノイの塔」は3本のポールと
サイズの異なる複数枚のドーナツ円盤を使ったパズルだ
スタートのポールに重ねられたすべての円盤を
予備のポールを活用しながら
ゴールとなるポールにすべて移動できれば正解だ
移動は一枚ずつ行い
如何なるときも
小さい円盤を大きい円盤の下に置いてはいけない(([http://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%8E%E3%82%A4%E3%81%AE%E5%A1%94:title=ハノイの塔 - Wikipedia]))


最小の円盤を1として
ポールの名前を(Start, Goal, Temp)とした場合
2枚の円盤(1、2)のハノイの答えは次のようになる
&gt;&gt;
+円盤1をStartからTempへ移動する
+円盤2をStartからGoalへ移動する
+円盤1をTempからGoalへ移動する
&lt;&lt;


3枚の円盤(1、2、3)のハノイの答えは次のようになる
&gt;&gt;
+円盤1をStartからGoalへ移動する
+円盤2をStartからTempへ移動する
+円盤1をGoalからTempへ移動する
+円盤3をStartからGoalへ移動する
+円盤1をTempからStartへ移動する
+円盤2をTempからGoalへ移動する
+円盤1をStartからGoalへ移動する
&lt;&lt;


まずはハノイの塔が再帰でいけるか検討してみる
答えの中に問いが含まれており
極限の答えがはっきりしていれば再帰でいける


例えば、円盤3枚の場合の問いをhanoi(3)とした場合
&gt;&gt;
hanoi(3) = 3 * hanoi(2)
&lt;&lt;
のような
答えの中に問いが含まれている形になればいい


一方
極限の答えはわかっている
円盤が0のとき(n=0)は動かすものが何もないのだから
&gt;&gt;
hanoi(0) = 何もしない
&lt;&lt;
となる


じゃあ円盤が1枚(n=1)のときはどうなるだろう
&gt;&gt;
hanoi(1) = ”円盤1をStartからGoalに移動する”
&lt;&lt;
円盤が1枚しかない場合の最適な移動はこれ以外にない


そうすると円盤が複数枚(n枚)ある場合の移動に関して
以下のような手順が見えてくる
&gt;&gt;
+Startにある一番下の円盤nをGoalに移動できるようにするため、その前の手順として、他のすべての円盤(1～n-1)の束をどうにかしてTempに一旦移動させる
+そして、Startにある一番下の円盤nをGoalに移動する
+その後、Tempに置いた他の円盤(1～n-1)の束をすべてどうにかしてGoalに移動させる
&lt;&lt;
ここで
1.に注目すると
これはまさにn-1枚の円盤を
StartからTempに移動させるというハノイの問題だ！
また
3.に注目すると
これもまたn-1枚の円盤を
TempからGoalに移動させるというハノイの問題だ！


つまりハノイの問題は
その答えにハノイの問題を含んだ再帰的なものになる！
そしてその極限の値n=0の答えは明らかだ
よって「ハノイの塔」は再帰で解くことができる！


これをもう少しまとめると
hanoi(n)の答えは以下のようになる
&gt;||
hanoi(n) =
         1. n = 0 のときは何もしない,
         2. hanoi(n-1)を求める。但し移動はStart =&gt; Temp,
         3. &quot;円盤nをStartからGoalへ移動する”,
         4. hanoi(n-1)を求める。但し移動はTemp =&gt; Goal
||&lt;


これをRubyで記述してみる
&lt;pre class=&quot;cobalt&quot; style=&quot;background-color:#002444;color:#e6e1dc&quot;&gt;&lt;span class=&quot;line-numbers&quot;&gt;   1 &lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;POLES&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;Start&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;Goal&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;Temp&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   2 &lt;/span&gt; 
&lt;span class=&quot;line-numbers&quot;&gt;   3 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#FFDD00;&quot;&gt;hanoi&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;n&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; from&lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;POLES&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; to&lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;POLES&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   4 &lt;/span&gt;   temp &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;POLES&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;-&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;from&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; to&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;to_s&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   5 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;if&lt;/span&gt; n &lt;span style=&quot;color:#FF9D00;&quot;&gt;==&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   6 &lt;/span&gt;   &lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;hanoi&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;n&lt;span style=&quot;color:#FF9D00;&quot;&gt;-&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; from&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; temp&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   7 &lt;/span&gt;   puts &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;move &lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;n&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;from&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt; =&amp;gt; &lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;to&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   8 &lt;/span&gt;   &lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;hanoi&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;n&lt;span style=&quot;color:#FF9D00;&quot;&gt;-&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; temp&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; to&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   9 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  10 &lt;/span&gt; 
&lt;span class=&quot;line-numbers&quot;&gt;  11 &lt;/span&gt; &lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;hanoi&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  12 &lt;/span&gt; 
&lt;span class=&quot;line-numbers&quot;&gt;  13 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; move 1 Start =&amp;gt; Goal&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  14 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; move 2 Start =&amp;gt; Temp&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  15 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; move 1 Goal =&amp;gt; Temp&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  16 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; move 3 Start =&amp;gt; Goal&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  17 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; move 1 Temp =&amp;gt; Start&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  18 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; move 2 Temp =&amp;gt; Goal&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  19 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; move 1 Start =&amp;gt; Goal&lt;/span&gt;
&lt;/pre&gt;


せっかくだから
円盤をA,B,C,…として
Hanoiクラスも書いてみよう
&lt;pre class=&quot;cobalt&quot; style=&quot;background-color:#002444;color:#e6e1dc&quot;&gt;&lt;span class=&quot;line-numbers&quot;&gt;   1 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color:#FFDD00;&quot;&gt;Hanoi&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   2 &lt;/span&gt;   &lt;span style=&quot;color:#CCCCCC;&quot;&gt;POLES&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;Start&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;Goal&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;Temp&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   3 &lt;/span&gt;   &lt;span style=&quot;color:#CCCCCC;&quot;&gt;DISCS&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;A&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;Z&lt;span style=&quot;color:#E1EFFF;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;to_a&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   4 &lt;/span&gt; 
&lt;span class=&quot;line-numbers&quot;&gt;   5 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#FFDD00;&quot;&gt;initialize&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;n&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   6 &lt;/span&gt;     &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;n&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; n
&lt;span class=&quot;line-numbers&quot;&gt;   7 &lt;/span&gt;     &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;from&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;POLES&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   8 &lt;/span&gt;     &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;to&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;POLES&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;   9 &lt;/span&gt;     &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;cnt&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  10 &lt;/span&gt;     &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;result&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  11 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  12 &lt;/span&gt;   
&lt;span class=&quot;line-numbers&quot;&gt;  13 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#FFDD00;&quot;&gt;steps&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  14 &lt;/span&gt;     &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;result&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  15 &lt;/span&gt;     &lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;hanoi&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;n&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;from&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;to&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  16 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  17 &lt;/span&gt;   
&lt;span class=&quot;line-numbers&quot;&gt;  18 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#FFDD00;&quot;&gt;to_s&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  19 &lt;/span&gt;     &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;result&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  20 &lt;/span&gt;     answer &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  21 &lt;/span&gt;     result &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;hanoi&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;n&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;from&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;to&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  22 &lt;/span&gt;     result&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;each_with_index&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;|&lt;/span&gt;(&lt;span style=&quot;color:#CCCCCC;&quot;&gt;disc&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;from&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;to&lt;/span&gt;)&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  23 &lt;/span&gt;       answer &lt;span style=&quot;color:#FF9D00;&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&quot;color:#3AD900;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;i&lt;span style=&quot;color:#FF9D00;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#80FF82;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;: move &lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;&lt;span style=&quot;color:#EDEF7D;&quot;&gt;DISCS&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;disc&lt;span style=&quot;color:#FF9D00;&quot;&gt;-&lt;/span&gt;&lt;span style=&quot;color:#80FF82;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;from&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt; =&amp;gt; &lt;span style=&quot;color:#9EFF80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#{&lt;/span&gt;to&lt;span style=&quot;color:#E1EFFF;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#80FF82;&quot;&gt;\n&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  24 &lt;/span&gt;     &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  25 &lt;/span&gt;     answer
&lt;span class=&quot;line-numbers&quot;&gt;  26 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  27 &lt;/span&gt;   
&lt;span class=&quot;line-numbers&quot;&gt;  28 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;private&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  29 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#FFDD00;&quot;&gt;hanoi&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;n&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; from&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; to&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  30 &lt;/span&gt;     tmp &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#CCCCCC;&quot;&gt;POLES&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;-&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;from&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; to&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;to_s&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  31 &lt;/span&gt;     &lt;span style=&quot;color:#FF9D00;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;result&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;if&lt;/span&gt; n &lt;span style=&quot;color:#FF9D00;&quot;&gt;==&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  32 &lt;/span&gt;     &lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;hanoi&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;n&lt;span style=&quot;color:#FF9D00;&quot;&gt;-&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; from&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; tmp&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  33 &lt;/span&gt;     &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;cnt&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;+=&lt;/span&gt; &lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  34 &lt;/span&gt;     &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;@&lt;/span&gt;result&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&quot;color:#E1EFFF;&quot;&gt;[&lt;/span&gt;n&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; from&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; to&lt;span style=&quot;color:#E1EFFF;&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  35 &lt;/span&gt;     &lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;hanoi&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;n&lt;span style=&quot;color:#FF9D00;&quot;&gt;-&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; tmp&lt;span style=&quot;color:#E1EFFF;&quot;&gt;,&lt;/span&gt; to&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  36 &lt;/span&gt;   &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  37 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  38 &lt;/span&gt; 
&lt;span class=&quot;line-numbers&quot;&gt;  39 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;if&lt;/span&gt; &lt;span style=&quot;color:#FF80E1;&quot;&gt;__FILE__&lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;==&lt;/span&gt; &lt;span style=&quot;color:#CCCCCC;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;$&lt;/span&gt;0&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  40 &lt;/span&gt;   h &lt;span style=&quot;color:#FF9D00;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#80FFBB;&quot;&gt;Hanoi&lt;/span&gt;&lt;span style=&quot;color:#FFEE80;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#FFDD00;&quot;&gt;new&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#FF628C;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  41 &lt;/span&gt;   puts h
&lt;span class=&quot;line-numbers&quot;&gt;  42 &lt;/span&gt; &lt;span style=&quot;color:#FF9D00;&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  43 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; 1: move A Start =&amp;gt; Goal&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  44 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; 2: move B Start =&amp;gt; Temp&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  45 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; 3: move A Goal =&amp;gt; Temp&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  46 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; 4: move C Start =&amp;gt; Goal&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  47 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; 5: move A Temp =&amp;gt; Start&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  48 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; 6: move B Temp =&amp;gt; Goal&lt;/span&gt;
&lt;span class=&quot;line-numbers&quot;&gt;  49 &lt;/span&gt; &lt;span style=&quot;color:#0088FF;font-style:italic;&quot;&gt;&lt;span style=&quot;color:#E1EFFF;&quot;&gt;#&lt;/span&gt; &amp;gt;&amp;gt; 7: move A Start =&amp;gt; Goal&lt;/span&gt;
&lt;/pre&gt;


Rubyを使って再帰とハノイの塔を勉強したので
それをまとめてみました
参考になればうれしいです


(参考サイト)
[http://www2.cc.niigata-u.ac.jp/~takeuchi/tbasic/BackGround/Hanoi.html:title=再帰的アルゴリズム]
[http://web.hc.keio.ac.jp/~fujimura/2002/lang/lec-n17.html:title=第１７章 再帰的手続き]　他

(追記:2008/7/10)Hanoiクラスを少し修正しました

</body>
</day>
<day date="2008-08-02" title="">
<body>
*p1*Rubyのシンボルは文字列の皮を被った整数だ！
Yugui著「初めてのRuby」を読んでいる
自分はこの本の想定する対象読者ではない
この本の対象読者は他言語プログラマだ
自分はRubyしか知らない
Rubyのこともまだ少ししか知らないアマチュアプログラマだ


けれどもこの本の内容は自分にとって極めて有益だ
初学者向けにありがちな方便としての「ウソ」がない
ちゃんと理解が書かれている
読者を事実に導こうとする努力がある
大見出しこそ他書と差はないが
一歩小見出しに入れば
他ではお目にかかれないような表題が満載で
その内容の多くが知ってはいるけど
正しく理解していなかったものばかりだ


動く疑似コード、DSL、処理系と実行環境、実行モデル
shebang、リソース管理、コールバック、添字代入の裏側
Enumerator、型と自動変換、バックラッシュ記法、Unicode文字
バッククォート文字列、文字リテラル、シンボルの性質と用途
マルチバイト文字列、ファイルのモード、標準入出力、ARGF
ダックタイピング、StringIO、エンコーディング（5章まで）


また文章も読みやすく
タイプミスを含めた間違いも極端に少ないように思う
著者に信頼をおいて読み進めることができる
著者の力量を感じさせる
残りの章を読むのがとても楽しみだ


「初めてのRuby」を読んでいて
シンボルのことが理解できた気がするので
自分の理解を書いてみることにする


**オブジェクト
Ruby空間における操作対象(オペランド)はオブジェクトである
Rubyオペレータはオブジェクトしか取り扱わない
オブジェクトはユーザによって初めてRuby空間に生み出されるが
それはクラスという設計図に従って常に構築される


ユーザは新しいクラスを設計して
それに基づいてオブジェクトを生成することもできるけれども
文字列、数字(整数)、シンボルなどのオペランドは
既にRuby設計者によって設計されたクラスString
Fixnum Symbolに属しているので
簡単にRuby空間に生み出すことができる

&gt;&gt;
  'Charlie'
  183
  :name
&lt;&lt;


**文字列
Ruby空間に生み出されたすべてのオブジェクトは
それぞれが固有のID(object_id)を持っていて
RubyオペレータはこのIDで個々のオブジェクトを管理する


一方ユーザはこのIDにアクセスすることはできるけれども
このIDでオブジェクトを管理することはできない
代わりにユーザは
変数(あるいは定数)という名札をオブジェクトに付けて
これを管理する

&gt;&gt;
  my_name = 'Charlie'
&lt;&lt;

これが文字列のオブジェクトに名札を付ける方法だ
以降ユーザはmy_nameを呼ぶことによって
Charlieオブジェクトにアクセスできるようになる

&gt;&gt;
  me = my_name
&lt;&lt;

このようにして
複数の名札を付けることもできる


世に同名の人が複数存在するように
同名の文字列オブジェクトも複数存在しうる

&gt;&gt;
  his_name = 'Charlie'
&lt;&lt;

これをRuby空間に新たに生成したとき
my_nameとhis_nameは同名のオブジェクトを指しているけれども
それらは異なるIDを備えた異なるオブジェクトである

&gt;&gt;
  my_name.object_id  # =&gt; 8848520
  his_name.object_id  # =&gt; 8827340
&lt;&lt;

だから僕が逆さの国'napaJ'に引っ越して
名前が変わっても彼の名前はそのままだ

&gt;&gt;
  my_name.reverse! # =&gt; &quot;eilrahC&quot;
  me                           # =&gt; &quot;eilrahC&quot;
  his_name                # =&gt; &quot;Charlie&quot;
&lt;&lt;


変数はユーザが文字列オブジェクトを管理するための唯一の方法だ
だから対象の文字列オブジェクトが名札である変数を失うと
ユーザはそれを見失いもう管理できなくなる

&gt;&gt;
  his_name = 'Fox'
&lt;&lt;

このようにCharlieに割り当てた変数his_nameをFoxに割り当て直すと
元のCharlieオブジェクトからはhis_nameの名札が外れる
結果ユーザはCharlieオブジェクトに対するアクセス手段を失う
Charlieオブジェクトのその後を知っているのは
Rubyオペレータのみとなりそのようなオブジェクトは彼が後に破棄する

**数字
整数のオブジェクトに名札を付ける方法も
文字列の場合と変わらない

&gt;&gt;
  my_number = 183
  his_number = 183
&lt;&lt;

だけど文字列の場合と異なって
これらのオブジェクトのIDは同じになる

&gt;&gt;
  my_number.object_id  # =&gt; 367
  his_number.object_id  # =&gt; 367
&lt;&lt;
(Fixnumのみ,Bignum,Floatは別IDとなる)


つまりmy_numberもhis_numberも
一つの183という整数オブジェクトを指している
これはつまり一つのRuby空間には
整数183というオブジェクトは
一つしか存在しないということを意味している


数字は文字列のような個性を持たず
それ自体が変化することは期待されない
だからIDが同じでも問題は生じないということなんだろう


そうすると本来整数には名札を付ける必要すらない
整数に対するオブジェクトは一意であり
ユーザは文字列の場合とは異なって
名札がなくても希望するオブジェクトにアクセスできるからだ
つまりユーザにとって
整数自体がそのオブジェクトの名札の役割を担う


Rubyでは数字にも名札を付けることができるけれども
これは対象オブジェクトの管理のためではなく
もっぱら代数演算の結果を格納する容器としての役割を担っている

&gt;&gt;
  a = 10
  b = a * 3
&lt;&lt;

**シンボル
シンボルは文字列と一対一で対応する記号である
文字列'Charlie'に対応するシンボルは:Charlieとなる
文字列のところで書いたように

&gt;&gt;
  my_name = 'Charlie'
  his_name = 'Charlie'
&lt;&lt;

とした場合
2つの異なるオブジェクトがRuby空間に生成される

&gt;&gt;
  my_name.object_id  # =&gt; 8848520
  his_name.object_id  # =&gt; 8827340
&lt;&lt;

これらのシンボルは以下により得られる

&gt;&gt;
  my_name.intern # =&gt; :Charlie
  his_name.intern # =&gt; :Charlie
&lt;&lt;

当然に異なるオブジェクトのシンボルは
異なるオブジェクトであることが期待される
しかしそうはならない

&gt;&gt;
  my_name.intern.object_id # =&gt; 314378
  his_name.intern.object_id # =&gt; 314378
&lt;&lt;

つまり同一記号のシンボルは同じオブジェクトである
これはつまり一つのRuby空間には
無数の&quot;Charlie&quot;が存在しうるけれども
これに対応する:Charlieというシンボルオブジェクトは
ただ一つしか存在しないということを意味している


そうこれはまるで整数だ


整数と同様にシンボルには名札を付ける必要はない
シンボル記号に対するオブジェクトは一意であり
ユーザは名札がなくても希望するオブジェクトにアクセスできる
つまりシンボル記号自体がそのオブジェクトの名札の役割を担う


ここまで来ればシンボルの正体ははっきりする
文字列のような顔をして
数字のようにそれ自体が名札として機能する


そうシンボルとは…


文字列の皮を被った整数だったんだ！


**シンボルの出番
Rubyには複数の関連するオブジェクトを
ユーザがまとめて管理できるようにするオブジェクトがある
配列とハッシュである

&gt;&gt;
  our_name = [ 'Charlie', 'Fox', 'Henry' ]
&lt;&lt;

これでRuby空間に3つの文字列オブジェクトを管理する
１つの配列オブジェクトが生成され
それにour_nameの名札が付けられる
配列で管理されるオブジェクトへのアクセスは
その位置を表す数字で行なえる

&gt;&gt;
  our_name[1] # =&gt; &quot;Fox&quot;
&lt;&lt;

でも数字には個性がないので
1と”Fox&quot;との間にはその位置以上の関連性はない
できればもっと関連性を持たせて意味付けをしたい


そのような場合シンボルが使える

&gt;&gt;
  our_name = { :my_name =&gt; 'Charlie', :his_name =&gt; 'Fox', :my_nephew =&gt; 'Henry' }
&lt;&lt;

これでRuby空間に3つの文字列オブジェクトを管理する
１つのハッシュオブジェクトが生成され
それにour_nameの名札がつけられる
ハッシュで管理されるオブジェクトへのアクセスは
そのキー値を使って行う

&gt;&gt;
  our_name[:his_name] # =&gt; &quot;Fox&quot;
&lt;&lt;

なおRuby空間では:his_nameは”his_name&quot;に対応しているが
それらは別のオブジェクトなので

&gt;&gt;
  our_name[&quot;his_name&quot;] # =&gt; nil
&lt;&lt;
となる
Rails空間では事情が異なるようだ


シンボルの特性をまとめてみよう
+文字列と一対一に対応した記号である(文字列オブジェクトとシンボルオブジェクトは多対一の関係になる)
+同一記号のシンボルはRuby空間に唯一つ存在する（整数と同様、文字列と相違）
+シンボル記号自体が意味付けを表象できる（文字列と同様、整数と相違）


これらの特性を考えれば
そのオブジェクトの変更が予定されない場合
無駄なオブジェクトが生成されないシンボルは
速度の点で文字列オブジェクトよりも有利であり
またその記号の可読性を高めたい場合
整数オブジェクトよりも有利である


関連記事：
[http://d.hatena.ne.jp/keyesberry/20080809/p1:title=Rubyのブロックはメソッドに対するメソッドのMix-inだ！ - hp12c]
[http://d.hatena.ne.jp/keyesberry/20080812/p1:title=Rubyのyieldは羊の皮を被ったevalだ！ - hp12c]
[http://d.hatena.ne.jp/keyesberry/20080816/p1:title=Rubyのクラスはオブジェクトの母、モジュールはベビーシッター - hp12c]


[asin:4873113679:detail]
</body>
<comments>
<comment>
<username>soiyam</username>
<body>シンボルについて、かなりスッキリしました。「たのしいRuby」よりそちらの方がよさげですね。ありがとうございました。</body>
<timestamp>1273728213</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;soiyamさん&lt;br&gt;お役に立ててうれしいです。</body>
<timestamp>1273730502</timestamp>
</comment>
</comments>
</day>
<day date="2008-08-09" title="">
<body>
*p1*Rubyのブロックはメソッドに対するメソッドのMix-inだ！
Yugui著「初めてのRuby」を読んでいる
7章メソッドにはブロック付きメソッドのことが
丁寧に記述されていて大変参考になる


Rubyのブロックは分かったようで分からない代物だ
スーパーマリオブラザーズのように
間口が広くて奥が深い
少し真剣に向き合ってみた
完全理解にはほど遠いけれども
頭を整理するために
今の理解を書いてみることにする


**引数付きメソッド
Ruby空間における操作対象はオブジェクトである
オブジェクトは外からのメッセージを受け取ると
その中の対応するメソッドを起動して
そこに書かれている手続きを実行する

&gt;|ruby|
  &quot;Charlie&quot;.length  # =&gt; 7が返る
||&lt;

文字列オブジェクト&quot;Charlie&quot;に
メッセージlengthが送られると
対応するlengthメソッドが起動され
7が返される


メソッドは引数を取ることができる
メッセージのカッコ内に収められたオブジェクトは
メソッドに渡されその中で他のオブジェクトと協同することになる


数字、文字列、配列、ハッシュ、範囲などはオブジェクトだから
それを受ける用意があるのなら
当然メソッドに渡すことができる

&gt;|ruby|
  class String
    def speak(word)
      case word
      when Integer
        word.times { print self, &quot; &quot; }
      else
        word.each { |item| print item, &quot;-#{self} &quot; }
      end
    end
  end

&quot;moo&quot;.speak(5)           # =&gt; moo moo moo moo moo 

&quot;moo&quot;.speak(&quot;hello!&quot;)    # =&gt; hello!-moo

&quot;moo&quot;.speak([1, 2, 3])   # =&gt; 1-moo 2-moo 3-moo

&quot;moo&quot;.speak({:love =&gt; 'lettuce',:hate =&gt; 'cucumber'})
             # =&gt; lovelettuce-moo hatecucumber-moo 

&quot;moo&quot;.speak('a'..'h') 
      # =&gt; a-moo b-moo c-moo d-moo e-moo f-moo g-moo h-moo
||&lt;


オブジェクトには変数という名札を付けられるので
変数を付けてメソッドに渡すこともできる

&gt;|ruby|
n = 5
s = &quot;hello!&quot;
a = [1, 2, 3]
h = {:love =&gt; 'lettuce',:hate =&gt; 'cucumber'}
r = 'a'..'h'

&quot;moo&quot;.speak(n)
&quot;moo&quot;.speak(s)
&quot;moo&quot;.speak(a)
&quot;moo&quot;.speak(h)
&quot;moo&quot;.speak(r)   # 結果は同じ
||&lt;

**ブロック
Rubyの構成要素の中に
ブレース { } または do end で表現される
ブロックというものがある
ブロックは一連の手続きをその間に封入する
封入された一連の手続きは一塊のモジュールになる

&gt;|ruby|
  { &quot;block me!&quot; * 3 }

  do
    a = [1,2,3]
    s = &quot;block me!&quot;
    a &lt;&lt; s
  end
||&lt;

一連の手続きもモジュールになれば他のオブジェクトと同様に
メソッドに渡すことができそうだけれども
ブロックはオブジェクトではないので
それはできない

&gt;|ruby|
  &quot;moo&quot;.speak({ &quot;block me!&quot; * 3 })
                # =&gt; エラー(odd number list for Hash)

  &quot;moo&quot;.speak(do
    a = [1,2,3]
    s = &quot;block me!&quot;
    a &lt;&lt; s
  end)                  # =&gt; エラー(syntax error)
||&lt;


変数に代入することもできない

&gt;|ruby|
  b1 = { &quot;block me!&quot; * 3 }  # =&gt; エラー(odd number list for Hash)

  b2 = do
    a = [1,2,3]
    s = &quot;block me!&quot;
    a &lt;&lt; s
  end                  # =&gt; エラー(syntax error)
 
  &quot;moo&quot;.speak(b1)
  &quot;moo&quot;.speak(b2)
||&lt;

**手続きオブジェクト
それならばブロックをオブジェクト化すればいい
ブロックの前にlambda(λ:ラムダ)(Proc.new、procでもよい)を付けると
ブロックは手続きオブジェクト(Proc)になる
オブジェクトになれば引数としてメソッドに渡せるし
変数への代入もできる
手続きオブジェクトになれば
メソッドと離れて存在することもできるようになる

&gt;|ruby|
  class String
    def speak(word)
      word.call.each { |item| print item, &quot;-#{self} &quot; }
               # Procオブジェクトをcallする
    end
  end

  b1 = lambda { &quot;block me!&quot; * 3 }

  b2 = lambda do
    a = [1,2,3]
    s = &quot;block me!&quot;
    a &lt;&lt; s
  end

  &quot;moo&quot;.speak(b1)      # =&gt; block me!block me!block me!-moo

  &quot;moo&quot;.speak(b2)      # =&gt; 1-moo 2-moo 3-moo block me!-moo
||&lt;

Procオブジェクトを受け取ったメソッド内で
callメソッドを呼べば(Ruby1.9ではyieldメソッドも使える)
渡されたブロック内の手続きが実行される


ブロックがオブジェクトになった以上
他のオブジェクトと同様に
機能的にはメソッドに複数渡せるし
配列などに入れてから渡すこともできる


lambdaを使ってメッセージ送信側で
ブロックをオブジェクト化するのに代えて
メッセージ受信側でオブジェクト化する方法もある
メソッド仮引数にアンパサンド &amp; をプリペンドすると
ブロックはここで手続きオブジェクトに変換されて
メソッド内で変数に代入できるようになる

&gt;|ruby|
  class String
    def speak(&amp;word)                      #仮引数に&amp;を付ける
      word.call.each { |item| print item, &quot;-#{self} &quot; }     
    end
  end

  &quot;moo&quot;.speak { &quot;block me!&quot; * 3 }  
                    # =&gt; block me!block me!block me!-moo

  &quot;moo&quot;.speak do
    a = [1,2,3]
    s = &quot;block me!&quot;
    a &lt;&lt; s
  end        # =&gt; 1-moo 2-moo 3-moo block me!-moo
||&lt;

注意点はブロックをメッセージに付けるとき
それをカッコの中に入れてはいけない
メッセージのカッコはオブジェクト引数のためのものであり
まだその時点ではブロックはオブジェクトになっていないからだ
(カッコに入れていないブロックが受側でカッコで受けられるという構文にはちょっと違和感があるけど)


**ブロック付きメソッド
手続きオブジェクトを利用することで
ブロックはメソッドにも渡せるし
変数にも代入できるポータブルなものになった
これこそ純粋オブジェクト指向プログラミングの真骨頂だ


でもその分ユーザは
オブジェクト生成コストを負担しなければいけない
ポータブル性を捨ててもそれを避けたい場合もある


Rubyでは引数とは別に
ブロックを直接メッセージに付ける方法で
これを可能にする(&amp;を用いた場合と同様、引数用のカッコの中にブロックを入れてはいけない)
Rubyは普段オブジェクトしか相手にしないけど
ブロックだけは特別扱いすることにしたのだ
(この点では純粋オブジェクト指向プログラミングの看板に偽りありか？)

&gt;|ruby|
  class String
    def speak
      yield.each { |item| print item, &quot;-#{self} &quot; }  
　　　　　　　 # yieldでブロックを呼ぶ
    end
  end

  &quot;moo&quot;.speak { &quot;block me!&quot; * 3 }
　　　　　      # =&gt; block me!block me!block me!-moo

  &quot;moo&quot;.speak do
    a = [1,2,3]
    s = &quot;block me!&quot;
    a &lt;&lt; s
  end         # =&gt; 1-moo 2-moo 3-moo block me!-moo
||&lt;

メッセージに直接付けたブロックは
オブジェクトのように引数を通してメソッドに渡されるのではなく
メソッド内でキーワードyieldを呼ぶことによって
直接実行される
実行結果は手続きオブジェクトの場合と変わらない


なお手続きオブジェクトをブロックに戻したいときには
メッセージの送信側で先のアンパサンド付き引数が使える

&gt;|ruby|
  block = lambda { |i| print i, &quot; &quot; }

  5.times(&amp;block)            # =&gt; 0 1 2 3 4

  3.upto(10, &amp;block)      # =&gt; 3 4 5 6 7 8 9 10
||&lt;
この例の場合ブロックは手続きオブジェクトの形で送られ
受側メソッドのyieldが呼ばれたときに
ブロックに戻されるようになる(と想像してます)


**ブロックとメソッド
考えてみればブロックはメソッドによく似ている
メソッドだって一連の手続きをモジュール化したものだ
メソッド同様ブロックの戻り値は最後の評価式かreturnの引数だ
(returnはオブジェクト化ブロックでのみ有効)

&gt;|ruby|
  def meth      # メソッド
    a = [1,2,3]
    s = &quot;method me&quot;
    a &lt;&lt; s
  end

  do                  #ブロック
    a = [1,2,3]
    s = &quot;block me!&quot;
    a &lt;&lt; s
  end
||&lt;


メソッドには名前は付き物だけれども
ブロックにはそれがないので


いわばブロックは名無しメソッドだ！


名無しの利点は
彼がそこにいるのだったら
いちいち名前を呼ばなくてもいい
ということなんだろうけど
その利点は僕の理解に余る


メソッドは引数を取れる
だからきっとブロックも取れるに違いない

そうその通り
でもやり方がちょっと違う
ブロックではその内側先頭に用意した垂直バーで挟んで
引数を受け取る

&gt;|ruby|
  def meth(arg)      # メソッド
    a = [1,2,3]
    s = &quot;method me&quot;
    (a &lt;&lt; s) * arg
  end

  do |arg|                 #ブロック
    a = [1,2,3]
    s = &quot;block me!&quot;
    (a &lt;&lt; s) * arg
  end
||&lt;

ブロックはyieldが呼ぶのだから
メソッド呼び出しのように
yieldに付けた引数がブロックに渡されることになる
(手続きオブジェクトを生成した場合はProc#callがブロックを呼ぶのでその場合はcallメソッドにつけた引数)


このときブロックを付けたメッセージに引数も付けて
これがyieldの引数として使われるようにしてもいい

&gt;|ruby|
  class String
    def speak(i)
      yield(i).each { |item| print item, &quot;-#{self} &quot; } 
　　　　　    # メソッドの引数 i をyieldに渡す
    end
  end

  &quot;moo&quot;.speak(2) do |arg|
    a = [1,2,3]
    s = &quot;block me!&quot;
    (a &lt;&lt; s) * arg
  end      
     # =&gt; -moo 2-moo 3-moo block me!-moo 1-moo 2-moo 3-moo block me!-moo
||&lt;

こうするとメッセージに付けた引数が
隣のブロックに直接渡されるように見える
でも実際には引数もブロックもメソッドに渡されて
その中のyieldで橋渡しされる


**ブロックのパワー
メソッドの挙動は通常クラスの設計時にほぼ決まる
でもブロックを使うことで
メソッドに元からある機能は大きく拡張されうる
ブロックはメソッドに後から一連の手続き(メソッド)を差し込める
まるでクラスにモジュールを差し込むみたいに

そうだからブロックは…


メソッドに対するメソッドのMix-inなんだ！


Mix-inの方法には制限はないけれども
渡したブロックを
対象のオブジェクトと密に結合するものと
粗に結合するものとがある


密に結合するものの代表例はイテレータ(繰り返し)である

&gt;|ruby|
  [1, 2, 3].each { |i| print i, &quot; &quot; }     # =&gt; 1 2 3
||&lt;

配列オブジェクトのeachメソッドは
任意の手続きを記述したブロックをとって
この手続きを自身の各要素に順次適用するという処理を施す


eachメソッドの実装等価コードは以下のようになる
&gt;|ruby|
  class Array
    def each
      n = 0
      while n &lt; self.length
        yield self[n]
        n += 1
      end
    end
  end
||&lt;

yieldは配列の各要素1,2,3を順次取って呼び出され
その都度要素を出力する


ブロックの中身を変えれば
元のメソッドの中身は同じでも
得られる結果は大きく変わる
これこそがブロックのパワーだ

&gt;|ruby|
  [1,2,3].each { |i| puts &quot;_R_&quot; * i * i }  

# =&gt; _R_
  _R__R__R__R_
  _R__R__R__R__R__R__R__R__R_
||&lt;

汎用性が認められるのなら
イテレータメソッドを自分で定義してもいい

&gt;|ruby|
  class Array
    def each_after_divide(i)
      n = 0
      while n &lt; self.length
        yield self[n]/i
        n += 1
      end
    end
  end

[1,2,3].each_after_divide(2.0) { |i| print i, &quot; &quot; }
　　　　　     # =&gt; 0.5 1.0 1.5
||&lt;


粗に結合するものの代表例はリソース管理だ
定型的な前処理、後処理を伴うこの種の手続きは
定型処理をメソッドで定義して
可変的な処理の実体をブロックで書いて渡す


ファイルをオープンしクローズする定型処理を
メソッドで記述しておけば
具体的にファイルの中身を処理するコードだけを
ブロックで追加的に書けばいい

**クロージャ
ブロックは名無しのメソッドで
だからほとんどメソッドを記述する気持ちで記述できる
でもちょっと違うところもある


メソッドはdef  endの厚い壁によって
外部の空間とは完全に分断されている
だからメソッドの中からは外にあるローカルな変数は見えない
この厚い壁を透過できるのは
インスタンス変数とそれ以上のグローバルな参照を許している変数
(クラス変数、定数、グローバル変数を指しています)のみだ


インスタンス変数とは特定のオブジェクト内で
他のオブジェクトをグローバル参照できるようにする変数である


一方ブロックのdo end あるいは { } は
それよりも壁が薄くて中から外が見える
つまり外にあるローカルな変数が見える
ブロックの中ではインスタンス変数に頼らずに
外の世界を把握し
場合によってはその状況を変えることができる
(ブロックにおける変数の透過性については「初めてのRuby」に詳しい)


一つのブロックから複数の手続きオブジェクトを生成するとき
個々の手続きオブジェクトは
外のローカル変数が参照するオブジェクトを
その生成時に一緒に閉じこめることができる
それはあたかもオブジェクトがその生成時に
その状態をインスタンス変数に閉じこめるようだ


メソッドに
このようなオブジェクト的な状態保持の機能を持たせたもの
それを一般にはクロージャーというようだ
Rubyのブロックはこの点から見れば
特定のオブジェクトに内包された
簡易なオブジェクト生成機構である

**メソッドオブジェクト
これほどブロックとメソッドとが似たものならば
当然メソッドもメッセージに付けて
他のオブジェクトに渡せないかと考える


RubyではメソッドをMethodオブジェクト化することによって
それもできる
手続きオブジェクトの場合と同じように
メソッドはオブジェクト化されるので
他のオブジェクト同様メッセージの引数として渡せるようになる

&gt;|ruby|
  class String
    def speak(arg, meth)
      meth.call(arg).each { |item| print item, &quot;-#{self} &quot; }
    end
  end

  def my_meth(arg)
    a = [1,2,3]
    s = &quot;hello!&quot;
    (a &lt;&lt; s) * arg 
  end

  &quot;moo&quot;.speak(2, method(:my_meth))　　# methodメソッドを使う
       # =&gt;1-moo 2-moo 3-moo hello!-moo 1-moo 2-moo 3-moo hello!-moo
||&lt;
メソッドのオブジェクト化には
Objectのmethodメソッドを使う


これはあくまでもメソッドなのでブロックと異なり
状態保持の機能はない


ブロック付きメソッドと同じように
メソッドオブジェクトを生成せずに
メソッドを渡す方法もある
Objectのsendメソッドを使う
&gt;|ruby|
  class String
    def speak(meth)
      meth.each { |item| print item, &quot;-#{self} &quot; }
    end
  end

  def my_meth(arg)
    a = [1,2,3]
    s = &quot;hello!&quot;
    (a &lt;&lt; s) * arg 
  end

  &quot;moo&quot;.speak(send(:my_meth, 2))  # sendメソッドを使う
    # =&gt;  1-moo 2-moo 3-moo hello-moo 1-moo 2-moo 3-moo hello!-moo
||&lt;
sendメソッドはメソッド名と共に
引数を同時に取って
そのメソッドの実行結果を返す
だからspeakメソッド内の変数methが
ブロック付きメソッドにおけるyield相当になる


最後にブロックの特性をまとめてみよう
+名前のないメソッドである
+メソッドに後から差し込めるMix-inメソッドである
+望めばオブジェクトになれる未登録オブジェクトである
+外部状態を閉じ込めた簡易オブジェクトあるいはクロージャーである


関連記事：
[http://d.hatena.ne.jp/keyesberry/20080802/p1:title=Rubyのシンボルは文字列の皮を被った整数だ！ - hp12c]
[http://d.hatena.ne.jp/keyesberry/20080812/p1:title=Rubyのyieldは羊の皮を被ったevalだ！ - hp12c]
[http://d.hatena.ne.jp/keyesberry/20080816/p1:title=Rubyのクラスはオブジェクトの母、モジュールはベビーシッター - hp12c]


[asin:4873113679:detail]

</body>
</day>
<day date="2008-08-12" title="">
<body>
*p1*Rubyのyieldは羊の皮を被ったevalだ！

Yugui著「初めてのRuby」の９章に
Rubyの黒魔術の一つとして
eval族と称されるメソッド群が紹介されている


危険らしい
素人が安易に手を出すべきではなさそうだ
でも魅力的らしい


暗黒の世界に引かれていく自分がいる…


勉学のために覗くだけならいいだろうし
危険であればその正しい理解がより重要になるだろう
自分が学んで理解したことをここに整理してみよう


eval族と呼ばれるものには
instance_evalメソッド
class_evalメソッド(またはmodule_eval)
および組み込み関数evalがある


**instance_eval
Ruby空間における操作対象はオブジェクトである
オブジェクトは外からのメッセージを受け取ると
その中の対応するメソッドを起動して
そこに書かれている手続きを実行する


メソッドは他のオブジェクトを引数として取ることができる
引数として渡されたオブジェクトは
メソッドにおいてオブジェクトとして操作され
メソッド内の他のオブジェクトと協同して
その処理の結果をメッセージ送信者に返す


instance_evalメソッドは文字列オブジェクトを
引数として取ることができる
しかしこのメソッドは他の一般的なメソッドとは異なり
これを文字列オブジェクトとしては扱わない
これをRubyの手続きとして扱う

&gt;|ruby|
  [1,2,3].instance_eval &quot;print 'Hello'&quot;   # =&gt; Hello
||&lt;

ここでprintは
トップレベルで実行されているように見えるけれども
&quot;print 'Hello'&quot;はinstance_evalの引数として
配列オブジェクト[1,2,3]に渡されているから
この配列オブジェクト内で実行されている
ということを理解しなければならない


そのことはこうするとよく分かるかもしれない

&gt;|ruby|
  [1,2,3].instance_eval &quot;print reverse&quot;    # =&gt; [3,2,1]
||&lt;

文字列中のreverseは明らかに
メッセージを受け取る配列オブジェクトに適用されている


つまりinstance_evalはオブジェクトの外にいて
オブジェクトの中のコンテキストで
渡された文字列をRubyコードとして評価する


これは確かに恐ろしいことかもしれない
なぜなら完成したプログラムに対して
そのユーザが後からキーボードで文字列を入力することにより
コードを追加し改変し
場合によっては破壊できることを意味するからだ

&gt;|ruby|
  class Account
    @@bank_money = 0
    def initialize(balance)
      @balance = balance
      @@bank_money += @balance
    end
  end

  my_account = Account.new(10000)
  my_account.instance_eval &quot;print @balance = @balance * 100&quot;
        # =&gt;1000000
||&lt;

インスタンス変数@balanceは
my_accountオブジェクトの内部状態を保持する
通常この値にアクセスするには
クラスにそのアクセッサメソッドを用意し
これを介さなければならない

&gt;|ruby|
  def balance
   @balance
  end
  def balance=(amt)
   @balance = amt
  end
または
  attr_accessor :balance
||&lt;

Rubyのようなオブジェクト指向言語では
オブジェクトへのアクセスは原則
用意されたメソッドからしか行えない
これがオブジェクトを予期せぬ変更や破壊から守る


しかしinstance_evalを使えば上のように
アクセッサメソッドを介さずに
インスタンス変数@balanceの参照を変更し
その結果にアクセスすることが可能となる


instance_evalを使えば
メソッド定義も難なくできてしまう

&gt;|ruby|
  my_account = Account.new(10000)
  his_account = Account.new(30000)

  my_account.instance_eval &quot;def transfer_all_to_me; @balance += @@bank_money; end&quot;
   #メソッドを定義する

  my_account.transfer_all_to_me
  my_account.instance_eval &quot;print @balance&quot;
      # =&gt; 50000
||&lt;

transfer_all_to_meは
僕のアカウントオブジェクトのコンテキストで生成されるので((Ruby1.9。Ruby1.8.7ではクラス変数@@bank_moneyがトップレベルのコンテキストで評価されてしまいうまく動作しません。なぜだろう？))
僕のオブジェクト専用のメソッド
つまりSingletonメソッド(抽象メソッド)だ
これで誰かが貯金をするたびに
僕はお金持ちになっていく！


ここでは示されていないけれども
instance_evalを使えば
ユーザから受け取った文字列を名前として
メソッドを動的に定義する
という荒技も可能だ


行指向の文字列には
ヒアドキュメントを使った方が見栄えがいい

&gt;|ruby|
  my_account.instance_eval &lt;&lt;DEF
    def transfer_all_to_me
      @balance += @@bank_money
    end
  DEF
||&lt;

こうすると
まるでブロックを渡しているように見える


期待に違わず
instance_evalはブロックも受け取る
ブロックの中身を
受け取ったオブジェクトのコンテキストで
Rubyコードとして評価する
だから上のコードはこうも書ける

&gt;|ruby|
  my_account.instance_eval do
    def transfer_me_all
      @balance += @@bank_money
    end
  end
||&lt;

当然にブロックには引数を渡したくなる
それが人情というものだ
Ruby1.9ではinstance_execがそれを可能にする

&gt;|ruby|
  my_account.instance_exec(2) do |arg|
    @@bank_money *= arg
    def transfer_me_all_with_double
      @balance += @@bank_money
    end
  end

  my_account.transfer_me_all_with_double
  my_account.instance_eval &quot;print @balance&quot;
      # =&gt; 90000
||&lt;

僕の口座が倍になった！

**class_eval(module_eval)
でもあまりにこれじゃ不公平だ
僕にだって幾らかの良心というものがある
そう思ったらclass_evalを使おう


class_evalは
そのクラスのコンテキストで文字列やブロックを評価する
だからブロックでメソッド定義をすれば
そのメソッドはクラスのインスタンスメソッドになる

&gt;|ruby|
  my_account = Account.new(10000)
  his_account = Account.new(30000)

  Account.class_eval do
    def transfer_all_to_me
      @balance += @@bank_money
    end
  end

  my_account.transfer_all_to_me
  his_account.transfer_all_to_me
  my_account.instance_eval &quot;print @balance&quot;  # =&gt; 50000
  his_account.instance_eval &quot;print @balance&quot;  # =&gt; 70000
||&lt;

これでみんながハッピーになれる！


module_evalはclass_evalと同様に
そのモジュールのコンテキストで文字列やブロックを評価する
これを使えば後からモジュールに
クラスを定義するようなことができる

**eval
Rubyにはオブジェクトを意識しないで使える
evalも用意されている

&gt;|ruby|
  eval &quot;print 'Hello'&quot;  # =&gt; Hello
||&lt;

evalはRubyの組み込み関数
つまりObjectクラスのインスタンスメソッドだ
これはトップレベルオブジェクトmainの
instance_evalと等価になる

&gt;|ruby|
  eval &quot;print self&quot;     # =&gt; main
  self.instance_eval &quot;print self&quot;  # =&gt; main
||&lt;

つまりデフォルトでevalは
mainオブジェクトのコンテキストで
文字列を評価する


でも第２引数に他のコンテキストを持った
Bindingオブジェクトを与えた場合
evalはそのコンテキストで文字列を評価する
これによりevalの実行コンテキストを
トップレベル以外にすることができる

&gt;|ruby|
  class Account
    @@bank_money = 0
    def initialize(balance)
      @balance = balance
      @@bank_money += @balance
    end
    def bind    # accountの環境情報を返すメソッド
      binding
    end
  end

  my_account = Account.new(10000)

  # evalの第２引数にBindingオブジェクトを渡す
  # ヒアドキュメントはこういうときでも便利に使える
  eval(&lt;&lt;DEF, my_account.bind)
   def transfer_all_to_me
     @balance += @@bank_money
   end
  DEF

  my_account.transfer_all_to_me
  my_account.instance_eval &quot;print @balance&quot;
     # =&gt; 20000
||&lt;

これは先の例のinstance_evalの使い方と等価である
evalの第２引数にmy_accountオブジェクトの
コンテキストを渡すことにより
そのコンテキストでブロックを評価する


evalはinstance_evalやclass_evalと異なり
引数にブロックを取れない

**yield
結局eval族は
その引数に与えられた文字列またはブロックを
それが置かれたコンテキストとは別のコンテキストで
評価できるようにするものだ


Rubyにおいてブロックを評価する一般的方法は
ブロックを渡すメソッド内でyieldを呼ぶことである

&gt;|ruby|
  class String
    def speak
      yield
    end
  end

  &quot;Charlie&quot;.speak { print &quot;hello&quot; }  # =&gt; hello
||&lt;

ブロックが評価されるコンテキストは
基本的にそれが置かれたコンテキストだけれど
yieldに引数を取ることによって
これを変えることができる

&gt;|ruby|
  class String
    def speak
      yield
    end
    def talk
      yield self   # selfを引数に取る
    end
  end

  &quot;Charlie&quot;.speak { print self }  # =&gt; main

  &quot;Charlie&quot;.talk { |this| print this }  # =&gt; Charlie
||&lt;

ブロックには当然メソッド定義を置くこともできるので
コンテキストの切替えと共にこれを用いれば
先に示したAccountクラスのインスタンス変数にも
アクセスできるようになる

&gt;|ruby|
  class Account
    def initialize(balance)
      @balance = balance
    end
    def yield_eval   #ブロックを評価するための汎用メソッド
      yield self
    end
  end

  my_account = Account.new(10000)

  my_account.yield_eval do |this|
    def this.add_money(i)
      @balance += i
    end
  end

  p my_account.add_money(10000)    # =&gt; 20000
||&lt;

ここでadd_moneyメソッドは
my_accountオブジェクトのSingletonメソッドである
だからブロックを受ける汎用メソッドを予め用意しておけば
先の例のinstance_eval相当のことができるようになる((先の例におけるクラス変数@@bank_moneyのコンテキストは、yieldを用いる場合なぜかmainのまま変わりません。理由は分かりません。その対応版の作成は断念しました。))


class_eval相当の処理をyieldで実現することもできる。

&gt;|ruby|
  my_account = Account.new(10000)
  his_account = Account.new(30000)

  my_account.yield_eval do
    def add_money(i)
      @balance += i
    end
    public :add_money
  end

  p my_account.add_money(10000)   # =&gt; 20000
  p his_account.add_money(10000)   # =&gt; 40000
||&lt;

ここでyield_evalメソッドは
Accountクラスにadd_moneyメソッドを追加する
これでみんながハッピーになれる！


こうしてみるとyieldは
evalの底知れないパワーには及ばないとしても
プログラミングに高い自由度を与える
強力なツールであることは間違いないし
まだまだ秘められたパワーを持っていそうだ

そう
だからRubyのyieldは…


羊の皮を被ったevalに違いない！


関連記事：
[http://d.hatena.ne.jp/keyesberry/20080802/p1:title=Rubyのシンボルは文字列の皮を被った整数だ！ - hp12c]
[http://d.hatena.ne.jp/keyesberry/20080809/p1:title=Rubyのブロックはメソッドに対するメソッドのMix-inだ！ - hp12c]
[http://d.hatena.ne.jp/keyesberry/20080816/p1:title=Rubyのクラスはオブジェクトの母、モジュールはベビーシッター - hp12c]

</body>
</day>
<day date="2008-08-16" title="">
<body>
*p1*Rubyのクラスはオブジェクトの母、モジュールはベビーシッター

Rubyのクラス、モジュール、オブジェクトの関係を
自分なりにまとめてみた
読みづらいかもしれないけど
だれかの参考になればうれしい

**オブジェクトの種類
Rubyはオブジェクト指向言語であり
Ruby空間に存在するオブジェクトをその操作対象とする
Ruby空間には3種類のオブジェクトすなわち
インスタンスオブジェクト、クラスオブジェクト
そしてモジュールオブジェクトが存在している
これらは通常単に
オブジェクト、クラス、モジュールと呼ばれているけど
ここではそれらのオブジェクトとしての側面を強調したいので
あえてその名称を使おう

**クラスオブジェクト ～クラスとしての側面～
クラスオブジェクトは通常単にクラスと呼ばれ
主にRuby空間に
インスタンスオブジェクトを生み出すために存在する
生み出されるインスタンスオブジェクトのデザインは
クラスオブジェクトに記述されており
しかもユーザがインスタンスオブジェクトにアクセスして
その機能を実現しようとするとき
インスタンスオブジェクトは
クラスオブジェクトからその機能を借り出す


Rubyにはその設計者により
予め多数のクラスオブジェクトが用意されている
これらは組み込みクラスと呼ばれる
ユーザは組み込みクラスを自由に使うことができるけれど
class式を使って独自クラスを定義することもできる

&gt;|ruby|
  class Creature
    def initialize(name)
      @name = name
    end
  end
||&lt;

ユーザがclass式を使って
既存クラスと同名のクラスオブジェクトを定義した場合
それは既存クラスの書き換えではなく拡張となる
その既存クラスが本来持っている機能は失われず
新たな機能がそこに付加される
&gt;|ruby|
  class String
    def speak(word)
     puts word
    end
  end

  my_name = &quot;Charlie&quot;
  my_name.speak('Hello') # =&gt; Hello
  my_name.length  # =&gt; 7
||&lt;

もっとも同名のメソッドを再定義すれば
それは基のメソッドの上書きになるので注意を要する

&gt;|ruby|
  class String
    def length
      &quot;I don't wanna tell you.&quot;
    end
  end

  &quot;Charlie&quot;.length  # =&gt; &quot;I don't wanna tell you.&quot;
||&lt;


特定のクラスオブジェクトから
インスタンスオブジェクトを生成するには
newメソッドを使う

&gt;|ruby|
  class Creature
    def initialize(name)
      @name = name
    end
  end

  # Creatureクラスのnewメソッドでオブジェクトを生成する
  my_pet = Creature.new('Doggie') 
||&lt;


ただ代表的な組み込みクラスでは
リテラル表記を使って
簡易にインスタンスオブジェクトを生成できる

&gt;|ruby|
  # 文字列オブジェクトの生成
  my_name = &quot;Charlie&quot;
  # 整数オブジェクトの生成
  my_age = 195
  # 配列オブジェクトの生成
  my_pets = [ 'Dog', 'Crocodile', 'Hippopotamus' ]
  # ハッシュオブジェクトの生成
  my_favorite = { :number =&gt; 3, :language =&gt; 'Ruby', :color =&gt; 'Blue' } 
  # 範囲オブジェクトの生成
  my_range = 9..21
  # 正規表現オブジェクトの生成
  my_regexp = /ruby/ 
||&lt;


オブジェクトの特性は
そのクラスオブジェクトのメソッド定義でほぼ決まる
メソッドはdef式を使って定義できる

&gt;|ruby|
  class Creature
    def self.description
      &quot;I'm a Creature Class for making creatures.&quot;
    end
    def initialize(name)
      @name = name
    end
    def name
      @name
    end
  end
||&lt;

クラスオブジェクトには
インスタンスオブジェクトのためのInstanceメソッドと
自身のためのselfメソッドとを定義できる


selfメソッドはメソッド名の前に
selfあるいはクラス名を冠することで
Instanceメソッドと区別される
クラスオブジェクトにおけるselfメソッドは
普通クラスメソッドと呼ばれている

&gt;|ruby|
  Creature.description
       # =&gt;  &quot;I'm a Creature Class for making creatures.&quot;
||&lt;


Instanceメソッドはこのクラスオブジェクトから
派生するインスタンスオブジェクトの挙動を決定付ける
つまりクラスオブジェクトから
インスタンスオブジェクトが生成されたとき
Instanceメソッドがあたかも
インスタンスオブジェクト自身が持つメソッドのように振る舞う

&gt;|ruby|
  my_pet = Creature.new('Doggie')
  my_pet.name   # =&gt; &quot;Doggie&quot;
||&lt;


**クラスオブジェクト ～オブジェクトとしての側面～
確かにクラスオブジェクトは
インスタンスオブジェクトを生成するための雛形的なものだ
だけれども同時にクラスオブジェクトは
それ自身もRuby空間に存在するオブジェクトである


インスタンスオブジェクトに
クラスオブジェクトという母があるように
すべてのクラスオブジェクトにも
Classクラスオブジェクトという母がある


つまりすべてのクラスの雛形となっているのは
Classクラスオブジェクトであり
クラスオブジェクトはすべてここから生成されている
classメソッドでこの事実を知ることができる

&gt;|ruby|
  Object.class           # =&gt; Class
  Array.class            # =&gt; Class
  Binding.class          # =&gt; Class
  Continuation.class     # =&gt; Class
  Data.class             # =&gt; Class
  Exception.class        # =&gt; Class
  Dir.class              # =&gt; Class
  File::Stat.class       # =&gt; Class
  Hash.class             # =&gt; Class
  IO.class               # =&gt; Class
  File.class             # =&gt; Class
  MatchData.class        # =&gt; Class
  Method.class           # =&gt; Class
  Module.class           # =&gt; Class
  Numeric.class          # =&gt; Class
  Proc.class             # =&gt; Class
  Process::Status.class  # =&gt; Class
  Range.class            # =&gt; Class
  Regexp.class           # =&gt; Class
  String.class           # =&gt; Class
  Struct.class           # =&gt; Class
  Symbol.class           # =&gt; Class
  Thread.class           # =&gt; Class
  ThreadGroup.class      # =&gt; Class
  Time.class             # =&gt; Class
  UnboundMethod.class    # =&gt; Class
  TrueClass.class        # =&gt; Class
  FalseClass.class       # =&gt; Class
  NilClass.class         # =&gt; Class
||&lt;


驚くべきことに
Classクラスオブジェクトの母も
Classクラスオブジェクト自身である！

&gt;|ruby|
  Class.class            # =&gt; Class
||&lt;

あなたが後から作るクラスオブジェクトも
その母はあなたではなくClassクラスオブジェクトである

&gt;|ruby|
  Creature.class # =&gt; Class
||&lt;

またある特定のクラスのサブクラスも
その母はスーパークラスではなく
Classクラスオブジェクトである

&gt;|ruby|
  class Person &lt; Creature  # CreatureクラスのサブクラスPersonを定義
  end

  Person.class # =&gt; Class
||&lt;

兎にも角にも
あらゆるクラスオブジェクトは
一つのクラスオブジェクトClassから生成されているのだ！


つまりRuby空間には
最初にClassクラスオブジェクトから生成された
Classクラスオブジェクトがあり
そのClassクラスオブジェクトが
次いで他のすべてのクラスオブジェクトを生成し
最後にこの生成された各種のクラスオブジェクトから
インスタンスオブジェクトが生成される
という構図が描かれる


クラスオブジェクトから
インスタンスオブジェクトを生成するときは
newメソッドを使うが
クラスオブジェクトの生成にはその必要はない
規定のクラスオブジェクトについてはおそらく初期化時に
ユーザ定義のクラスオブジェクトについてはclass定義式の解析時に
Rubyが自動で生成する
生成されたクラスオブジェクトには
そのクラス名を冠した定数が付けられ
これによりユーザによる
クラスオブジェクトへのアクセスが可能になる


このことを確認するために
恣意的にClassクラスオブジェクトのnewクラスメソッドを使って
クラスオブジェクトを生成してみよう

&gt;|ruby|
  puts Creature = Class.new(Creature)
        # =&gt;warning: already initialized constant Creature
        # =&gt; Creature
||&lt;

これによりCreature定数には既に
Creatureクラスオブジェクトが
セットされていることが確認できる
なお上記により
Creatureクラスオブジェクトのサブクラスが生成され
それがCreature定数に再設定される


既に書いたがクラスオブジェクトには
自身のためのselfメソッド(クラスメソッド)を定義できる
クラスオブジェクトに対し
クラスメソッドを直接呼び出すことによって
クラスオブジェクト自身にアクセスできる
クラスメソッドは
そこから派生したインスタンスオブジェクト全体を
管理するためなどに使うことができる

&gt;|ruby|
  class Creature
    @@counter = 0
    def initialize(name)
      @name = name
      @@counter += 1
    end

    def self.count
      &quot;You have #{@@counter} creatures.&quot;
    end
  end

  dog = Creature.new('hot')
  alligator = Creature.new('thanks')
  hippopotamus = Creature.new('idiot')
  Creature.count  # =&gt; &quot;You have 3 creatures.&quot;
||&lt;


**継承(Inheritance)
継承とはクラスオブジェクト間の相互依存関係のことである
Rubyではあるクラスオブジェクトが定義したメソッドを
あたかも自分に定義されたもののように
他のクラスオブジェクトが利用できる
利用される側をスーパークラス
利用する側をサブクラスと呼ぶ


他のクラスオブジェクトを利用して
クラスを定義する場合
自分の名前にスーパークラス名を接ぎ木する

&gt;|ruby|
  class Person &lt; Creature  # CreatureクラスのサブクラスPersonを定義
    def initialize(name,age)
      super(name)
      @age = age
    end
    def age
     @age
    end
  end

  me = Person.new('Charlie', 8)
  me.name   # =&gt; &quot;Charlie&quot;
  me.age      # =&gt; 8
||&lt;

こうすれば
サブクラスPersonのインスタンスであるmeオブジェクトでも
自ら定義することなくメソッドnameが使える
つまりme.nameが実行されたとき
このメッセージは最初Personクラスオブジェクトに送られて
そこで対応するnameメソッドが存在しないことが分かると
次いでそのスーパークラスに渡され実行される
(Moduleクラスオブジェクトの話はここでは割愛する)


一般的に言えば
Rubyはメッセージに対応するメソッドが見つかるまで
クラスツリーを遡り
最後にはObjectクラスオブジェクトに至る


一つのクラスオブジェクトは同時並行的に
複数のクラスオブジェクトと継承関係になれない
つまり複数のスーパークラスを同時に持てない
このような制限を
制限のない多重継承に対して単純継承という


しかし他のクラスオブジェクトのサブクラスを
スーパークラスにすることはできる
この数つまり経時直線的な段数に制限はない

&gt;|ruby|
  class PersonInEarth &lt; Person
    def initialize(name, age, country)
      super(name, age)
      @country = country
    end
    def country
      @country
    end
  end

  a_friend = PersonInEarth.new('Fernando', 34, &quot;Spain&quot;)
  a_friend.name    # &gt;&gt; &quot;Fernando&quot;
  a_friend.country # &gt;&gt; &quot;Spain&quot;
||&lt;

誰がスーパークラスかはsuperclassメソッドで調べられる
&gt;|ruby|
  PersonInEarh.superclass # &gt;&gt; Person
||&lt;


Rubyでは継承関係にない
独立したクラスオブジェクトというのは作れない
クラス定義においてスーパークラスを指定しないとき
Rubyは勝手にObjectクラスオブジェクトを
そのスーパークラスにセットする
つまりすべてのクラスオブジェクトは
Objectクラスオブジェクトのサブクラスである
組み込みクラスも例外ではない


何も定義しないクラスでmethodsメソッドを呼べば
それが既にObjectクラスオブジェクトの
サブクラスになっていることが確認できる
(このメソッドを呼べること自体が証拠ですが)

&gt;|ruby|
  class Nothing
  
  end

  n = Nothing.new
  p n.methods 
  # &gt;&gt; [&quot;inspect&quot;, &quot;tap&quot;, &quot;clone&quot;, &quot;public_methods&quot;, &quot;object_id&quot;,  &quot;__send__&quot;, &quot;instance_variable_defined?&quot;, &quot;equal?&quot;, &quot;freeze&quot;,  &quot;extend&quot;, &quot;send&quot;, &quot;methods&quot;, &quot;hash&quot;, &quot;dup&quot;, &quot;to_enum&quot;,  &quot;instance_variables&quot;, &quot;eql?&quot;, &quot;instance_eval&quot;, &quot;id&quot;,  &quot;singleton_methods&quot;, &quot;taint&quot;, &quot;frozen?&quot;, &quot;instance_variable_get&quot;,  &quot;enum_for&quot;, &quot;instance_of?&quot;, &quot;display&quot;, &quot;to_a&quot;, &quot;method&quot;, &quot;type&quot;,  &quot;instance_exec&quot;, &quot;protected_methods&quot;, &quot;==&quot;, &quot;===&quot;,  &quot;instance_variable_set&quot;, &quot;kind_of?&quot;, &quot;respond_to?&quot;, &quot;to_s&quot;,  &quot;class&quot;, &quot;__id__&quot;, &quot;tainted?&quot;, &quot;=~&quot;, &quot;private_methods&quot;,  &quot;untaint&quot;, &quot;nil?&quot;, &quot;is_a?&quot;]
||&lt;

Nothingクラスオブジェクトは
Objectクラスオブジェクトが持っている
すべてのメソッドを継承する


継承はクラスオブジェクト間の師弟制度のようなものである
とりわけRubyの継承は一子相伝
一人がそのすべてを引き継ぐという特徴を有する
この特徴のため
継承関係が成熟しクラス階層が限りなきものになったとしても
Rubyは迷うことなくその末端から頂点つまり
Objectクラスオブジェクトまでを遡ることができる


基本的にサブクラスは
スーパークラスの特性をすべて引き継ぐが
サブクラスにおいて
その一部を拒否したり再定義することは許される

&gt;|ruby|
  class PersonInEarth &lt; Person
    undef :age  # ageメソッドを未定義にする
    alias :name_old :name  #nameメソッドをname_oldに変える

    def initialize(name,age,country)
      super(name,age)
      @country = country
    end
    def country
      @country
    end
    def name   # nameメソッドを再定義する
      &quot;my name is #{name_old}.&quot;
    end
  end

  a_friend = PersonInEarth.new('Fernand', 34, &quot;Spain&quot;)
  p a_friend.name　# &gt;&gt; &quot;my name is Fernand.&quot;
  p a_friend.age
  # ~&gt; -:39: undefined method `age' for #&lt;PersonInEarth:0x23550&gt; (NoMethodError)
||&lt;


**モジュールオブジェクト
単純継承はメソッド探索の複雑さを排除する
一方で継承の本来的意義を低下させうる
仮に異なる系譜の継承クラス群があり
その両方の系譜の特性を持った
クラスオブジェクトを生成したい場合
単純継承ではそれを一方の系譜のサブクラスとし
そこに他方の系譜の特性すべてを一から書き足す必要が生じる
これは継承の目的に反し極めて非生産的だ


Rubyではモジュールオブジェクトがこの問題を最小化する
モジュールオブジェクトは通常単にモジュールと呼ばれる


モジュールオブジェクトは
継承関係に立つことができない独立したクラスオブジェクトである
そこからインスタンスオブジェクトを生成することもできない
モジュールオブジェクトはその中に特定の機能のまとまりを持って
クラスオブジェクトにMix-inつまり挿し木される
モジュールオブジェクトをMix-inしたクラスオブジェクトは
追加的にその機能を獲得することになる

&gt;|ruby|
  module Behavior
    def self.description  # モジュールメソッドの定義
      &quot;I'm a Behavior Module.&quot;
    end
    def sleep  # Instanceメソッドの定義
      &quot;I'm sleeping.&quot;
    end
    def eat
      &quot;I'm eating.&quot;
    end
  end

  class PersonInEarth &lt; Person
    include Behavior  # Behaviorモジュールを読み込む
    def initialize(name,age,country)
      super(name,age)
      @country = country
    end
    def country
      @country
    end
  end

  a_friend = PersonInEarth.new('Fernand', 34, &quot;Spain&quot;)
  a_friend.eat  # &gt;&gt; &quot;I'm eating.&quot;
  a_friend.sleep  # &gt;&gt; &quot;I'm sleeping.&quot;
  Behavior.description  # &gt;&gt; &quot;I'm a Behavior Module.&quot;
||&lt;

モジュールの定義はmodule式で行う
クラスオブジェクトと同様モジュールオブジェクトには
インスタンスオブジェクトのためのInstanceメソッドと
自身のためのselfメソッドとを定義できる
モジュールのselfメソッドは一般にモジュールメソッドと称される


クラスオブジェクトにモジュールオブジェクトを
Mix-inするにはincludeメソッドを使う
これによりあたかも
モジュールオブジェクトで定義したメソッドが
クラスオブジェクトにあるかのように働く
よって
クラスオブジェクトから生成されたインスタンスオブジェクトは
それらのInstanceメソッドを自由に使える


もっともモジュールのselfメソッドが
Mix-in先クラスのselfメソッドとして働くことはない
つまりモジュールメソッドはクラスメソッドにはならない
この点が継承の場合とは異なっている


モジュールオブジェクトのMix-inによって
継承におけるメソッド探索のルートが変わる
モジュールオブジェクトをMix-inした
クラスオブジェクト内が探索されると
そのスーパークラスに先立って
モジュールオブジェクト内が探索される
多重継承におけるようなあいまいさはない
ancestorsメソッドでその順位を確認できる

&gt;|ruby|
  PersonInEarth.ancestors 
   #  &gt;&gt; [PersonInEarth, Behavior, Person, Creature, Object, Kernel, BasicObject]
||&lt;


インスタンスオブジェクトにとって
その母がクラスオブジェクトであるならば
モジュールオブジェクトは
彼のベビーシッターのような存在だ
母に代わって子をヘルプする
ベビーシッターがそうであるように
モジュールオブジェクトは
複数のクラスオブジェクトにおいて掛け持ちされうる


この点に鑑みればモジュールオブジェクトに
特定のインスタンスオブジェクトの属性情報を保持させる
つまりインスタンス変数を持たせることは
危険だということが分かる


なお
モジュールオブジェクトは継承関係には立てないが
モジュールオブジェクトに
他のモジュールオブジェクトをMix-inすることはできる
しかし最終的にモジュールオブジェクトは
クラスオブジェクトにMix-inされ
その継承関係に割り込まなければ機能しない
(ただモジュールメソッドは直接呼ぶことができる)


**インスタンスオブジェクト
インスタンスオブジェクトは
普通単にオブジェクトあるいはインスタンスと呼ばれ
先に書いたようにクラスオブジェクトをnewすることで
Ruby空間に生み出される


Ruby空間では
各種のクラスオブジェクトから生み出された
多数のインスタンスオブジェクトが
順次・分岐・繰り返しの制御構造の中で
相互に働き掛けあうことによって
ユーザの所望する意味のある結果が返される


Rubyではインスタンスオブジェクトが主役である


ところがその存在の重みとは裏腹に
インスタンスオブジェクトの中身はほとんど空である
基本的にインスタンスオブジェクトは
自分の属性情報のみを保持する
他のオブジェクトとの相互作用のための
メソッド群を基本的に保持しない
つまりインスタンスオブジェクトは
自分が何者で誰が親なのかということは知っているけれども
ユーザから送られてくるメッセージの処理方法を知らない


一方インスタンスオブジェクトへのアクセスは
それにメッセージを送ることで達成される
より正確にはメッセージを送る以外に
インスタンスオブジェクトにアクセスする手段はない


結局メッセージを受け取ったインスタンスオブジェクトは
それを自分の生成元のクラスオブジェクトに投げ
彼女がインスタンスオブジェクトに代わって答えを用意する
そのクラスオブジェクト自身が
対応するメソッドを備えていない場合
先に書いたように
モジュールオブジェクトを含むクラスツリーを辿って
メソッドが探索される

&gt;|ruby|
  # a_friendでラベル付けされたオブジェクトにメッセージnameを送る
  a_friend.name
||&lt;


この例でa_friendでラベル付けされたインスタンスオブジェクトは
メッセージnameを受け取るとこれを
その生成元であるPersonInEarthクラスオブジェクトへ送る
(後で述べるSingletonメソッドがある場合はまずそれを探索する)
PersonInEarthでは対応するnameメソッドを呼び出すために
まず自分自身がそれを持っているかが調べられる
次いでそこにincludeしたBehaviorモジュールオブジェクト内が探索される
PersonInEarthおよびBehaviorモジュールは
nameメソッドを持っていないので
メッセージは今度は
そのスーパークラスであるPersonに渡される


ところがPersonクラスオブジェクトも
nameメソッドを備えていないので
メッセージは更に
そのスーパークラスであるCreatureクラスに渡される
そしてここに定義されたnameメソッドが実行され
その結果が順次逆のルートを辿って
a_friendでラベル付けされた
インスタンスオブジェクトからユーザに返される


**Singletonメソッド(抽象メソッド)
インスタンスオブジェクトの中身は
ほとんど空であるということを書いた
しかしインスタンスオブジェクトは
クラスオブジェクトやモジュールオブジェクトと同様に
その内部にselfメソッドを持つことができる
インスタンスオブジェクトにおけるselfメソッドは
Singletonメソッドまたは抽象メソッドと呼ばれる


Singletonメソッドは
そのインスタンスオブジェクト固有のメソッドを
定義するために使われる

&gt;|ruby|
  a_friend = PersonInEarth.new('Fernand', 34, &quot;Spain&quot;)

  def a_friend.name
    &quot;My friend, #{@name}&quot;
  end

  p a_friend.name   # &gt;&gt; &quot;My friend, Fernand&quot;
||&lt;

メソッド定義におけるメソッド名の前に
インスタンスオブジェクトを置くことによって
そのインスタンスオブジェクトの
Singletonメソッドが定義される
Singletonメソッドはクラスツリーの最下層に位置し
メソッド探索において最優先の探索先となる


正確に記せばSingletonメソッドは
そのインスタンスオブジェクト自身に
定義されているのではなく
そのインスタンスオブジェクトと
そのクラスオブジェクトとの間に生成される
無名のクラスに定義される

だからこの無名クラスにSingletonメソッドを定義しても
同様の結果が得られる

&gt;|ruby|
  class &lt;&lt; a_friend
    def name
      &quot;My friend, #{@name}&quot;
    end
  end

  p a_friend.name  # &gt;&gt; &quot;My friend, Fernand&quot;
||&lt;

class名を無名とし
インスタンスオブジェクト名を
二重の接ぎ木記号で繋ぐ(感情的には接ぎ木の向きは逆ですが)
複数のSingletonメソッドをまとめて定義する場合
この書式が有用だ
この無名クラスはSingletonクラスとも呼ばれる


Singletonクラスは
クラスメソッドやモジュールメソッドを
定義する場合にも使える

**extend
なおSingletonクラスはクラスに他ならないので
当然そこにモジュールオブジェクトをMix-inできる

&gt;|ruby|
  module Business
    def job
      &quot;Programmer&quot;
    end
  end

  class &lt;&lt; a_friend
    include Business
  end

  p a_friend.job  # &gt;&gt; &quot;Programmer&quot;
||&lt;

SingletonクラスにMix-inされた
モジュールBusinessのメソッドjobは
インスタンスオブジェクトa_friendのSingletonメソッドになる


でもRubyではもっと簡単にモジュールメソッドを
SingletonメソッドとしてMix-inする方法がある
それがextendだ


SingletonメソッドがSingletonクラスのメソッドを
直接インスタンスオブジェクトに追加できるようにするのと同様
extendはモジュールのメソッドを
直接インスタンスオブジェクトに追加できるようにする

&gt;|ruby|
  a_friend.extend Business
  p a_friend.job  # &gt;&gt; &quot;Programmer&quot;
||&lt;

これによりモジュール内メソッドは
特定のインスタンスオブジェクトの機能になる


**まとめ
最後にクラス、モジュールおよびオブジェクト
の特性を整理しておこう
+すべてのクラスオブジェクトは、Classクラスオブジェクトから生成される
+クラスオブジェクトは、インスタンスオブジェクトの雛形となり、それを生み出す母のような存在である
+それと共にそれ自身もオブジェクトである
+クラスオブジェクトは、インスタンスオブジェクトのためのInstanceメソッドと自身のためのクラスメソッドを持てる
+クラスオブジェクトは、継承によって他のクラスオブジェクトのメソッドを利用できる
+すべてのクラスオブジェクトは継承に係わっていて、その頂点にはObjectクラスオブジェクトがいる
+Rubyの継承は、スーパークラスを唯一つしか持たない単純継承である
+しかし継承の経時直線的な段数には制限はない
+モジュールオブジェクトは、クラスオブジェクトに代わってインスタンスオブジェクトを支援する、ベビーシッターのような存在である
+モジュールオブジェクトは継承関係に係われず、インスタンスオブジェクトを生成することもできない
+モジュールオブジェクト自身もオブジェクトであり、Instanceメソッドの他に自身のためのモジュールメソッドを持てる
+インスタンスオブジェクトは、クラスオブジェクトから生成される
+インスタンスオブジェクトがRuby空間における主役である
+インスタンスオブジェクトには、メッセージ送信以外にアクセス方法がない
+インスタンスオブジェクトに送られたメッセージは、クラスツリーに従って順次クラスオブジェクトに渡される
+インスタンスオブジェクト自身も固有のメソッドを持てる


関連記事：
[http://d.hatena.ne.jp/keyesberry/20080802/p1:title=Rubyのシンボルは文字列の皮を被った整数だ！ - hp12c]
[http://d.hatena.ne.jp/keyesberry/20080809/p1:title=Rubyのブロックはメソッドに対するメソッドのMix-inだ！ - hp12c]
[http://d.hatena.ne.jp/keyesberry/20080812/p1:title=Rubyのyieldは羊の皮を被ったevalだ！ - hp12c]

(追記:2008/8/17) メソッド探索の順位について誤りがあったので訂正しました
(追記:2008/8/27) extendの項目を追加しました

</body>
</day>
<day date="2008-08-27" title="">
<body>
*p1*Rubyのクラスはソフトクリームコーン

みんな大好きソフトクリーム
ソフトとコーンでできている
みんなは最初教えてくれる
コーンは容器と教えてくれる


それに答えてしっかりと
ぼくは正しく記憶する
コーンは容器と記憶する
ソフトの容器と記憶する


でもぼくが
そろそろソフトを食べ終わるとき
それを教えた人たちは
とぼけた顔で白状する
実はコーンも食べれると


そうならば
先にそうだと言ってくれ
コーンもおいしく食べれると
そうすれば
コーンが汚れず済んだのに


みんな大好きRubyのことが
オブジェクトとクラスでできている
みんなは最初教えてくれる
クラスは雛形と教えてくれる


それに答えてしっかりと
ぼくは正しく記憶する
クラスは雛形と記憶する
オブジェクトの雛形と記憶する


でもぼくが
そろそろオブジェクトを理解したとき
それを教えた人たちは
とぼけた顔で白状する
実はクラスもオブジェクトよと


そうならば
先にそうだと言ってくれ
クラスもメソッド呼べるのと
そうすれば
シングルトンとすぐ分かるのに


＊だから
Rubyのクラスはソフトクリームコーン
Rubyのクラスはソフトクリームコーン
容器のようで容器でない
雛形のようで雛形でない


ぼくの覚えが悪いのは
ぼくだけのせいじゃない＊


＊繰り返し


みんな大好きRubyのことが
オブジェクトとクラスでできている
</body>
</day>
<day date="2008-09-05" title="">
<body>
*p1*Rubyのオブジェクトは生物なんかじゃない、トップレベルこそが生物なんだ！
RubyのTopLevelは不思議だ
Rubyはオブジェクト指向言語だから
普通まずクラスでオブジェクトを定義し
これをインスタンス化し
この生まれたオブジェクトにメッセージを送る
という手続きを経てプログラムが組成される

&gt;|ruby|
  class Person
    def initialize(name)
      @name = name
    end
    def name
      @name
    end
  end

  me = Person.new(&quot;Charlie&quot;)
  me.name # =&gt; &quot;Charlie&quot;
||&lt;

でもTopLevelではそんな手続きを吹っ飛ばして
いきなりメソッドが実行できたり書けたりする

&gt;|ruby|
  rand(10) # =&gt; 4

  def hello(name)
    puts &quot;hello, #{name}&quot;
  end
  hello(&quot;Charlie&quot;)
        # &gt;&gt; hello, Charlie
||&lt;

なぜ？
メソッドのレシーバは誰？
此処は一体どこ？


それを知るにはselfが使える

&gt;|ruby|
  self  #  =&gt; main
||&lt;

ここはどうやらmainらしい

Rubyの操作対象はすべてオブジェクトだから
mainもきっとオブジェクトに違いない
とすればIDを持っているはずだ

&gt;|ruby|
  self.object_id # =&gt; 107690
||&lt;

やはりオブジェクトだった
そうなると当然に
その基となるクラスが存在するはずだ

&gt;|ruby|
  self.class  # =&gt; Object
||&lt;

クラスはObjectクラスだった
mainはObjectクラスのインスタンスなんだ
だからObjectクラスに定義されたinstanceメソッドが使えるんだな
他にも使えるメソッドを調べてみよう

&gt;|ruby|
  self.methods.sort # =&gt; [&quot;==&quot;, &quot;===&quot;, &quot;=~&quot;, &quot;__id__&quot;, &quot;__send__&quot;, &quot;class&quot;, &quot;clone&quot;, &quot;display&quot;, &quot;dup&quot;, &quot;enum_for&quot;, &quot;eql?&quot;, &quot;equal?&quot;, &quot;extend&quot;, &quot;freeze&quot;, &quot;frozen?&quot;, &quot;hash&quot;, &quot;id&quot;, &quot;include&quot;, &quot;inspect&quot;, &quot;instance_eval&quot;, &quot;instance_exec&quot;, &quot;instance_of?&quot;, &quot;instance_variable_defined?&quot;, &quot;instance_variable_get&quot;, &quot;instance_variable_set&quot;, &quot;instance_variables&quot;, &quot;is_a?&quot;, &quot;kind_of?&quot;, &quot;method&quot;, &quot;methods&quot;, &quot;nil?&quot;, &quot;object_id&quot;, &quot;private&quot;, &quot;private_methods&quot;, &quot;protected_methods&quot;, &quot;public&quot;, &quot;public_methods&quot;, &quot;respond_to?&quot;, &quot;send&quot;, &quot;singleton_methods&quot;, &quot;taint&quot;, &quot;tainted?&quot;, &quot;tap&quot;, &quot;to_a&quot;, &quot;to_enum&quot;, &quot;to_s&quot;, &quot;type&quot;, &quot;untaint&quot;]
||&lt;

ずいぶんあるけどちょっと変だな
さっき使ったrandも定義したhelloもこのリストにはないぞ

レシーバがはっきりしたんだから
もう一度レシーバを明示してメソッドを呼んでみよう

&gt;|ruby|
  main.rand(10) # =&gt; 
      # ~&gt; -:10: undefined local variable or method `main' for main:Object (NameError)
  main.hello(&quot;Charlie&quot;) # =&gt; 
      # ~&gt; -:10: undefined local variable or method `main' for main:Object (NameError)
||&lt;

だめだ
selfでどうかな

&gt;|ruby|
  self.hello(&quot;Charlie&quot;) # =&gt; 
      # ~&gt; -:10: private method `hello' called for main:Object (NoMethodError)
  self.rand(10) # =&gt; 
      # ~&gt; -:10: private method `rand' called for main:Object (NoMethodError)
||&lt;

あれ？
randもhelloもprivateメソッドて書いてあるぞ！
privateメソッドっていうのは確か
レシーバを明示しては呼び出せないメソッドだったよね
じゃあmainのprivateメソッドのリストを見てみようか

&gt;|ruby|
  self.private_methods.sort # =&gt; [&quot;Array&quot;, &quot;Float&quot;, &quot;Integer&quot;, &quot;String&quot;, &quot;__method__&quot;, &quot;`&quot;, &quot;abort&quot;, &quot;at_exit&quot;, &quot;autoload&quot;, &quot;autoload?&quot;, &quot;binding&quot;, &quot;block_given?&quot;, &quot;callcc&quot;, &quot;caller&quot;, &quot;catch&quot;, &quot;chomp&quot;, &quot;chomp!&quot;, &quot;chop&quot;, &quot;chop!&quot;, &quot;eval&quot;, &quot;exec&quot;, &quot;exit&quot;, &quot;exit!&quot;, &quot;fail&quot;, &quot;fork&quot;, &quot;format&quot;, &quot;getc&quot;, &quot;gets&quot;, &quot;global_variables&quot;, &quot;gsub&quot;, &quot;gsub!&quot;, &quot;hello&quot;, &quot;initialize&quot;, &quot;initialize_copy&quot;, &quot;iterator?&quot;, &quot;lambda&quot;, &quot;load&quot;, &quot;local_variables&quot;, &quot;loop&quot;, &quot;method_missing&quot;, &quot;open&quot;, &quot;p&quot;, &quot;print&quot;, &quot;printf&quot;, &quot;proc&quot;, &quot;putc&quot;, &quot;puts&quot;, &quot;raise&quot;, &quot;rand&quot;, &quot;readline&quot;, &quot;readlines&quot;, &quot;remove_instance_variable&quot;, &quot;require&quot;, &quot;scan&quot;, &quot;select&quot;, &quot;set_trace_func&quot;, &quot;singleton_method_added&quot;, &quot;singleton_method_removed&quot;, &quot;singleton_method_undefined&quot;, &quot;sleep&quot;, &quot;split&quot;, &quot;sprintf&quot;, &quot;srand&quot;, &quot;sub&quot;, &quot;sub!&quot;, &quot;syscall&quot;, &quot;system&quot;, &quot;test&quot;, &quot;throw&quot;, &quot;trace_var&quot;, &quot;trap&quot;, &quot;untrace_var&quot;, &quot;warn&quot;]
||&lt;

リストが長くて見つけられないなあ
じゃあスーパークラスのものを除外して表示してみよう

&gt;|ruby|
  self.private_methods(false) # =&gt; [&quot;initialize&quot;, &quot;hello&quot;]
||&lt;

helloがあったぞ！
でもずいぶんときれいさっぱり他のメソッドが無くなっちゃったね
randも見つからないし
スーパークラスにあるのかな？

あれ？ちょっと待った
mainのクラスはObjectだったよね
それにスーパークラスなんてあるの？

&gt;|ruby|
  Object.superclass # =&gt; nil
||&lt;

やっぱり無い((Ruby1.9ではBasicObjectがある))
じゃあさっきの長いメソッドリストはどこから来たの？

そうか！
きっとモジュールだよ
Objectクラスには他のモジュールがMix-inされていて
そのモジュールにさっきのメソッドたちが定義されてるんだ
調べてみよう

&gt;|ruby|
  Object.included_modules # =&gt; [Kernel]
||&lt;

KernelというモジュールがMix-inされている
じゃあKernelに定義されているprivateなInstanceメソッドをリストしてみよう

&gt;|ruby|
  Kernel.private_instance_methods.sort # =&gt; [&quot;Array&quot;, &quot;Float&quot;, &quot;Integer&quot;, &quot;String&quot;, &quot;__method__&quot;, &quot;`&quot;, &quot;abort&quot;, &quot;at_exit&quot;, &quot;autoload&quot;, &quot;autoload?&quot;, &quot;binding&quot;, &quot;block_given?&quot;, &quot;callcc&quot;, &quot;caller&quot;, &quot;catch&quot;, &quot;chomp&quot;, &quot;chomp!&quot;, &quot;chop&quot;, &quot;chop!&quot;, &quot;eval&quot;, &quot;exec&quot;, &quot;exit&quot;, &quot;exit!&quot;, &quot;fail&quot;, &quot;fork&quot;, &quot;format&quot;, &quot;getc&quot;, &quot;gets&quot;, &quot;global_variables&quot;, &quot;gsub&quot;, &quot;gsub!&quot;, &quot;initialize_copy&quot;, &quot;iterator?&quot;, &quot;lambda&quot;, &quot;load&quot;, &quot;local_variables&quot;, &quot;loop&quot;, &quot;method_missing&quot;, &quot;open&quot;, &quot;p&quot;, &quot;print&quot;, &quot;printf&quot;, &quot;proc&quot;, &quot;putc&quot;, &quot;puts&quot;, &quot;raise&quot;, &quot;rand&quot;, &quot;readline&quot;, &quot;readlines&quot;, &quot;remove_instance_variable&quot;, &quot;require&quot;, &quot;scan&quot;, &quot;select&quot;, &quot;set_trace_func&quot;, &quot;singleton_method_added&quot;, &quot;singleton_method_removed&quot;, &quot;singleton_method_undefined&quot;, &quot;sleep&quot;, &quot;split&quot;, &quot;sprintf&quot;, &quot;srand&quot;, &quot;sub&quot;, &quot;sub!&quot;, &quot;syscall&quot;, &quot;system&quot;, &quot;test&quot;, &quot;throw&quot;, &quot;trace_var&quot;, &quot;trap&quot;, &quot;untrace_var&quot;, &quot;warn&quot;]
||&lt;

今度は目を凝らしてみつけるぞ
randがあったぞ！
randはKernelモジュールに定義されたprivateメソッドだったんだ
するとここに並んでいるメソッドはTopLevelで使えるんだね

じゃあKernelにメソッドを定義して
TopLevelで呼べるか試してみよう

&gt;|ruby|
  module Kernel
    private
    def kernel_private_hello
      &quot;hello of Kernel Private called from #{self}&quot;
    end
  end

  kernel_private_hello # =&gt; &quot;hello of Kernel Private called from main&quot;
||&lt;

うまくいった


でも不思議だなあ
mainはオブジェクトなのに
Kernelのprivateメソッドがなぜ使えるんだろう
ここがObjectクラス内だったら分かるんだけど…
それからなぜオブジェクトにhelloメソッドが定義できたんだろう
メソッド定義はクラスにしかできないと思ってたのに…


もしかして…
そうかSingletonメソッドがあるじゃないか
helloはきっとmainのSingletonメソッドになってるんだよ

&gt;|ruby|
  self.singleton_methods # =&gt; [&quot;public&quot;, &quot;to_s&quot;, &quot;include&quot;, &quot;private&quot;]
||&lt;

違った…
なんか違うの出てきちゃったな


試しにSingletonメソッドをTopLevelで定義して
ここにリストアップされるか見てみよう

&gt;|ruby|
  def self.toplevel_singleton_hello
    &quot;hello of TopLevl Singleton from #{self}}&quot;
  end

  class &lt;&lt; self
    def toplevel_singleton_class_hello
      &quot;hello of TopLevel Singleton Class from #{self}&quot;
    end
  end

  toplevel_singleton_hello # =&gt; &quot;hello of TopLevl Singleton from main}&quot;
  toplevel_singleton_class_hello # =&gt; &quot;hello of TopLevel Singleton Class from main&quot;

  self.singleton_methods # =&gt; [&quot;public&quot;, &quot;toplevel_singleton_class_hello&quot;, &quot;to_s&quot;, &quot;include&quot;, &quot;toplevel_singleton_hello&quot;, &quot;private&quot;]
||&lt;

ちゃんとリストアップされるなあ
やっぱりここはmainオブジェクトだよ


まさか…


ここはObjectクラス？
試しにObjectクラスが持っているprivateなinstanceメソッドを調べてみよう

&gt;|ruby|
  Object.private_instance_methods(false) # =&gt; [&quot;initialize&quot;, &quot;hello&quot;]
||&lt;

あっ！
TopLevelで定義したhelloがある！
つまりここは…
Objectクラスの中なんだ！
これでprivateメソッドが呼べるのにも筋が通る


よしもう一つ確かめてみよう
ここがObjectクラスの中なら
そこに定義されるクラスはネストされたクラスになるはずだ

&gt;|ruby|
  class Nested
  
  end

  Object::Nested # =&gt; Nested
  ::Nested # =&gt; Nested
  Object::Nested.new # =&gt; #&lt;Nested:0x1bf58&gt;
  Object.constants.detect{ |c| c =~ /^Ne/ } # =&gt; &quot;Nested&quot;
||&lt;

確かにObjectにネストされているぞ


これで答えが出た


RubyのTopLevelは
Objectクラスであり
かつ
そのインスタンスであるmainオブジェクトだったんだ！
だからそこでクラスとしてinstanceメソッドを定義でき
しかもそのメソッドをそのインスタンスとして呼び出せる


つまり自身で自身を作るという自己増殖の機能を備えている！


そうRubyのTopLevelは…


生物だったんだ！


不思議の国Rubyでは
ClassクラスがClassクラスを生成するように
TopLevelがTopLevelを生成していたんだ！

</body>
</day>
<day date="2008-09-13" title="">
<body>
*p1*Rubyのクラスとメソッドを全部いっぺんに見たい！
Rubyの組み込みクラスとモジュールと
それらのメソッド群を全部いっぺんに見たい
そんな欲求があるかは知らないけれど
いつもメソッド検索で右往左往している
自分にとっては助けになるはずだ
だからそんなものを作ってみた


スクリプトを実行すると
その実行フォルダに
ruby&lt;RUBY_VERSION&gt;_class_list.htmlというファイルができる
表示されるクラス・メソッドは
実行したRubyのバージョンに対応する


各メソッドは
Rubyリファレンスマニュアルにリンクしているので
そのインタフェースとして使えるかもしれない
使ってくれる人がいたらうれしい


[f:id:keyesberry:20080923182421p:image]


公開サイト：[http://www8.plala.or.jp/abridge/:title=Ruby Class List]


ソースコード：[https://gist.github.com/10357/f66e3cf1375c709de055db89242951cd5551df72:title=gist: 10357 ― GitHub]


2008-9-19追記：Ruby1.86以降に導入されたメソッドのリンクカラーを変えるようにしました。ruby186_methods.datファイルをruby_class_list2html.rbと同じフォルダに置いてください。その他の細かい修正をしました。

2008-9-23追記：メソッドのリンク先を新バージョン・リファレンスマニュアルに変更しました。検索ボックスを追加しました。その他細かい修正をしました。

2008-9-24追記：ネットにアップしました。

2008-9-29追記：ファイル構成の変更、バグ修正をしました。メソッドデータのファイルフォーマットをyamlに変更しました(ruby186_methods.yaml)
</body>
</day>
<day date="2008-09-17" title="">
<body>
*p1*RubyのSymbol#to_procを考えた人になってみる
Rubyのメソッドはブロックを取れる
ブロックはコードの塊だから
その内容に応じてメソッドの挙動を
大きく変化させることができるんだ


例えばinjectメソッドはリストタイプのオブジェクトに対して
たたみこみ演算を実行するものだけれど
これに加算を行うコードブロックを渡せば
injectメソッドはたたみこみ加算器となり

&gt;|ruby|
  (1..10).inject(5) { |mem, var| mem + var }　# =&gt; 60
||&lt;

一方乗算を行うコードブロックを渡せば
たたみこみ乗算器となるんだ

&gt;|ruby|
  (1..5).inject(2) { |mem, var| mem * var }　# =&gt; 240
||&lt;


またmapメソッドはリストの各要素に
同じ評価を与えるものだけれど
これにcapitalizeメソッドのコードブロックを渡せば
mapメソッドはcapitalize変換器となり

&gt;|ruby|
   [&quot;ruby&quot;, &quot;c&quot;, &quot;lisp&quot;, &quot;smalltalk&quot;].map { |item| item.capitalize }      # =&gt; [&quot;Ruby&quot;, &quot;C&quot;, &quot;Lisp&quot;, &quot;Smalltalk&quot;]
||&lt;

一方lengthメソッドのコードブロックを渡せば
長さ演算器となるんだ

&gt;|ruby|
   [&quot;ruby&quot;, &quot;c&quot;, &quot;lisp&quot;, &quot;smalltalk&quot;].map { |item| item.length }       # =&gt; [4, 1, 4, 9]
||&lt;

もちろんブロックにはもっと複雑なコードを渡せる
でも意外と上で示したような単純な演算をさせることが多いよね


そうするとただ各要素の加算をしたり長さを求めるときに
いちいちmemとかitemとかのブロック変数を書くのが面倒くさい


なんとかならないかな…

&gt;|ruby|
  (1..10).inject(5, :+) # =&gt; 60
||&lt;

とか書けたらすてきだなあ…


基の式はこうだから
&gt;|ruby|
  (1..10).inject(5) { |mem, var| mem + var }　# =&gt; 60
||&lt;

こうはなるよね
&gt;|ruby|
  (1..10).inject(5) { |mem, var| mem.send(:+, var) }　# =&gt; 60
||&lt;

Kernelのsendメソッドは
シンボル化されたメソッド名を第1引数に取れるんだ


ブロックをブロックとしてではなく
injectの引数として何とか渡したいなあ


ならブロックをオブジェクト化すればいいんだ

&gt;|ruby|
  (1..10).inject(5, &amp;lambda { |mem, var| mem.send(:+, var) })　# =&gt; 60
||&lt;

メソッドはその引数としてオブジェクトしか受け付けないけど
lambdaでブロックを手続きオブジェクトに変えてやれば
他のオブジェクトと同じようにカッコに入れられる
それで＆(アンパサンド)を前置すれば
呼び出し側(injectメソッド内部)ではブロックに戻されて
ブロックとして評価されるようになる


さて次にこの手続きオブジェクトをどこかに隠したいなあ


そうか
シンボルのメソッドにしちゃえばいいんだよ！
つまりシンボルを
この手続きオブジェクトに変換するメソッドを書けばいいんだ

&gt;|ruby|
  class Symbol
    def to_proc
      lambda { |mem, var| mem.send(:+, var) }
    end
  end

  (1..10).inject(5, &amp;:+.to_proc)　# =&gt; 60
||&lt;


すごいな俺！
これでto_procが取れたら完成なんだけど…

&gt;|ruby|
  class Symbol
    def to_proc
      lambda { |mem, var| mem.send(:+, var) }
    end
  end

  (1..10).inject(5, &amp;:+)　# =&gt; 60
||&lt;

あれ？
取ってもうまくいくぞ
なんで？


そうか暗黙の型変換だよ


＆を前置したからRubyは
それが手続きオブジェクトであると期待したんだ
でもその期待に反して＆を伴っていたのはシンボルだったので
そのオブジェクトに手続きオブジェクトへの変換を要求
つまりto_procメソッドを自動で送信したんだ


できちゃったよ！
ラッキーだな俺！


じゃあ次にmapについても
同じように考えてみよう


基の式はこうだから
&gt;|ruby|
   [&quot;ruby&quot;, &quot;c&quot;, &quot;lisp&quot;, &quot;smalltalk&quot;].map { |item| item.capitalize }
            # =&gt; [&quot;Ruby&quot;, &quot;C&quot;, &quot;Lisp&quot;, &quot;Smalltalk&quot;]
||&lt;

こうはなるよね
&gt;|ruby|
   [&quot;ruby&quot;, &quot;c&quot;, &quot;lisp&quot;, &quot;smalltalk&quot;].map { |item| item.send(:capitalize) }
            # =&gt; [&quot;Ruby&quot;, &quot;C&quot;, &quot;Lisp&quot;, &quot;Smalltalk&quot;]
||&lt;

次にブロックをオブジェクト化する

&gt;|ruby|
   [&quot;ruby&quot;, &quot;c&quot;, &quot;lisp&quot;, &quot;smalltalk&quot;].map(&amp;lambda { |item| item.send(:capitalize) })
            # =&gt; [&quot;Ruby&quot;, &quot;C&quot;, &quot;Lisp&quot;, &quot;Smalltalk&quot;]
||&lt;

それでこの手続きオブジェクトをシンボルのto_procメソッドにすれば完成だ

&gt;|ruby|
  class Symbol
    def to_proc
      lambda { |item| item.send(:capitalize) }
    end
  end

   [&quot;ruby&quot;, &quot;c&quot;, &quot;lisp&quot;, &quot;smalltalk&quot;].map(&amp;:capitalize)
            # =&gt; [&quot;Ruby&quot;, &quot;C&quot;, &quot;Lisp&quot;, &quot;Smalltalk&quot;]
||&lt;

よし！


最後はこのto_procメソッドを一般化しなけりゃ
つまり上の2つの例ではそれぞれのメソッド:+と:capitalizeが
to_procに書かれてしまっている
これらはto_procメソッドの呼びだし元
つまりselfだからこれに置き換えよう

&gt;|ruby|
  class Symbol
    def to_proc
      lambda { |obj, *args| obj.send(self, *args) }
    end
  end
||&lt;

うまいことにRubyのブロックはクロージャとして
外部環境を一緒に閉じ込めるから
to_proc内のブロックにおけるselfは
その呼びだし元(先の例では:+, :capitalize)となる


これでSymbol#to_procの完成だ！


----------------------------------------------------------------

ってか
こういうことを考えつく人は
パッと閃いてサッと書いてしまうんでしょう…
僕はSymbol#to_procをこうやってやっと理解できたのでした


ただここまでくると
こんどはちょっと＆が邪魔に思えてくる
だからやっぱりこう書きたい

&gt;|ruby|
  (1..10).inject(5, :+) # =&gt; 60
||&lt;

あれ？
実行できる…
これは？

&gt;|ruby|
  (1..10).inject(5, '+') # =&gt; 60
||&lt;

これもOKだ
じゃあmapも？
&gt;|ruby|
  [&quot;ruby&quot;, &quot;c&quot;, &quot;lisp&quot;, &quot;smalltalk&quot;].map(:capitalize)
        # =&gt;ArgumentError: wrong number of arguments (1 for 0)
||&lt;

mapはだめだった


Ruby1.9のリファレンスマニュアルを調べてみると…
injectメソッドはシンボルを渡すと
それをメソッドとして呼ぶように実装されていた(([http://doc.loveruby.net/refm/api/view/method/Enumerable/i/inject:title=instance method Enumerable#inject]))


こうなるとmapもなんとかしたい
まずmapの実装等価コードを
mappメソッドとして書いてみる

&gt;|ruby|
  module Enumerable
    def mapp
      i = 0
      while i &lt; self.length
        self[i] = yield self[i]
        i += 1
      end
      self
    end
  end
||&lt;

こんな感じだろうか
&gt;|ruby|
  [&quot;ruby&quot;, &quot;c&quot;, &quot;lisp&quot;, &quot;smalltalk&quot;].mapp(&amp;:capitalize)
            # =&gt; [&quot;Ruby&quot;, &quot;C&quot;, &quot;Lisp&quot;, &quot;Smalltalk&quot;]
  [&quot;ruby&quot;, &quot;c&quot;, &quot;lisp&quot;, &quot;smalltalk&quot;].mapp { |item| item.capitalize }
           # =&gt; [&quot;Ruby&quot;, &quot;C&quot;, &quot;Lisp&quot;, &quot;Smalltalk&quot;]
||&lt;

いいみたいだ


次にブロックが渡されないときの処理を分岐して
その場合には渡された第1引数をメソッドとして呼ぶようにしてみる

&gt;|ruby|
  module Enumerable
    def mapp(*args)
      i = 0
      while i &lt; self.length
        self[i] = block_given? ? yield(self[i]) : self[i].send(args[0])
        i += 1
      end
      self
    end
  end
||&lt;

ブロックの有無の判断にはblock_given?メソッドを使う

&gt;|ruby|
  [&quot;ruby&quot;, &quot;c&quot;, &quot;lisp&quot;, &quot;smalltalk&quot;].mapp(:capitalize)
                # =&gt; [&quot;Ruby&quot;, &quot;C&quot;, &quot;Lisp&quot;, &quot;Smalltalk&quot;]
  [&quot;ruby&quot;, &quot;c&quot;, &quot;lisp&quot;, &quot;smalltalk&quot;].mapp('capitalize')
               # =&gt; [&quot;Ruby&quot;, &quot;C&quot;, &quot;Lisp&quot;, &quot;Smalltalk&quot;]

  [&quot;ruby&quot;, &quot;c&quot;, &quot;lisp&quot;, &quot;smalltalk&quot;].mapp(&amp;:capitalize)
               # =&gt; [&quot;Ruby&quot;, &quot;C&quot;, &quot;Lisp&quot;, &quot;Smalltalk&quot;]
  [&quot;ruby&quot;, &quot;c&quot;, &quot;lisp&quot;, &quot;smalltalk&quot;].mapp { |item| item.capitalize }
               # =&gt; [&quot;Ruby&quot;, &quot;C&quot;, &quot;Lisp&quot;, &quot;Smalltalk&quot;]
||&lt;

うまくいった


ただどういうわけか
mapを再定義して上記を実装するとうまくいかない
自分の理解の限界に来たのでここまでとします


関連記事：[http://d.hatena.ne.jp/keyesberry/20080809/p1:title=Rubyのブロックはメソッドに対するメソッドのMix-inだ！ - hp12c]

</body>
</day>
<day date="2008-09-27" title="">
<body>
*p1*RubyのObjectクラスは過去を再定義するタイムマシンだ！
Objectクラスはすべてのクラスのスーパークラスである
だからObjectクラスに定義されたinstanceメソッドoは
すべてのクラスで定義されたinstanceメソッドoになる

&gt;|ruby|
  class Object
    def o
      'o'
    end
  end
  class MyClass
  end
  Object.new.o # =&gt; &quot;o&quot;
  Array.new.o # =&gt; &quot;o&quot;
  Hash.new.o # =&gt; &quot;o&quot;
  MyClass.new.o # =&gt; &quot;o&quot;
||&lt;

ClassクラスもObjectクラスのサブクラスだから
このinstanceメソッドoは
当然Classクラスのinstanceメソッドoにもなる

&gt;|ruby|
  Class.new.o # =&gt; &quot;o&quot;
||&lt;


一方Classクラスはすべてのクラスの生成クラスである
だからClassクラスのinstanceメソッドとなったoは
すべてのクラスのクラスメソッドself.oになる

&gt;|ruby|
  Array.o # =&gt; &quot;o&quot;
  Hash.o # =&gt; &quot;o&quot;
  MyClass.o # =&gt; &quot;o&quot;
||&lt;

この中には当然Objectクラスが含まれているから
Classクラスのinstanceメソッドoは
Objectクラスのクラスメソッドself.oにもなる

&gt;|ruby|
  Object.o # =&gt; &quot;o&quot;
||&lt;


ところがObjectクラスはClassクラスのスーパークラスだから
Objectクラスのクラスメソッドになったself.oは
Classクラスのクラスメソッドself.oにもなる

&gt;|ruby|
  Class.o # =&gt; &quot;o&quot;
||&lt;


整理しよう
Objectクラスが１つのinstanceメソッドoを持つと
それがClassクラスを含むすべてのクラスのinstanceメソッドoとなり
Objectを含むすべてのクラスのクラスメソッドself.oとなり
Classクラスのクラスメソッドself.oとなる
こうしてRuby空間に存在するすべてのクラスには
instanceメソッドoとクラスメソッドself.oが生まれることとなる


ClassクラスはObjectクラスを含むすべてのクラスの母である
従ってすべてのクラスはClassクラスの特性に依存する
一方でClassクラスはその子であるObjectクラスの弟子である
従ってClassクラスはObjectクラスの特性を受け継ぐ


このような多層的循環構造によって
Objectクラスが変わると
Classクラスが変わり
その変化はすべてのクラスを変える
つまりObjectクラスへのオペレーションは
過去の事実(Classクラス)を再定義し
延いては今の世界(すべてのクラス)を再構築する！


そうRubyのObjectクラスは…


時空を超えて過去を再定義し
世界を再構築するタイムマシンだったんだ！



ところでObjectクラスにはKernelモジュールがincludeされている
モジュールに定義されたinstanceメソッドは
それをincludeしたクラスのものになるから
Kernelモジュールのinstanceメソッドは
Objectクラスのものになる


つまりKernelモジュールはObjectクラスに
過去を変えるためのメソッドを補給する
Kernelモジュールから補給されたメソッドは
Objectクラスに定義されたメソッドとして
同様に過去を再定義し今の世界を再構築する


そうRubyのKernelモジュールは…


タイムマシン補助燃料タンクだったんだ！


関連記事：[http://d.hatena.ne.jp/keyesberry/20080816/p1:title=Rubyのクラスはオブジェクトの母、モジュールはベビーシッター - hp12c]


2008-9-29追記：Kernelモジュールのところを追加しました。

</body>
</day>
<day date="2008-09-30" title="">
<body>
*p1*RubyのModuleクラスはすべてのモジュールの母であり同時にすべてのクラスの父である！
Moduleクラスはすべてのモジュールの生成クラスである
だからModuleクラスに定義されたinstanceメソッドmは
すべてのモジュールで定義されたモジュールメソッドself.mになる

&gt;|ruby|
  class Module
    def m
      'm'
    end
  end
  Module.new.m # =&gt; &quot;m&quot;
  Kernel.m # =&gt; &quot;m&quot;
  Enumerable.m # =&gt; &quot;m&quot;
  Math.m # =&gt; &quot;m&quot;
||&lt;

またModuleクラスはClassクラスのスーパークラスでもある
だからModuleクラスに定義されたinstanceメソッドmは
Classクラスで定義されたinstanceメソッドmになる

&gt;|ruby|
  Class.new.m # =&gt; &quot;m&quot;
||&lt;

ここでClassクラスはすべてのクラスの生成クラスである
だからClassクラスのinstanceメソッドとなったmは
すべてのクラスのクラスメソッドself.mになる

&gt;|ruby|
  Object.m # =&gt; &quot;m&quot;
  Array.m # =&gt; &quot;m&quot;
  class MyClass
  end
  MyClass.m # =&gt; &quot;m&quot;
||&lt;

この中には当然Moduleクラスも含まれているから
Classクラスのinstanceメソッドmは
Moduleクラスのクラスメソッドself.mにもなる

&gt;|ruby|
  Module.m # =&gt; &quot;m&quot;
||&lt;

ところがModuleクラスはClassクラスのスーパークラスだから
Moduleクラスのクラスメソッドになったself.mは
Classクラスのクラスメソッドself.mにもなる

&gt;|ruby|
  Class.m # =&gt; &quot;m&quot;
||&lt;


整理しよう
Moduleクラスが１つのinstanceメソッドmを持つと
それがすべてのモジュールのモジュールメソッドself.mとなり
Classクラスのinstanceメソッドmとなり
ModuleクラスおよびClassクラスを含む
すべてのクラスのクラスメソッドself.mとなる


Moduleクラスはモジュールの生成クラスである
だからClassクラスがすべてのクラスを生み出すように
Moduleクラスはすべてのモジュールを生み出す
そして生み出されたすべてのモジュールは
Moduleクラスの特性に依存する


そうClassクラスがすべてのクラスの母であるなら…


Moduleクラスはすべてのモジュールの母だ！


加えてModuleクラスはClassクラスのスーパークラスである
だからModuleクラスに定義されたすべてのメソッドは
Classクラスで使える
すべてのクラスは
その生成クラスであるClassクラスの影響を受けるので
結果すべてのクラスはModuleクラスの影響を受けることになる
つまりModuleクラスはClassクラスによるクラス生成において
それを支援する極めて重要な役割を担っている


要するにModuleクラスは
すべてのクラスの母であるClassクラスを支える…


すべてのクラスの父なんだ！


そうModuleクラスは
一方で各モジュールの母として彼らを生み出し
他方で各クラスの父としてClassクラスを支えるという
父と母の２つの顔を持った実体だったんだ！


関連記事：[http://d.hatena.ne.jp/keyesberry/20080927/p1:title=RubyのObjectクラスは過去を再定義するタイムマシンだ！ - hp12c]

</body>
</day>
<day date="2008-10-01" title="">
<body>
*p1*Rubyのクラスとメソッドを全部いっぺんに見たい！ - 改訂版

[http://d.hatena.ne.jp/keyesberry/20080913/p1:title=前の投稿]でRubyのメソッド群を
一覧表示するHTMLを生成するコード書いた
これに修正を加えたものを公開したので
使ってくれる人がいたらうれしい


[http://www8.plala.or.jp/abridge/:title=Ruby Methods List]


**説明
-1.8.6、1.8.7、1.9.0の各Rubyバージョン
-クラスタイトルおよび各メソッドは、Rubyリファレンスマニュアルの新バージョンの該当箇所にリンク
-1.9で追加されたメソッドを色分け表示
-標準添付ライブラリのリファレンスへのリンクとRuby関連サイトへのリンク

**スクリプトの使い方
-rb_meth_list2html.rbとrbutils.rbを同じフォルダにおき、rb_meth_list2html.rbを実行
-実行するRubyのバージョンによって、ruby&lt;RUBY_VERSION&gt;_class_list.htmlというファイルができる
-1.9のメソッドを色分け表示させたい場合は、rbutils.rbのruby186_methodsメソッドに自身の環境におけるruby186の実行ファイル名をセットする
-スクリプトの使用は自己責任でお願いします

[f:id:keyesberry:20081001083952p:image]


&lt;script src=&quot;http://gist.github.com/10357.js&quot;&gt;&lt;/script&gt;
</body>
</day>
<day date="2008-10-02" title="">
<body>
*p1*GraphvizでRubyのクラス階層を視覚化しよう！
[http://graphviz.org/:title=Graphviz]というオープンソースのグラフ描画ツールがある
これはマウスを使ってグラフオブジェクトを配置していくような
一般的なグラフツールとは違って
DOTという言語を用いてスクリプトを記述し
そこで表現されたグラフを視覚化するものだ


各要素の配置を望み通りにするのはちょっと難しいけど
スクリプトを書き換えるだけでグラフの修正ができるので
とても自由度が高くて便利だ


このツールを使ってRuby1.9のクラス階層をグラフ化してみた
でき上がった配置には若干の不満はあるけれども
おおむねイメージ通りのものが書けた


でも以下の点がうまくいっていない
-ObjectクラスからGeneralクラスへの継承ラインが必要だが、それを入れると現在の配置が崩れてしまう
-モジュール系をクラス系の右側に配置できない
-ラインの説明文をそれに合わせた色の矢印で示したい


どなたか直せる人がいたらお願いします


[f:id:keyesberry:20081002130058p:image]


&lt;script src=&quot;http://gist.github.com/14242.js&quot;&gt;&lt;/script&gt;
</body>
</day>
<day date="2008-10-22" title="">
<body>
*p1*メソッドが見つからないならRubyに作ってもらえばいいよ！ - If method_missing, define_method by Ruby -

**メソッド定義
Rubyのオブジェクトはメッセージに反応する
つまりオブジェクトがメッセージを受けると
オブジェクトは対応するメソッドを見つけてその結果を返す


Rubyではオブジェクト自身はメソッドを持っていない
だからオブジェクトは自身が属するクラスにアクセスして
対応するメソッドを得てその結果を返す


つまりRubyのメソッドはクラスに定義される


メソッド定義はdef文で行う

&gt;|ruby|
 class Person
   def name(arg)
    &quot;My name is #{arg}&quot;
   end
 end
 my = Person.new
 my.name &quot;Charlie&quot; # =&gt; &quot;My name is Charlie&quot;
||&lt;

特定のクラスで定義されたメソッドは
そのクラスから生成されるオブジェクトで使えるようになる


Rubyではすべてのクラスは
Classクラスから生成されたオブジェクトである
だからClassクラスで定義されたメソッドは
すべてのクラスで使えるようになる

&gt;|ruby|
  class Class
    def mother
      &quot;My mother is #{self.class}&quot;
    end
  end
  class Person
   p mother
  end
    # &gt;&gt; &quot;My mother is Class&quot;
||&lt;

もちろんClassクラスでも！

&gt;|ruby|
  class Class
    p mother
  end
    # &gt;&gt; &quot;My mother is Class&quot;
||&lt;


**singletonクラスでのメソッド定義
通常一つのクラスからは複数のオブジェクトが生成されるので
それらのオブジェクトは同じメソッドを共有することになる
だけど
特定のオブジェクトだけが使えるメソッドを定義したい場合もある


そのためにRubyではsingletonクラス(特異クラス)が用意されている

&gt;|ruby|
  my = Person.new
  his = Person.new
  class &lt;&lt; my
    def secret
      &quot;My account number is #100789&quot;
    end
  end
  my.secret # =&gt; &quot;My account number is #100789&quot;
  his.secret # =&gt; 15: undefined method `secret' for #&lt;Person:0x23168&gt; (NoMethodError)
||&lt;

略記法もある((適切じゃないけど理解を容易にするために))

&gt;|ruby|
  my = Person.new
  def my.secret  #myのselfメソッドにする
    &quot;My account number is #100789&quot;
  end
  my.secret # =&gt; &quot;My account number is #100789&quot;
||&lt;

前にも書いたようにRubyではクラスもオブジェクトだから
クラスに対してもsingletonクラスを用意して
そこでメソッドを定義できる
このsingletonクラスで定義されるメソッドは
そのクラスだけが使えるメソッドになる

&gt;|ruby|
  class Person
  end

  class &lt;&lt; Person
    def secret
      &quot;My secret code is #{self.to_s.reverse}.&quot;
    end
  end
  Person.secret # =&gt; &quot;My secret code is nosreP.&quot;
||&lt;

略記法のほうが広く使われている

&gt;|ruby|
  class Person
    def self.secret
      &quot;My secret code is #{self.to_s.reverse}.&quot;
    end
  end
  Person.secret # =&gt; &quot;My secret code is nosreP.&quot;
||&lt;

このようなクラスが使うメソッドは
一般にクラスメソッドと呼ばれるけれど
機能上普通のオブジェクトが使うメソッドと変わりはない
もちろんClassクラスもオブジェクトだから
singletonクラスを定義できる

&gt;|ruby|
  class Class
    def self.secret
      &quot;My secret code is #{self.to_s.reverse}.&quot;
    end
  end
  Class.secret # =&gt; &quot;My secret code is ssalC.&quot;
||&lt;


**モジュールにおけるメソッド定義
Rubyにはモジュールというクラスに似たオブジェクトがある
モジュールはクラスと違ってオブジェクトを生成できないけれども
そこにメソッドを定義することはできる
特定のクラスに特定のモジュールをincludeすることによって
そのクラスから生成されるオブジェクトにおいて
モジュールに定義されたメソッドが使えるようになる

&gt;|ruby|
  module Secret
    def secret
      &quot;My secret code is #{self.to_s.reverse}.&quot;
    end
  end
  class Person
    include Secret
  end
  my = Person.new
  my.secret # =&gt; &quot;My secret code is &gt;46a32x0:nosreP&lt;#.&quot;
||&lt;

モジュールもクラス同様オブジェクトだから
モジュールに対してもsingletonクラスを定義できる

&gt;|ruby|
  module Secret
  end
  class &lt;&lt; Secret
    def secret
      &quot;My secret code is #{self.to_s.reverse}.&quot;
    end
  end
  Secret.secret # =&gt; &quot;My secret code is terceS.&quot;
||&lt;

クラス同様略記法の方が一般的だ

&gt;|ruby|
  module Secret
    def self.secret
      &quot;My secret code is #{self.to_s.reverse}.&quot;
    end
  end
  Secret.secret # =&gt; &quot;My secret code is terceS.&quot;
||&lt;

モジュールはModuleクラスから生成されるので
Moduleクラスに定義されたメソッドは
すべてのモジュールで使えるようになる

&gt;|ruby|
  class Module
    def secret
      &quot;My secret code is #{self.to_s.reverse}.&quot;
    end
  end
  module Secret
  end
  Secret.secret # =&gt; &quot;My secret code is terceS.&quot;
||&lt;

なおClassクラスはModuleクラスのサブクラスだから
Moduleクラスに定義されたメソッドは
Classクラスに定義されたメソッドとなり
従ってすべてのクラスでも使えるようになる

&gt;|ruby|
  class Module
    def secret
      &quot;My secret code is #{self.to_s.reverse}.&quot;
    end
  end
  class Person
  end
  Person.secret # =&gt; &quot;My secret code is nosreP.&quot;
||&lt;


**動的メソッド定義 -define_method
メソッドはクラスにdef文で定義すると書いた
つまり通常メソッドはクラスの設計時に定義される
だけどメソッドを必要に応じて後から定義したい場合もある


そのような場合メソッド定義をネストすればいい

&gt;|ruby|
  class Person
    def method_maker
      def name(word)
        &quot;My name is #{word}&quot;
      end
    end
  end
  my = Person.new
  my.method_maker
  my.name &quot;Charlie&quot; # =&gt; &quot;My name is Charlie&quot;
||&lt;

こうすれば外側のメソッドが呼ばれたとき
初めて内側のメソッドが定義されるようになる


でもせっかく後から定義するんだから
もっと柔軟に定義できたらうれしい
例えばメソッド名をユーザの入力で決めるとか


それに答えるのがModuleクラスのdefine_methodだ

&gt;|ruby|
  class Person
    def method_maker(meth_name)
      define_method(meth_name) do |word|
        &quot;My #{meth_name} is #{word}.&quot;
      end
    end
  end
  my = Person.new
  my.method_maker(:name)
  my.name &quot;Charlie&quot;
||&lt;

これでmethod_makerによってnameメソッドが作られて
myオブジェクトから呼べるようになる

&gt;|ruby|
  # ~&gt; -:5:in `method_maker': undefined method `define_method' for #&lt;Person:0x23f14&gt; (NoMethodError)
  # ~&gt; 	from -:12
||&lt;


残念ながらこれはうまくいかないようだ
エラーメッセージをよく見ると
Personクラスのオブジェクトに対して
define_methodを呼んでるようだ
つまりdef文の中のコンテキストは
Personクラスのオブジェクトということらしい
確かめてみよう

&gt;|ruby|
  class Person
    def method_maker(meth_name)
      p self
    end
  end
  my = Person.new
  my.method_maker(:name)
    # &gt;&gt; #&lt;Person:0x23c08&gt;
||&lt;

やっぱりそうだ
def文の中ではselfはPersonクラスのオブジェクトになってる
Personクラスにメソッドを定義したいんだからそれじゃだめだ
Personクラスのコンテキストでdefine_methodを呼びたいんだ


こんなときはeval系メソッドが使える
class_evalはクラスのコンテキストで渡されたブロックを評価する
だからPersonクラスに対してclass_evalを呼び出して
そのブロックの中でdefine_methodを定義すればいい

&gt;|ruby|
  class Person
    def method_maker(meth_name)
      Person.class_eval do
        define_method(meth_name) do |word|
          &quot;My #{meth_name} is #{word}.&quot;
        end
      end
    end
  end
  my = Person.new
  my.method_maker(:name)
  my.name &quot;Charlie&quot; # =&gt; &quot;My name is Charlie.&quot;
  my.method_maker(:old_name)
  my.old_name &quot;Henry&quot; # =&gt; &quot;My old_name is Henry.&quot;
  my.method_maker(:size)
  my.size &quot;XXL&quot; # =&gt; &quot;My size is XXL.&quot;
||&lt;


クラスのユーザが後からメソッドを追加できるなんて素敵だ


method_makerに可変長引数を渡せるようにすれば
もう少しよくなる

&gt;|ruby|
  class Person
    def method_maker(*meth_names)
      meth_names.each do |meth_name|
        Person.class_eval do
          define_method(meth_name) do |word|
            &quot;My #{meth_name} is #{word}.&quot;
          end
        end
      end
    end
  end
  my = Person.new
  my.method_maker :name, :old_name, :size
  my.name &quot;Charlie&quot; # =&gt; &quot;My name is Charlie.&quot;
  my.old_name &quot;Henry&quot; # =&gt; &quot;My old_name is Henry.&quot;
  my.size &quot;XXL&quot; # =&gt; &quot;My size is XXL.&quot;
||&lt;

ここでdefine_methodは
Personクラスのコンテキストで評価されているので
Personクラスの特定のオブジェクト(my)で
method_makerを呼ぶと
Personクラスの他のオブジェクトでは
既にname, old_name, sizeの各メソッドが使える

&gt;|ruby|
  his = Person.new
  his.name &quot;Peter&quot; # =&gt; &quot;My name is Peter.&quot;
  his.old_name &quot;arthur&quot; # =&gt; &quot;My old_name is arthur.&quot;
  his.size &quot;M&quot; # =&gt; &quot;My size is M.&quot;
||&lt;


でも各オブジェクト毎に使えるメソッドを変えたい場合もある
そんなときはオブジェクトのsingletonクラスのコンテキストで
define_methodが評価されるようにすればいい

&gt;|ruby|
  class Person
    def method_maker(*meth_names)
      obj_singleton = class &lt;&lt; self; self end
      meth_names.each do |meth_name|
        obj_singleton.class_eval do
          define_method(meth_name) do |word|
            &quot;My #{meth_name} is #{word}.&quot;
          end
        end
      end
    end
  end
  my = Person.new
  my.method_maker :name, :old_name, :size
  my.name &quot;Charlie&quot; # =&gt; &quot;My name is Charlie.&quot;
  my.old_name &quot;Henry&quot; # =&gt; &quot;My old_name is Henry.&quot;
  my.size &quot;XXL&quot; # =&gt; &quot;My size is XXL.&quot;

  his = Person.new
  his.name &quot;Peter&quot; # ~&gt; -:25: undefined method `name' for #&lt;Person:0x1f824&gt; (NoMethodError)

  his.method_maker :name, :age, :address
  his.name &quot;Peter&quot; # =&gt; &quot;My name is Peter.&quot;
  his.age 21 # =&gt; &quot;My age is 21.&quot;
  his.address &quot;New York&quot; # =&gt; &quot;My address is New York.&quot;
||&lt;


**動的メソッド定義 -method_missing
ここまで来ると欲が出てくる
メソッドを追加するのにいちいちmethod_makerメソッドを
呼ばなければならないのはスマートじゃない


そこでmethod_missingメソッドの出番だ
method_missingは呼び出されたメソッドが未定義のときに
Rubyが自動で起動するフックメソッドだ

&gt;|ruby|
  class Person &lt; BasicObject
    def initialize(*meths)
      meths.each { |meth| __send__(meth) }
    end
    def method_missing(meth_name)
      obj_singleton = class &lt;&lt; self; self end
      obj_singleton.class_eval do
        define_method(meth_name) do |word|
          &quot;My #{meth_name} is #{word}.&quot;
        end
      end
    end
  end
  my = Person.new :name, :old_name, :size
  my.name &quot;Charlie&quot; # =&gt; &quot;My name is Charlie.&quot;
  my.old_name &quot;Henry&quot; # =&gt; &quot;My old_name is Henry.&quot;
  my.size &quot;XXL&quot; # =&gt; &quot;My size is XXL.&quot;

  his = Person.new :name, :age, :address, :class
  his.name &quot;Peter&quot; # =&gt; &quot;My name is Peter.&quot;
  his.age 21 # =&gt; &quot;My age is 21.&quot;
  his.address &quot;New York&quot; # =&gt; &quot;My address is New York.&quot;
  his.class &quot;Premier&quot; # =&gt; &quot;My class is Premier.&quot;
||&lt;

上のコードではinitializeメソッドにおいて
引き渡されたメソッド名を呼び出すようにしている
こうすればオブジェクトの生成時にmethod_missingが呼ばれて
対応するメソッドが定義されるようになる


でもユーザがクラス階層にある
既存のメソッドを引き渡した場合
Rubyはそのクラス階層をすべて探索して
そのメソッドを見つけるからmethod_missingは当然呼ばれない
例のようにPersonクラスをBasicObjectのサブクラスにすれば
そのリスクは最小になる(例ではObject#class)


さらにmethod_missingが
定義したメソッドの結果を返すようにすれば
オブジェクト生成時にメソッド名を渡す必要もなくなる

&gt;|ruby|
  class Person &lt; BasicObject
    def method_missing(meth_name, word)
      obj_singleton = class &lt;&lt; self; self end
      obj_singleton.class_eval do
        define_method(meth_name) do |word|
          &quot;My #{meth_name} is #{word}.&quot;
        end
      end
      __send__(&quot;#{meth_name}&quot;, word)  #定義したメソッドを返す
    end
  end
  my = Person.new
  my.name &quot;Charlie&quot; # =&gt; &quot;My name is Charlie.&quot;
  my.old_name &quot;Henry&quot; # =&gt; &quot;My old_name is Henry.&quot;
  my.size &quot;XXL&quot; # =&gt; &quot;My size is XXL.&quot;

  his = Person.new
  his.name &quot;Peter&quot; # =&gt; &quot;My name is Peter.&quot;
  his.age 21 # =&gt; &quot;My age is 21.&quot;
  his.address &quot;New York&quot; # =&gt; &quot;My address is New York.&quot;
  his.class &quot;Premier&quot; # =&gt; &quot;My class is Premier.&quot;
||&lt;


上の例では未定義のinstanceメソッドの呼び出しに対して
method_missingが起動して
対応するinstanceメソッドが定義されるようにした


こうなると未定義のクラスメソッドの呼び出しに対しても
method_missingを起動させて
対応するクラスメソッドを定義できるようにもしたくなる
その場合method_missingおよびdefine_methodを
クラスのsingletonクラスのコンテキスト
つまりクラスメソッドで定義すればいい

&gt;|ruby|
  class Country &lt; BasicObject
    def self.method_missing(meth_name)
      cls_singleton = class &lt;&lt; self; self end
      cls_singleton.class_eval do
        define_method(meth_name) do |word|
          instance_variable_set(&quot;@#{meth_name}&quot;, word)
        end
      end
    end
    capital; language; population
  end

  class Japan &lt; Country
    capital &quot;Tokyo&quot;
    language &quot;Japanese&quot;
    population 127433494
    def self.to_s
      &quot;Japan\n Capital: #{@capital}\n Language: #{@language}\n Population: #{@population}&quot;
    end
  end

  class Denmark &lt; Country
    capital &quot;Copenhagen&quot;
    language &quot;Danish&quot;
    population 5475791
    def self.to_s
      &quot;Denmark\n Capital: #{@capital}\n Language: #{@language}\n Population: #{@population}&quot;
    end
  end
  puts Japan
  puts Denmark

  # =&gt;
    Japan
      Capital: Tokyo
      Language: Japanese
      Population: 127433494
    Denmark
      Capital: Copenhagen
      Language: Danish
      Population: 5475791
||&lt;

この例ではCountryクラスの最後で
クラスメソッドを呼ぶことでそれらを定義し
CountryクラスのサブクラスであるJapanとDenmarkで
それらのメソッドを使っている
定義したメソッドはメソッド名のインスタンス変数に引数をセットする


なおBasicObjectは他のクラス同様
Classクラスのオブジェクトなので
instanceメソッドの場合と異なって
そこから継承された多数のクラスメソッドがある
だからそれらとの衝突が起きないよう注意が必要だ

**まとめ
+メソッドはクラスに定義される
+クラスに定義されるメソッドはそのクラスから生成される各オブジェクトで使える
+クラスはClassクラスのオブジェクト(インスタンス)だからClassクラスに定義されたメソッドは各クラスで使える
+singletonクラスに定義されるメソッドはそのオブジェクト専用になる
+クラスメソッドとはクラスのsingletonクラスに定義されたメソッドである
+モジュールに定義されるメソッドはそれがincludeされたクラスのオブジェクト(インスタンス)で使える
+メソッド定義をネストすれば外側のメソッドが呼ばれたときに内側のメソッドが定義されるようになる
+class_evalとdefine_methodを使って動的にメソッドを定義できる
+method_missingを使って自動的にメソッドが生成されるようにできる


追記2008-10-26：Countryクラスでclass_variable_setでなくinstance_variable_setを使うよう修正。

</body>
</day>
<day date="2009-01-11" title="">
<body>
*p1*Rubyでフィボナッチ、トリボナッチ、テトラナッチ！そして僕はヒトリボッチ
&lt;a href=&quot;http://d.hatena.ne.jp/torikobito/20090108/1231398740&quot;&gt;ぴえろっちが問題をくれた。その１ - とりこびとの雑記&lt;/a&gt;
&gt;&gt;
フィボナッチ数列の項は前の2つの項の和である。最初の2項を 1, 2 とすれば、最初の10項は以下の通りである。 

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

数列の項が400万を超えない範囲で、偶数の項の総和を求めよ。
&lt;&lt;
&lt;a href=&quot;http://d.hatena.ne.jp/rurar/20090109/1231505507&quot;&gt;配列を入れたら最初の項を好きなのにできるようにしてみた。 - るーごん☆151☆&lt;/a&gt;


刺激を受けてやってみた
&gt;|ruby|
 def fibo_even_sum(max, a=1, b=2)
   sum = 0
   loop do
     break if a &gt;= max
     sum += a if a.even?
     a, b = b, a + b
   end
   sum
 end
 fibo_even_sum 400_0000 # =&gt; 4613732
||&lt;


一旦フィボナッチ数列を求めてから版

&gt;|ruby|
 def fibo_by_max(max, seq=[1,2])
   loop do
     _next = seq[-2] + seq[-1]
     break if _next &gt;= max
     seq &lt;&lt; _next
   end
   seq
 end
 fibo_by_max 400_0000 # =&gt; [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578]
 fibo_by_max(400_0000).inject(0) { |mem, var| var.even? ? mem + var : mem } # =&gt; 4613732
||&lt;


フィボナッチの仲間に
トリボナッチ、テトラナッチというのがあるそうだ

&gt;&gt;
フィボナッチ数列が「前の2項の和」なのに対し、トリボナッチ数列は「前の3項の和」である。
フィボナッチ数列が「前の2項の和」、トリボナッチ数列が「前の3項の和」なのに対し、テトラナッチ数列は「前の4項の和」である。
   -Wikipediaより
&lt;&lt;


それらに対応した版
&gt;|ruby|
 def fibo_tribo_tetra_by_max(max, *seq)
   seq = [0, 1] if seq.empty?
   l = seq.length
   loop do
     _next = seq[-l..-1].inject(:+)
     break if _next &gt;= max
     seq &lt;&lt; _next
   end
   seq
 end
 #fibonacci
 fibo_tribo_tetra_by_max 400_0000 # =&gt; [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578]
 #tribonacci
 fibo_tribo_tetra_by_max 400_0000, 0, 0, 1 # =&gt; [0, 0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757]
 #tetranacci
 fibo_tribo_tetra_by_max 400_0000, 0, 0, 0, 1 # =&gt; [0, 0, 0, 1, 1, 2, 4, 8, 15, 29, 56, 108, 208, 401, 773, 1490, 2872, 5536, 10671, 20569, 39648, 76424, 147312, 283953, 547337, 1055026, 2033628, 3919944]
||&lt;


ついでにｎ項目のフィボナッチ数を求める版
&gt;|ruby|
 def fibo_by_nth(nth, a=0, b=1)
   nth.times do |n|
     a, b = b, a + b
   end
   a
 end
 fibo_by_nth 33 # =&gt; 3524578
||&lt;


その再帰版
&gt;|ruby|
 def fibo_by_nth(nth, a=0, b=1)
   case nth
   when 0
     a
   when 1
     b
   else
     fibo_by_nth(nth-1) + fibo_by_nth(nth-2)
   end
 end
 fibo_by_nth 33 # =&gt; 3524578
||&lt;
再帰版は遅い


再帰でｎ項目までのフィボナッチ数列を求める版
こちらのほうが早い
&gt;|ruby|
 def fibo_by_nth(nth)
   case nth
   when 0
     [0]
   when 1
     [0, 1]
   else
     result = fibo_by_nth(nth-1)
     result &lt;&lt; result[-2] + result[-1]
   end
 end
 fibo_by_nth2 33 # =&gt; [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578]
||&lt;


[http://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0:title=フィボナッチ数 - Wikipedia]

</body>
</day>
<day date="2009-01-13" title="">
<body>
*p4*Rubyで素因数を求める ～Rubyでオイラープロジェクトを解こう！Problem3
[http://projecteuler.net/index.php?section=problems&amp;id=3:title=Problem 3 - Project Eulerより]
&gt;&gt;
 The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the number 600851475143 ?
13195の素因数は、5、7、13および29である。
では600851475143の最大の素因数はいくらか。
&lt;&lt;

[http://ja.wikipedia.org/wiki/%E7%B4%A0%E5%9B%A0%E6%95%B0:title=素因数 - Wikipedia]
&gt;&gt;
素因数は自然数で、ある自然数の約数になる素数である。
&lt;&lt;

最小の素数から対象の数を割って
割り切れる素数を順次見つけ出す

&gt;|ruby|
 def prime_factor(n)
   prime = 2
   result = []
   loop do
     break if n &lt; prime
     while n.modulo(prime).zero?
       n = n / prime
       result &lt;&lt; prime
     end
     prime = next_prime(prime)
   end
   result
 end

 def next_prime(prime)
   _next = prime + 1
   loop do
     return _next if prime?(_next)
     _next += 1
   end
 end

 def prime?(n)
   2.upto(n-1) do |i|
     return false if n.modulo(i).zero?
   end
   true
 end

primes = prime_factor(600851475143) # =&gt; [71, 839, 1471, 6857]
primes.last # =&gt; 6857
||&lt;

*p3*Rubyでフィボナッチ数列を求める ～Rubyでオイラープロジェクトを解こう！Problem2
[http://projecteuler.net/index.php?section=problems&amp;id=2:title=Problem 2 - Project Eulerより]
&gt;&gt;
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
Find the sum of all the even-valued terms in the sequence which do not exceed four million.
フィボナッチ数列の項は前の2つの項の和である。 最初の2項を 1, 2 とすれば、最初の10項は以下の通りである。
 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
数列の項が400万を超えない範囲で、偶数の項の総和を求めよ。
&lt;&lt;

[http://d.hatena.ne.jp/keyesberry/20090111/p1:title=先日解いた問題]はここの問題だった

&gt;|ruby|
def fibo_even_sum(max, a=1, b=2)
  sum = 0
  loop do
    break if a &gt;= max
    sum += a if a.even?
    a, b = b, a + b
  end
  sum
end
fibo_even_sum 400_0000 # =&gt; 4613732
||&lt;

*p2*Rubyで3と5の倍数を求める ～Rubyでオイラープロジェクトを解こう！Problem1
[http://projecteuler.net/index.php?section=problems&amp;id=1:title=Problem 1 - Project Eulerより]
&gt;&gt;
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.
10未満の自然数で3または5の倍数であるものは、3、5、6および9であり、それらの合計は23である。
では1,000未満で3または5の倍数であるものの合計はいくらか。
&lt;&lt;


[http://projecteuler.net/index.php?section=about:title=Project Euler]というものがあることを知った
刺激されてやってみた

&gt;|ruby|
 def multi_of_three_or_five_upto(max)
   sum = 0
   1.upto(max-1) do |n|
     sum += n if (n % 3).zero? or (n % 5).zero?
   end
   sum
 end

 multi_of_three_or_five_upto 1000 # =&gt; 233168
||&lt;

*p1*効率的市場仮説はそれを信じない者へのご褒美である

[http://ja.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E5%B8%82%E5%A0%B4:title=効率的市場仮説　～Wikipediaより]
&gt;&gt;
市場参加者は利用可能なすべての情報を迅速に取り入れており、新規情報によって他の市場参加者より有利になるという状況は生じないため、市場の挙動はランダムウォークになるという仮説。
&lt;&lt;


株券は紙幣同様信用ベースの資産であり
長期的に株価はその企業の内在価値に相関すると信じられている
その企業が将来上げるであろう利益の総額を
現在価値に割り引いた価額を一株当たりで見れば
おおよその理論株価になる


効率的市場仮説に従えば
ある企業の株価が
この理論株価を下回れば直ちに買いが入り
上回れば直ちに売りが入って
その結果株価は常に理論株価に均衡することになる


ところが企業の将来利益を算出することは
まだ起きていない未来を予想することに他ならないから
その算出は極めて困難であり
結果は算出者によってまちまちである


そのため株価は思惑に反して理論株価に均衡せず
大なるマーケット参加者たちの算出した株価の平均値に収束する
もちろん企業の将来利益は
彼らの合意によって決まるわけではないから
株価は通常ミスプライスされている


バブルが発生したり100年に一度の金融危機が訪れると
マーケット参加者の思考は
理論株価のことを忘れて直近の株価へ向かう
明日株が上がるという理由で株が買われ
明日下がるという理由で売られる
つまり株価を決めるのは
もはや信用ベースの理論株価ではなくなり
マーケット参加者の個別合理的な行動である
その結果ミスプライスの幅は肥大する


しかしながら効率的市場仮説を信じる限り
株価は常に理論株価にあるから
金融危機で株価が暴落しようとも
期待リターンは一定であり投資リスクは変わらないか
ボラティリティが増加してリスクが増えることになる


それが誤りであることは現場を見ればわかる


おそらく効率的市場仮説はそれを信じない者に
投資機会を与えるためのプロパガンダであり
ご褒美なのだろう

</body>
</day>
<day date="2009-01-14" title="">
<body>
*p1*Rubyで回文数を求める ～Rubyでオイラープロジェクトを解こう！Problem4
[http://projecteuler.net/index.php?section=problems&amp;id=4:title=Problem 4 - Project Eulerより]
&gt;&gt;
A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91  99.
Find the largest palindrome made from the product of two 3-digit numbers.
回文数はどちらからでも同じに読める。2つの二桁の数の積からできる最大の回文数は9009 = 91 × 99である。
2つの三桁の数の積からできる最大の回文数を求めよ。
&lt;&lt;


なんかスマートではありません…


（チョンボなところ）

+計算量を減らすため任意のlimitを使っている
+数字を文字列に変換して回文数を見つけている

&gt;|ruby|
def max_palindrome_from(digits)
  base = 10 ** digits - 1
  limit = base &gt;= 9999 ? base - 1000 : base - 10 ** (digits-1)
  a, b = base, base
  candidate = 0
  loop do
    multi = a * b
    if multi.to_s == multi.to_s.reverse
      if multi &gt; candidate
        candidate = multi
      end
    end
    b -= 1
    case 
    when b &lt;= limit
      b = base
      a -= 1
    when a &lt;= limit
      break
    end
  end
  candidate
end

max_palindrome_from(3) # =&gt; 906609
||&lt;

</body>
</day>
<day date="2009-01-15" title="">
<body>
*p1*Rubyで最小公倍数を求める ～Rubyでオイラープロジェクトを解こう！Problem5
[http://projecteuler.net/index.php?section=problems&amp;id=5:title=Problem 5 - Project Eulerより]
&gt;&gt;
2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest number that is evenly divisible by all of the numbers from 1 to 20?
2520は1から10の各数字で割り切れる数の中で最小のものである。
同様に1から20の全ての数字で割り切れる最小の数は何か。
&lt;&lt;


素直に20より大きい数字を順に1から20で割って
割り切れるものを見つける

&gt;|ruby|
 def find_divisible(max)
   n = max
   loop do
     break n if divisible_all?(n, max)
     n += 1
   end
   n
 end

 def divisible_all?(number, max=10)
   1.upto(max) do |n|
     return false if number.modulo(n) != 0
   end
   true
 end

 t = Time.now
 find_divisible(20) # =&gt; 232792560
 Time.now - t # =&gt; 504.792946
||&lt;

500秒！
遅すぎる！
別のやり方ないかな


全ての数で割り切れるというのは…
要するに最小公倍数のことだよね？


[http://ja.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0:title=最小公倍数] - Wikipediaより
&gt;&gt;
二つの整数に対して、どちらの倍数にもなっている最小の自然数をいう。
&lt;&lt;

じゃあその求め方は？

&gt;&gt;
最小公倍数の計算には、最大公約数 GCD (Greatest Common Divisor) を用いて行う。どちらも 0 でない整数 a, b に対して、最小公倍数は、最大公約数 gcd(a, b) を用いて、
[f:id:keyesberry:20090115082304p:image]

二つの数に限らず、より多くの数の最小公倍数を求めたい場合は、上記のlcm関数を入れ子にすればよい。
&lt;&lt;

なるほどなるほど
じゃあこれを入れ子にして
1から20の全てを求めればいいんだな
最大公約数は割り算を繰り返せば求められそうだ


最小公倍数を使った版
&gt;|ruby|
 def find_divisible(max)
   case max
   when 2
     lcm(1, 2)
   else
     lcm(find_divisible(max-1), max)
   end
 end

 def lcm(a, b)
   a * b / gcd(a, b)
 end

 def gcd(a, b)
   a, b = b, a if a &lt; b
   return a if b == 0
   _mod = a.modulo(b)
   if _mod == 0
     b
   else
     gcd(b, _mod)
   end
 end

 t = Time.now
 find_divisible 20 # =&gt; 232792560
 Time.now - t # =&gt; 0.000371
||&lt;

断然速いぞ！


Rubyのリファレンスをよく見たら…
Rationalという便利なライブラリーがあったのですね
&gt;|ruby|
require &quot;rational&quot;

def find_divisible(max)
  case max
  when 2
    2.lcm(1)
  else
    max.lcm(find_divisible(max-1))
  end
end

find_divisible 20 # =&gt; 232792560
||&lt;
あれ？Ruby1.9ではrequireも不要みたいな…

</body>
</day>
<day date="2009-01-16" title="">
<body>
*p1*Rubyでエラトステネス ～Rubyでオイラープロジェクトを解こう！Problem7
[http://projecteuler.net/index.php?section=problems&amp;id=7:title=Problem 7 - Project Eulerより]
&gt;&gt;
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
What is the 10001st prime number?
最初の6つの素数2、3、5、7、11、および13を並べれば、6番目が13であることがわかる。
では10001番目の素数は何か。
&lt;&lt;


[http://d.hatena.ne.jp/keyesberry/20090113/p4:title=Rubyで素因数を求める]で書いた
next_primeメソッドとprime?メソッドをそのまま使おう

&gt;|ruby|
 def nth_prime(nth)
   prime = 1
   n = 1
   until n &gt; nth
     prime = next_prime(prime)
     n += 1
   end
   prime
 end

 def next_prime(prime)
   _next = prime + 1
   loop do
     return _next if prime?(_next)
     _next += 1
   end
 end

 def prime?(n)
   2.upto(n-1) do |i|
     return false if n.modulo(i).zero?
   end
   true
 end

 t = Time.now
 nth_prime 10001 # =&gt; 104743
 Time.now - t # =&gt; 263.424058
||&lt;

ちょっと時間が掛かる…


数字を小さくしてプロファイルを見る
&gt;|
ruby -r profile p7.rb 

  %   cumulative   self              self     total
 time   seconds   seconds    calls  ms/call  ms/call  name
 63.80   172.72    172.72     1000   172.72   267.66  Integer#upto
 17.90   221.19     48.47  3711627     0.01     0.01  Fixnum#modulo
 17.42   268.34     47.15  3711627     0.01     0.01  Fixnum#zero?
  0.06   268.51      0.17     8918     0.02     0.02  Fixnum#+
  0.03   268.59      0.08     7918     0.01     0.01  Fixnum#-
  0.01   268.63      0.04     1000     0.04   267.71  Object#prime?
  0.00   268.63      0.00        2     0.00     0.00  IO#set_encoding
  0.00   268.63      0.00     1001     0.00     0.00  Fixnum#&gt;
  0.00   268.63      0.00        2     0.00     0.00  Time#now
  0.00   268.63      0.00        2     0.00     0.00  Time#initialize
  0.00   268.63      0.00        3     0.00     0.00  Module#method_added
  0.00   268.63      0.00        1     0.00   580.00  Object#nth_prime
  0.00   268.63      0.00        1     0.00     0.00  Time#-
  0.00   270.74      0.00        1     0.00 270740.00  #toplevel
|&lt;

ボトルネックはやはりprime?メソッドだ…


素数の判定法に
エラトステネスのふるいというのがある


[http://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9:title=エラトステネスの篩] - Wikipediaより
&gt;|
ステップ 1
　整数を最初の素数である 2 から昇順で探索リストに羅列する。
　2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
ステップ 2
　リストの先頭の数を素数リストに記録する。
　素数リスト：2
　探索リスト：2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
ステップ 3
　前のステップで素数リストに加えられた数の全ての倍数を、探索リストから削除する。
　素数リスト：2
　探索リスト：3 5 7 9 11 13 15 17 19
ステップ 4
　探索リストの最大値が素数リストの最大値の平方よりも小さい場合、素数リストおよび探索リストに残っている数が素数となる。探索リストの最大値が素数リストの最大値の平方よりも大きい場合、ステップ 2 に戻る。
|&lt;


これを利用して上のコードを少し改良してみる
nth_primeメソッドにおいて
得られた素数をprime_listに持たせ
prime?に渡すようにしよう

&gt;|ruby|
 def nth_prime(nth)
   prime_list = [2]
   n = 2
   until n &gt; nth
     prime_list &lt;&lt; next_prime(prime_list)
     n += 1
   end
   prime_list.last
 end

 def next_prime(prime_list)
   _next = prime_list.last + 1
   loop do
     return _next if prime?(_next, prime_list)
     _next += 1
   end
 end

 def prime?(n, prime_list)
   prime_list.each { |i| return false if n != i and (n % i).zero? }
   return true if n &lt; (prime_list.last ** 2)
   2.upto(n-1) do |i|
     return false if n.modulo(i).zero?
   end
   true
 end

 t = Time.now
 nth_prime 10001 # =&gt; 104743
 Time.now - t # =&gt; 21.216265
||&lt;

いくらかよくなったかな

*p2*Rubyでサムオブスクエアスクエアオブサム ～Rubyでオイラープロジェクトを解こう！Problem6
[http://projecteuler.net/index.php?section=problems&amp;id=6:title=Problem 6 - Project Eulerより]
&gt;&gt;
The sum of the squares of the first ten natural numbers is,
[tex:1^2 + 2^2 + ... + 10^2 = 385]
The square of the sum of the first ten natural numbers is,
[tex:(1 + 2 + ... + 10)^2 = 55^2 = 3025]
Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.
Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
最初の10個の自然数を二乗したものの合計は、
[tex:1^2 + 2^2 + ... + 10^2 = 385]
最初の10個の自然数の合計を二乗したものは、
[tex:(1 + 2 + ... + 10)^2 = 55^2 = 3025]
よってこれらの差は、3025 - 385 = 2640である。
最初の100個の自然数を二乗したものの合計と、それら自然数の合計を二乗したものとの差を求めよ。
&lt;&lt;


&gt;|ruby|
 def sum_of_squares(limit)
   sum = 0
   1.upto(limit) do |n|
     sum += n ** 2
   end
   sum
 end

 def square_of_sum(limit)
   (1..limit).to_a.inject(:+) ** 2
 end

 limit = 100
 (sum_of_squares(limit) - square_of_sum(limit)).abs # =&gt; 25164150
||&lt;

</body>
</day>
<day date="2009-01-17" title="">
<body>
*p2*Rubyでピタゴラスを求める ～Rubyでオイラープロジェクトを解こう！Problem9
[http://projecteuler.net/index.php?section=problems&amp;id=9:title=Problem 9 - Project Eulerより]
&gt;&gt;
A Pythagorean triplet is a set of three natural numbers, a &lt; b &lt; c, for which,
[tex:a^2 + b^2 = c^2]
For example, [tex:3^2 + 4^2 = 9 + 16 = 25 = 5^2].
There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.
ピタゴラス数とは、次の関係にある3つの自然数の組(a &lt; b &lt; c )をいう。
[tex:a^2 + b^2 = c^2]
例： [tex:3^2 + 4^2 = 9 + 16 = 25 = 5^2].
 a + b + c = 1000 となるピタゴラス数がただ一つある。abcの積を求めよ。
&lt;&lt;


a &lt; b &lt; c の条件を維持しながら
 a + b + c = 1000 なるピタゴラス数を
順番に探していく

&gt;|ruby|
def sum_of_pythagoras(sum)
  a = 1; b, c = a+1, a+2
  limit = sum
  loop do
    if pythagoras?(a, b, c) and (a + b + c) == sum
      return a, b, c
    end
    c += 1
    if c &gt; limit
      b += 1; c = b + 1
    end
    if b &gt; limit/2
      a += 1; b = a + 1; c = b + 1
    end
    return nil if a &gt; limit/3
  end
end

def pythagoras?(a, b, c)
  return true if (a ** 2 + b ** 2) == c ** 2
  false
end

t =  Time.now
a, b, c = sum_of_pythagoras(1000)
&quot;#{a} * #{b} * #{c} = #{a*b*c}&quot; # =&gt; &quot;200 * 375 * 425 = 31875000&quot;
Time.now - t # =&gt; 70.728619
||&lt;

ちょっと時間が掛かる
(a + b + c) == sum を先に評価するようにしたら…

&gt;|ruby|
def sum_of_pythagoras(sum)
  a = 1; b, c = a+1, a+2
  limit = sum
  loop do
    if (a + b + c) == sum and pythagoras?(a, b, c)
      return a, b, c
    end
    c += 1
    if c &gt; limit
      b += 1; c = b + 1
    end
    if b &gt; limit/2
      a += 1; b = a + 1; c = b + 1
    end
    return nil if a &gt; limit/3
  end
end

def pythagoras?(a, b, c)
  return true if (a ** 2 + b ** 2) == c ** 2
  false
end

t =  Time.now
a, b, c = sum_of_pythagoras(1000)
&quot;#{a} * #{b} * #{c} = #{a*b*c}&quot; # =&gt; &quot;200 * 375 * 425 = 31875000&quot;
Time.now - t # =&gt; 34.074137
||&lt;

時間が半分になった
*p1*Rubyで数字をスライスする ～Rubyでオイラープロジェクトを解こう！Problem8
[http://projecteuler.net/index.php?section=problems&amp;id=8:title=Problem 8 - Project Eulerより]
&gt;&gt;
Find the greatest product of five consecutive digits in the 1000-digit number.
以下の1000桁の数字における連続した5つの数の積の最大値を求めよ。

7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450
&lt;&lt;


数字の各桁を配列の要素として取り込み
そこから順に5桁を切り出してその積を求めます

&gt;|ruby|
number = &lt;&lt;DATA
 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450
DATA

 def greatest_five(number)
   seq = number.split(&quot;&quot;).map { |s| s.to_i  }
   candidate = 0
  (seq.length-4).times do |n|
     multi = seq.slice(n, 5).inject(:*)
     candidate = multi if multi &gt; candidate
   end
   candidate
 end

 greatest_five(number) # =&gt; 40824
||&lt;

</body>
<comments>
<comment>
<username>通りすがり</username>
<body>a + b + c = n&lt;br&gt;を&lt;br&gt;c = n - (a + b)&lt;br&gt;と変形して、&lt;br&gt;a&#178; + b&#178; = c&#178; &lt;br&gt;に代入して、さらに変形すると&lt;br&gt;b = (2 * a * n - n&#178;) / (2 * a - 2 *n)&lt;br&gt;  = n - n&#178; / (2 * (n - a))&lt;br&gt;となります。&lt;br&gt;この式の a に 1 から順に整数を代入していって、b が整数になる場合を求め&lt;br&gt;ると、かなり速く答えが出せます。&lt;br&gt;&lt;br&gt;&lt;br&gt;def pythagorean_triples (n)&lt;br&gt;  return([]) if n.odd?&lt;br&gt;&lt;br&gt;  ans = Array.new&lt;br&gt;  1.step(n) do |a|&lt;br&gt;    b = n - 0.5 * (n ** 2) / (n - a.to_f)&lt;br&gt;    case&lt;br&gt;    when (a &gt; b)&lt;br&gt;      return(ans)&lt;br&gt;    when (b.to_i == b)&lt;br&gt;      ans.push([a, b.to_i, Math.sqrt(a ** 2 + b ** 2).to_i])&lt;br&gt;    end&lt;br&gt;  end&lt;br&gt;end&lt;br&gt;&lt;br&gt;p pythagorean_triples(1000)</body>
<timestamp>1232178603</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;通りすがりさん&lt;br&gt;圧倒的に速いですね。なるほど。</body>
<timestamp>1232186274</timestamp>
</comment>
</comments>
</day>
<day date="2009-01-18" title="">
<body>
*p1*Rubyで縦横斜めの積を求める ～Rubyでオイラープロジェクトを解こう！Problem11
[http://projecteuler.net/index.php?section=problems&amp;id=11:title=Problem 11 - Project Eulerより]
&gt;&gt;
In the 20×20 grid below, four numbers along a diagonal line have been marked in red.

&lt;span style=&quot;font-size:x-small;&quot;&gt;08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;32 98 81 28 64 23 67 10 &lt;span style=&quot;color:#FF0000;&quot;&gt;26&lt;/span&gt; 38 40 67 59 54 70 66 18 38 64 70&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;67 26 20 68 02 62 12 20 95 &lt;span style=&quot;color:#FF0000;&quot;&gt;63&lt;/span&gt; 94 39 63 08 40 91 66 49 94 21&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;24 55 58 05 66 73 99 26 97 17 &lt;span style=&quot;color:#FF0000;&quot;&gt;78&lt;/span&gt; 78 96 83 14 88 34 89 63 72&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;21 36 23 09 75 00 76 44 20 45 35 &lt;span style=&quot;color:#FF0000;&quot;&gt;14&lt;/span&gt; 00 61 33 97 34 31 33 95&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54&lt;/span&gt;
&lt;span style=&quot;font-size:x-small;&quot;&gt;01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48&lt;/span&gt;

The product of these numbers is 26×63×78×14 = 1788696.

What is the greatest product of four adjacent numbers in any direction (up, down, left, right, or diagonally) in the 2020 grid?
上の20×20グリッドにおいて、対角線に沿う4つの数字が赤く印されている。
これら数字の積は、26×63×78×14 = 1788696である。
この20×20グリッドにおいて、その並びの方向(上下左右または対角)を問わず、4つ並んだ数字の積の最大値は何か。
&lt;&lt;


[http://d.hatena.ne.jp/keyesberry/20090117/p1:title=Rubyで数字をスライスする]と同じ戦略で
各列を配列に見立てそこから4つの数字をスライスする戦略を取る
上下および対角方向の並びに対しては
それらを左右方向に並び替えて処理する


つまり上下方向の並びに対しては
Array#transposeメソッドを使う
対角方向の並びに対しては
行方向の位置に応じて列をシフトしてからtransposeする

&gt;|ruby|
number = &lt;&lt;DATA
08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
DATA

 def greatest_four(number)
   horz = number.split(&quot;\n&quot;).map { |s| s.split(&quot;\s&quot;).map { |s| s.to_i } }
   vert = horz.transpose
   diag_r, diag_l = [], []
   horz.each_with_index do |line, i|
     line_r = [0, 0, 0, 0] + line.dup
     line_l = line.dup + [0, 0, 0, 0]
     (i % 4).times do |n|
       line_r.push(line_r.shift)
       line_l.unshift(line_l.pop)
     end
     diag_r &lt;&lt; line_r
     diag_l &lt;&lt; line_l
   end
   [product_max(horz), product_max(vert), product_max(diag_r.transpose), product_max(diag_l.transpose)].max
 end

 def product_max(seq)
   max = 0
   seq.each do |line|
     (line.length-3).times do |n|
       _product = line.slice(n, 4).inject(:*)
       max = _product if _product &gt; max
     end
   end
   max
 end

 greatest_four(number) # =&gt; 70600674
||&lt;

*p2*Rubyでサブプライム問題解決！ ～Rubyでオイラープロジェクトを解こう！Problem10
[http://projecteuler.net/index.php?section=problems&amp;id=10:title=Problem 10 - Project Eulerより]
&gt;&gt;
The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
Find the sum of all the primes below two million.
10未満の素数の和は、2 + 3 + 5 + 7 = 17 である。
200万未満の素数すべての和を求めよ。
&lt;&lt;


[http://d.hatena.ne.jp/keyesberry/20090113/p4:title=Problem3]で既に素数を求めているので
それを使って解く
200万はちょっと大きいので
まずは2万を入れて…

&gt;|ruby|
 def sum_prime(limit)
   sum = 0
   prime = 2
   loop do
     break if prime &gt; limit
     sum += prime if prime?(prime)
     prime += 1
   end
   sum
 end

 def prime?(n)
   2.upto(n-1) do |i|
     return false if n.modulo(i).zero?
   end
   true
 end

 t = Time.now
 sum_prime(20_000) # =&gt;21171191
 Time.now - t # =&gt; 73.649596
||&lt;

ぎゃ！
2万で73秒…
200万だと…


じゃあ…
エラトステネスのふるいでやってみよう


[http://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9:title=エラトステネスの篩] - Wikipediaより
&gt;|
ステップ 1
　整数を最初の素数である 2 から昇順で探索リストに羅列する。
　2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
ステップ 2
　リストの先頭の数を素数リストに記録する。
　素数リスト：2
　探索リスト：2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
ステップ 3
　前のステップで素数リストに加えられた数の全ての倍数を、探索リストから削除する。
　素数リスト：2
　探索リスト：3 5 7 9 11 13 15 17 19
ステップ 4
　探索リストの最大値が素数リストの最大値の平方よりも小さい場合、素数リストおよび探索リストに残っている数が素数となる。探索リストの最大値が素数リストの最大値の平方よりも大きい場合、ステップ 2 に戻る。
|&lt;


各ステップをそのままコードにしてみた

&gt;|ruby|
 def sum_prime(limit)
   candidates = (2..limit).to_a
   primes = []
   loop do
     primes &lt;&lt; candidates.shift
     candidates.delete_if do |i|
       primes.any? { |e| (i % e).zero? }
     end
     return (primes + candidates).inject(:+) if candidates.max &lt; (primes.max ** 2)
   end
 end

 t = Time.now
 sum_prime(20_000) # =&gt; 21171191
 Time.now - t # =&gt; 6.052391
||&lt;

6秒に短縮された
でも200万を入れると…
…
…
答えが出てこない！


あきらめるか…



と…
mathnライブラリに
Primeクラス発見！
これ使っちゃお

&gt;|ruby|
 require &quot;mathn&quot;

 def sum_prime(limit)
   sum = 0
   Prime.each do |prime|
     return sum if prime &gt; limit
     sum += prime
   end
 end

 t = Time.now
 sum_prime(2_000_000) # =&gt; 142913828922
 Time.now - t # =&gt; 26.524741
||&lt;

これで
サ&lt;del datetime=&quot;2009-01-18T11:13:25+09:00&quot;&gt;ブ&lt;/del&gt;ムプライム問題
無事解決！

</body>
</day>
<day date="2009-01-19" title="">
<body>
*p2*Rubyで100個の数を足す ～Rubyでオイラープロジェクトを解こう！Problem13
[http://projecteuler.net/index.php?section=problems&amp;id=13:title=Problem 13 - Project Eulerより]
&gt;&gt;
Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
以下の50桁数字100個の合計における最初の10桁を算出せよ。
&lt;&lt;


配列に入れてinject(:+)します
&gt;|ruby|
number = &lt;&lt;DATA
37107287533902102798797998220837590246510135740250
46376937677490009712648124896970078050417018260538
74324986199524741059474233309513058123726617309629
91942213363574161572522430563301811072406154908250
23067588207539346171171980310421047513778063246676
89261670696623633820136378418383684178734361726757
28112879812849979408065481931592621691275889832738
44274228917432520321923589422876796487670272189318
47451445736001306439091167216856844588711603153276
70386486105843025439939619828917593665686757934951
62176457141856560629502157223196586755079324193331
64906352462741904929101432445813822663347944758178
92575867718337217661963751590579239728245598838407
58203565325359399008402633568948830189458628227828
80181199384826282014278194139940567587151170094390
35398664372827112653829987240784473053190104293586
86515506006295864861532075273371959191420517255829
71693888707715466499115593487603532921714970056938
54370070576826684624621495650076471787294438377604
53282654108756828443191190634694037855217779295145
36123272525000296071075082563815656710885258350721
45876576172410976447339110607218265236877223636045
17423706905851860660448207621209813287860733969412
81142660418086830619328460811191061556940512689692
51934325451728388641918047049293215058642563049483
62467221648435076201727918039944693004732956340691
15732444386908125794514089057706229429197107928209
55037687525678773091862540744969844508330393682126
18336384825330154686196124348767681297534375946515
80386287592878490201521685554828717201219257766954
78182833757993103614740356856449095527097864797581
16726320100436897842553539920931837441497806860984
48403098129077791799088218795327364475675590848030
87086987551392711854517078544161852424320693150332
59959406895756536782107074926966537676326235447210
69793950679652694742597709739166693763042633987085
41052684708299085211399427365734116182760315001271
65378607361501080857009149939512557028198746004375
35829035317434717326932123578154982629742552737307
94953759765105305946966067683156574377167401875275
88902802571733229619176668713819931811048770190271
25267680276078003013678680992525463401061632866526
36270218540497705585629946580636237993140746255962
24074486908231174977792365466257246923322810917141
91430288197103288597806669760892938638285025333403
34413065578016127815921815005561868836468420090470
23053081172816430487623791969842487255036638784583
11487696932154902810424020138335124462181441773470
63783299490636259666498587618221225225512486764533
67720186971698544312419572409913959008952310058822
95548255300263520781532296796249481641953868218774
76085327132285723110424803456124867697064507995236
37774242535411291684276865538926205024910326572967
23701913275725675285653248258265463092207058596522
29798860272258331913126375147341994889534765745501
18495701454879288984856827726077713721403798879715
38298203783031473527721580348144513491373226651381
34829543829199918180278916522431027392251122869539
40957953066405232632538044100059654939159879593635
29746152185502371307642255121183693803580388584903
41698116222072977186158236678424689157993532961922
62467957194401269043877107275048102390895523597457
23189706772547915061505504953922979530901129967519
86188088225875314529584099251203829009407770775672
11306739708304724483816533873502340845647058077308
82959174767140363198008187129011875491310547126581
97623331044818386269515456334926366572897563400500
42846280183517070527831839425882145521227251250327
55121603546981200581762165212827652751691296897789
32238195734329339946437501907836945765883352399886
75506164965184775180738168837861091527357929701337
62177842752192623401942399639168044983993173312731
32924185707147349566916674687634660915035914677504
99518671430235219628894890102423325116913619626622
73267460800591547471830798392868535206946944540724
76841822524674417161514036427982273348055556214818
97142617910342598647204516893989422179826088076852
87783646182799346313767754307809363333018982642090
10848802521674670883215120185883543223812876952786
71329612474782464538636993009049310363619763878039
62184073572399794223406235393808339651327408011116
66627891981488087797941876876144230030984490851411
60661826293682836764744779239180335110989069790714
85786944089552990653640447425576083659976645795096
66024396409905389607120198219976047599490197230297
64913982680032973156037120041377903785566085089252
16730939319872750275468906903707539413042652315011
94809377245048795150954100921645863754710598436791
78639167021187492431995700641917969777599028300699
15368713711936614952811305876380278410754449733078
40789923115535562561142322423255033685442488917353
44889911501440648020369068063960672322193204149535
41503128880339536053299340368006977710650566631954
81234880673210146739058568557934581403627822703280
82616570773948327592232845941706525094512325230608
22918802058777319719839450180888072429661980811197
77158542502016545090413245809786882778948721859617
72107838435069186155435662884062257473692284509516
20849603980134001723930671666823555245252804609722
53503534226472524250874054075591789781264330331690
DATA

 number.split(&quot;\n&quot;).map { |s| s.to_i }.inject(:+).to_s.slice(0,10) # =&gt; &quot;5537376230&quot;
||&lt;
*p1*Rubyで三角数の約数を探せ！ ～Rubyでオイラープロジェクトを解こう！Problem12
[http://projecteuler.net/index.php?section=problems&amp;id=12:title=Problem 12 - Project Eulerより]
&gt;&gt;
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
Let us list the factors of the first seven triangle numbers:
 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?
三角数の数列は自然数を足し合わせていくことで作られる。故に7番目の三角数は1 + 2 + 3 + 4 + 5 + 6 + 7 = 28となる。最初の10項は1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...となる。
最初の7つの三角数の因数を並べてみよう。
 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
そうすると28は約数が5つを超える最初の三角数であることがわかる。
では約数が500を超える最初の三角数の値は何か。
&lt;&lt;


ちょっと悩んだけど以下の戦略で
+factorメソッドで順番に三角数の因数((ここでは三角数を積の形で表したときの要素とします))を求める
+Array#combinationメソッドで因数同士の全て組み合わせを求める
+その組み合わせから約数((ここでは三角数を割りきれる数とします))を求める

&gt;|ruby|
 require &quot;mathn&quot;
 def triangle_number(divs)
   i = 1; tri = 1
   loop do
     divisors = []
     factors = factor(tri)
     1.upto(factors.length-1) do |n|
       divisors += factors.combination(n).to_a
     end
     result = divisors.map { |c| c.inject(:*) }.uniq
     return result if result.length &gt; divs
     i += 1; tri += i
   end
 end

 def factor(n)
   return [1, n] if Prime.prime?(n)
   2.upto(n-1) do |i|
     return factor(n/i) &lt;&lt; i if n.modulo(i).zero?
   end
 end

 triangle_number(500).max # =&gt; 76576500
||&lt;

ちょっと遅いです…
結果が出たということで…


(追記:2009/1/22)
[http://projecteuler.net/index.php?section=problems&amp;id=21:title=Problem 21 - Project Euler]を解いていたら
ここでバカみたいに複雑なことやっているのに気付いた


方針：
+三角数は (1..n).inject(:+)で求まる
+約数は三角数を割ってあまりが出ないもので求まる
&gt;|ruby|
 def tr_with_divs(limit)
   i = 1
   loop do
     tr = (1..i).inject(:+)
     return tr if div_num(tr) &gt; limit
     i += 1
   end
 end

 def div_num(tr)
   num = 0
   (1..tr).each do |i|
     num += 1 if tr % i == 0
   end
   num
 end

 tr_with_divs 500 # =&gt;
||&lt;
ところが…
答えが出てこない！
他の方法が必要だ…


でWikipediaを調べてみると…


[http://ja.wikipedia.org/wiki/%E7%B4%84%E6%95%B0:title=約数の個数 - Wikipediaより]
&gt;&gt;
自然数 n の全ての正の約数の個数を d(n) で表す。
n の素因数分解が
  [tex:n = p1^{a1}p2^{a2}...pm^{am}]
と表せるとき、d(n) は以下の式で求められる。
  [tex:d(n) = (a1 + 1)(a2 +1)...(am + 1)]
&lt;&lt;


じゃあ今度はこの方向で…
&gt;|ruby|
 require &quot;mathn&quot;
 def tr_with_divs(limit)
   i = 1
   loop do
     tr = (1..i).inject(:+)
     return tr if div_num(tr) &gt; limit
     i += 1
   end
 end

 def div_num(tr)
   cnt = Hash.new(0)
   f = factor(tr)
   f.each { |e| cnt[e] += 1 }
   cnt.values.map { |e| e + 1 }.inject(:*)
 end

 def factor(n)
   return [n] if Prime.prime?(n)
   (2...n).each do |i|
     return factor(n/i) &lt;&lt; i if n % i == 0
   end
 end

 t = Time.now
 tr_with_divs 500 # =&gt; 76576500
 Time.now - t  3 # =&gt; 330.58157
||&lt;

やっぱり時間が掛かる…

</body>
</day>
<day date="2009-01-20" title="">
<body>
*p1*Rubyで最長の数列を探す ～Rubyでオイラープロジェクトを解こう！Problem14
[http://projecteuler.net/index.php?section=problems&amp;id=14:title=Problem 14 - Project Eulerより]
&gt;&gt;
The following iterative sequence is defined for the set of positive integers:
n → n/2 (n is even)
n → 3n + 1 (n is odd)
Using the rule above and starting with 13, we generate the following sequence:
13  40  20  10  5  16  8  4  2  1
It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.
Which starting number, under one million, produces the longest chain?
NOTE: Once the chain starts the terms are allowed to go above one million.
正の整数の組に関して、次の反復数列条件を定義する。
n →  n/2 (nが偶数のとき)
n → 3n + 1 (nが奇数のとき)
このルールを使い13から始めると、次の数列が作られる。
13  40  20  10  5  16  8  4  2  1
13から始まり1で終わるこの数列は10の項を含むということがわかるだろう。いまだ証明されていないが(コラッツ問題)、如何なる数字で始まっても1で終わると考えられる。
100万未満で、どの数字から始まったものが最長の連鎖を作るか。
注釈：連鎖が開始されたら項が100万を超えることはかまわない。
&lt;&lt;


方針：
+数列はその終了条件がわかっているので再帰を使う
+各開始数と数列の長さをハッシュでペアにして持つ
+その中から最長のものの開始数を抽出する
&gt;|ruby|
 def longest_chain(range)
   pair = {}
   range.each do |n|
     pair[n] = sequence(n).length
   end
   pair.rassoc(pair.values.max).first
 end

 def sequence(start)
   return [1] if start == 1
   if start.even?
     sequence(start / 2).unshift(start)
   else
     sequence(3 * start + 1).unshift(start)
   end
 end

 t = Time.now
 longest_chain 1...1_000_000 # =&gt; 837799
 Time.now - t # =&gt; 95.898332
||&lt;
ちょっと時間が掛かります…

</body>
</day>
<day date="2009-01-22" title="">
<body>
*p2*Rubyで桁の合計を求める ～Rubyでオイラープロジェクトを解こう！Problem16
[http://projecteuler.net/index.php?section=problems&amp;id=16:title=Problem 16 - Project Eulerより]
&gt;&gt;
[tex:2^{15} = 32768] and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
What is the sum of the digits of the number [tex:2^{1000}]?
[tex:2^{15} = 32768] の各桁の合計は 3 + 2 + 7 + 6 + 8 = 26である。
[tex:2^{1000}]の各桁の合計はいくつか。
&lt;&lt;


算数的でないけど
&gt;|ruby|
 def sum_of_digits(n)
   n.to_s.split(&quot;&quot;).map { |s| s.to_i }.inject(:+)
 end

 sum_of_digits(2**1000) # =&gt; 1366
||&lt;


もう少し算数的に
&gt;|ruby|
 def sum_of_digits(n)
   sum = 0
   begin
     n, b = n.divmod(10)
     sum += b
   end until n == 0 and b == 0
   sum
 end

 sum_of_digits(2**1000) # =&gt; 1366
||&lt;

*p1*Rubyで最短ルート数を探す ～Rubyでオイラープロジェクトを解こう！Problem15
[http://projecteuler.net/index.php?section=problems&amp;id=15:title=Problem 15 - Project Eulerより]
&gt;&gt;
Starting in the top left corner of a 2×2 grid, there are 6 routes (without backtracking) to the bottom right corner.
[f:id:keyesberry:20090121100543g:image]
How many routes are there through a 20×20 grid?
2×2グリッドの左上の角からスタートした場合、右下の角に至るには6つのルートがある(引き返しはなし)。
では20×20のグリッドではいくつのルートがあるか。
&lt;&lt;


任意の交点に至るルートは
その真上と左隣の交点からだけなので
そこまでのルートの合計が
任意の交点に至るルートの数になる


交点横一列の要素数の配列を作り
ここに対応する交点に至るルート数を格納する
&gt;|ruby|
 def routes(x,y)
   points = Array.new(x+1, 1)
   y.times do |n|
     (points.length).times do |i|
       next if i == 0
       points[i] = points[i-1] + points[i]
     end
   end
   points.last
 end

 routes(20,20) # =&gt; 137846528820
||&lt;


これは再帰でもいけそうだ
こちらのほうがエレガントだ
&gt;|ruby|
 def routes(x, y)
   return 1 if x == 0 or y == 0
   routes(x, y-1) + routes(y, x-1)
 end

 routes(20, 20) # =&gt;
||&lt;
でもいつまで待っても答えが出ない…

</body>
</day>
<day date="2009-01-23" title="">
<body>
*p1*Rubyで英数字を作って文字数を数える ～Rubyでオイラープロジェクトを解こう！Problem17
[http://projecteuler.net/index.php?section=problems&amp;id=17:title=Problem 17 - Project Eulerより]
&gt;&gt;
If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?
NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of &quot;and&quot; when writing out numbers is in compliance with British usage.
1から5の数は英単語で one, two, three, four, five と書かれるが、これには全部で3 + 3 + 5 + 4 + 4 = 19 の文字が使われている。
1から1000(one thousand)までの全ての数を英単語で書いた場合、何文字が使われるか。
注記：スペースとハイフンは数えない。例えば、342 (three hundred and forty-two) は23文字、115 (one hundred and fifteen)は20文字からなる。数字を書くときの&quot;and&quot;の使用は英国式に従う。
&lt;&lt;


方針：
+1から1000までの数字を英単語に変換するnum_to_wordメソッドを作る
+入力範囲の数字の文字数の合計をカウントするcount_lettersメソッドを作る

&gt;|ruby|
 WORDS = {0 =&gt; &quot;&quot;, 1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;, 3 =&gt; &quot;three&quot;, 4 =&gt; &quot;four&quot;, 5 =&gt; &quot;five&quot;, 6 =&gt; &quot;six&quot;, 7 =&gt; &quot;seven&quot;, 8 =&gt; &quot;eight&quot;, 9 =&gt; &quot;nine&quot;, 10 =&gt; &quot;ten&quot;, 11 =&gt; &quot;eleven&quot;, 12 =&gt; &quot;twelve&quot;, 13 =&gt; &quot;thirteen&quot;, 14 =&gt; &quot;fourteen&quot;, 15 =&gt; &quot;fifteen&quot;, 16 =&gt; &quot;sixteen&quot;, 17 =&gt; &quot;seventeen&quot;, 18 =&gt; &quot;eighteen&quot;, 19 =&gt; &quot;nineteen&quot;, 20 =&gt; &quot;twenty&quot;, 30 =&gt; &quot;thirty&quot;, 40 =&gt; &quot;forty&quot;, 50 =&gt; &quot;fifty&quot;, 60 =&gt; &quot;sixty&quot;, 70 =&gt; &quot;seventy&quot;, 80 =&gt; &quot;eighty&quot;, 90 =&gt; &quot;ninety&quot;}

 def count_letters(range)
   ans = 0
   range.each do |n|
     word = num_to_word(n)
     ans += word.gsub(/[-\s]/, &quot;&quot;).length
   end
   ans
 end

 def num_to_word(n)
   word = &quot;&quot;
   hund, ten = n.divmod(100)
  
   case hund
   when 1..9
     if ten.zero?
       word &lt;&lt; &quot;#{WORDS[hund]} hundred&quot;
     else
       word &lt;&lt; &quot;#{WORDS[hund]} hundred and &quot;
     end
   when 10
     word &lt;&lt; &quot;one thousand&quot;
   end

   case ten
   when 10..19
     word &lt;&lt; WORDS[ten]
   when 1..9, 20..99
     ten, one = ten.divmod(10)
     if one.zero?
       word &lt;&lt; &quot;#{WORDS[ten*10]}&quot;
     elsif ten.zero?
       word &lt;&lt; &quot;#{WORDS[one]}&quot;
     else
       word &lt;&lt; &quot;#{WORDS[ten*10]}-#{WORDS[one]}&quot;
     end
   end
   word
 end

 count_letters(1..1000) # =&gt; 21124
||&lt;

</body>
</day>
<day date="2009-01-25" title="">
<body>
*p1*Rubyで三角形の最大ルートを求める ～Rubyでオイラープロジェクトを解こう！Problem18
[http://projecteuler.net/index.php?section=problems&amp;id=18:title=Problem 18 - Project Eulerより]
&gt;&gt;
By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.

       &lt;span style=&quot;color:#FF0000;&quot;&gt;3&lt;/span&gt;
     &lt;span style=&quot;color:#FF0000;&quot;&gt;7&lt;/span&gt; 5
   2 &lt;span style=&quot;color:#FF0000;&quot;&gt;4&lt;/span&gt; 6
 8 5 &lt;span style=&quot;color:#FF0000;&quot;&gt;9&lt;/span&gt; 3

That is, 3 + 7 + 4 + 9 = 23.
Find the maximum total from top to bottom of the triangle below:
次の三角形の頂点から始めて、隣接するその下の列の番号に移動していく場合、頂点から底辺までの合計の最大値は23である。
つまり、3 + 7 + 4 + 9 = 23である。
次の三角形の頂点から底辺までの合計の最大値を求めよ。
&lt;&lt;


難しかったけど以下の方針でなんとか
+三角形のデータを二次元配列のデータとして読み込む。
+底辺の各点から頂点に向かってそれぞれ合計を再帰的に求める(route_sum)。
+それらの合計から最大値を選ぶ(max_route)。

&gt;|ruby|
data = &lt;&lt;DATA
75
95 64
17 47 82
18 35 87 10
20 04 82 47 65
19 01 23 75 03 34
88 02 77 73 07 63 67
99 65 04 28 06 16 70 92
41 41 26 56 83 40 80 70 33
41 48 72 33 47 32 37 16 94 29
53 71 44 65 25 43 91 52 97 51 14
70 11 33 28 77 73 17 78 39 68 17 57
91 71 52 38 17 14 91 43 58 50 27 29 48
63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23
DATA

 TRI = data.split(/\n+/).map { |line| line.split(/\s+/).map { |e| e.to_i } }

 def max_route
   ans = []
   lev = TRI.length
   lev.times do |n|
     ans &lt;&lt; route_sum(lev-1, n)
   end
   ans.max
 end

 def route_sum(lev, x)
   return TRI[0][0] if lev == 0
   return 0 if x &lt; 0 or x &gt; lev
   [route_sum(lev-1, x-1), route_sum(lev-1, x)].max + TRI[lev][x]
 end

 max_route2 # =&gt; 10xx
||&lt;


Euler Projectのフォーラムで
三角形の上から攻められることを知って愕然とする
そのほうがずっとエレガントだ


上から攻める版に書き直す

&gt;|ruby|
data = &lt;&lt;DATA
75
95 64
17 47 82
18 35 87 10
20 04 82 47 65
19 01 23 75 03 34
88 02 77 73 07 63 67
99 65 04 28 06 16 70 92
41 41 26 56 83 40 80 70 33
41 48 72 33 47 32 37 16 94 29
53 71 44 65 25 43 91 52 97 51 14
70 11 33 28 77 73 17 78 39 68 17 57
91 71 52 38 17 14 91 43 58 50 27 29 48
63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23
DATA

 TRI = data.split(/\n+/).map { |line| line.split(/\s+/).map { |e| e.to_i } }

 def max_route(lev, x)
   return TRI[lev][x] if lev == TRI.length-1
   [max_route(lev+1, x), max_route(lev+1, x+1)].max + TRI[lev][x]
 end

 max_route(0, 0) # =&gt; 10xx
||&lt;

</body>
</day>
<day date="2009-01-26" title="">
<body>
*p2*Rubyで階乗して桁を合計 ～Rubyでオイラープロジェクトを解こう！Problem20
[http://projecteuler.net/index.php?section=problems&amp;id=20:title=Problem 20 - Project Eulerより]
&gt;&gt;
n! means n × (n - 1)×  ... × 3 × 2 × 1
Find the sum of the digits in the number 100!
n!は n × (n - 1)×  ... × 3 × 2 × 1を意味する。
100!における桁の合計を求めよ。
&lt;&lt;


Integerクラスのインスタンスメソッドとして
!とsum_digitを定義してみた
&gt;|ruby|
 class Integer
   def !
     (1..self).inject(:*)
   end

   def sum_digit
     n = self.abs
     sum = 0
     until n &lt;= 0
       a, b = n.divmod(10)
       sum += b
       n = a  
     end
     sum
   end
 end

 100.!.sum_digit # =&gt; 6xx
||&lt;
*p1*Rubyで20世紀の日曜日を求める ～Rubyでオイラープロジェクトを解こう！Problem19
[http://projecteuler.net/index.php?section=problems&amp;id=19:title=Problem 19 - Project Eulerより]
&gt;&gt;
You are given the following information, but you may prefer to do some research for yourself.

1 Jan 1900 was a Monday.
Thirty days has September,
April, June and November.
All the rest have thirty-one,
Saving February alone,
Which has twenty-eight, rain or shine.
And on leap years, twenty-nine.
A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.
How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
以下の情報が与えられているが、あなたは更なる調査を欲している。
-1900年1月1日は月曜日である。
-9月、4月、6月および11月は30日である。
-2月を別にして残りは31日である。
-2月は28日で、うるう年には29日である。
-うるう年は、4で割り切れる年に起こるが、400で割れる年を除くと世紀の年には起こらない。
20世紀(1901年1月1日から2000年12月31日まで)における月の初日が日曜日である日はいくつあるか。
&lt;&lt;


方針：
-入力日の曜日を返すwdayメソッドを作る
-sundays_on_first_of_monthメソッドで20世紀のすべての月の初日の曜日を当たる

&gt;|ruby|
 MONTHS = %w(nil Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)
 MONTH_DAYS = (1..12).inject({}) { |h, m| [4,6,9,11].include?(m) ? h[m] = 30 : h[m] = 31; h}

 def wday(day, mon, year)
   days = 0
   mon = month_index(mon)
   (1900..year).each do |y|
     leap_year?(y) ? MONTH_DAYS[2] = 29 : MONTH_DAYS[2] = 28
     if y != year
       (1..12).each { |m| days += MONTH_DAYS[m] }
     else
       (1...mon).each { |m| days += MONTH_DAYS[m] }
       days += day
     end
   end
   days % 7 #return day of week: 0:sun, 1:mon..
 end

 def leap_year?(year)
   if (year%4).zero? &amp;&amp; (year%100).nonzero? || (year%400).zero?
     true
   else
     false
   end
 end

 def sundays_on_first_of_month(start_date, end_date)
   st_day, st_mon, st_year = start_date
   end_day, end_mon, end_year = end_date
   st_mon, end_mon = month_index(st_mon), month_index(end_mon)
   count = 0
   (st_year..end_year).each do |y|
     cnt_blk = lambda { |m| count += 1 if wday(1, MONTHS[m], y).zero? } # count Sunday
     if y == st_year and y == end_year
       (st_mon..end_mon).each(&amp;cnt_blk)
     elsif y == st_year
       (st_mon..12).each(&amp;cnt_blk)
     elsif y == end_year
       (1..end_mon).each(&amp;cnt_blk)
     else
       (1..12).each(&amp;cnt_blk)
     end
   end
   count
 end

 def month_index(word) # from month word to month number
   MONTHS.find_index { |m| m =~ /#{word.slice(0..2)}/i }
 end

 wday(1, 'january', 1900) # =&gt; 1
 sundays_on_first_of_month([1, 'Jan', 1901],[31, 'Dec', 2000]) # =&gt; 1xx
||&lt;

答えはでたけど
効率悪そうです

</body>
</day>
<day date="2009-01-27" title="">
<body>
*p1*Rubyで友愛数を探す ～Rubyでオイラープロジェクトを解こう！Problem21
[http://projecteuler.net/index.php?section=problems&amp;id=21:title=Problem 21 - Project Eulerより]
&gt;&gt;
Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).
If d(a) = b and d(b) = a, where a != b, then a and b are an amicable pair and each of a and b are called amicable numbers.
For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.
Evaluate the sum of all the amicable numbers under 10000.
d(n)をnの真約数(nを割り切れるn以下の数字)の合計と定義しよう。
d(a) = b and d(b) = a (ただしa != b)であるとき、aとbは友愛ペアであり、a、bそれぞれは友愛数と呼ばれる。
例えば、220の真約数は、1, 2, 4, 5, 10, 11, 20, 22, 44, 55および110であるから、d(220) = 284となる。284の真約数は、1, 2, 4, 71および142であるから、d(284) = 220となる。
10000未満の全ての友愛数の和を求めよ。
&lt;&lt;


上の条件をそのまま素直に書いてみる
&gt;|ruby|
 def d(n)
   (1...n).inject(0) { |sum, v| n%v == 0 ? sum + v : sum }
 end

 def sum_amicables(limit)
   (1...limit).inject(0) do |sum, a|
     (d(b = d(a)) == a and a != b) ? sum + a : sum
   end
 end

 t = Time.now
 sum_amicables 10000 # =&gt; 3xxxx
 Time.now - t # =&gt; 31.430755
||&lt;


やっぱりd(n)メソッドがちょっと遅い
ちょっとキレイでないけど
factorで因数を求めてから約数を求める
&gt;|ruby|
 def d(i)
   f = factor(i)
   com = [1]
   (1...f.length).each do |i|
     com &lt;&lt; f.combination(i).map { |e| e.inject(:*) }.uniq
   end
   com.flatten.inject(:+)
 end

 def factor(n)
   result = []
   (2..n).each do |i|
     while n % i == 0
       n /= i
       result &lt;&lt; i
     end
     break if n == 1
   end
   result
 end

 def sum_amicables(limit)
   (1...limit).inject(0) do |sum, a|
     (d(b = d(a)) == a and a != b) ? sum + a : sum
   end
 end

 t = Time.now
 sum_amicables 10000 # =&gt; 3xxxx
 Time.now - t # =&gt; 5.993918
||&lt;
速度的には改善された

</body>
</day>
<day date="2009-01-28" title="">
<body>
*p1*Rubyでアルファベット値を数える ～Rubyでオイラープロジェクトを解こう！Problem22
[http://projecteuler.net/index.php?section=problems&amp;id=22:title=Problem 22 - Project Eulerより]
&gt;&gt;
Using names.txt (right click and 'Save Link/Target As...'), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.
For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938  53 = 49714.
What is the total of all the name scores in the file?
5000以上の名前が入った46kのテキストファイルnames.txtをアルファベット順に並び替え、各名前のアルファベット値を求め、これをリストにおける位置で掛けて、名前のスコアを得よ。
例えば、リストをアルファベット順に並び替えたとき、COLINは値が3 + 15 + 12 + 9 + 14 = 53になり、リストにおける938番目である。よってCOLINは938×53=49714を得る。
このファイルの全ての名前のスコアの合計はいくらか。
&lt;&lt;


文字コードを使ってアルファベットの値を求める
&gt;|ruby|
 sum = 0
 File.read('names.txt').gsub(&quot;\&quot;&quot;,&quot;&quot;).split(&quot;,&quot;).sort.each_with_index do |name, i|
   sum += name.each_byte.inject(0) { |sum, byte| sum + (byte - 64) } * (i + 1)
 end
 sum # =&gt; 8xxxxxxxx
||&lt;

</body>
</day>
<day date="2009-01-29" title="">
<body>
*p1*SchemeとRubyで高階関数を学ぼう
「[asin:489471163X:title]」という本を図書館で借りた
プログラマー必読の名著で
Amazonによればこれ1冊でコンピュータのすべてがわかるらしい
主著者はLISPの一方言であるSchemeという言語を作った人で
本書もSchemeで書かれている
Ruby以外知らない自分には新鮮で大変勉強になる


最初の方に高階手続きによる抽象という章がある
高階手続きというのは手続きを扱う手続き
つまり手続きの引数として手続きを取ったり
手続きを値として返す手続きのことだ


Rubyにもそういう表現力があるので
同じことをRubyでもできるか試してみよう


**高階手続き
最初に以下の似たような3つの手続きを考える
+aからbまでの整数の和を計算する(sum_integers)
+与えられた範囲の整数の三乗の和を計算する(sum_cubes)
+級数の項の並びの和を計算する(pi_sum)


これらをSchemeで表現すると通常次のようになる
&gt;|scheme|
 (define (sum_integers a b)
	(if (&gt; a b)
	     0
	     (+ a (sum_integers (+ a 1) b))))
		
 (define (sum_cubes a b)
	(if (&gt; a b)
	     0
	     (+ (sum_cubes (+ a 1) b))))
		
 (define (pi_sum a b)
	(if (&gt; a b)
	     0
	     (+ (/ 1.0 (* a (+ a 2))) (pi_sum (+ a 4) b))))
||&lt;
defineの後に手続き名と引数をカッコで括って置き
続けて手続きの実体を置く


Rubyでは以下のように表現される
&gt;|ruby|
 def sum_integers(a, b)
   if a &gt; b
     0
   else
     a + sum_integers(a+1, b)
   end
 end

 def sum_cubes(a, b)
   if a &gt; b
     0
   else
     cube(a) + sum_cubes(a+1, b)
   end
 end

 def pi_sum(a, b)
   if a &gt; b
     0
   else
     1.0/(a*(a+2)) + pi_sum(a+4, b)
   end
 end
||&lt;


見ての通り3つの手続きの実体は共通のパターンを持っている
加算するaの関数とaの次の値を計算する関数が違うだけだ
これらをterm, nextと記号化し
3つの手続きで共通する総和sumという概念を表現する
Schemeでは以下のようになる
&gt;|scheme|
 (define (sum term a next b)
	(if (&gt; a b)
	     0
	     (+ (term a)
		   (sum term (next a) next b))))
||&lt;
手続きsumにはtermとnextがその引数として加わる
その取り扱いに特別なものはない
Schemeではこのような手続きを引数として取る手続きが
自然な形で書ける


sum手続きを使って先の3つの手続きを完成させるには
以下のように手続きを加える
&gt;|scheme|
 (define (inc n) (+ n 1))					
 (define (sum_cubes a b)
	(sum cube a inc b))

 (sum_cubes 1 10)
 3025

 (define (identity x) x)
 (define (sum_integers a b)
	(sum identity a inc b))
	
 (sum_integers 1 10)
 55

 (define (pi_sum a b)
	(define (pi_term x)
		(/ 1.0 (* x (+ x 2))))
	(define (pi_next x)
		(+ x 4))
	(sum pi_term a pi_next b))
	
 (* 8 (pi_sum 1 1000))
 3.139592655589783
||&lt;
sum_cubesとsum_integersのためにincを定義し
pi_sumのためにpi_termとpi_nextを定義している
pi_term,pi_nextは汎用性が低いからpi_sumの中で定義している
それぞれに固有の手続きをsumのtermとnextに渡すことで
共通のsum手続きを用いて3つの異なる演算が実現できる


これをRubyで表現してみよう
まずはsumメソッドから
&gt;|ruby|
 def sum(term, a, _next, b)
   if a &gt; b
     0
   else
     term.call(a) + sum(term, _next.call(a), _next, b)
   end
 end
||&lt;
Schemeと異なりRubyでは手続きはオブジェクトではない
だけど手続きをオブジェクトにすることはできる
この手続きオブジェクトの起動にはcallが必要だ


このsumメソッドを使って先の3つの手続きを完成させよう
&gt;|ruby|
 def cube(n)
   n**3
 end

 def inc(n)
   n + 1
 end

 def sum_cubes(a, b)
   sum(method(:cube), a, method(:inc), b)
 end

 sum_cubes(1, 10) # =&gt; 3025

 def identity(n)
   n
 end

 def sum_integers(a, b)
   sum(method(:identity), a, method(:inc), b)
 end

 sum_integers(1, 10) # =&gt; 55

 def pi_sum(a, b)
   def pi_term(x)
     1.0/(x*(x+2))
   end
   def pi_next(x)
     x + 4
   end
   sum(method(:pi_term), a, method(:pi_next), b)
 end

 8 * pi_sum(1, 1000) # =&gt; 3.13959265558978
||&lt;
Rubyではメソッドをオブジェクト化するのに
Object#methodメソッドを使いメソッド名をシンボルで渡す
pi_sumメソッドのように
メソッド定義の中にメソッド定義をした場合
Rubyでは外側のメソッドの呼び出し時に
内側のメソッドが定義される


**lambda
Schemeに戻ろう
先の高階手続きにおいてその引数として使うためだけに
pi_termやpi_nextの手続きを定義するのは煩わしい
このような場合lambdaが使える
lambdaを使ったpi_sum手続きは以下のようになる
&gt;|scheme|
 (define (pi_sum a b)
	(sum (lambda (x) (/ 1.0 (* x (+ x 2))))
	a
	(lambda (x) (+ x 4))
	b))

;元のpi_sum手続き
 (define (pi_sum a b)
	(define (pi_term x)
		(/ 1.0 (* x (+ x 2))))
	(define (pi_next x)
		(+ x 4))
	(sum pi_term a pi_next b))
||&lt;
元のpi_sum手続きにおける
sumの引数pi_term, pi_nextに直接
手続きを埋め込んでいるのがわかる


Rubyもlambdaを持っているので
同様のことができる
&gt;|ruby|
 def pi_sum(a, b)
   sum(lambda { |x| 1.0/(x*(x+2)) }, a, lambda { |x| x + 4 }, b)
 end

 #元のpi_sumメソッド
 def pi_sum(a, b)
   def pi_term(x)
     1.0/(x*(x+2))
   end
   def pi_next(x)
     x + 4
   end
   sum(method(:pi_term), a, method(:pi_next), b)
 end
||&lt;
Rubyでは手続きはブロックで表現する


メソッドに渡す手続きが一つなら
Rubyではブロックが使える
ブロックの起動はyieldを呼ぶ
&gt;|ruby|
 def sum(a, _next, b)
   if a &gt; b
     0
   else
     yield(a) + sum(_next.call(a), _next, b){ |a| yield a }
   end
 end

 inc = lambda { |i| i + 1 }
 pi_next = lambda { |i| i + 4 }

 sum(1, inc, 10){ |i| i } # =&gt; 55
 sum(1, inc, 10){ |i| i**3 } # =&gt; 3025
 8 * sum(1, pi_next, 1000){ |i| 1.0/(i*(i+2)) } # =&gt; 3.13959265558978
||&lt;


**let
Schemeではlambdaは局所変数を作り出すためにも使われる

&gt;&gt;
[tex:f(x,y) = x(1 + xy)^2 + y(1 - y) + (1 + xy)(1 - y)]
&lt;&lt;
という関数を計算したい場合
これは以下のように書ける
&gt;&gt;
[tex:a = 1 + xy]
[tex:b = 1 - y]
[tex:f(x,y) = xa^2 + yb + ab]
&lt;&lt;

手続きfにおいてこの途中のa,bも束縛しておきたい
そのようなときは補助手続きを定義する
&gt;|scheme|
 (define (f x y)
	(define (f_helper a b)
		(+ (* x (square a))
		     (* y b)
		     (* a b)))
	(f_helper (+ 1 (* x y))
			 (- 1 y)))
||&lt;
もちろんlambdaが使える

&gt;|scheme|
 (define (f x y)
	((lambda (a b)
		(+ (* x (square a))
		     (* y b)
		     (* a b)))
	 (+ 1 (* x y))
	 (- 1 y)))
||&lt;

更にletというものが使える
letを使えば最初にa,bを定義できる
&gt;|scheme|
 (define (f x y)
	(let ((a (+ 1 (* x y)))
		(b (- 1 y)))
	  (+ (* x (square a))
	       (* y b)
	       (* a b))))
||&lt;

これら3つのRubyの等価コードは以下のようになる
&gt;|ruby|
 def f(x, y)
   def f_helper(a, b, x, y)
     x*a**2 + y*b + a*b
   end
   f_helper(1+(x*y), 1-y, x, y)
 end

 def f(x, y)
   f_helper = lambda do |a,b|
     x*a**2 + y*b + a*b
   end
   a = 1+(x*y)
   b = 1-y
   f_helper.call(a, b)
 end

 def f(x, y)
   a = 1+(x*y)
   b = 1-y
   x*a**2 + y*b + a*b
 end
||&lt;
一番上のコードにおいて
Rubyではローカル変数はメソッドを透過できないので
明示的に引数で受け渡す必要がある


関連記事：[http://d.hatena.ne.jp/keyesberry/20080809/p1:title=Rubyのブロックはメソッドに対するメソッドのMix-inだ！ - hp12c]


[asin:489471163X:detail]
(追記:2009/2/1）タイトルを「RubyでSchemeの高階関数を学ぼう」から「SchemeでRubyの高階関数を学ぼう」に変えました
(追記:2009/2/5)　タイトルを「SchemeでRubyの高階関数を学ぼう」から「SchemeとRubyで高階関数を学ぼう」に変えました

</body>
</day>
<day date="2009-01-31" title="">
<body>
*p1*SchemeとRubyで高階関数を学ぼう ~その2~
[http://d.hatena.ne.jp/keyesberry/20090129/p1:title=前回]に引き続き「[rakuten:book:10825992:title]」を使って
SchemeとRubyで平方根の求め方と
手続きを出力とする高階手続きをまとめてみました
なおSchemeのコードは本書からの抜粋で
説明は自分の要約です


**Newton法を使って平方根を求める
平方根を求めるとき
通常次々と近似を求めていくNewton法を使う


xの平方根を求める場合任意の予測値yを選び
yとx/yの平均を取っていくことでより良い予測値yが得られる
これを繰り返し十分に良い予測値が得られたら処理を終える
この手続きはSchemeでは以下のように表現できる

&gt;|scheme|
 (define (sqrt_iter guess x)
 	(if (good_enough? guess x)
 	     guess
 	     (sqrt_iter (improve guess x)
 			      x)))
||&lt;
予想値guessがgood_enough?になるまで
改善された予想値で処理が繰り返される(improve)


予想値guessを改善する手続きimproveは次のようになる
&gt;|scheme|
 (define (improve guess x)
 	(average guess (/ x guess)))
 
 (define (average x y)
 	(/ (+ x y) 2))
||&lt;

任意の許容値を決めて手続きgood_enough?を定義する
ここでは予想値の二乗とxの差が0.001より小さくなるまでとする

&gt;|scheme|
 (define (good_enough? guess x)
 	(&lt; (abs (- (square guess) x)) 0.001))
 	
 (define (square x)
 	(* x x))
||&lt;
最後に最初の予想値を1として
平方根を求めるsqrt手続きを定義すれば
任意の数の平方根が得られる

&gt;|scheme|
 (define (sqrt x)
 	(sqrt_iter 1.0 x))
 
 (sqrt 9)
 3.00009155413138
||&lt;


次に対応するRubyのコードを書いてみる
同様にNewton法により平方根を求める
&gt;|ruby|
 def sqrt_iter(guess, x)
   if good_enough?(guess, x)
     guess
   else
     sqrt_iter(improve(guess, x), x)
   end
 end
||&lt;

improve、good_enough?メソッドは以下のようになる

&gt;|ruby|
 def improve(guess, x)
   average(guess, x/guess)
 end
 
 def average(x, y)
   (x + y) / 2
 end
 
 def good_enough?(guess, x)
   (square(guess) - x).abs &lt; 0.001
 end
 
 def square(x)
   x * x
 end
||&lt;

これで平方根を求める準備が整った
&gt;|ruby|
 def sqrt(x)
   sqrt_iter(1.0, x)
 end
 
 sqrt 9 # =&gt; 3.00009155413138
||&lt;


Rubyはオブジェクト指向言語なので
これらのメソッドを特定のオブジェクトに
結びつけたほうがRubyっぽいかもしれない
ここではNumericクラスのインスタンスメソッドとして
これらの手続きを定義してみる

&gt;|ruby|
 class Numeric
   def square
     self**2
   end
   
   def sqrt
     sqrt_iter(1.0)
   end
   
   private
   def sqrt_iter(guess)
     if good_enough?(guess, self)
       guess
     else
       sqrt_iter(improve(guess))
     end
   end
   
   def improve(guess)
     average(guess, self/guess)
   end
   
   def average(x, y)
     (x + y) / 2
   end
   
   def good_enough?(guess, x)
     (guess.square - x).abs &lt; 0.001
   end
 end
 
 2.sqrt # =&gt; 1.41421568627451
 2.square # =&gt; 4
||&lt;
sqrt,square以外のメソッドが
外から呼び出せるのは適当でないから
それらのメソッドはprivateとした


**不動点探索を使って平方根を求める
平方根は不動点探索を使っても求めることができる
xがf(x)=xを満たすとき、xを関数fの不動点(fixed point)という
予想値からはじめて関数fを繰り返し適用することで
不動点を見つけることができる


Schemeで表現すると以下のようになる
手続きfixed_pointは入力として
関数fと最初の予想値first_guessを取る

&gt;|scheme|
 (define tolerance 0.00001)
 
 (define (fixed_point f first_guess)
 	(define (close_enough? v1 v2)
 		(&lt; (abs (- v1 v2)) tolerance))
 	(define (try guess)
 		(let ((next (f guess)))
 			(if (close_enough? guess next)
 			     next
 			    (try next))))
 	(try first_guess))
||&lt;

補助手続きとしてclose_enough?,tryを定義し抽象化する
これを用いて例えば
方程式[tex:y=sin y + cos y]の解が得られる

&gt;|scheme|
 (fixed_point (lambda (y) (+ (sin y) (cos y)))
 		 1.0)
 1.25873159629712
||&lt;


平方根の計算は不動点探索の問題に置き換えられる
つまりxの平方根の計算は[tex:y^2] = xなるyを探すことだから
これはy=x/yと書けy -&gt; x/yの不動点を探しているのと等価である
先のfixed_point手続きを使って平方根を求めてみよう

&gt;|scheme|
 (define (sqrt x)
 	(fixed_point (lambda (y) (average y (/ x y)))
 		1.0))
 		
 (sqrt 3)
 1.73205080756888
||&lt;

なおfixed_pointに渡す関数fをx/yとすると
うまく収束しないのでここでは
yとx/yの平均を使っている
これを平均緩和法(average damping)という


同様のことをRubyでやってみる
まずfixed_pointメソッドを定義する

&gt;|ruby|
 Tolerance = 0.00001
 def fixed_point(f, first_guess)
   def close_enough?(v1, v2)
     (v1 - v2).abs &lt; Tolerance
   end
   try = lambda do |guess|
     _next = f.call(guess)
     if close_enough?(guess, _next)
       _next
     else
       try.call(_next)
     end
   end
   try.call(first_guess)
 end
 
 fixed_point(lambda{ |y| Math.sin(y) + Math.cos(y) }, 1.0) # =&gt;  1.25873159629712
||&lt;

Rubyではローカル変数はメソッドを透過できないので
tryをメソッドではなくブロックで定義し
引数として渡される関数fが参照できるようにした


平方根を求めよう
&gt;|ruby|
 def sqrt(x)
   fixed_point(lambda { |y| average(y, x/y) }, 1.0)
 end
 
 sqrt 3 # =&gt; 1.73205080756888
||&lt;

fixed_pointをMathモジュールとしたほうが
Rubyっぽいかもしれない
&gt;|ruby|
 module Math
   def self.fixed_point(first_guess)
     @first_guess = first_guess
     _next = yield(first_guess)
     if close_enough?(first_guess, _next)
       _next
     else
       self.fixed_point(_next){ yield(@first_guess) }
     end
   end
 
   private
   Tolerance = 0.00001
   def self.close_enough?(v1, v2)
     (v1 - v2).abs &lt; Tolerance
   end
 end
 
 Math.fixed_point(1.0){ |y| Math.sin(y) + Math.cos(y) } # =&gt; 1.25873159629712
 
 class Numeric
   def sqrt
     Math.fixed_point(1.0) { |y| average(y, self/y) }
   end
 end
 
 3.sqrt # =&gt; 1.73205080756888
||&lt;


**手続きを返す高階手続き
平方根を求めるのに先の例では平均緩和法を使った
今度は手続きを返すSchemeの高階手続きを使って
これを一般化する


次の手続きaverage_dampは引数として手続きfをとり
手続きを返す高階手続きである
&gt;|scheme|
 (define (average_damp f)
	(lambda (x) (average x (f x))))
||&lt;

例えばこれに[tex:x]を[tex:x^2]とする手続きsquareを渡すと
[tex:x]と[tex:x^2]の平均を値とする手続きを返す
だから例えばこの返された手続きに10を作用させると
10と100の平均が得られる

&gt;|scheme|
(average_damp square) 10)
55
||&lt;

これを用いて先の手続きsqrtを書き換える
&gt;|scheme|
 (define (sqrt x)
	(fixed_point (average_damp (lambda (y) (/ x y)))
				 1.0))

 (sqrt 3)
 1.73205080756888

;先のコード
(define (sqrt x)
	(fixed_point (lambda (y) (average y (/ x y)))
		1.0))
||&lt;


同様の高階手続きをRubyでもやってみる
average_dampメソッドは以下のようになる
&gt;|ruby|
 def average_damp(f)
   lambda { |x| average(x, f.call(x)) }
 end
 
 def sqrt(x)
   fixed_point(average_damp(lambda { |y| x/y }), 1.0)
 end
 
 sqrt 3 # =&gt; 1.73205080756888
||&lt;
average_dampはProcオブジェクトを返す


ブロックを使えば
もう少しRubyらしくなる
&gt;|ruby|
 def average_damp
   lambda { |x| average(x, yield(x)) }
 end
 
 def sqrt(x)
   fixed_point(average_damp{ |y| x/y }, 1.0)
 end
 
 sqrt 3 # =&gt; 1.73205080756888
||&lt;

さらにsqrtをNumericクラスのインスタンスメソッドにしてみる
&gt;|ruby|
 class Numeric
   def sqrt
     Math.fixed_point(1.0) { |y| average_damp{ |x| self/x }.call(y) }
   end
   
   private
   def average_damp
     lambda { |x| average(x, yield(x)) }
   end
 end
 
 3.sqrt # =&gt; 1.73205080756888
||&lt;


[rakuten:book:10825992:detail]
(追記:2009/2/1）タイトルを「RubyでSchemeの高階関数を学ぼう~その2~」から「SchemeでRubyの高階関数を学ぼう~その2~」に変えました
(追記:2009/2/5)　タイトルを「SchemeでRubyの高階関数を学ぼう~その2~」から「SchemeとRubyで高階関数を学ぼう~その2~」に変えました

</body>
</day>
<day date="2009-02-01" title="">
<body>
*p1*SchemeとRubyでデータ抽象を学ぼう
[http://d.hatena.ne.jp/keyesberry/20090131/p1:title=前回]に引き続き「[rakuten:book:10825992:title]」を使って
今度はSchemeとRubyにおける
データ抽象の違いを見ていこうと思います
なおSchemeのコードは本書からの抜粋で
説明は自分の要約です


**有理数演算手続き
有理数に対する演算(例えばadd_rat)を考えるとき
分子と分母の数値を個別で取り扱う手続きを考えるよりも
分子と分母を対とした一つの有理数を対象に
手続きを考えられたら楽である


Schemeでは合成データを使って有理数を表現し
この抽象データに対しての演算手続きを表現することで
データ抽象を実現する


Schemeで有理数に対する算術演算
add_rat, sub_rat, mul_rat, div_rat, equal_rat?を考える
有理数に対する演算式は次の通りである


[tex:\frac{n1}{d1} + \frac{n2}{d2} = \frac{n1d2 + n2d1}{d1d2}]
[tex:\frac{n1}{d1} - \frac{n2}{d2} = \frac{n1d2 - n2d1}{d1d2}]
[tex:\frac{n1}{d1} * \frac{n2}{d2} = \frac{n1n2}{d1d2}]
[tex:\frac{n1/d1}{n2/d2} = \frac{n1d2}{d1n2}]
[tex:\frac{n1}{d1} = \frac{n2}{d2}] のときに限り [tex:n1d2 = n2d1]


整数nと整数dを取って
分子がn分母がdの有理数を返す手続きをmake_ratとし
make_ratで作られた有理数の分子を返す手続きをnumer
分母を返す手続きをdenomとした場合
Schemeによる上の演算表現は以下のようになる

&gt;|scheme|
 (define (add_rat x y)
        (make_rat (+ (* (numer x) (denom y))
                                (* (numer y) (denom x)))
                           (* (denom x) (denom y))))
 
 (define (sub_rat x y)
        (make_rat (- (* (numer x) (denom y))
                               (* (numer y) (denom x)))
                           (* (denom x) (denom y))))
 
 (define (mul_rat x y)
       (make_rat (* (numer x) (numer y))
                          (* (denom x) (denom y))))
 
 (define (div_rat x y)
       (make_rat (* (numer x) (denom y))
                          (* (denom x) (numer y))))
 
 (define (equal_rat? x y)
       (= (* (numer x) (denom y))
            (* (numer y) (denom x))))
||&lt;


これらの演算をRubyで表現してみる

&gt;|ruby|
 def add_rat(x, y)
   make_rat numer(x) * denom(y) + numer(y) * denom(x), 
            denom(x) * denom(y)
 end
 
 def sub_rat(x, y)
   make_rat numer(x) * denom(y) - numer(y) * denom(x),
            denom(x) * denom(y)
 end
 
 def mul_rat(x, y)
   make_rat numer(x) * numer(y),
            denom(x) * denom(y)
 end
 
 def div_rat(x, y)
   make_rat numer(x) * denom(y),
            denom(x) * numer(y)
 end
 
 def equal_rat?(x, y)
   numer(x) * denom(y) == numer(y) * denom(x)
 end
||&lt;


**有理数のデータ表現
Schemeに戻ろう
次に有理数を表現するために
手続きconsで構成される対を使う
consは2つの引数を取り
これらを部分として含む合成データオブジェクトを返す
合成データオブジェクトの部分は手続きcarとcdrで取り出せる

&gt;|scheme|
 (define x (cons 1 2))
 (car x)
 1
 (cdr x)
 2
||&lt;


これらを使って有理数を表現する

&gt;|scheme|
 (define (make_rat n d) (cons n d))
 (define (numer x) (car x))
 (define (denom x) (cdr x))
||&lt;

また結果を表示する手続きを加える

&gt;|scheme|
 (define (print_rat x)
 	 (newline)
 	(display (numer x))
 	(display &quot;/&quot;)
 	(display (denom x)))
||&lt;

これで有理数演算ができるようになった

&gt;|scheme|
 (define one_half (make_rat 1 2))
 
 (print_rat one_half)
 1/2
 (define one_third (make_rat 1 3))
 
 (print_rat (add_rat one_half one_third))
 5/6
 (print_rat (mul_rat one_half one_third))
 1/6
 (print_rat (add_rat one_third one_third))
 6/9
||&lt;

なお最後の例を見るとわかるが
先の手続きは簡約まではしない
最大公約数gcdを使ってこれを改善する

&gt;|scheme|
 (define (make_rat n d)
 	(let ((g (gcd n d)))
 	 (cons (/ n g) (/ d g))))
||&lt;


さてRubyでも有理数を表現してみる
Rubyでは配列を使うのがよさそうだ

&gt;|ruby|
 reqire 'rational'
 def make_rat(n, d)
   g = n.gcd(d)
   [n/g, d/g]
 end
 
 def numer(x)
   x[0]
 end
 
 def denom(x)
   x[1]
 end
 
 def print_rat(x)
   puts &quot;#{numer x}/#{denom x}&quot;
 end
||&lt;

gcdを使うのにrationalライブラリをrequireする
演算結果は以下の通り

&gt;|ruby|
 def one_half
   make_rat 1, 2
 end
 print_rat one_half
 
 def one_third
   make_rat 1, 3
 end
 print_rat one_third
 
 print_rat add_rat(one_half, one_third)
 
 print_rat mul_rat(one_half, one_third)
 
 print_rat add_rat(one_third, one_third)
 # &gt;&gt; 1/2
 # &gt;&gt; 1/3
 # &gt;&gt; 5/6
 # &gt;&gt; 1/6
 # &gt;&gt; 2/3
||&lt;


**クラスによるデータ抽象
でもこれは実にRubyっぽくない
Rubyではデータ抽象にクラスを使うのがよさそうだ
有理数クラスRatを定義してみる

&gt;|ruby|
 require &quot;rational&quot;
 class Rat
   attr_reader :numer, :denom
   def initialize(n, d)
     g = n.gcd d
     @numer, @denom = n/g, d/g
   end
   
   def +(other)
    Rat.new(self.numer * self.denom + other.numer * other.denom,
             self.denom * other.denom)
   end
   
   def -(other)
    Rat.new(self.numer * other.denom - other.numer * self.denom,
             self.denom * other.denom)
   end
   
   def *(other)
     Rat.new(self.numer * other.numer,
             self.denom * other.denom)
   end
   
   def /(other)
     Rat.new(self.numer * other.denom,
             self.denom * other.numer)
   end
   
   def ==(other)
     self.numer * other.denom == other.numer * self.denom
   end
   
   def to_s
     &quot;#{self.numer}/#{self.denom}&quot;
   end
 end
 
 one_half = Rat.new(1, 2) # =&gt; #&lt;Rat:0x140dc @numer=1, @denom=2&gt;
 one_third = Rat.new(1, 3) # =&gt;#&lt;Rat:0x13ce0 @numer=1, @denom=3&gt;
 
 one_third.denom # =&gt; 3
 
 one_half.to_s # =&gt; &quot;1/2&quot;
 (one_third + one_third).to_s # =&gt; &quot;2/3&quot;
 (one_half * one_third).to_s # =&gt; &quot;1/6&quot;
 (one_half / one_third).to_s # =&gt; &quot;3/2&quot;
 one_half == one_third # =&gt; false
||&lt;

newで渡した引数を分子分母とする
有理数クラスのインスタンスを生成する
分子分母にはnumer、denomメソッドでアクセスできる
各算術演算は整数と同じ記号を使え
算術の結果は有理数クラスのインスタンスで返される


もちろんRubyには標準でRationalクラスがある

&gt;|ruby|
 one_half = Rational(1, 2)
 one_third = Rational(1, 3)
 one_half * one_third # =&gt; Rational(1, 6)
 one_half /one_third # =&gt; Rational(3, 2)
||&lt;


[rakuten:book:10825992:detail]
(追記:2009/2/5)　タイトルを「SchemeでRubyのデータ抽象を学ぼう」から「SchemeとRubyでデータ抽象を学ぼう」に変えました

</body>
</day>
<day date="2009-02-05" title="">
<body>
*p1*SchemeとRubyでリストの操作を学ぼう
引き続き「[asin:489471163X:title]」を使って
今度はSchemeとRubyでのリストの操作を見ていこうと思います
なおSchemeのコードは本書からの抜粋で
説明は自分の要約です


**リスト要素の参照
Schemeにはデータオブジェクトの並びを表現する
リストというデータ構造がある
リストはlist手続きで作ることができるが
これはconsを入れ子にしたものと等価である
&gt;|scheme|
 list 1 2 3 4
 (1 2 3 4)
 
 (cons 1 (cons 2 (cons 3 (cons 4 nil))))
 (1 2 3 4)
||&lt;

だからconsを順にcdrダウンしていけば
リストの各要素にアクセスできる
これを使って
リストのn番目の要素を返す手続きlist_refを定義する
リストは0番から始まる

&gt;|scheme|
 (define (list_ref items n)
 	(if (= n 0)
 		(car items)
 		(list_ref (cdr items) (- n 1))))
 
 (define squares (list 1 4 9 16 25))
 
 (list_ref squares 3)
 16
||&lt;
再帰を使ってリストをcdrダウンしていき
nが0になったところでその第一要素をcarで返す


Rubyでも同様のことをやってみる
まずconsを定義しこれを使ってリストを定義する
consの定義にはRubyのArrayクラスを使うのがよさそうだ

&gt;|ruby|
 def cons(a, b=nil)
   [a, b]
 end
 
 def car(items)
   case items
   when Array
     items[0]
   else
     raise &quot;bad argument type&quot;
   end
 end
 
 def cdr(items)
   case items
   when Array
     items[1]
   else
     raise &quot;bad argument type&quot;
   end
 end
 
 def list(*i)
   if i.empty?
     nil
   else
     cons i.shift, list(*i)
   end
 end
 
 odds = list 1, 3, 5, 7 # =&gt; [1, [3, [5, [7, nil]]]]
||&lt;


consに基づいてリストが定義できれば
schemeと同じアルゴリズムで
list_refが定義できるはずだ
&gt;|ruby|
 def list_ref(items, n)
   if n == 0
     car items
   else
     list_ref(cdr(items), n-1)
   end
 end
 
 list_ref(odds, 3) # =&gt; 7
||&lt;


**リストの長さ
schemeに戻って
リストの長さ(要素数)を返す手続きlengthを定義する
&gt;|scheme|
 (define (length items)
 	(if (null? items)
 		0
 		(+ 1 (length (cdr items)))))
 		
 (define odds (list 1 3 5 7 9))		
 (length odds)
 5
||&lt;
cdrダウンするたびに1カウントして
第二要素がnilになったところで終了する


Rubyでもlengthを定義しよう
&gt;|ruby|
 def length(items)
   if items.nil?
     0
   else
     1 + length(cdr items)
   end
 end
 
 length(odds) # =&gt; 4
||&lt;


**リストの結合
次に2つのリストを結合する手続きappendを定義する
&gt;|scheme|
 (define (append list1 list2)
 	(if (null? list1)
 		list2
 		(cons (car list1) (append (cdr list1) list2))))
 
 (append squares odds)
 (1 4 9 16 25 1 3 5 7 9)
||&lt;
list1をcdrダウンしていくたびに
list1をcarして新たなpairをconsする
list1が空に達したらlist2を繋ぐ


Rubyでもappendを定義しよう
&gt;|ruby|
 def append(list1, list2)
   if list1.nil?
     list2
   else
     cons car(list1), append(cdr(list1), list2)
   end
 end
 
 squares = list 1, 4, 9, 16, 25
 append(odds, squares) # =&gt; [1, [3, [5, [7, [1, [4, [9, [16, [25, nil]]]]]]]]]
||&lt;


**リスト要素に手続きを作用させる
今度はリストの各要素に
任意の手続きを作用させたリストを返す手続きmapを定義する

&gt;|scheme|
 (define (map proc items)
 	(if (null? items)
 		`()
 		(cons (proc (car items))
 			(map proc (cdr items)))))
||&lt;
map手続きにはリストと共に手続きprocを渡し
リストをcdrダウンしていくたびに
リストの第一要素にprocを作用させた結果を
consして新たな要素を作る


mapに渡す演算を変えることによって
多様な結果が得られる
&gt;|scheme|
 (map abs (list -10 2.5 -11.6 17))
 (10 2.5 11.6 17)
 
 (map (lambda (x) (* x x))
 		(list 1 2 3 4))
 (1 4 9 16)
||&lt;

これを使って新たな演算を定義してもいい

&gt;|scheme|
 (define (scale_list items)
 	(map (lambda (x) (* x x))
 		 items))
 (square_list (list 1 2 3 4))
 (1 4 9 16)
||&lt;


次にRubyでもmapを定義しよう
&gt;|ruby|
 def map(proc, items)
   if items.nil?
     nil
   else
     cons proc.call(car items), map(proc, cdr(items))
   end
 end
 
 map(lambda { |x| x.abs }, list(-10, 2.5, -11.6, 17)) # =&gt; [10, [2.5, [11.6, [17, nil]]]]
 
 def scale_list(items)
   map(lambda { |x| x**2 }, items)
 end
 
 scale_list odds # =&gt; [1, [9, [25, [49, nil]]]]
||&lt;


**treeに対する演算
並びはその要素自身が並びである階層構造を許す
&gt;|scheme|
 (cons (list 1 2) (list 3 4))
 ((1 2) 3 4)
||&lt;
これは再帰的に枝分かれしていくtreeの構造を表現する
ここで先のlength手続きを適用した場合
先端の葉の部分までは数え上げてくれない

&gt;|scheme|
 (define tree (cons (list 1 2) (list 3 4)))
 
 (length tree)
 3
||&lt;


葉を数える手続きcount_leavesを定義しよう

&gt;|scheme|
 (define (count_leaves tree)
 	(cond ((null? tree) 0)
 		  ((not (pair? tree)) 1)
 		  (else (+ (count_leaves (car tree))
 				   (count_leaves (cdr tree))))))
 
 (count_leaves tree)
 4
 
 ;length手続き
 (define (length items)
 	(if (null? items)
 		0
 		(+ 1 (length (cdr items)))))
||&lt;
length手続きと比べると分かるが
treeをcdrダウンするときに
1を足す代わりにtreeをcarダウンして
葉に至ったら1を足すようにする
これは要素がpairでないことで判定できる


Rubyでもcount_leavesを定義しよう
その前にpair?メソッドを定義する
&gt;|ruby|
 def pair?(items)
   case items
   when Array
     true
   else
     false
   end
 end
 
 def count_leaves(x)
   case 
   when x.nil? then 0
   when !pair?(x) then 1
   else
     count_leaves(car x) + count_leaves(cdr x)
   end
 end
 
 count_leaves(x) # =&gt; 7
||&lt;
うまくいった


schemeに戻ってcount_leaves同様に
先のscale_listもtreeに対応させよう

&gt;|scheme|
 (define (scale_tree tree factor)
 	(cond ((null? tree) `())
 		  ((not (pair? tree)) (* tree factor))
 		  (else (cons (scale_tree (car tree) factor)
 					  (scale_tree (cdr tree) factor)))))
 					
 (scale_tree (list 1 (list 2 (list 3 4) 5) (list 6 7))
 			   10)
 (10 (20 (30 40) 50) (60 70))
 
 ;scale_list手続き
 (define (scale_list items factor)
 	(if (null? items)
 		`()
 		(cons (* (car items) factor)
 			  (scale_list (cdr items) factor))))
||&lt;
scale_listとの違いはcdrダウンするときに
listの第一要素とfactorを直ぐに掛けず
carダウンして葉に至ったところでfactorを作用させる点である


Rubyでも同じようにやってみよう
&gt;|ruby|
 def scale_tree(tree, factor)
   case 
   when tree.nil? then nil
   when !pair?(tree) then tree * factor
   else
     cons scale_tree(car(tree), factor), scale_tree(cdr(tree), factor)
   end
 end
 l = list(1, (list 2, (list 3, 4), 5), (list 6, 7)) # =&gt; [1, [[2, [[3, [4, nil]], [5, nil]]], [[6, [7, nil]], nil]]]
 scale_tree l, 10 # =&gt; [10, [[20, [[30, [40, nil]], [50, nil]]], [[60, [70, nil]], nil]]]
||&lt;


**Listクラスを定義する
Rubyではリストをオブジェクトしたバージョンも書いてみる
Arrayクラスを継承してListクラスを定義する

&gt;|ruby|
 class List &lt; Array
   def list_ref(n)
     self[n]
   end
   
   def append(list)
     self + list
   end
   
   def last_pair
     self[-1]
   end
   
   def scale_list(n)
     self.inject([]) { |arr, e| arr &lt;&lt; e * n  }
   end
   
   def map
     self.inject([]) { |arr, e| arr &lt;&lt; yield(e) }
   end
   
   def count_leaves
     self.inject(0) do |len, e|
       case e
       when List
         len + e.count_leaves
       else
         len + 1
       end
     end
   end
   
   def map_tree
     self.inject([]) do |arr, e|
       case e
       when List
         arr &lt;&lt; e.map_tree{ |x| yield(x) }
       else
         arr &lt;&lt; yield(e)
       end
     end
   end
 end
 
 odds = List[1, 3, 5, 7] # =&gt; [1, 3, 5, 7]
 
 odds.list_ref(2) # =&gt; 5
 
 odds.length # =&gt; 4
 
 squares = List[1, 4, 9, 16, 25]
 
 odds + squares # =&gt; [1, 3, 5, 7, 1, 4, 9, 16, 25]
 odds.append(squares) # =&gt; [1, 3, 5, 7, 1, 4, 9, 16, 25]
 
 odds.last_pair # =&gt; 7
 odds.scale_list(5) # =&gt; [5, 15, 25, 35]
 
 odds.map { |e| e**2 } # =&gt; [1, 9, 25, 49]
 
 tree = List[1, List[2, List[3, 4], 5], List[6, 7]] # =&gt; [1, [2, [3, 4], 5], [6, 7]]
 
 tree.count_leaves # =&gt; 7
 tree.map_tree { |x| x**2 } # =&gt; [1, [4, [9, 16], 25], [36, 49]]
||&lt;
injectを使うのはちょっとずるっぽいけど
まあいいか


[asin:489471163X:detail]

</body>
</day>
<day date="2009-02-06" title="">
<body>
*p1*SchemeとRubyで接続インタフェースを学ぼう
引き続き「[asin:489471163X:title]」を使って
SchemeとRubyでリストの接続インタフェース((conventional interface:訳書では公認インタフェースとなっています))
としての使用について見ていこうと思います
なおSchemeのコードは本書からの抜粋で
説明は自分の要約です

**リストの接続インタフェースとしての使用
いま構造的に大きく異なった2つの手続きをみていく
１つは引数としてtreeを取り
それが奇数である葉の二乗の和を計算する手続きであり
１つは整数n以下のkに対して
偶数のフィボナッチ数のリストを作る手続きである


前者の手続きはSchemeで以下のように表現できる
&gt;|scheme|
 (define (sum_odd_squares tree)
       (cond ((null? tree) 0)
                  ((not (pair? tree))
                       (if (odd? tree) (square tree) 0))
                  (else (+ (sum_odd_squares (car tree))
                                 (sum_odd_squares (cdr tree))))))
 
 (define tree (list 1 (list 2 (list 3 4) 5 (list 6 7))))
 (sum_odd_squares tree)
 84
||&lt;
treeをcarダウンおよびcdrダウンしていき
その葉が奇数であるときにその二乗を取り加算する


一方後者の手続きは以下のようになる
&gt;|scheme|
 (define (even_fibs n)
       (define (next k)
             (if (&gt; k n)
                 `()
             (let ((f (fib k)))
                  (if (even? f)
                       (cons f (next (+ k 1)))
                       (next (+ k 1))))))
        (next 0))
 
 (even_fibs 20)
 (0 2 8 34 144 610 2584)
||&lt;
k番目のフィボナッチ数を求める手続きをfib(k)とし
その結果が偶数であるときにconsで
選択されたフィボナッチ数の列を構築していく


**手続きの部品化
これらの手続きは構造的には大きく異なっているが
それらの計算のより抽象的なレベルでは類似性がある


つまり
-葉を数え上げる &lt;-&gt; 整数をnまで数え上げる(enumarate)
-奇数のものを選ぶ &lt;-&gt; 偶数のものを選ぶ(filter)
-選ばれたものを二乗する &lt;-&gt; 各整数のフィボナッチ数を計算する(map)
-結果を足し合わせていく &lt;-&gt; 結果をconsしていく(accumurate)


これら各手続きを抽象化された部品として構築し
リストをこれらの接続インタフェースとして使用することによって
プログラマはあたかも信号処理技術者のように
信号処理に必要な標準化部品を選び
これらを接続することによって複雑さを制御できるようになる


このことをこれから示そう
まず最初の標準化部品としてmap手続きを書こう
&gt;|scheme|
 (define (map proc items)
        (if (null? items)
             `()
         (cons (proc (car items))
                    (map proc (cdr items)))))
||&lt;
これはリストの二乗計算にも
フィボナッチ数演算にも使え
結果はリストで返される

&gt;|scheme|
 (map square (list 1 2 3 4 5))
 (1 4 9 16 25)
 
 (map fib (list 0 1 2 3 4 5 6 7 8))
 (0 1 1 2 3 5 8 13 21)
||&lt;


次に条件を満たした要素だけを選び出す
filter手続きを書こう
&gt;|scheme|
 (define (filter predicate sequence)
        (cond ((null? sequence) `())
                 ((predicate (car sequence))
                          (cons (car sequence)
                                  (filter predicate (cdr sequence))))
                  (else (filter predicate (cdr sequence)))))
 
 (p (filter odd? (list 1 2 3 4 5)))
 (1 3 5)
 (p (filter even? (list 1 2 3 4 5)))
 (2 4)
||&lt;
predicateの条件を満たした要素だけの
新たなリストをconsで作成していく


結果を順次継ぎ足していく
accumurate手続きは以下のようになる

&gt;|scheme|
 (define (accumulate op initial sequence)
         (if (null? sequence)
               initial
              (op (car sequence)
                     (accumulate op initial (cdr sequence)))))
 
 (accumulate + 0 (list 1 2 3 4 5))
 15
 (accumulate * 1 (list 1 2 3 4 5))
 120
 (accumulate cons `() (list 1 2 3 4 5))
 (1 2 3 4 5)
||&lt;
引数opに目的の演算を渡すことによって
それに沿った継ぎ足しが行われる


enumarate手続きは各異なるものが必要だ
木の葉を数え上げるenumarate_treeを最初に定義しよう
&gt;|scheme|
 (define (enumerate_tree tree)
        (cond ((null? tree) `())
                 ((not (pair? tree)) (list tree))
                 (else (append (enumerate_tree (car tree))
                                          (enumerate_tree (cdr tree))))))
 
 (enumerate_tree (list 1 (list 2 (list 3 4)) 5))
 (1 2 3 4 5)
||&lt;


整数をnまで数え上げるenumarate_intervalは以下のようになる
&gt;|scheme|
 (define (enumerate_interval low high)
         (if (&gt; low high)
              `()
              (cons low (enumerate_interval (+ low 1) high))))
 
 (enumerate_interval 2 7)
 (2 3 4 5 6 7)
||&lt;


**部品の接続
これで標準化部品が揃ったので
これらを使って
最初のsum_odd_squaresとeven_fibを
定義し直そう

&gt;|scheme|
  (define (sum_odd_squares tree)
        (accumulate +
             0
             (map square
                      (filter odd?
                            (enumerate_tree tree)))))
  
  (define tree (list 1 (list 2 (list 3 4) 5 (list 6 7))))
  
  (sum_odd_squares tree)
  84
  
  (define (even_fibs n)
       (accumulate cons
            `()
             (filter even?
                    (map fib
                           (enumerate_interval 0 n)))))
  (even_fibs 20)
  (0 2 8 34 144 610 2584)
||&lt;


このような標準化部品のライブラリがあれば
例えば個人レコードから最高収入のプログラマの給料を抽出する
といった処理のプログラムを簡単に書くことができる
&gt;|scheme|
 (define (salary_of_highest_paid_programmer records)
         (accumulate max
                  0
                  (map salary
                          (filter programmer? records))))
||&lt;


**Rubyでの実装
最初に検討される2つの手続き
sum_odd_squaresとeven_fibsをRubyで書いてみる
なおconsおよびlistの定義は前回を参照のこと((pはdef p(x); x.join(&quot; &quot;).chop endで定義している))
&gt;|ruby|
 def sum_odd_squares(tree)
   case
   when tree.nil? then 0
   when !pair?(tree)
     if tree.odd?
       square(tree)
     else
       0
     end
   else
     sum_odd_squares(car tree) + sum_odd_squares(cdr tree)
   end
 end
 
 tree = list 1, (list 2, (list 3, 4), 5, (list 6, 7))
 sum_odd_squares tree # =&gt; 84
 
 def fib(n)
   case
   when n == 0 then 0
   when n == 1 then 1
   else
     fib(n-1) + fib(n-2)
   end
 end
 
 def even_fibs(n)
   _next = lambda do |k|
     if k &gt; n
       nil
     else
       f = fib(k)
       if f.even?
         cons f, _next.call(k+1)
       else
         _next.call(k+1)
       end
     end
   end
   _next.call 0
 end
 
 p even_fibs 20 # =&gt; &quot;0 2 8 34 144 610 2584&quot;
||&lt;


Rubyではmapメソッドは以下のようになる
&gt;|ruby|
 def map(proc, items)
   if items.nil?
     nil
   else
     cons send(proc, car(items)), map(proc, cdr(items))
   end
 end
 
 tree = list 1, 2, 3, 4, 5
 p map(:square, tree) # =&gt; &quot;1 4 9 16 25&quot;
||&lt;
procへの手続きの引き渡しはシンボルで行い
これをsendメソッドに渡すことによって呼び出す


filterメソッドは以下のようになる
&gt;|ruby|
 def filter(predicate, sequence)
   case
   when sequence.nil? then nil
   when (car sequence).send(predicate)
     cons car(sequence), filter(predicate, cdr(sequence))
   else
     filter(predicate, cdr(sequence))
   end
 end
 
 p filter(:odd?, list(1, 2, 3, 4, 5)) # =&gt; &quot;1 3 5&quot;
||&lt;


accumurateメソッドは以下のようになる

&gt;|ruby|
 def accumulate(op, initial, sequence)
   if sequence.nil?
     initial
   else
     car(sequence).send(op, (accumulate(op, initial, cdr(sequence))))
   end
 end
 
 class Integer
   def cons(other=nil)
     [self, other]
   end
 end
 
 accumulate(:+, 0, list(1, 2, 3, 4, 5)) # =&gt; 15
 accumulate(:*, 1, list(1, 2, 3, 4, 5)) # =&gt; 120
 p accumulate(:cons, nil, list(1, 2, 3, 4, 5)) # =&gt; &quot;1 2 3 4 5&quot;
||&lt;
ここではcons手続きを
 +や*メソッドと同様に扱えるようにするため
Integerクラスのインスタンスメソッドとして定義している


次にenumarate_treeとenumarate_intervalをそれぞれ定義する

&gt;|ruby|
 def append(list1, list2)
   if list1.nil?
     list2
   else
     cons car(list1), append(cdr(list1), list2)
   end
 end
 
 def enumarate_tree(tree)
   case
   when tree.nil? then nil
   when !pair?(tree) then list tree
   else
     append enumarate_tree(car tree), enumarate_tree(cdr tree)
   end
 end
 
 p enumarate_tree list 1, (list 2, list(3, 4), 5) # =&gt; &quot;1 2 3 4 5&quot;
 
 def enumerate_interval(low, high)
   if low &gt; high
     nil
   else
     cons low, enumerate_interval(low+1, high)
   end
 end
 
 p enumerate_interval 2, 7 # =&gt; &quot;2 3 4 5 6 7&quot;
||&lt;


これで標準化部品が揃ったので
これらを使って先のsum_odd_squaresとeven_fibsを書いてみる
&gt;|ruby|
 def sum_odd_squares(tree)
   accumulate(:+, 0, map(:square, filter(:odd?, enumarate_tree(tree))))
 end
 
 tree = list 1, (list 2, (list 3, 4), 5, (list 6, 7))
 sum_odd_squares tree # =&gt; 84
 
 def even_fibs(n)
   accumulate(:cons, nil, filter(:even?, map(:fib, (enumerate_interval(0, n)))))
 end
 
 p even_fibs 20 # =&gt; &quot;0 2 8 34 144 610 2584&quot;
||&lt;


**RubyでArrayオブジェクトを接続インタフェースとした実装
Rubyには上記の各手続きを規定したEnumerableモジュールがあり
リストの実装に適したArrayクラスで利用できるようになっているので
これを継承した例を最後にかいてみる

&gt;|ruby|
 class List &lt; Array
 end
 
 tree = List[1, 2, 3, 4, 5] # =&gt; [1, 2, 3, 4, 5]
 
 tree.map { |e| e * e } # =&gt; [1, 4, 9, 16, 25]
 
 tree.select { |e| e.odd? } # =&gt; [1, 3, 5]
 
 tree.inject(:+) # =&gt; 15
 tree.inject(:*) # =&gt; 120
 tree.inject([]) { |arr, e| arr &lt;&lt; e } # =&gt; [1, 2, 3, 4, 5]
 
 tree = List[1, List[2, List[3, 4], 5, List[6, 7]]] # =&gt; [1, [2, [3, 4], 5, [6, 7]]]
 tree.flatten # =&gt; [1, 2, 3, 4, 5, 6, 7]
 
 class List
   def sum_odd_squares
     self.flatten.select { |e| e.odd? }.map { |e| e * e  }.inject(:+)
   end
 end
 
 tree.sum_odd_squares # =&gt; 84
 
 def even_fibs(n)
   0.upto(n).map { |e| fib(e) }.select { |e| e.even? }.inject([]) { |arr, e| arr &lt;&lt; e }
 end
 
 def fib(n)
   case
   when n == 0 then 0
   when n == 1 then 1
   else
     fib(n-1) + fib(n-2)
   end
 end
 
 even_fibs 20 # =&gt; [0, 2, 8, 34, 144, 610, 2584]
||&lt;
Schemeにおける接続インタフェースでは処理の流れは
括弧でカスケードされて右から左へいくのに対し
Rubyのオブジェクトを使った接続インタフェースでは
左から右へ順次流れていくので
より構造の把握がしやすい


[asin:489471163X:detail]

</body>
</day>
<day date="2009-02-08" title="">
<body>
*p1*SchemeとRubyで写像の入れ子を学ぼう
引き続き「[asin:489471163X:title]」を使って
SchemeとRubyで写像の入れ子を見ていきます
なおSchemeのコードは本書からの抜粋で
説明は自分の要約です


**整数の和の素数列
1からnの範囲において j &lt; i なる2つの整数 i, j の和が
素数になるものを見つける例を通して写像の入れ子を学ぼう


nが6の場合のペアは以下のようになる
&gt;|
 i      2  3  4  4  5  6  6
 j      1  2  1  3  2  1  5
 i+j    3  5  5  7  7  7  11
|&lt;

戦略としてはn以下の正の整数のすべてのペア(i, j)を生成し
その合計が素数であるものを選択し
選択されたペアからそれに合計を加えたセット(i, j, i+j)を作る
&gt;|scheme|
 (accumulate append
    `()
    (map (lambda (i)
       (map (lambda (j) (list i j))
            (enumerate_interval 1 (- i 1))))
          (enumerate_interval 1 n)))
||&lt;
enumerate_interval 1 nで1からnの各整数iを生成し
これを次の段のmap手続きに渡すmap手続きに作用させる
次段のmapでは受け取った整数iに対し
enumerate_interval 1 (- i 1)で1からi-1の整数jを生成し
リストi jを生成する
これをaccumulate手続きに渡したappendで
順次並べていけば目的の対のセットができ上がる


次にその和が素数であるものを見つける手続きprime_sum?と
結果のセットを作る手続きmake_pair_sumを書く

&gt;|scheme|
 (define (prime_sum? pair)
    (prime? (+ (car pair) (cadr pair))))
 
    
 (define (make_pair_sum pair)
    (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
||&lt;

これらを繋いで目的の手続きprime_sum_pairsが得られる

&gt;|scheme|
 (define (prime_sum_pairs n)
    (map make_pair_sum
       (filter prime_sum?
          (flatmap
             (lambda (i)
                (map (lambda (j) (list i j))
                   (enumerate_interval 1 (- i 1))))
             (enumerate_interval 1 n)))))
 
 (prime_sum_pairs 6)
 ((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11))
||&lt;


なおここではmapとappendによるaccumulateの手続きを
flatmap手続きとして抽象化している
&gt;|scheme|
 (define (flatmap proc seq)
    (accumulate append `() (map proc seq)))
||&lt;


**Ruby版素数列
同じことをRubyでもやってみる
&gt;|ruby|
 def flatmap(proc, seq)
   accumulate(:append, nil, map(proc, seq))
 end
 
 def prime_sum?(pair)
   prime?(car(pair) + car(cdr(pair)))
 end
 
 def make_pair_sum(pair)
   a, b = car(pair), car(cdr(pair))
   list a, b, a+b
 end
 
 def prime_sum_pairs(n)
   mapping = lambda { |i| map(lambda { |j| list i, j }, enumerate_interval(1, i-1)) }
   seq = enumerate_interval(1, n)
   list = filter(method(:prime_sum?), flatmap(mapping, seq))
   map(method(:make_pair_sum), list)
 end
 
 def _p(x)
   x.join(&quot; &quot;).chop
 end
 
 _p prime_sum_pairs 6 # =&gt; &quot;2 1 3  3 2 5  4 1 5  4 3 7  5 2 7  6 1 7  6 5 11 &quot;
||&lt;


**Arrayクラス版素数列
Arrayクラスの各種メソッドを使えば
もう少しRubyらしくなる
&gt;|ruby|
 def pairs(n)
   (1..n).map { |i| (1...i).map { |j| [i, j] } }.flatten(1)
 end
 pairs 6 # =&gt; [[2, 1], [3, 1], [3, 2], [4, 1], [4, 2], [4, 3], [5, 1], [5, 2], [5, 3], [5, 4], [6, 1], [6, 2], [6, 3], [6, 4], [6, 5]]
 
 def prime_sum?(pair)
   prime? pair.inject(:+)
 end
 
 def make_list(pair)
   pair &lt;&lt; pair.inject(:+)
 end
 
 def prime_sum_pairs(n)
   pairs(n).inject([]) { |arr, pair| prime_sum?(pair) ? arr &lt;&lt; make_list(pair) : arr}
 end
 
 prime_sum_pairs 6 # =&gt; [[2, 1, 3], [3, 2, 5], [4, 1, 5], [4, 3, 7], [5, 2, 7], [6, 1, 7], [6, 5, 11]]
||&lt;


**集合Sの順列
Schemeに戻って
先のflatmap手続きを使って
集合Sのすべての順列を求めてみよう

&gt;|scheme|
 (define (permutations s)
    (if (null? s)
       (list `())
       (flatmap (lambda (x)
                (map (lambda (p) (cons x p))
                    (permutations (remove x s))))
              s)))
 
 (permutations (list 1 2 3))
 ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))
||&lt;
内側のmap手続きで
外側のflatmapから渡された要素xを除く集合に対し
すべての組の順列を求めることを再帰的に繰り返す


要素xを除く手続きは以下のようになる
&gt;|scheme|
 (define (remove item seq)
    (filter (lambda (x) (not (= x item)))
       seq))
||&lt;


**Ruby版順列
Rubyでもpermutationsを書いてみる
&gt;|ruby|
 def permutations(s)
   mapping = lambda { |x| map(lambda { |p| cons x, p }, permutations(remove x, s)) }
   if s.nil?
     list nil
   else
     flatmap(mapping, s)
   end
 end
 
 def remove(item, seq)
   filter(lambda { |x| x != item }, seq)
 end
 
 _p permutations(list 1, 2, 3) # =&gt; &quot;1 2 3  1 3 2  2 1 3  2 3 1  3 1 2  3 2 1 &quot;
||&lt;


RubyのArrayクラスにはpermutationというメソッドが既にある

&gt;|ruby|
 List[1, 2, 3].permutation.to_a # =&gt; [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
||&lt;


[asin:489471163X:detail]

</body>
</day>
<day date="2009-02-15" title="">
<body>
*p1*SchemeとRubyで図形言語を学ぼう
「[asin:489471163X:title]」を読んでいる
2.2.4章に高階手続きを使った図形言語のサンプルが出てくる
何度か読み返しコードを実行しRuby版も一応できたけど
高階手続きの使い方に自分の思考がついていけない


[f:id:keyesberry:20090215180346p:image]


とりあえずRuby版をShoesで描画できるようにしたので
サンプルコードを公開しておきます


[http://gist.github.com/64646:title=gist: 64646 - GitHub]
</body>
</day>
<day date="2009-02-16" title="">
<body>
*p1*高階関数はコードをユーザフレンドリーにする
「[asin:489471163X:title]」の
図形言語のところでつまずいているので
もう一度高階関数に対する自分の理解を
Rubyを使って整理してみる


「高階関数」とはその引数として関数を取ったり
その戻り値として関数を返したりする関数のことである


今3つの数の和、差、積、商を求めるメソッドを考える
&gt;|ruby|
 def plus_abc(a, b, c)
   a + b + c
 end
 
 def minus_abc(a, b, c)
   a - b - c
 end
 
 def mul_abc(a, b, c)
   a * b * c
 end
 
 def div_abc(a, b, c)
   a / b / c unless b == 0 or c == 0
 end
 
 plus_abc(1, 2, 3) # =&gt; 6
 minus_abc(10, 5, 3) # =&gt; 2
 mul_abc(4, 5, 6) # =&gt; 120
 div_abc(12, 3, 2) # =&gt; 2
||&lt;
これらのメソッドは
使っている演算子は違うけれども
a (演算子) b (演算子) cという制御構造は同じだ


だから変数と同じように演算を引数として渡せれば
これらのメソッドは一つにまとめられる
&gt;|ruby|
 def calc_abc(a, b, c, op)
   op[a, b, c]  #またはop.call(a, b, c)
 end
||&lt;
ここでopは上記演算の抽象である


これに対して各演算の専用メソッドにおいて
具体的な演算の手続きをcalc_abcメソッドの引数として渡す
&gt;|ruby|
 def plus_abc(a, b, c)
   calc_abc(a, b, c, lambda { |x, y, z| x + y + z })
 end
 
 def minus_abc(a, b, c)
   calc_abc(a, b, c, lambda { |x, y, z| x - y - z })
 end
 
 def mul_abc(a, b, c)
   calc_abc(a, b, c, lambda { |x, y, z| x * y * z })
 end
 
 def div_abc(a, b, c)
   calc_abc(a, b, c, lambda { |x, y, z| x / y / z }) unless b ==0 or c == 0
 end
 
 plus_abc(1, 2, 3) # =&gt; 6
 minus_abc(10, 5, 3) # =&gt; 2
 mul_abc(4, 5, 6) # =&gt; 120
 div_abc(12, 3, 2) # =&gt; 2
||&lt;


演算を抽象化したcalc_abcメソッドがあれば
後から同種の演算を簡単に追加できる
&gt;|ruby|
 def power_abc(a, b, c)
   calc_abc(a, b, c, lambda { |x, y, z| x ** y ** z })
 end
 
 power_abc(2, 2, 2) # =&gt; 16
||&lt;


さらに同種の演算子を追加する場合に
毎回手続きであるlambda...の入力は煩わしい
演算子を引数にとって手続きを戻り値とする
メソッドを定義できれば問題は解決する
&gt;|ruby|
 def operator(op)
   lambda { |x, y, z| (x.send(op, y)).send(op, z) }
 end
||&lt;
operatorメソッドは演算子を引数に取って
3つの数に順次その演算子を作用させる手続きを返す
つまりoperatorメソッドは演算手続きを抽象化する


これを用いることによって
各演算メソッドはより簡潔になる
&gt;|ruby|
 def plus_abc(a, b, c)
   calc_abc(a, b, c, operator(:+))
 end
 
 def minus_abc(a, b, c)
   calc_abc(a, b, c, operator(:-))
 end
 
 def mul_abc(a, b, c)
   calc_abc(a, b, c, operator(:*))
 end
 
 def div_abc(a, b, c)
   calc_abc(a, b, c, operator(:/)) unless b ==0 or c == 0
 end
 
 def power_abc(a, b, c)
   calc_abc(a, b, c, operator(:**))
 end
 
 plus_abc(1, 2, 3) # =&gt; 6
 minus_abc(10, 5, 3) # =&gt; 2
 mul_abc(4, 5, 6) # =&gt; 120
 div_abc(12, 3, 2) # =&gt; 2
 power_abc(2, 2, 2) # =&gt; 16
||&lt;


ついでに引数をいくつでも取れるようにすれば
より汎用性が高まる
&gt;|ruby|
 def calc_abc(*i, op)
   op[i]
 end
 
 def operator(op)
  lambda do |x|
    mem = x.shift
    until x.empty?
      mem = mem.send(op, x.shift)
    end
    mem
  end
end

 def plus_abc(*i)
   calc_abc(*i, operator(:+))
 end
 
 def minus_abc(*i)
   calc_abc(*i, operator(:-))
 end
 
 def mul_abc(*i)
   calc_abc(*i, operator(:*))
 end
 
 def div_abc(*i)
   calc_abc(*i, operator(:/))
 end
 
 def power_abc(*i)
   calc_abc(*i, operator(:**))
 end
 
 def join_abc(*i)
   calc_abc(*i, operator(:join))
 end
 class Fixnum
   def join(other)
     self * 10 + other
   end
 end
 
 plus_abc(1, 2, 3, 4, 5) # =&gt; 15
 minus_abc(10, 5, 3, 2) # =&gt; 0
 mul_abc(4, 5, 6, 7, 8, 9) # =&gt; 60480
 div_abc(12, 3, 2) # =&gt; 2
 power_abc(2, 2, 2, 2) # =&gt; 256
 join_abc(1, 2, 3, 4, 5) # =&gt; 12345
||&lt;


高階関数の別の例を示そう
配列の各要素を倍にするメソッドと
配列の各要素を大文字にするメソッドを考える
&gt;|ruby|
 def multi_list(list)
   if list.empty?
     []
   else
     data = list.pop
     multi_list(list) &lt;&lt; data * 2
   end
 end
 
 def upper_list(list)
   if list.empty?
     []
   else
     data = list.pop
     upper_list(list) &lt;&lt; data.upcase
   end
 end
 
 multi_list([1, 2, 3, 4]) # =&gt; [2, 4, 6, 8]
 upper_list(['cat', 'dog', 'horse']) # =&gt; [&quot;CAT&quot;, &quot;DOG&quot;, &quot;HORSE&quot;]
||&lt;
これらの制御構造はそっくりで
dataに対する演算のところだけが違う
だからこの演算のところを抽象化できれば汎用メソッドができる
&gt;|ruby|
 def mappie(list, op)
   if list.empty?
     []
   else
     data = list.pop
     mappie(list, op) &lt;&lt; op[data]
   end
 end
||&lt;
このメソッドを使えば各メソッドは簡潔に書ける
&gt;|ruby|
 def multi_list(list)
   mappie(list, lambda { |x| x * 2 })
 end
 
 def upper_list(list)
   mappie(list, lambda { |x| x.upcase })
 end
 
 multi_list([1, 2, 3, 4]) # =&gt; [2, 4, 6, 8]
 upper_list(['cat', 'dog', 'horse']) # =&gt; [&quot;CAT&quot;, &quot;DOG&quot;, &quot;HORSE&quot;]
||&lt;


先の例と同様に
mappieに渡す手続きもメソッドにしよう
&gt;|ruby|
 def operator(op, *args)
   lambda { |x| x.send(op, *args) }
 end
||&lt;
そうすればメソッドは一層簡潔になる
&gt;|ruby|
 def multi_list(list)
   mappie(list, operator(:*, 2))
 end
 
 def upper_list(list)
   mappie(list, operator(:upcase))
 end
 
 multi_list([1, 2, 3, 4]) # =&gt; [2, 4, 6, 8]
 upper_list(['cat', 'dog', 'horse']) # =&gt; [&quot;CAT&quot;, &quot;DOG&quot;, &quot;HORSE&quot;]
||&lt;
メソッドの追加も容易だ
&gt;|ruby|
 def reverse_list(list)
   mappie(list, operator(:reverse))
 end
 reverse_list(%w(elppa odnetnin elgoog)) # =&gt; [&quot;apple&quot;, &quot;nintendo&quot;, &quot;google&quot;]
||&lt;

このように高階関数を使えば
任意の抽象手続きを定義できるようになり
その結果下流コードが簡潔になって
それを利用するユーザにやさしいプログラムができる

</body>
</day>
<day date="2009-02-21" title="">
<body>
*p1*全文翻訳は彼の意思である！~罪を憎んで人を憎まず
[http://d.hatena.ne.jp/pollyanna/20090220/p1:title=全文翻訳は適法か - 理系兼業主婦日記より]
&gt;&gt;
　したがって、ブログにおける翻訳の公開についても、特に著作権者（この場合は村上春樹氏）からの許諾を得ていない限りは、全文の翻訳は違法であると判断するのが妥当でしょう。
&lt;&lt;


世の中は危険がいっぱいである
通りを歩けばクルマに撥ねられないかと心配し
街に出れば通り魔に会わないかと心配する
家にいると電話が掛かってきて振り込め詐欺に遭う
仕方がないからネットに繋いでブログを書く
ところがここにも危険が待ち受けている
著作権法である


特許権とは異なり
著作権を得るのには何の手続きも要らない
思想・感情を創作的に表現すれば
その瞬間に権利があなたのもとに発生する
僕も無数の著作権を持っている
君も持っている
Rubyオブジェクトの比じゃない数だ！
だって子供の頃に書いた落書きだって著作物なんだから


僕が死んだって50年はだめだ
僕の宝箱から「ドレマンとドバチン先生」の絵を盗んで
ネットにアップしたら君はもう犯罪者だ！
僕の配偶者が幼なじみが君を常に監視している
そんな中で僕らは暮らしている
自由はどこに行ったんだ？



さて
全文翻訳の違法性が問われている
村上春樹のエルサレム賞受賞スピーチの件である
2つのことを考えなければいけない
１つは法に照らした行為の違法性についてであり
もう１つは違法と言うことの意味についてである


**行為の違法性
「著作者はその著作物を翻訳する権利を専有する」
と著作権法27条に書いてある
id:pollyannaさんはこれを根拠に「全文翻訳は違法だ」と言っている
でも僕はそう思わない


この規定は「著作者が著作物を翻訳する権利を自由にできる」
といっているのだと理解する
つまり他人が勝手に翻訳を作ってそれを公表したら
著作者はダメだということもできるし
一定の条件の下で許可することもできるし
あるいは放置することもできる
それがいいか悪いかは著作者が決める
それは丁度所有権の対応に似ている
僕のアップルパイを隣のおっちゃんが勝手に食べたら怒るけど
かわいい女の子が食べたら僕は怒らない


だから翻訳問題の違法性は村上春樹が翻訳をしたブロガーたちに
具体的にアクションを取ったときに問われるべきもので
当事者ではない僕らが
それらの行為を違法と判断することはできないと思う


また仮に村上春樹がアクションを取るにしても
それはその行為の差し止めが限度ではないだろうか
果たして彼らの行為が村上氏に損害を生じさせ
また彼らが不当な利得を得ているといえるだろうか
彼らの行為は著作権法が目的とする
「文化の発展」の妨げになっているのだろうか
僕にはとても思えない


**違法と言うことの意味
村上春樹のスピーチはなぜこんなにも注目を集め
多数のブロガーによって翻訳されたのだろうか
その理由は明らかである
内容が素晴らしいからである
オバマスピーチ同様
歴史に残るほどの素晴らしさがあるからである
その英文を読んだ彼らはそれを伝えたかった
村上春樹の言葉を他の日本人にも伝えたかった


そしてそれは村上春樹自身が望んだことである


彼は言う
&gt;&gt;
So let me tell you the truth. A fair number of people advised me not to come here to accept the Jerusalem Prize. Some even warned me they would instigate a boycott of my books if I came.(中略)
Any number of times after receiving notice of the award, I asked myself whether traveling to Israel at a time like this and accepting a literary prize was the proper thing to do, whether this would create the impression that I supported one side in the conflict, that I endorsed the policies of a nation that chose to unleash its overwhelming military power.(中略) 
Finally, however, after careful consideration, I made up my mind to come here.(中略) 
And that is why I am here. I chose to come here rather than stay away. I chose to see for myself rather than not to see. I chose to speak to you rather than to say nothing.
ということで真実のことを話させてください。かなりの人が私に、ここに来てエルサレム賞を受けないようアドバイスしました。私が行くなら私の本のボイコットを扇動すると警告する人までいました。(中略)
受賞の知らせを聞いてから何度も自問しました…(中略)
しかし結局よく考えた末、ここに来ることを決心しました。(中略)
それが私がここにいる理由です。遠くにいることより来ることを選びました。見ないことより自分自身で見ることを選びました。何も言わないことよりみなさんに話をすることを選びました。
&lt;&lt;


村上春樹は迷った揚げ句
イスラエルに行った
彼の言葉をみんなに伝えるために


果たしてそんな彼が
このスピーチを訳し公開した彼らを
彼の言葉を伝える担い手たちを
彼の権利の略奪者だとして訴えることを誰が想像できるだろうか
彼らはそのリスクに恐怖すべきだろうか
そんな必要はない


村上春樹が彼の父の話をした
&gt;&gt;
He was praying for all the people who died, he said, both ally and enemy alike. Staring at his back as he knelt at the altar, I seemed to feel the shadow of death hovering around him.
父は死んだすべての人々のために、それが敵であろうと味方であろうと、祈っていると言いました。仏壇の前に座っている父の背中を見ているときに、私は彼の回りに浮遊している死者の影を感じ取りました。
&lt;&lt;
&gt;&gt;
My father died, and with him he took his memories, memories that I can never know. But the presence of death that lurked about him remains in my own memory. It is one of the few things I carry on from him, and one of the most important.
父は死に、その記憶、私が決して知ることができない記憶を共に持ち去りました。しかし彼の回りに潜んでいた死の存在は、私自身の記憶に残りました。これが私が父から受け継いだ僅かな、そしてもっとも重要なことの一つです。
&lt;&lt;


村上春樹は父が死に
戦争によってすべての人が
敗北の中へ消えていった
と言いたかったのかもしれない
そして彼の記憶にはシステムの作り出した
死の存在だけが残った

&gt;&gt;
Take a moment to think about this. Each of us possesses a tangible, living soul. The System has no such thing. We must not allow The System to exploit us. We must not allow The System to take on a life of its own. The System did not make us: We made The System.
このことについてもう少し考えてみてください。私たち一人ひとりは形ある生きた命を持っています。「システム」はそのようなものを持っていません。私たちは「システム」が私たちのことを食い物にすることを許してはなりません。「システム」が自身の生命を身に付けることを許してはなりません。「システム」が私たちを作ったのではなく、私たちが「システム」を作ったのです。
&lt;&lt;


「法」は私たちが作ったシステムです
「法」が社会の秩序を作ります
「法」に暴走させてはいけません
私たちが「法」をコントロールするのです
これも彼が言いたかったことの一つ
にきっと違いありません


参考：[http://blog.tatsuru.com/2009/02/20_1543.php:title=壁と卵（つづき） (内田樹の研究室)]
参考：[http://finalvent.cocolog-nifty.com/fareastblog/2009/02/post-1345.html:title=極東ブログ: 村上春樹、エルサレム賞受賞スピーチ試訳]

</body>
<comments>
<comment>
<username>通りすがり</username>
<body>思い込み恣意的に解釈してねじ曲げる。あるいは「それが始められたそもそもの動機は、善意によったものであった」</body>
<timestamp>1235198803</timestamp>
</comment>
</comments>
</day>
<day date="2009-02-23" title="">
<body>
*p1*ストールマンは謳う ～正しさと　困難さと　心強さと
リチャード　M　ストールマン
フリーソフトウェアと　自由な社会を　描く人
Richard M. Stallman
時代を代表する　プログラマ　哲学者


ソフトウェアは　料理のレシピと　同じよう
それを手にした　何人も
原材料を入手して　自由に手を入れ　作れます
受け取るあなたが　そうするなら
わたしのレシピも　あげましょう
誰かに売っても　構いません
同じ思想を　持つのなら


フリーソフトの　フリーとは
無料のフリーじゃ　ありません
フリーソフトの　フリーとは
自由のフリーを　意味します
フリービールの　仲間じゃなく
フリースピーチの　仲間です


GNUとは　GNU's Not Unixの　頭字語で
ウシカモシカじゃ　ありません
コピーライトじゃなく　コピーレフトです
Linuxじゃなく　GNU/Linuxです
名前はとても　重要です
正しい理解に　必要です


フリーと言うからには　どこまで行っても
フリーじゃなくちゃ　困ります
どこかの誰かが　ずるをして
フリーの鎖が　途切れたら
そのユーザの　自由がなくなります
フリーの鎖を　つなげるため
コピーレフトを　GPLを　使いましょう


フリーソフトの　フリーとは
無料のフリーじゃ　ありません
フリーソフトの　フリーとは
自由のフリーを　意味します
フリービールの　仲間じゃなく
フリースピーチの　仲間です


あなたの哲学　理解します
あなたの正しさ　認めます
理想の社会が　浮かびます
自由な社会が　描かれます


だけれども


あなたの哲学　強烈すぎて
わたしの生き方　規定します
自由を求めた　憲法が
わたしの生き方　規定します
あなたのように　強く誇り高く
突き進む　自信が
今はまだ　持てません


市販ソフトの手軽さと　幅広さ
それを捨てることは　まだできません
もしかしたら　わたしは
本物の自由を　恐れているのかもしれません


フリーソフトの　フリーとは
無料のフリーじゃ　ありません
フリーソフトの　フリーとは
自由のフリーを　意味します
フリービールの　仲間じゃなく
フリースピーチの　仲間です


だけれども


わたしの片足　GNUの上に乗ってます
あなたの作った　一匹のGNU
いまでは　大きな群れになって
わたしの体を　支えてます
ネットの出現　Rubyの出現((RubyはGPLとRubyオリジナルとのデュアルライセンスです))
重心は　少しづつ　少しづつ
あなたのサイドに　移っています
いつか片足で　立てるときが来たのなら
わたしのことも　受け入れてください
あなたが正しいことは　知っているのですから


フリーソフトの　フリーとは
無料のフリーじゃ　ありません
フリーソフトの　フリーとは
自由のフリーを　意味します
フリービールの　仲間じゃなく
フリースピーチの　仲間です


リチャード　M　ストールマン
フリーソフトウェアと　自由な社会を　描く人
Richard M. Stallman
時代を代表する　プログラマ　哲学者


正しさと　困難さと　心強さと
いつも感じている　理想へと向かって
現実は　恐れずに　進むあなたを
涙は見せないで　見つめていたいよ


ーこの文章はGPLでライセンスされますー


[http://www.gnu.org/home.ja.html:title=GNU オペレーティング・システム]


[asin:4756142818:detail]
</body>
</day>
<day date="2009-03-13" title="">
<body>
*p1*SchemeとRubyで記号微分を学ぼう
引き続き「[asin:489471163X:title]」を使って
今度はSchemeとRubyでの
記号データの扱い方を見ていこうと思います
なおSchemeのコードは本書からの抜粋で
説明は自分の要約です


Schemeではクオート(｀)を使って
データオブジェクトを記号として表現できる
&gt;|scheme|
 (list `a `b)
 (a b)
||&lt;
クオートを使えばa, bは値を指す変数ではなく
記号として解釈される


この能力を使って
代数式の記号微分を実行する手続きを作る
この手続きは引数として
記号を含んだ代数式と変数を取り
代数式のこの変数に関する微分を返す
例えば[tex:ax^2 + bx + c]と[tex:x]なら
[tex:2ax + b]が返る


ここでは2つの引数を持った加算と乗算と累乗からなる式を扱う
この微分の規則は次の通りである
&gt;&gt;
[tex:\frac{dc}{dx}=0] cは定数かxと異なる変数
[tex:\frac{dx}{dx}=1]
[tex:\frac{d(u+v)}{dx}=\frac{du}{dx}+\frac{dv}{dx}]
[tex:\frac{d(uv)}{dx}=u(\frac{dv}{dx})+(\frac{du}{dx})v]
[tex:\frac{d(u^n)}{dx}=nu^{n-1}(\frac{du}{dx})]
&lt;&lt;


この規則をSchemeで表現すれば以下の通りである
&gt;|scheme|
 (define (deriv exp var)
    (cond ((number? exp) 0)
         ((variable? exp)
          (if (same_variable? exp var) 1 0))
         ((sum? exp)
          (make_sum (deriv (addend exp) var)
                  (deriv (augend exp) var)))
         ((product? exp)
          (make_sum
             (make_product (multiplier exp)
                        (deriv (multiplicand exp) var))
             (make_product (deriv (multiplier exp) var)
                        (multiplicand exp))))
         ((exponentiation? exp)
          (make_product
             (make_product (exponent exp)
                        (make_exponentiation (base exp)
                                        (- (exponent exp) 1)))
             (deriv (base exp) var)))
         (else
          (error &quot;unknown expression type -- DERIV&quot; exp))))
||&lt;


このコードはまだ未定義の以下のサブ手続きを含んでいる
&gt;&gt;
(variable? e)  ｅは変数か
(same_variable? v1 v2)  v1, v2は同じ変数か
(sum? e)  eは和か
(addend e)  eの加数
(augend e)  eの被加数
(make_sum a1 a2)  a1, a2の和を構成
(product? e)  eは積か
(multiplier e)  eの乗数
(multiplicand e)  eの被乗数
(make_product m1 m2)  m1, m2の積を構成
(exponentiation? e)  eは累乗か
(base e)  eの基数
(exponent e)  eの指数
(make_exponentiation e1 e2)  e1, e2の累乗を構成
&lt;&lt;


次にこれらの手続きを実装しよう
&gt;|scheme|
 (define (variable? x) (symbol? x))
 
 (define (same_variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
 
 (define (make_sum a1 a2) (list `+ a1 a2))
 
 (define (=number? exp num)
    (and (number? exp) (= exp num)))
 
 (define (make_product m1 m2) (list `* m1 m2))
 
 (define (sum? x)
    (and (pair? x) (eq? (car x) `+)))
    
 (define (addend s) (cadr s))
 
 (define (augend s) (caddr s))
 
 (define (product? x)
    (and (pair? x) (eq? (car x) `*)))
    
 (define (multiplier p) (cadr p))
 
 (define (multiplicand p) (caddr p))
 
 (define (exponentiation? x)
    (and (pair? x) (eq? (car x) `**)))
    
 (define (base e) (cadr e))
 
 (define (exponent e) (caddr e))
 
 (define (make_exponentiation e1 e2) (list `** e1 e2))
||&lt;


実装が済んだら早速試してみよう
&gt;|scheme|
 (deriv `(+ x 3) `x)
 (deriv `(* x y) `x)
 (deriv `(* (* x y) (+ x 3)) `x)
 (deriv `(+ (* a (** x 2)) (* b x)) `x)
 
 (+ 1 0)
 (+ (* x 0) (* 1 y))
 (+ (* (* x y) (+ 1 0)) (* (+ (* x 0) (* 1 y)) (+ x 3)))
 (+ (+ (* a (* (* 2 (** x 1)) 1)) (* 0 (** x 2))) (+ (* b 1) (* 0 x)))
||&lt;

正しい答えが出た
でも簡約されていない


基のderiv手続きに変更を加えることなく
make_sum, make_product, make_exponentiationを
変更することで簡約を実現しよう


make_sumには
両方のオペランドが数値ならそれらを足し
一方が0なら他方のオペランドを返す条件を加える
&gt;|scheme|
 (define (make_sum a1 a2)
    (cond ((=number? a1 0) a2)
         ((=number? a2 0) a1)
         ((and (number? a1) (number? a2)) (+ a1 a2))
          (else (list `+ a1 a2))))
 
 (define (=number? exp num)
    (and (number? exp) (= exp num)))
||&lt;
サブ手続き=number?は数が等しいか見る


make_productでは
両方のオペランドが数値ならそれらを掛け
一方が0なら0を
1なら他のオペランドを返す条件を加える
&gt;|scheme|
 (define (make_product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
         ((=number? m1 1) m2)
         ((=number? m2 1) m1)
         ((and (number? m1) (number? m2)) (* m1 m2))
         (else (list `* m1 m2))))
||&lt;


make_exponentiationでは
指数が0なら1を1なら基数を返す条件を加える
&gt;|scheme|
 (define (make_exponentiation e1 e2)
    (cond ((=number? e2 0) 1)
         ((=number? e2 1) e1)
         (else (list `** e1 e2))))
||&lt;


これらの変更により簡約された結果が得られる
&gt;|scheme|
 (deriv `(+ x 3) `x)
 (deriv `(* x y) `x)
 (deriv `(* (* x y) (+ x 3)) `x)
 (deriv `(+ (* a (** x 2)) (* b x)) `x)
 
 1
 y
 (+ (* x y) (* y (+ x 3)))
 (+ (* a (* 2 x)) b)
||&lt;


**Rubyによる記号微分
同じことをRubyでも挑戦してみよう
Rubyでは記号を表現するために
シンボル(Symbol)と文字列(String)が使えそうだ


まずはderivメソッドを書く
&gt;|ruby|
 def deriv(exp, var)
   case exp
   when Numeric
     0
   when Symbol, String
     same_variable?(exp, var) ? 1 : 0
   when Sum
     make_sum deriv(addend(exp), var), deriv(augend(exp), var)
   when Product
     m1 = make_product multiplier(exp), deriv(multiplicand(exp), var)
     m2 = make_product deriv(multiplier(exp), var), multiplicand(exp)
     make_sum(m1, m2)
   when Exponentiation
     e1 = make_product(exponent(exp), make_exponentiation(base(exp), exponent(exp)-1))
     e2 = deriv(base(exp), var)
     make_product(e1, e2)
   else
     raise &quot;unknown expression type -- DERIV #{exp.inspect}&quot;
   end
 end
||&lt;


記号をシンボルまたは文字列で表現したので
引数expが和であるか積であるか累乗であるかを判断するために
それぞれに別のクラスSum、Product、Exponentiationを
定義するのがよさそうだ
&gt;|ruby|
 class Sum
   def self.===(x)
     pair?(x) and car(x).equal? :+
   end
 end
 
 class Product
   def self.===(x)
     pair?(x) and car(x).equal? :*
   end
 end
 
 class Exponentiation
   def self.===(x)
     pair?(x) and car(x).equal? :**
   end
 end
||&lt;
case文での判断は===メソッドでなされるので
それぞれに専用メソッドを定義する


他のメソッドはSchemeと同様に定義すればいい
&gt;|ruby|
 def same_variable?(exp, var)
   exp == var ? true : false
 end
 
 def make_sum(a1, a2)
   if eql_number?(a1, 0)
     a2
   elsif eql_number?(a2, 0)
     a1
   elsif Numeric === a1 and Numeric === a2
     a1 + a2
   else
     list :+, a1, a2
   end
 end
 
 def eql_number?(exp, num)
   Numeric === exp and exp == num
 end
 
 def make_product(m1, m2)
   if eql_number?(m1, 0) or eql_number?(m2, 0)
     0
   elsif m1 == 1
     m2
   elsif m2 == 1
     m1
   elsif Numeric === m1 and Numeric === m2
     m1 * m2
   else
     list :*, m1, m2
   end
 end
 
 def addend(s)
   cadr s
 end
 
 def augend(s)
   caddr s
 end
 
 def multiplier(p)
   cadr p
 end
 
 def multiplicand(p)
   caddr p
 end
 
 def base(e)
   cadr e
 end
 
 def exponent(e)
   caddr e
 end
 
 def make_exponentiation(e1, e2)
   if e2 == 0
     1
   elsif e2 == 1
     e1
   else
     list :**, e1, e2
   end
 end
||&lt;


リストは以前実装したlistメソッドを使って作る
このリストはSchemeのリスト同様consの入れ子になっている
リストをキレイに出力するlist_pメソッドも定義した
準備が整ったので実行してみよう
&gt;|ruby|
 list_p deriv list(:+, :x, 3), :x
 list_p deriv list(:*, :x, :y), :x
 list_p deriv list(:*, list(:*, :x, :y), list(:+, :x, 3)), :x
 list_p deriv list(:+, list(:*, :a, list(:**, :x, 2)), list(:*, :b, :x)), :x
 
 # &gt;&gt; 1
 # &gt;&gt; y
 # &gt;&gt; (+ (* x y) (* y (+ x 3)))
 # &gt;&gt; (+ (* a (* 2 x)) b)
||&lt;


コードを以下に置きました
http://gist.github.com/64646

</body>
</day>
<day date="2009-03-15" title="">
<body>
*p1*文化と変化と情報化
情報は社会を変える中核的要素である
情報の量や質が変わると社会が変わる


技術の進歩は情報の流通を加速させる
より正確には技術の進歩とは情報流通の進歩とほぼ同義である


つまり技術の進歩が続く限り社会の変化は続く
技術の進歩が是であるか非であるかに拘わらず
頭蓋骨のサイズによって脳の進化が許容される限り
人は技術を進歩させ
その結果として社会を変えてゆく


変化とはかつてあった価値を否定し
新たな価値を受け入れることである
かつてあった価値とは文化のことである
つまり変化とは文化の反意語である
文化に対するノスタルジーは変化への抵抗である
社会変化に追随できなくなったとき
人は文化を口にする


技術を進歩させ情報の流通を加速させる
そこに新たな価値を創造する
更に技術を進歩させかつて創造した価値を否定する
文化を構築しそれを破壊する
創っては壊し創っては壊す
残念ながら
それが人間の日々の営みなんだと思う

*p2*現行著作権法の問題はその非対称性にある
権利は常に義務と対である
誰かの権利は誰かの義務を生む


著作権や特許権は所有権と同様に私権である
これらの権利は一市民の権利である
一市民の権利は公権すなわち国家の権利とは異なる
著作権は国家が国民に規範を求める性質のものではなく
その権利に関わる特定の市民間における問題解決理論である


著作権法は一定の情報に権利を与え
その流通のコントロール権を作者に留保する
ディジタルおよびネットワーク技術は
情報の流通を飛躍的に向上させた
その結果現行著作権法における権利者のコントロール権は巨大化した
コントロール権の巨大化は同時並行的に市民に規範を求める
公権的な性質を帯びたものになる


著作者がそのことを意識できず
むしろ情報技術がかつての権利を脅かされると感じるのは
この変化に追随できないがためである
本来的に情報の流通性が向上すれば
ユーザへの到達率が高まるので
情報技術は著作者にとってはポジティブである


著作者およびその関係者たちが
このことに気付いたとき彼らの利益は膨大になる
マーケットがグローバル化し
それを利用するユーザが著作者予備軍であることに気付くなら
彼らの利益は膨大になる


だから既に公権化している著作権法を強化してはいけない
その本来的な特定市民間における問題解決のツールとなるよう
縮体化させなければいけない
そうでなければ明らかに著作権法は
権利と義務を非対称にするアンバランスな法律となる


[asin:464114382X:detail]
</body>
</day>
<day date="2009-03-17" title="">
<body>
*p1*我らにラテンの血を！！
[f:id:keyesberry:20090317154930j:image]


任天堂Ｗｉｉ-[http://wii.com/jp/articles/vote-channel/:title=みんなで投票チャンネル]より
</body>
</day>
<day date="2009-03-18" title="">
<body>
*p1*再帰は再帰なんかじゃない！末尾再帰こそが真の再帰なんだ！
「[asin:489471163X:title]」で
末尾再帰というものを知ったので勉強しました
自分の理解を書いてみます


**再帰
再帰呼び出しとはある手続きの中で
再びその手続き自身を呼び出すことと定義される(([http://ja.wikipedia.org/wiki/再帰:title=再帰：Wikipediaより]))
でもこの定義は正確じゃない
なぜなら再帰呼び出しは自分自身を呼んでいないからだ


階乗を考えてみよう
階乗は数学的にこう定義できる
&gt;&gt;
[tex:n!=n * (n-1)!]
但し、自然数n=1のときは1
&lt;&lt;


ふつうRubyで階乗メソッドはこう書く
&gt;|ruby|
 def fact(n)
   if n == 1
     1
   else
     n * fact(n-1)
   end
 end
 
 fact 5 #&gt; 120
||&lt;
factメソッドの中でfactメソッドが呼ばれているので
自分自身が呼ばれているように見える
でもそうじゃない


最初の引数5を受け取ったfactメソッド(彼をfact5と呼ぼう)は
引数4と共に自分が呼んだfactメソッド(fact4)の結果を
待たなきゃならない
なぜならその結果と5をあとで掛けなきゃならないからだ
fact4もfact3もfact2も同じだ
自分が呼んだメソッドの結果を待たなきゃならない


人間が待ちながらその要求に答える
なんて芸当ができないのと同様に
Rubyにだってそんなことはできない
こういうときは誰か他の人に頼むしかない
だからfact4メソッドはfact5とは別人なんだ
fact3もfact2もfact1も全部別人なんだ


つまり上のコードはメソッド呼び出しに関して
次のコードとほぼ等価だ
&gt;|ruby|
 def fact5
   5 * fact4
 end
 
 def fact4
   4 * fact3
 end
 
 def fact3
   3 * fact2
 end
 
 def fact2
   2 * fact1
 end
 
 def fact1
   1
 end
 
 fact5 #&gt; 120
||&lt;

このコードではfact1が結果を返すまで
他のメソッドはRuby空間に止まってることははっきりしてる
これは再帰でも同じだ
各factメソッドは内容は同じだけれども
別のメソッドとしてRuby空間に置かれる


これはちょうど同じ文字列が
Rubyでは別のオブジェクトとして扱われるのと似ている
&gt;|ruby|
 5.times do
   s = 'factorial'
   puts &quot;#{s}(id:#{s.__id__})&quot;
 end
 
 # &gt;&gt; factorial(id:72570)
 # &gt;&gt; factorial(id:72580)
 # &gt;&gt; factorial(id:72560)
 # &gt;&gt; factorial(id:72530)
 # &gt;&gt; factorial(id:72500)
||&lt;


つまりふつうの再帰は自分ではなく
自分とそっくりな人
そう
分身を呼んでいるんだ


**再帰の問題点
同じことをするのに反復手続きがあるのに
なぜ再帰を使う必要があるんだろう


反復手続きによる階乗メソッドを見てみよう
&gt;|ruby|
 def fact(n)
   p = 1
   while n &gt; 1
     p *= n
     n -= 1
   end
   p
 end
 
 p fact 5
||&lt;


これを見れば理由はわかる
そう反復手続きはエレガントじゃない
再帰では階乗の数学的表現をそのまま自然に記述できる
反復手続きではそうはいかない


でも再帰はその度に別の手続きを呼び出すのと等価だから
深い再帰では手続きでRuby空間が溢れるという問題が生じる
&gt;|ruby|
fact 10000 #&gt; `fact': stack level too deep (SystemStackError)
||&lt;


**末尾再帰で階乗
そこで末尾再帰の出番だ


ふつうの再帰による階乗を再掲しよう
&gt;|ruby|
 def fact(n)
   if n == 1
     1
   else
     n * fact(n-1)
   end
 end
 
 fact 5 #&gt; 120
||&lt;


再帰では手続きが次の手続きの結果を必要としてる
だからRuby空間で結果を待たなきゃならない
上のコードではelse節のnが掛けられるのを待ってる
それが問題になる


ならば待たないようにすればいい
つまりnを一緒に次のfactに投げちゃえばいい
それで知らぬ顔をしてRuby空間からおさらばする
そうすると困るのは最後のfact(fact1)だけだから
彼に後処理を全部やってもらえばいい


この考えに基づいたコードはこうなる
&gt;|ruby|
 def fact(n, mem=[])
   if n == 1
     mem.inject(:*)     #fact1が配列の要素を全部掛けて返す
   else
     mem &lt;&lt; n
     fact(n-1, mem)   #nを配列に入れて次のfactに順次渡す
   end
 end
||&lt;
これによって処理の末尾が再帰だけになるので
値を渡した手続きはもう結果を待たなくていい
最終的な結果は最後の手続きが返してくれる
つまり手続きを呼び出した手続きは
もう必要なくなるので呼び出した手続きとして使える
そう自分自身を使える！


だから末尾再帰こそが真の再帰で
その名に値するんだ


fact1にすべてをさせるのが酷というなら
各人が自分のところの計算をやって
その結果を投げるようにすればいい
&gt;|ruby|
 def fact(n, mem=n)
   if n == 1
     mem
   else
     fact(n-1, mem*(n-1))
   end
 end
 
 fact 5 #&gt; 120
||&lt;


実は残念ながらSchemeとは違って
現在のRubyの実装では
この末尾再帰のメリットは受けられないようだ
&gt;|ruby|
 fact 10000 #&gt; `fact': stack level too deep (SystemStackError)
||&lt;


**末尾再帰によるフィボナッチ
Rubyで末尾再帰を使っても
ふつうの再帰と同様に分身が呼ばれるようだ


それでもRubyで末尾再帰するメリットはある


フィボナッチ数を考えよう
n番目のフィボナッチ数は数学的に次のように定義できる
&gt;&gt;
[tex:fn = 0] : n = 0のとき
[tex:fn = 1] : n = 1のとき
[tex:fn = f(n-1) + f(n-2)] : それ以外のとき
&lt;&lt;


これをRubyで書くとこうなる
&gt;|ruby|
 def fib(n)
   if n == 0
     0
   elsif n == 1
     1
   else
     fib(n-1) + fib(n-2)
   end
 end
 
 fib 10 #&gt; 55
||&lt;


これは数学的記述に従ったエレガントなコードだけれども
末尾再帰になっていない上に末尾の＋メソッドは
2つの再帰メソッドfibの結果を待たなきゃならない
呼び出された各メソッドfibはそれぞれにまた2つのfibを呼び
この数はフィボナッチ数的に増える


すると高々20番目のフィボナッチ数を求めるのに
fibメソッドは21891回も呼ばれることになる
&gt;&gt;
% _ruby -rprofile fib.rb
% cumulative self self total time seconds seconds calls  ms/call  ms/call  name
 69.45     2.16      2.16    21891     0.10     1.93  Object#fib
 15.76     2.65      0.49    39601     0.01     0.01  Fixnum#==
 10.61     2.98      0.33    21890     0.02     0.02  Fixnum#-
  4.18     3.11      0.13    10945     0.01     0.01  Fixnum#+
  0.00     3.11      0.00        1     0.00     0.00  Module#method_added
  0.00     3.11      0.00        2     0.00     0.00  IO#set_encoding
  0.00     3.11      0.00        1     0.00  3110.00  #toplevel
&lt;&lt;


fibメソッドを末尾再帰で書けたなら
fibメソッドの呼び出し回数は21回で済む
だからRubyでも検討する価値がある


今8番目のフィボナッチ数を求める演算をfib8とすると
これは以下のように展開できる
&gt;&gt;
fib8 = 1*fib8 + 0*fib7
= 1*fib7 + 1*fib6 = (fib6 + fib5) + fib6
= 2*fib6 + 1*fib5
= 3*fib5 + 2*fib4
= 5*fib4 + 3*fib3
= 8*fib3 + 5*fib2
=13*fib2 + 8*fib1
= 21*fib1 + 13*fib0 = 21
&lt;&lt;


各項の係数をそれぞれa, bとすると
各ステップでbには前のステップのaの値が
aにはa+bの値が与えられていることがわかる
また最後のステップをみると
fib0が0なので第2項の演算結果は
結果的に答えに反映されないことがわかる
だから１つのfibメソッドにa、bを渡していき
fib1に達したところでaの値を返すようにすればいい

&gt;|ruby|
 def fib(n, a=1, b=0)
   if n == 0
     0
   elsif n == 1
     a
   else
     fib(n-1, a+b, a)
   end
 end
 
 fib 8 #&gt; 21
||&lt;


これでフィボナッチを末尾再帰で実現できた
これなら1000番目のフィボナッチ数だって直ぐ求められる
&gt;|ruby|
 t = Time.now
 p fib 1000
 p Time.now - t
 #&gt;43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875
 0.001581
||&lt;


関連：[http://d.hatena.ne.jp/keyesberry/20080708/p1:title=Ruby、同じことの繰り返しは君に任せるよ ～ 再帰でハノイの塔を解こう！～]


（訂正：末尾再帰であることはfibメソッドの呼び出し回数とは直接関係しないことが分かりましたので訂正します）

</body>
<comments>
<comment>
<username>Mozk</username>
<body>末尾再帰かどうかとfibの呼び出し回数には関係ないですよ。&lt;br&gt;アルゴリズムの違いが呼び出し回数に関係してます。&lt;br&gt;例えば、効率の悪い方のアルゴリズムを使って以下のように末尾再帰でfibを書けます。&lt;br&gt;def fib(n)&lt;br&gt;  fib_loop([n], 0)&lt;br&gt;end&lt;br&gt;&lt;br&gt;def fib_loop(arr, sum)&lt;br&gt;  if arr.length == 0&lt;br&gt;    sum&lt;br&gt;  elsif arr[0] &lt;= 1&lt;br&gt;    fib_loop(arr[1..-1], sum+1)&lt;br&gt;  else&lt;br&gt;    fib_loop([arr[0]-1, arr[0]-2] + arr[1..-1], sum)&lt;br&gt;  end&lt;br&gt;end</body>
<timestamp>1237373929</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;Mozkさん&lt;br&gt;なるほど、僕の理解が違ってました。ご指摘助かります。</body>
<timestamp>1237379063</timestamp>
</comment>
</comments>
</day>
<day date="2009-03-26" title="">
<body>
*p1*Rubyでスペル修正プログラムを書こう！
青木靖さんの訳「[http://www.aoky.net/articles/peter_norvig/spell-correct.htm:title=スペル修正プログラムはどう書くか]」を通して
Peter Norvigさんの「[http://www.norvig.com/spell-correct.html:title=How to Write a Spelling Corrector]」を知った


僅か21行のPythonコードで
スペル修正プログラムが書かれている
Pythonのコードを初めて見たけど
解説が丁寧にされていることもあり
またRubyにも似ているので何となく理解できた
配列の範囲表現とか空配列が偽になるとかの違いがあるのね


等価のプログラムをRubyで書いた
速度的には問題ありだけど
そこに時間を掛けるのはやめて
読みやすさを優先した


ここのところSICP内でSchemeで書かれたコードを
Rubyで書き直す投稿を何度かしたけれど
このコードの書き直しは大変勉強になっている
それは言語によって機能実現のための表現方法が異なり
そこで驚きと共に
コーディングに対する別の見方ができるからだ
少し続けてみよう


詳細は先のサイトを見てもらうとして
スペル修正の手順は以下のようになる
+数冊の本と頻出用語集から作ったbig.txtを用意する。
+wordsメソッドでbig.txtに出現するすべての単語を小文字にしその配列(features)を作る。
+trainメソッドでfeaturesから単語とその出現頻度の組のハッシュ(NWORDS)を作る。
+edits1メソッドで対象ワードに対する1ストロークによる入力ミス(編集距離1)で得られる語の集合を作る。
+つまり1字不足(drop_char:削除)、1字入れ違い(trans_char:転位)、1字打ち間違い(alt_char:置換)、1字余分(insert_char:挿入)の各ケースにつき対象箇所を変えてこれらの処理を行う。これらの処理はStringクラスのメソッドとして実装した。
+edits2メソッドでedits1で生成されたものに対して再度edits1を繰り返し編集距離2として精度を上げる。最終出力をNWORDSに含まれている単語のみに限定するためそれと＆する。
+correctメソッドはスペル修正の対象ワードを引数としその誤りモデルに従って修正ワードを出力する。
+correctメソッドの誤りモデルは対象ワードが既知の語つまりNWORDSにあるならそれを最優先候補とする。そうでなければ編集距離1で既知の語群を候補とする。それらがなければ編集距離2で既知の語群を候補とする。それらもなければ入力語とする。語群が候補とされた場合はNWORDSにおける最大出現頻度の語が選ばれる。


&lt;script src=&quot;http://gist.github.com/85967.js&quot;&gt;&lt;/script&gt;


big.txtはPeter Norvigさんのサイトから入手できます

</body>
</day>
<day date="2009-04-07" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その1)
ー2020年ー
インターネットにおけるワード枯渇問題が深刻化している
この10年で紙ベースのドキュメントから
ビットドキュメントへの移行が急速に進行し
現在では新刊書籍の90%は書店に置かれることなく
ネット上の大規模ストレージに直接格納されるようになった
人々の「本を読む」という習慣は
ネットインタフェースとしての
モバイルディスプレイに対峙するものに完全に置き換えられた


そこで10年前には誰も想像しえなかった
新たな問題が浮上してきた
それは当初懸念されていた
IPアドレスやストレージの枯渇問題ではなかった


それは
ワードとりわけASCIIワードの枯渇問題であった


米国資源エネルギー庁主任研究員ドレス・コード博士の研究((『共空間における多重情報ー自然言語アスペクト間の競合およびエネルギー零回帰の可能性(ICWSM2019, Seattle, Washington)』))
によれば
ネット上の特定英単語(以下ワードという)の出現数が[tex:10^{68}]を
超えると
ネット接続ストレージ上の対象ワードが消失する((正確にはコード博士は’逸失’という語を使用している。’消失’という語の使用頻度を低減する目的と考えられる))
ということが判明し
現在の指数関数的なワード伸長率を勘案すれば
5年後の2025年に最頻出の10ワードが消失し
7年後の2027年には100ワード
10年後の2030年には1000ワードが消失すると予言されている


主要国政府による連携した対応により本年2月に
スウェーデン国ルンド([http://www.lund.se/default____141.aspx:title=Lund])にて
ワード枯渇問題に関する国際条約 ールンド条約ー が制定され
主要20カ国はこれを直ちに批准した
本条約発効に伴い条約加盟各国には
国民による主要ワード30語の使用頻度を
年内に30%以上削減することを課せられたことになる
各国政府は現在この問題の対応に追われている...


 -*-*-*-*-*-*-*-*-*-*-


この影響は
世界小説家協会日本支部情報処理課に
新人プログラマとして入社・配属されたあなたにも及んでいる
早々同課課長安藤はこの問題に対応するプロジェクトを発足し
あなたに以下の指令を出した
「本日10時までに英文小説の最頻出ワードトップ30を特定せよ！」
そしてその結果をもって協会加盟の小説家たちに
それらのワードの使用を制限する通達を即時出せという


あなたに与えられた時間は2時間しかない
しかもあなたは初級プログラマである


逡巡する気持ちを抱えながら
席に戻ろうとするあなたの背中越しに
上司は一言付け加えた
「無駄にワードは使うなよ」


そんなこと分かっています
ワードエコのこの時代...


さてどうしようか
自分一人ではできそうにない
誰かの助けが必要だ...


席に戻ると直ちにネットを検索し助けを求めた
検索結果の一覧の中に
『Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう！』
というタイトルのブログ投稿を見つけた
救われたか...
しかしRubyのことはよく知らない
でもまずはこれを読んで見ようか...


**Rubyチュートリアル　～英文小説の最頻出ワードを見つけよう！
忙しい読者の皆様が求めているものは
表題「英文小説の最頻出ワードを見つけよう！」に対する
Rubyのサンプルプログラムであることは熟知しています
しかしそれを速やかに理解するためには
Rubyに関する前提知識が必要です
少し時間をいただいて
最初にRubyの特徴的な事柄について説明させてください


なおRubyは1993年に日本で生まれてから
複数回のヴァージョンアップを繰り返し
現在もなお進化の過程にあります
現行安定ヴァージョンはRuby4.8.10ですが
以下で説明する内容はレガシーヴァージョンでも動作します
またJRuby, PRuby, MRuby, SRuby,
あるいはLittleRuby, MicroRuby, uby, byでも動作するでしょう
ただ, Cuby, roobee, RubybuR, λRuby, ComeOn!Rubyおよび
LavieRubis, Ruby&amp;#54861;, Rubykak&amp;#257;((rubyインタプリタのマオリ語による実装))では動作しないでしょう
さあ説明を始めましょう


([http://d.hatena.ne.jp/keyesberry/20090408/p1:title=次回に続く]）
</body>
</day>
<day date="2009-04-08" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その2)
これから説明するのは次の4つの項目です
+Rubyはオブジェクト指向です
+Rubyのブロックは仮装オブジェクトです
+クラスはオブジェクトの母であってクラスの子であるオブジェクトです
+Rubyはユーザフレンドリです


**1. Rubyはオブジェクト指向です
依然として現在主流のプログラミング言語は手続き型です
手続き型言語では手続きは
関数などのかたちでモジュール化されていますが
データ構造はそれとは別に管理されています


でもRubyではデータ構造も手続きと一緒にパッケージ化されており
それはオブジェクトと呼ばれています
つまりRubyではプログラムを組成する最小単位はオブジェクトです
そのためRubyプログラマのやるべきことは
「メモリ空間に必要なオブジェクトを生成し
それにメッセージを送ってその結果としてのオブジェクトを得る」
というかたちでプログラムを組成することになります


例えば次の例はメモリ空間に文字列オブジェクトを生成し
それにlengthというメッセージを送っています
&gt;|ruby|
 'hippopotamus'.length # =&gt; 12
||&lt;
文字列をクォートすれば文字列オブジェクトが生成されます
生成された文字列オブジェクト'hippopotamus'は
内部に多数のメソッドを持っており
lengthメッセージが送られると
これに対応するメソッドを検索し
あればそれを起動し結果を返します


通常反応するメソッドは
送られるメッセージ名と同じ名前を持っています
ですからこれからはメッセージとメソッドを区別しないで用います
メッセージを受けるオブジェクトのことを
レシーバと言うことがあります


注目して頂きたいのは
オブジェクトがメッセージを受けて返す値は
オブジェクトであるということです
つまり上で返された整数12は単なる整数ではなく
整数オブジェクト((正確には固定長整数オブジェクト))なのです
従ってこの返された値もメッセージを受け取ることができます
ですからRubyではこんな記述が許されます
&gt;|ruby|
 'hippopotamus'.length.even? # =&gt; true
||&lt;
これはメソッドチェーンと呼ばれることがあります


別の例を示します
&gt;|ruby|
 ['donkey', 'alligator', 'hippopotamus'].at(0) # =&gt; &quot;donkey&quot;
||&lt;
これはメモリ空間に3つの文字列オブジェクトを要素として含んだ
１つの配列オブジェクトを生成し
それにatメソッドを
0整数オブジェクトを引数に付けて送っているコードです
任意のオブジェクトを[ ]で括ると配列オブジェクトが生成されます


このようにメッセージには引数を付けることができます
ただしRubyはオブジェクトしか相手にしませんから
この引数はオブジェクトでなければなりません
返される結果は配列の先頭要素の'donkey'文字列オブジェクトです
確認のためこの結果にもメソッドチェーンを試みてみましょう
&gt;|ruby|
 ['donkey', 'alligator', 'hippopotamus'].at(0) # =&gt; &quot;donkey&quot;
 ['donkey', 'alligator', 'hippopotamus'].at(0).length # =&gt; 6
 ['donkey', 'alligator', 'hippopotamus'].at(0).length.even? # =&gt; true
||&lt;


メソッドチェーンの個数に制限はありません
暇つぶしをしたいのなら次のようにしてもかまいません
&gt;|ruby|
 1.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next # =&gt; 100
||&lt;

([http://d.hatena.ne.jp/keyesberry/20090409/p1:title=次回に続く]）

</body>
</day>
<day date="2009-04-09" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その3)
**Rubyのブロックは仮装オブジェクトです
次にRubyのブロックを説明します


手続き型言語同様
Rubyもifやwhileなどの制御構造をサポートしており
メソッド定義式の中でこれらを使うことができます((メソッド定義の外でも使えます))
&gt;|ruby|
 def hello(name)
   if name.length &gt; 10
     name.squeeze!
   else
     name += name.reverse
   end
   &quot;Hello, #{name}.&quot;
 end
 
 hello('mississippi-hippopotamus') # =&gt; &quot;Hello, misisipi-hipopotamus.&quot;
 hello('donkey') # =&gt; &quot;Hello, donkeyyeknod.&quot;
||&lt;


case式というユニークな制御構造もあります
&gt;|ruby|
 def good_bye(name)
   new_name = case name.length
   when 1..8
     name.next.capitalize
   when 9..15
     name.upcase.chop
   else
     name.replace(&quot;too-long-name&quot;)
   end
   &quot;Good-bye, #{new_name}!!&quot;
 end
 
 good_bye('donkey') # =&gt; &quot;Good-bye, Donkez!!&quot;
 good_bye('alligator') # =&gt; &quot;Good-bye, ALLIGATO!!&quot;
 good_bye('mississppi-hippopotamus') # =&gt; &quot;Good-bye, too-long-name!!&quot;
||&lt;
コードをよく見て頂ければわかると思いますが
caseはcase式であり値を返します
Rubyでは多くの制御構造や構文が式であり値を返します
つまりRubyでは制御構造もオブジェクト的なのです


しかしこれらの制御構造は真のオブジェクトではありません
したがってこのような制御構造を
メソッドの引数として渡すことはできません
LispやSchemeなどの異次元言語では
これらの制御構造を何の苦もなく関数の引数として渡せるそうです
このような関数は高階関数などとブルジョワジーに呼ばれます


しかしハンカチを噛む必要はありません
Rubyにはブロックがあります
制御構造をdo endまたは{ }のブロックに入れると
メソッドに引数のように渡せるようになります
&gt;|ruby|
 ['donkey', 'alligator', 'hippopotamus'].each do |name|
   salute = if name.start_with?('hip')
     'ばか！'
   else
     'やあ！'
   end
   puts salute + name
 end
 # &gt;&gt; やあ！donkey
 # &gt;&gt; やあ！alligator
 # &gt;&gt; ばか！hippopotamus
||&lt;
例では配列オブジェクトにeachメソッドを送る際に
ブロックを渡しています
これを受け取った配列オブジェクトは
各要素をブロック引数nameに順番に渡して
ブロックの制御構造を起動するのです
eachに渡すブロックの中身を変えれば
eachメソッドの働きは大幅に変更できます


この項の表題における「仮装」はtypoではありません
そう制御構造はブロックでオブジェクトに仮装して
他のオブジェクトに入り込むのです！


制御構造をメソッドに付けてオブジェクトに
渡せるようにする方法はまだあります
勘のいい人は気が付いたかもしれません
そう制御構造をオブジェクト化すればいいのです
手続きオブジェクト  メソッドオブジェクト  スレッドオブジェクト
ファイバーオブジェクト  継続オブジェクト
などがこれを可能にします
先を急がれるでしょうからこの話題はこれで終わりにします


興味のある方は以下が参考になるかもしれません
[http://d.hatena.ne.jp/keyesberry/20080809/p1:title=Rubyのブロックはメソッドに対するメソッドのMix-inだ！ - hp12c]


([http://d.hatena.ne.jp/keyesberry/20090410/p1:title=次回に続く]）

</body>
</day>
<day date="2009-04-10" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その4)
**クラスはオブジェクトの母であってクラスの子であるオブジェクトです
こういう表現は「クレタ人は嘘つきである」と言った
クレタ人のセリフに聞こえるでしょう(([http://ja.wikipedia.org/wiki/%E8%87%AA%E5%B7%B1%E8%A8%80%E5%8F%8A%E3%81%AE%E3%83%91%E3%83%A9%E3%83%89%E3%83%83%E3%82%AF%E3%82%B9:title=自己言及のパラドックス - Wikipedia]))
でもわたしはクレタ人ではありません
Rubyワールドにおいてこの表題は事実なのです


先に「オブジェクトは内部に多数のメソッドを持っており」と
書きましたが実際には持っていません
Rubyはクラスベースのオブジェクト指向言語であり
実際にメソッドを持っているのは
オブジェクトの雛型となっているクラスです
オブジェクトはメッセージを受けると
密かに自分の属するクラスにアクセスして結果を得ているのです


例えば 'donkey'.length というコードでは
文字列オブジェクト'donkey'は
自分ではlengthメソッドを持っておらず
その属するStringクラスに問い合わせをして結果を得ます
基本的にすべてのメソッドはクラスが持っており
オブジェクトは自分の属性情報
(自身のIDとか属するクラス名とか)しか持っていません


つまりオブジェクトは「知らないことは俺に聞け！」と言って
陰でググってるわたしと大差ないのです！


Rubyには40以上の標準添付のクラスがあり
それぞれがその特性を示すような多数のメソッドを備えています
自分で新しいクラスを作ることも
他の人が作ったクラスを取り込むこともできます((kernelモジュールのrequireメソッドを使います))
オブジェクトはほぼ例外なく
これらの何れかのクラスから生成されます((ARGFのようなクラスを持たないオブジェクトもあります))


クラスとメソッドを一望できるページを作りましたので
どんなクラスがあってどんなメソッドを持っているか
ここで確かめてください


[http://rbref.heroku.com/:title=Ruby 1.9.2 Methods List]


各メソッドはRubyリファレンスマニュアルにおける
メソッド解説にリンクしていますから
リンクを辿れば詳細を知ることができます


一般にクラスはオブジェクトの雛型であると言われます
わたしもさっきそう言いました
でも雛型というと設計図をイメージします
そしてその設計図に基づいて
建造物という実体が作られるとイメージします


しかしそのイメージはRubyのクラスに関しては正しくありません
なぜならRubyにおいてクラスは実体だからです
つまりクラスもメモリ空間の一部を占有するオブジェクトなのです
ですからクラス自身もメッセージを受信します


&gt;|ruby|
 Hash.ancestors # =&gt; [Hash, Enumerable, Object, Kernel, BasicObject]
||&lt;


クラスはメッセージを受けると自身の中に対応するメソッドを探し
あればそれを起動し結果を返します
このクラスに直接送られるメソッドを
特にクラスメソッドと呼ぶことがあります


前でオブジェクトはメッセージを受けると
属するクラスにメソッドを問い合わせると書きました
ではそのクラスが
対応するメソッドを持っていないときはどうなるでしょう
その答えが上のancestorsです


ここで出力されたクラス群は
Hashクラスと血の繋がりはありませんが
武芸の師匠といった位置づけのクラスです((正確にはEnumerableと Kernelはモジュールという特殊なクラスです))
だからancestorsというよりteachersといったほうがぴったりきます
つまりクラスが対応するメソッドを持たない場合
そのancestorsに順次問い合わせて答えを得ます
このような仕組みを技芸の継承・文化の継承に倣って
クラスの継承といいます


すべてのクラスが答えることができるクラスメソッドはnewです
これはその属するオブジェクトを生み出すものです
&gt;|ruby|
 charlie = Person.new('Charlie', 12, :male)
||&lt;
Personクラスに名前、年齢、性別の属性情報を渡して
newメソッドを呼んでいます


これでメモリ空間に１つの人オブジェクトが生まれます
このときnewメソッドを受けるクラスが既にオブジェクトとして
メモリ空間に生成されているということを忘れないでください


誰がオブジェクトの母親かはclassメソッドで知ることができます
&gt;|ruby|
 carlie.class # =&gt; Person
 'alligator'.class # =&gt; String
 [1, 2, 3].class # =&gt; Array
||&lt;


ではオブジェクトを生み出すクラスは誰が生み出すのでしょう
答えは上と同様クラスにclassメソッドを送れば得られます
&gt;|ruby|
 String.class # =&gt; Class
 Array.class # =&gt; Class
 Person.class # =&gt; Class
||&lt;


RubyにおけるアダムとイブはClassという名を持ったクラスでした
次なる疑問は「ではClassクラスはいったい誰が生むのか？」です
これはご自身で試してみてください
驚愕の事実が得られます


以上でクラスについてのこの項の説明は終わりです
わたしはクレタ人にならずに済んだでしょうか


クラスに関して更に知りたい方は以下を参考にしてみてください


[http://d.hatena.ne.jp/keyesberry/20080816/p1:title=Rubyのクラスはオブジェクトの母、モジュールはベビーシッター - hp12c]


([http://d.hatena.ne.jp/keyesberry/20090411/p1:title=次回に続く])

</body>
</day>
<day date="2009-04-11" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その5)
**Rubyはユーザフレンドリです
Rubyにおいてオブジェクト指向はその基本的設計思想です
Ruby設計者まつもとゆきひろさん(愛称Matz)は
その思想を頑なに守りながら
一方でプログラマーの負担を最小化するために
ユーザインタフェースをよりフレンドリなものにしました
そのいくつかを紹介します


**メソッド呼び出しのシンタックスシュガー
オブジェクト指向の基本ルールに従えば
簡単な算術演算も整数オブジェクトに対する
メソッド呼び出しのかたちを取ります
&gt;|ruby|
 6.+(2) # =&gt; 8
 6.-(2) # =&gt; 4
 6.*(2) # =&gt; 12
 6./(2) # =&gt; 3
||&lt;


しかしRubyでは慣れ親しんだ数学式の書き方ができます
&gt;|ruby|
 6 + 2 # =&gt; 8
 6 - 2 # =&gt; 4
 6 * 2 # =&gt; 12
 6 / 2 # =&gt; 3
||&lt;


オブジェクトの状態変数((Rubyではインスタンス変数と呼びます))への代入も次のように自然に書けます
&gt;|ruby|
 charlie = Person.new('Charlie', 12, :male)
 charlie.age = 18 # =&gt; 18
||&lt;


このようなメソッド呼び出しのシンタックスシュガー(簡略表記)が
Rubyではできます


**クラス定義およびレシーバの省略
Rubyではクラス定義をすることなく
コードを手続き型言語のように書くこともできます
&gt;|ruby|
 def fact(n)
   if n == 1
     1
   else
     n * fact(n-1)
   end
 end
 puts fact(10)
# &gt;&gt; 3628800
||&lt;


このようにいきなりメソッドfactを定義したり
レシーバを指定せずにputsメソッド呼んだりできます


でもここでもオブジェクト指向設計は崩れていません
Matzはオブジェクト内でのメソッド呼び出しを
そのレシーバを省略できるようにすると共に
クラスの外で書かれたコードが
Objectクラスという基本クラスに自動設定されるようにし
これによって設計の一貫性を維持しつつ
手続き型記述を許せるようにしたのです


Rubyの手続き型記述をよく使う方も
このことは頭の片隅にあって良いと思います
Rubyではクラスの外をトップレベルと呼ぶことがあります


**変数・定数
以下の構文は変数carに対する値の代入ですが
Rubyではそれは正確な表現ではありません
&gt;|ruby|
 car = 'mini cooper'
||&lt;


「変数carで'mini cooper'文字列オブジェクトを
参照できるようにする」
と言ったほうがより正確です
つまり変数carは単なる参照ラベルに過ぎません
ですから
１つのオブジェクトに複数の変数を付けてもコピーは起きません
型といった概念もないので型宣言は不要です
Rubyでは次のコードは問題ありません
&gt;|ruby|
 a = 3
 b = 6
 c = a + b
 puts c
 a = 'mississippi'
 b = '-hippopotamus'
 c = a + b
 puts c
 # &gt;&gt; 9
 # &gt;&gt; mississippi-hippopotamus
||&lt;


’+’が算術演算子ではなくてメソッドであると前に書きました
前者のa + bは3整数オブジェクトに対して
6整数オブジェクトを引数に+メソッドを呼び出しています
その後a, bの参照先が変わって
後者のa + bは'mississippi'文字列オブジェクトに対して
'-hippopotamus'文字列オブジェクトを引数に
 +メソッドを呼び出しています
つまり+メソッドは
異なるタイプのオブジェクトに送られているのです


そして整数オブジェクトでは+メソッドは
自身と引数を加算した整数オブジェクトを返すように
文字列オブジェクトでは自身と引数を連結した文字列オブジェクトを
返すようにそれぞれ定義されています


定数に対する考え方も同じです
定数は大文字で始まり貼り替えの必要のない
つまり内容が変化しないオブジェクトを指す目的で使います
なおクラス定義は大文字で始まりますが(String, Array)
これらはクラスオブジェクトを指し示す定数です


**括弧の省略
Rubyでは解釈に曖昧さが生じない限り
括弧を省略できます
&gt;|ruby|
 def say word
   &quot;#{word} &quot; * 3
 end
 puts say &quot;Hello!&quot;
 puts say say &quot;Hi!&quot;
 # &gt;&gt; Hello!　Hello!　Hello!　
 # &gt;&gt; Hi!　Hi!　Hi!　　Hi!　Hi!　Hi!　　Hi!　Hi!　Hi!　　
||&lt;


このオブジェクト原理主義的な書き方はこうです
&gt;|ruby|
 def say(word)
   &quot;#{word} &quot;.*(3)
 end
 puts(say(&quot;Hello!&quot;))
 puts(say(say(&quot;Hi!&quot;)))
 # &gt;&gt; Hello!　Hello!　Hello!　
 # &gt;&gt; Hi!　Hi!　Hi!　　Hi!　Hi!　Hi!　　Hi!　Hi!　Hi!　　
||&lt;


括弧の省略はこのようにコードの見た目を改善し読みやすくします
しかし行き過ぎはむしろコードを読み難くします
文章の句読点を使うように適度に括弧を使うのが常識人です


**多重代入と*(アスタリスク)
Rubyでは関連する複数の変数に対して同時に代入ができます
&gt;|ruby|
 a, b, c = 0, 1, 2
||&lt;


これを多重代入といいます
もちろん関連がなくてもできますが推奨されません
&gt;|ruby|
 SIZE, name, switch = {:L =&gt; 'large', :M =&gt; 'medium', :S =&gt; 'small' }, 'Ruby',  [0, 1]
||&lt;


メソッドは複数の返り値を返せるので
これを多重代入で受けることもできます
&gt;|ruby|
 class Fixnum
   def plus_multi(other)
     return self + other, self * other
   end
 end
 
 a, b = 3.plus_multi 4
 puts a, b
 # &gt;&gt; 7
 # &gt;&gt; 12
||&lt;


変数に*(アスタリスク)を付けるとマルチラベルになって
受けたオブジェクトを配列に入れてそれを指します
&gt;|ruby|
 *a = 1, 2, 3
 p a
 # &gt;&gt; [1, 2, 3]
||&lt;


Rubyではこれをメソッドの引数にも使えるのです
&gt;|ruby|
 def hello(*a)
   a.each { |name| puts &quot;Hello, #{name}!&quot; }
 end
 
 hello 'donkey', 'alligator', 'hippopotamus'
 # &gt;&gt; Hello, donkey!
 # &gt;&gt; Hello, alligator!
 # &gt;&gt; Hello, hippopotamus!
||&lt;


このようにRubyは純粋なオブジェクト指向言語でありながら
とてもユーザフレンドリな作りになっています


呆れるほど長い前置きが続きました
でもこれで最初に掲げた4つの項目の説明は終わりです
もちろん説明はし尽くされていませんが
最初の目的を失しそうなのでここまでとします


そろそろ本題に入りましょう


([http://d.hatena.ne.jp/keyesberry/20090412/p1:title=次回に続く])

</body>
</day>
<day date="2009-04-12" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その6)
さてこれまでに得た知識を基礎として
目的のRubyスクリプトを作ります
最初にベースとなるコードを提示して
これを少しずつ改良していきながらRubyを学びます


まずは手元にRubyで処理できる
英文小説のテキストファイルを用意します
以下のサイトがよさそうです


[http://www.gutenberg.org/wiki/Main_Page:title=Project Gutenberg]


ここから気に入った小説を
plain text形式で2、3ダウンロードします


もしrubyインタプリタが手元にないか
ヴァージョンが古いのなら
[http://www.ruby-lang.org/ja/:title=Ruby公式サイト]にアクセスして入手します
4.8.10があればいいですが1.8.7でも1.9.1でも足ります
ターミナルを開いて ruby -v と打てばインストールされている
rubyのヴァージョンが分かります


さて準備が整ったら
まずは入力と出力をイメージしましょう
このRubyスクリプトの名前をtopwords.rbとします
もちろんtop10.rbでもtopoftheworld.rbでもかまいません
&gt;|ruby|
 $ ruby topwords.rb novel1.txt novel2.txt novel3.txt
 {'this' =&gt; 123, 'is' =&gt; 85, 'a' =&gt; 65, 'ruby' =&gt; 30, ... }
||&lt;


rubyインタプリタにスクリプト名と
上で入手したファイルを渡します
その実行結果として
最頻出単語とその出現数のリストが得られる
そんなイメージがよさそうです


次にRubyスクリプトの大ざっぱなプランを描きます


例えば次のように
-コマンド引数として渡したファイルをスクリプトに取り込むためにARGFというオブジェクトを使う
-ARGFから順次ファイルの行を読み出す
-読み出した行から単語を切り出す
-ハッシュオブジェクトを用意して単語とその出現数の対を格納する
-ハッシュオブジェクトの内容をその出現数の順位で並べ替える
-その上位30を取り出す


**Version01
突然ですが
この方針による最初のスクリプトは次のようになりました
&gt;|ruby|
 dic = Hash.new(0)
 while line = ARGF.gets
   line.downcase!
   while line.sub!(/[a-z]+/, &quot;&quot;)
     word = $&amp;
     dic[word] += 1
   end
 end
 
 p dic.sort { |a, b| b[1] &lt;=&gt; a[1] }[0...30]
||&lt;


最初に単語と出現数のリストを格納する
ハッシュオブジェクトを用意します
ハッシュは通常 dic = {}で簡単に生成できますが
ここでは対応するキーがない場合の
デフォルト値0を設定するために
newメソッドを呼んでいます
これにより6行目の増分が可能になります


Rubyはスクリプトに指定した引数をファイル名とみなして
その内容を持ったARGFというオブジェクトを作り出します
ARGFオブジェクトは
その内容にアクセスするためのメソッド群を持っており
ここではその１つであるgetsメソッドを使って
ファイルの各行を文字列オブジェクトとして得ています


ARGFといわれてもピンと来ませんが
何かの略です
たぶんAiR GolFかARGument Filesです


いえ
わかりました
ARt GarFunkelの略です
そのうちPRSMというのも出てくると思います


以下のサイトで「ARGF」を検索しリンクを辿れば
ARGFが持っているメソッドを調べられます


[http://rbref.heroku.com/:title=Ruby 1.9.2 Methods List]


whileループで順次ファイルの行を変数lineに読み込みます
getsメソッドはファイルの終わりに来るとnilを返しますから
ここでループが終わります
読み込まれた行はdowncase!メソッドで小文字に変換され
次にsub!メソッドでそこから単語を切り出します


sub!メソッドは第1引数の正規表現の条件にマッチしたものを
第2引数に(ここでは空文字)置き換えます
sub!メソッドは元のline文字列オブジェクト自体を変更します
つまりlineはマッチするたびに短くなっていき
最後にはマッチするものが無くなってnilが返りループが終わります
マッチした単語はその都度変数$&amp;でアクセスできます


取得したwordでハッシュdicのキーにアクセスし
対応するバリューを増分します
dicに対応wordが無い場合
デフォルト値0で項目が作成され1増分されます


次にハッシュオブジェクトであるdicをソートします
sortメソッドは
ハッシュの[key, value]を要素とする配列の配列を作り
ブロックの条件でこれをソートした結果を返します
ここではvalue値の大小でソートします
降順ソートとするためa,bを逆に書きます


最後に[]メソッドに0...30の範囲オブジェクトを渡して
対象の配列オブジェクトのみを取り出します
ドットが3つであることに注意してください
この場合は30つまり31番目の要素は範囲外になります


では実際に入手したファイルでこのスクリプトを実行してみましょう
&gt;|ruby|
 $ ruby topwords.rb 11.txt 1342.txt 18503.txt 
 [[&quot;the&quot;, 16077], [&quot;of&quot;, 9823], [&quot;and&quot;, 7482], [&quot;to&quot;, 7098], [&quot;in&quot;, 4456], [&quot;a&quot;, 3841], [&quot;that&quot;, 3161], [&quot;was&quot;, 3040], [&quot;it&quot;, 2919], [&quot;i&quot;, 2881], [&quot;her&quot;, 2550], [&quot;she&quot;, 2313], [&quot;as&quot;, 2134], [&quot;you&quot;, 2071], [&quot;not&quot;, 2057], [&quot;be&quot;, 2044], [&quot;is&quot;, 2033], [&quot;his&quot;, 2009], [&quot;he&quot;, 1940], [&quot;for&quot;, 1927], [&quot;with&quot;, 1875], [&quot;on&quot;, 1638], [&quot;had&quot;, 1567], [&quot;but&quot;, 1519], [&quot;s&quot;, 1495], [&quot;all&quot;, 1363], [&quot;at&quot;, 1344], [&quot;by&quot;, 1308], [&quot;this&quot;, 1249], [&quot;have&quot;, 1201]]
||&lt;


うまくいきました
'the'が英文小説における最頻出ワードであることが分かりました
上の正規表現は「'」にうまく対応していないので
完全ではありませんが
一応これで仕事が片づきました
上司に報告が必要な人は
この結果をプリントアウトしてください


([http://d.hatena.ne.jp/keyesberry/20090413:title=次回に続く])

</body>
</day>
<day date="2009-04-13" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その7)
10行程度のスクリプトで目的を達成できました
前置きばかりが長かったこの連載も
これで終えられます


でも...
わたしはどうも気に入りません
先のコードは分かりにくいというか
Rubyっぽくないというか...


もう一度スクリプトを見てみます
&gt;|ruby|
 dic = Hash.new(0)
 while line = ARGF.gets
   line.downcase!
   while line.sub!(/[a-z]+/, &quot;&quot;)
     word = $&amp;
     dic[word] += 1
   end
 end
 
 p dic.sort { |a, b| b[1] &lt;=&gt; a[1] }[0...30]
||&lt;


不満点を言えば...


!を忘れただけで無限ループに陥るのがヤです
「こら」と「こら！」で確かに雰囲気は変わりますが
怒っていることに変わりはありません


「$&amp;」記号が意味不明です
しかも中途半端です
「$&amp;♀」なら納得しますが...((ええ、男には無くてはならないものです))


subの第2引数も何かを忘れちゃったようでヤです
できれば省略したい


なによりもオブジェクト指向してません


**Version02
そうです
気に入らないなら改良しましょう
リファクタリングです


単語を切り出す処理を
dicを作る処理と切り分けましょう
&gt;|ruby|
 WORDS = ARGF.read.downcase.scan(/[a-z]+/)
 dic = Hash.new(0)
 for word in WORDS
   dic[word] += 1
 end
 p dic.sort { |a, b| b[1] &lt;=&gt; a[1] }[0...30]
||&lt;


一行目を見てください
「Rubyはオブジェクト指向です」のところで説明した
メソッドチェーンです
ここではARGFに対しreadメソッドで一気にファイルを読み出し
まとめて小文字化した文字列オブジェクトを得ています
そしてscanメソッドを使ってそこから単語を切り出しています
scanメソッドはマッチした単語の配列を返します
これをWORDSで参照できるようにします


次にfor文でWORDSから単語を一つずつ取り出し辞書を作ります


1行目がオブジェクト指向的なコードになり
機能的にも(1)単語の切り出し(2)辞書dicの作成(3)ソート
の各処理が分離して全体がすっきりしました
大分好きなかたちになりました


**Version03
でもこうなると
(2)がオブジェクト指向的でなく
制御構造中心になっているところが
気になる人は気になります


リファクタリングしましょう
&gt;|ruby|
 WORDS = ARGF.read.downcase.scan(/[a-z]+/)
 DICTIONARY = WORDS.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
 p DICTIONARY.sort { |a, b| b[1] &lt;=&gt; a[1] }[0...30]
||&lt;


配列のinjectメソッドは
畳み込みという処理をする便利なメソッドです
injectは引数とブロックを取って引数で渡されたオブジェクトに
配列の各要素をブロック内の条件で投入していきます


次のコードは配列要素を順次引数10に加算した結果を返します
&gt;|ruby|
 p [1, 2, 3].inject(10) { |mem, var| mem + var } 
 # &gt;&gt; 16
||&lt;


上のスクリプトでは引数に初期値0のハッシュを与えて
ブロック内で辞書を作ります
なおinjectメソッドからの返り値を
ハッシュオブジェクトとするために
ブロックの返り値をdicとする必要があります


スクリプトが3行になりました
極めてワードエコなコードです
Rubyのパワーを垣間見ます
これなら上司も喜びます


オブジェクト指向の良いところは
文章を読むように左から右にコードを読めるところです
ファイルを読んで小文字にして単語を取り出す
単語からその出現数の辞書を作る
辞書をソートして先頭の30件を取り出す


さあ目的は達成できました
スクリプトもRubyっぽくなりました
気分がいいです


([http://d.hatena.ne.jp/keyesberry/20090414:title=次回に続く])

</body>
</day>
<day date="2009-04-14" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その8)
先のスクリプトにわたしは何の不満もありません
でもリファクタリングはクセになります
3行目のsortのブロックが
気になる人には気になります
&gt;|ruby|
 p DICTIONARY.sort { |a, b| b[1] &lt;=&gt; a[1] }[0...30]
||&lt;

**Version04
少し直しましょう
&gt;|ruby|
 WORDS = ARGF.read.downcase.scan(/[a-z]+/)
 DICTIONARY = WORDS.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
 p DICTIONARY.sort_by { |key, val| val }.slice(-30..-1)
||&lt;


sortに代えてsort_byを使いました
辞書の要素数が多ければこちらのほうが速度的に有利です
これは好みの問題かもしれませんが
[]に代えてsliceを使いました
sort_byが昇順ソートになっているので
sliceの範囲オブジェクトは最後尾(-1)から指定しています


**Version05
でも次の方がもっとすっきりします
&gt;|ruby|
 WORDS = ARGF.read.downcase.scan(/[a-z]+/)
 DICTIONARY = WORDS.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
 p DICTIONARY.sort_by { |key, val| -val }.take(30)
||&lt;


valを負数にすれば降順ソートになります
takeメソッドは先頭から30要素を取ります


**TMTOWTDI
「同じことをやるのに複数のやり方があっていい」
というのがPerlの流れを汲むRubyの流儀です(([http://ja.wikipedia.org/wiki/Perl:title=Perl - Wikipedia]))
ですからRubyではこのように
同じ処理を複数の方法で実現できます


この「同じことをやるのに複数のやり方があっていい」
という考え方は
英語では -TMTOWTDI- といいます
There's More Than One Way To Do It だそうです
最初に見たとき
TiMe TO WheTher Die or Ill かと思いました


でもいま
本当の答えに気が付きました
 -TMTOWTDI- は正規表現だったんです


/Today's (Mon|Tue) Or (Wed|Thu) Day/I


**Version06
やり方が複数あることに最初は戸惑うかもしれません
でもジブンノカタチニコダワル派には麻薬になります


ではもう少しコダワッテ...


この「ハッシュをソートして端からいくつか取る」というのは
汎用性がありそうです
標準メソッドに似たようなtake_whileというのはあるのですが
目的のものはありません


ではこれをtake_byメソッドとしてHashクラスに作りましょう
&gt;|ruby|
 class Hash
   def take_by(nth)
     sort_by { |elem| yield elem }.take(nth)
   end
 end
 
 WORDS = ARGF.read.downcase.scan(/[a-z]+/)
 DICTIONARY = WORDS.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
 p DICTIONARY.take_by(30) { |key, val| -val }
 p DICTIONARY.take_by(30) { |key, val| val }
 
 # &gt;[[&quot;the&quot;, 16077], [&quot;of&quot;, 9823], [&quot;and&quot;, 7482], [&quot;to&quot;, 7098], [&quot;in&quot;, 4456], [&quot;a&quot;, 3841], [&quot;that&quot;, 3161], [&quot;was&quot;, 3040], [&quot;it&quot;, 2919], [&quot;i&quot;, 2881], [&quot;her&quot;, 2550], [&quot;she&quot;, 2313], [&quot;as&quot;, 2134], [&quot;you&quot;, 2071], [&quot;not&quot;, 2057], [&quot;be&quot;, 2044], [&quot;is&quot;, 2033], [&quot;his&quot;, 2009], [&quot;he&quot;, 1940], [&quot;for&quot;, 1927], [&quot;with&quot;, 1875], [&quot;on&quot;, 1638], [&quot;had&quot;, 1567], [&quot;but&quot;, 1519], [&quot;s&quot;, 1495], [&quot;all&quot;, 1363], [&quot;at&quot;, 1344], [&quot;by&quot;, 1308], [&quot;this&quot;, 1249], [&quot;have&quot;, 1201]]
 [[&quot;rained&quot;, 1], [&quot;grows&quot;, 1], [&quot;pearly&quot;, 1], [&quot;hinder&quot;, 1], [&quot;overturn&quot;, 1], [&quot;interpose&quot;, 1], [&quot;infuse&quot;, 1], [&quot;prescribes&quot;, 1], [&quot;escaping&quot;, 1], [&quot;guinness&quot;, 1], [&quot;belch&quot;, 1], [&quot;humbling&quot;, 1], [&quot;appropriately&quot;, 1], [&quot;luminous&quot;, 1], [&quot;frailty&quot;, 1], [&quot;rightful&quot;, 1], [&quot;nods&quot;, 1], [&quot;purple&quot;, 1], [&quot;sepulcher&quot;, 1], [&quot;hollow&quot;, 1], [&quot;rivaled&quot;, 1], [&quot;pearls&quot;, 1], [&quot;eyed&quot;, 1], [&quot;judaizing&quot;, 1], [&quot;fulton&quot;, 1], [&quot;taylor&quot;, 1], [&quot;coincidence&quot;, 1], [&quot;apocalypticae&quot;, 1], [&quot;clime&quot;, 1], [&quot;atoning&quot;, 1]]
||&lt;


これでDICTIONARYに対する
メソッド呼び出しが１つで済むようになりました


ちょっと分かりづらいかもしれませんが
キモはメソッド定義中のyieldです
yieldがあるとメソッド呼び出しの際に
ブロックを取れるようになります
メソッドが呼び出されて実行がyieldに達すると
ブロックが実行されます


上の例ではsort_byのブロック引数elemに
ハッシュの最初の要素つまりkey, valueの組が渡されると
yieldがtake_byに付けられたブロックの中身-valになります


([http://d.hatena.ne.jp/keyesberry/20090415:title=次回に続く])

</body>
</day>
<day date="2009-04-15" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その9)
更に欲が出てきました
このtake_byというメソッドを
配列でも使いたくなりました


実は先のsort_byというメソッドはHashクラスにも
Arrayクラスにも定義されていません
それが定義されているのはEnumerableというモジュールです
モジュールというのはクラスの亜種です
オブジェクトを生成できないクラスです
飛べない鳥ニワトリのようなものです((説明のためモジュールおよびニワトリに対するこのような差別的発言をお許しください))


EnumerableモジュールをHashおよびArrayクラスに
インクルードすることでsort_byの夢のコラボが実現しています


**Version07
我らtake_byにも夢を実現させましょう

&gt;|ruby|
 module Enumerable
   def take_by(nth)
     sort_by { |elem| yield elem }.take(nth)
   end
 end
 
 WORDS = ARGF.read.downcase.scan(/[a-z]+/)
 DICTIONARY = WORDS.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
 p DICTIONARY.take_by(30) { |key, val| -val }
 p WORDS.take_by(30) { |n| -n.length }
 
 #&gt; [[&quot;the&quot;, 16077], [&quot;of&quot;, 9823], [&quot;and&quot;, 7482], [&quot;to&quot;, 7098], [&quot;in&quot;, 4456], [&quot;a&quot;, 3841], [&quot;that&quot;, 3161], [&quot;was&quot;, 3040], [&quot;it&quot;, 2919], [&quot;i&quot;, 2881], [&quot;her&quot;, 2550], [&quot;she&quot;, 2313], [&quot;as&quot;, 2134], [&quot;you&quot;, 2071], [&quot;not&quot;, 2057], [&quot;be&quot;, 2044], [&quot;is&quot;, 2033], [&quot;his&quot;, 2009], [&quot;he&quot;, 1940], [&quot;for&quot;, 1927], [&quot;with&quot;, 1875], [&quot;on&quot;, 1638], [&quot;had&quot;, 1567], [&quot;but&quot;, 1519], [&quot;s&quot;, 1495], [&quot;all&quot;, 1363], [&quot;at&quot;, 1344], [&quot;by&quot;, 1308], [&quot;this&quot;, 1249], [&quot;have&quot;, 1201]]
 [&quot;communicativeness&quot;, &quot;congregationalist&quot;, &quot;indestructibility&quot;, &quot;disinterestedness&quot;, &quot;misrepresentation&quot;, &quot;superciliousness&quot;, &quot;unenforceability&quot;, &quot;unenforceability&quot;, &quot;incomprehensible&quot;, &quot;inextinguishable&quot;, &quot;discontentedness&quot;, &quot;internationalism&quot;, &quot;incomprehensible&quot;, &quot;unenforceability&quot;, &quot;congratulations&quot;, &quot;acknowledgments&quot;, &quot;accomplishments&quot;, &quot;unrighteousness&quot;, &quot;condescendingly&quot;, &quot;congratulations&quot;, &quot;transformations&quot;, &quot;merchantibility&quot;, &quot;notwithstanding&quot;, &quot;congratulations&quot;, &quot;recommendations&quot;, &quot;appropriateness&quot;, &quot;congratulations&quot;, &quot;contemporaneous&quot;, &quot;comprehensively&quot;, &quot;thoughtlessness&quot;]
||&lt;


すばらしい！
配列オブジェクトを指すWORDSに対して
ワード長降順の条件でtake_byメソッドを呼んでいます


実はわたくし最頻出ワードよりも
最長ワードに興味があったのですよ
'incomprehensibleなcongregationalist'になりたい！
そんな今日この頃です...


さて...


もう終わりでしょうか？
気になる人には気になるところは
もうないでしょうか


**Version08
take_byでよく使いそうなのは
やっぱり最大値最小値でソートしてtakeでしょう
take_byとは別にHashクラスにこれら
top_by_value, bottom_by_valueを
定義するというのはどうでしょうか

&gt;|ruby|
 module Enumerable
   def take_by(nth)
     sort_by { |elem| yield elem }.take(nth)
   end
 end
 
 class Hash
   def top_by_value(nth)
     take_by(nth) { |key, val| -val }
   end
 
   def bottom_by_value(nth)
     take_by(nth) { |key, val| val }
   end
 end
 
 WORDS = ARGF.read.downcase.scan(/[a-z]+/)
 DICTIONARY = WORDS.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
 p DICTIONARY.top_by_value(30)
 p DICTIONARY.bottom_by_value(30)
||&lt;


DICTIONARYに対するメソッド呼び出しがすっきりしました


実行結果は次のようになります
&gt;|ruby|
#&gt; [[&quot;the&quot;, 16077], [&quot;of&quot;, 9823], [&quot;and&quot;, 7482], [&quot;to&quot;, 7098], [&quot;in&quot;, 4456], [&quot;a&quot;, 3841], [&quot;that&quot;, 3161], [&quot;was&quot;, 3040], [&quot;it&quot;, 2919], [&quot;i&quot;, 2881], [&quot;her&quot;, 2550], [&quot;she&quot;, 2313], [&quot;as&quot;, 2134], [&quot;you&quot;, 2071], [&quot;not&quot;, 2057], [&quot;be&quot;, 2044], [&quot;is&quot;, 2033], [&quot;his&quot;, 2009], [&quot;he&quot;, 1940], [&quot;for&quot;, 1927], [&quot;with&quot;, 1875], [&quot;on&quot;, 1638], [&quot;had&quot;, 1567], [&quot;but&quot;, 1519], [&quot;s&quot;, 1495], [&quot;all&quot;, 1363], [&quot;at&quot;, 1344], [&quot;by&quot;, 1308], [&quot;this&quot;, 1249], [&quot;have&quot;, 1201]]
  [[&quot;rained&quot;, 1], [&quot;grows&quot;, 1], [&quot;pearly&quot;, 1], [&quot;hinder&quot;, 1], [&quot;overturn&quot;, 1], [&quot;interpose&quot;, 1], [&quot;infuse&quot;, 1], [&quot;prescribes&quot;, 1], [&quot;escaping&quot;, 1], [&quot;guinness&quot;, 1], [&quot;belch&quot;, 1], [&quot;humbling&quot;, 1], [&quot;appropriately&quot;, 1], [&quot;luminous&quot;, 1], [&quot;frailty&quot;, 1], [&quot;rightful&quot;, 1], [&quot;nods&quot;, 1], [&quot;purple&quot;, 1], [&quot;sepulcher&quot;, 1], [&quot;hollow&quot;, 1], [&quot;rivaled&quot;, 1], [&quot;pearls&quot;, 1], [&quot;eyed&quot;, 1], [&quot;judaizing&quot;, 1], [&quot;fulton&quot;, 1], [&quot;taylor&quot;, 1], [&quot;coincidence&quot;, 1], [&quot;apocalypticae&quot;, 1], [&quot;clime&quot;, 1], [&quot;atoning&quot;, 1]]
||&lt;


ん～
これじゃbottom_by_valueはあまり意味がありませんね


**Version09
ブロックを取って範囲を限定できるようにしたら
もう少しマシになるかもしれません

&gt;|ruby|
 module Enumerable
   def take_by(nth)
     sort_by { |elem| yield elem }.take(nth)
   end
 end
 
 class Hash
    def top_by_value(nth)
     select { |key, val| yield val }.take_by(nth) { |key, val| -val }
    end
 
    def bottom_by_value(nth)
     select { |key, val| yield val }.take_by(nth) { |key, val| val }
    end
 end
 
 WORDS = ARGF.read.downcase.scan(/[a-z]+/)
 DICTIONARY = WORDS.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
 p DICTIONARY.top_by_value(30) { |val| val &lt; 400 }
 p DICTIONARY.bottom_by_value(30) { |val| val &gt; 100 }
||&lt;


top_by_value, bottom_by_valueでは
selectメソッドを使って
対象範囲を限定できるようにしました
結果に少し意味がでました

&gt;|ruby|
 #&gt; [[&quot;know&quot;, 386], [&quot;up&quot;, 383], [&quot;into&quot;, 382], [&quot;its&quot;, 380], [&quot;did&quot;, 378], [&quot;am&quot;, 377], [&quot;than&quot;, 377], [&quot;little&quot;, 376], [&quot;can&quot;, 372], [&quot;may&quot;, 370], [&quot;how&quot;, 365], [&quot;every&quot;, 365], [&quot;only&quot;, 361], [&quot;man&quot;, 361], [&quot;now&quot;, 361], [&quot;first&quot;, 358], [&quot;other&quot;, 358], [&quot;christ&quot;, 358], [&quot;should&quot;, 353], [&quot;mrs&quot;, 352], [&quot;after&quot;, 346], [&quot;again&quot;, 346], [&quot;come&quot;, 344], [&quot;see&quot;, 338], [&quot;some&quot;, 338], [&quot;well&quot;, 329], [&quot;world&quot;, 326], [&quot;bennet&quot;, 323], [&quot;prophecy&quot;, 322], [&quot;never&quot;, 317]]
 [[&quot;gave&quot;, 101], [&quot;forth&quot;, 101], [&quot;course&quot;, 101], [&quot;thy&quot;, 102], [&quot;speak&quot;, 102], [&quot;get&quot;, 102], [&quot;head&quot;, 102], [&quot;home&quot;, 103], [&quot;bible&quot;, 103], [&quot;pleasure&quot;, 103], [&quot;seemed&quot;, 104], [&quot;together&quot;, 105], [&quot;why&quot;, 105], [&quot;high&quot;, 106], [&quot;thou&quot;, 106], [&quot;myself&quot;, 106], [&quot;daniel&quot;, 108], [&quot;hand&quot;, 109], [&quot;near&quot;, 109], [&quot;often&quot;, 110], [&quot;better&quot;, 110], [&quot;hear&quot;, 110], [&quot;left&quot;, 110], [&quot;believe&quot;, 110], [&quot;moment&quot;, 111], [&quot;find&quot;, 111], [&quot;half&quot;, 113], [&quot;really&quot;, 114], [&quot;prophet&quot;, 114], [&quot;book&quot;, 114]]
||&lt;


([http://d.hatena.ne.jp/keyesberry/20090416:title=次回に続く])

</body>
</day>
<day date="2009-04-16" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その10)
なかなかいいですね
さてこれでもう完成でしょうか...


いいえ！
問題が発生しました！
先のコードはDRY原則に反します！！

**DRY原則
「DON'T REPEAT YOURSELF!」(([http://ja.wikipedia.org/wiki/Don't_repeat_yourself:title=Don't repeat yourself - Wikipedia]))
達人プログラマは言いました
「お前は二人も要らないよ！」
あるいは
「愚鈍なる君の二度手間はダメ！」


そうです同じコードの繰り返しは罪なのです！


もう一度コードを見てみましょう
&gt;|ruby|
 class Hash
    def top_by_value(nth)
     select { |key, val| yield val }.take_by(nth) { |key, val| -val }
    end
 
    def bottom_by_value(nth)
     select { |key, val| yield val }.take_by(nth) { |key, val| val }
    end
 end
||&lt;


「-」記号１つの差はありますが...
確かに...
そっくりです
Yes, I repeat myself...

**Version10
Hashクラスにtake_by_valueというメソッドを作って
上のコードを1ヶ所に集約します

&gt;|ruby|
 class Hash
   def top_by_value(nth, &amp;blk)
     take_by_value(nth, lambda { |v| -v }, &amp;blk)
   end
 
   def bottom_by_value(nth,&amp;blk)
     take_by_value(nth, lambda { |v| v }, &amp;blk)
   end
 
   private
   def take_by_value(nth, sort_opt)
     select { |key, val| yield val }.take_by(nth) { |key, val| sort_opt[val] }
   end
 end
||&lt;
差し当たりtake_by_valueはクラスの中から呼ぶだけなので
その可視性をprivateにします


take_by_valueはtop_by_valueおよびbottom_by_value
に渡される引数nthの他
手続きオブジェクトsort_optを引数に取ります
top_by_valueおよびbottom_by_value側では
{|v| -v}または{|v| v}をlambdaでオブジェクト化して渡します
take_by_valueのsort_opt[val]は受け取った
手続きオブジェクトを実行します
これはsort_opt.call(val)でもいいです


またtop_by_valueおよびbottom_by_valueでは
受け取るブロックをtake_by_valueに引き渡すために
&amp;blkでブロックを一旦オブジェクト化する必要があります


ちょっと込み入った話になりました
関連する話題はここにも書いているので
参考になるかもしれません


[http://d.hatena.ne.jp/keyesberry/20080809/p1:title=Rubyのブロックはメソッドに対するメソッドのMix-inだ！ - hp12c]


兎に角
これでもう達人は怒らないでしょうか


あっ！
ちょっと問題を発見しました
top_by_valueにブロックを与えないで渡すとエラーがでます

&gt;|ruby|
 WORDS = ARGF.read.downcase.scan(/[a-z]+/)
 DICTIONARY = WORDS.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
 p DICTIONARY.top_by_value(30)
||&lt;
&gt;|ruby|
 $ ruby topwords.rb 11.txt 1342.txt 18503.txt 
 topwords.rb:109:in `block in take_by_value': no block given (yield)
||&lt;


ブロックを渡さない場合は
範囲を限定しない結果を返すべきです

**Version11
ブロックがあるか無いかを判定するメソッドとして
block_given?があります
それを使ってブロックがない場合
代わりのブロックをtake_by_valueに渡してあげます

&gt;|ruby|
 class Hash
   def top_by_value(nth, &amp;blk)
     blk = lambda { |v| v } unless block_given?
     take_by_value(nth, lambda { |v| -v }, &amp;blk)
   end
   
   def bottom_by_value(nth, &amp;blk)
     blk = lambda { |v| v } unless block_given?
     take_by_value(nth, lambda { |v| v }, &amp;blk)
   end
   
   private
   def take_by_value(nth, sort_opt)
     select { |key, val| yield val }.take_by(nth) { |key, val| sort_opt[val] }
   end
 end
||&lt;


上の例ではblock_given?の代わりに
引数blkを使ってもいいです
これで問題はなくなりました


と　こ　ろ　が！


また恐ろしいことが起こりました
Hashクラスを見てください

&gt;|ruby|
 class Hash
   def top_by_value(nth, &amp;blk)
     blk = lambda { |v| v } unless block_given?
     take_by_value(nth, lambda { |v| -v }, &amp;blk)
   end
   
   def bottom_by_value(nth,&amp;blk)
     blk = lambda { |v| v } unless block_given?
     take_by_value(nth, lambda { |v| v }, &amp;blk)
   end
   
   private
   def take_by_value(nth, sort_opt)
     select { |key, val| yield val }.take_by(nth) { |key, val| sort_opt[val] }
   end
 end
||&lt;


lambda {|v| v }が4回も！
Don't Repeat Yourself!
Yes, I repeat myself!!


達人...
大至急直しますから...

**Version12
lambda {|v| v }という手続きを返す
optというメソッドを定義しましょう

&gt;|ruby|
 class Hash
   def top_by_value(nth, &amp;blk)
     blk = opt unless blk
     take_by_value(nth, opt(false), &amp;blk)
   end
 
   def bottom_by_value(nth,&amp;blk)
     blk = opt unless blk    
     take_by_value(nth, opt, &amp;blk)
   end
 
   private
   def take_by_value(nth, sort_opt)
     select { |key, val| yield val }.take_by(nth) { |key, val| sort_opt[val] }
   end
 
   def opt(flag=true)
     lambda { |v| flag ? v : -v }
   end
 end
||&lt;


optメソッドのflag引数にデフォルトでtrueをセットしておきます
そうすればvalueがマイナスのときだけfalseを渡せばいいのです


果たしてこれでコードが読みやすくなったのか
わたしにはわかりません
これはちょっとやり過ぎかもしれませんが
達人に怒られないということが
ここでは重要なのです


と...
ここまでやってミスに気が付きました
Version11のところでblock_given?の判定を
top_by_valueとbottom_by_valueのところでしました
でもこれをtake_by_valueのところでやればいいんです
そうすれば上のような手間は不要です
Version12はこんなやり方もあるんだという
ご理解でお願いします...

**Version13
&gt;|ruby|
 class Hash
   def top_by_value(nth, &amp;blk)
     take_by_value(nth, lambda { |v| -v }, &amp;blk)
   end
   def bottom_by_value(nth,&amp;blk)
     take_by_value(nth, lambda { |v| v }, &amp;blk)
   end
   private
   def take_by_value(nth, sort_opt)
     select { |key, val| block_given? ? yield(val) : val }.take_by(nth) { |key, val| sort_opt[val] }
   end
 end
||&lt;


take_by_value内で条件演算子(条件 ? 真 : 偽)を使って
ブロックの有無でyieldするかしないか分けています


（[http://d.hatena.ne.jp/keyesberry/20090417:title=次回に続く])

</body>
</day>
<day date="2009-04-17" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その11)
さてもう改良点はないでしょうか
スクリプト全体をもう一度みてみましょう


&gt;|ruby|
 module Enumerable
   def take_by(nth)
     sort_by { |elem| yield elem }.take(nth)
   end
 end
 
 class Hash
   def top_by_value(nth, &amp;blk)
     take_by_value(nth, opt(false), &amp;blk)
   end
 
   def bottom_by_value(nth,&amp;blk)
     take_by_value(nth, opt, &amp;blk)
   end
 
   private
   def take_by_value(nth, sort_opt)
     select { |key, val| block_given? ? yield(val) : val }.take_by(nth) { |key, val| sort_opt[val] }
   end
 end
 
 WORDS = ARGF.read.downcase.scan(/[a-z]+/)
 DICTIONARY = WORDS.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
 p DICTIONARY.top_by_value(30)
||&lt;


3行目が思いの外すっきりしたので
1行目のメソッドチェーンが気になりだしました
ちょっと病的な感覚かもしれません
でも楽しいRubyの学習のために先に進みます

**Version14
「添付ファイルから単語を取って配列に入れる」
という操作は汎用性がありそうです
今度はこれをいじりましょう
ARGFに対するtake_wordsメソッドを定義します


ARGFは通常のオブジェクトと違い
属するクラスを持っていません
ですから上で示したハッシュや配列のように
その属するHashクラスやArrayクラスにメソッドを定義する
といったことができません


ではどうするか


こういう場合はそのオブジェクト専用の
名無しクラスにメソッドを定義します

&gt;|ruby|
 class &lt;&lt; ARGF
   def take_words(regexp)
     read.downcase.scan(regexp)
   end
 end
 
 WORDS = ARGF.take_words(/[a-z]+/)
 DICTIONARY = WORDS.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
 p DICTIONARY.top_by_value(30)
||&lt;


この場合クラスに名前を与えずに
オブジェクトを&lt;&lt;で接ぎ木します
この無名クラスはSingletonクラス
または特異クラスなどと呼ばれます


クラスを定義しない
別の書き方もあります
&gt;|ruby|
 def ARGF.take_words(regexp)
   read.downcase.scan(regexp)
 end
||&lt;
こう書いたときSingletonメソッド
または特異メソッドなどと呼ばれます


take_wordsには正規表現を渡せるようにしてます
先頭がx,y,zで始まる単語のみを対象に
最頻出ワード30をリストしてみましょう
&gt;|ruby|
 WORDS = ARGF.take_words(/[xyz][a-z]+/)
 DICTIONARY = WORDS.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
 p DICTIONARY.top_by_value(30)
 
 #&gt; [[&quot;you&quot;, 2071], [&quot;zabeth&quot;, 636], [&quot;your&quot;, 597], [&quot;ys&quot;, 556], [&quot;ying&quot;, 322], [&quot;years&quot;, 226], [&quot;yes&quot;, 214], [&quot;ything&quot;, 176], [&quot;ydia&quot;, 172], [&quot;yet&quot;, 163], [&quot;young&quot;, 144], [&quot;xt&quot;, 143], [&quot;ye&quot;, 137], [&quot;year&quot;, 124], [&quot;yself&quot;, 108], [&quot;zzy&quot;, 97], [&quot;yed&quot;, 82], [&quot;ybody&quot;, 77], [&quot;ylon&quot;, 75], [&quot;zed&quot;, 67], [&quot;ze&quot;, 64], [&quot;yourself&quot;, 60], [&quot;xpected&quot;, 58], [&quot;yton&quot;, 58], [&quot;yphon&quot;, 55], [&quot;xactly&quot;, 54], [&quot;yond&quot;, 54], [&quot;xed&quot;, 52], [&quot;yright&quot;, 48], [&quot;yone&quot;, 45]]
||&lt;


Singletonメソッドについては以下が参考になるかもしれません


[http://d.hatena.ne.jp/keyesberry/20080816/p1:title=Rubyのクラスはオブジェクトの母、モジュールはベビーシッター - hp12c]


[http://d.hatena.ne.jp/keyesberry/20081022/p1:title=メソッドが見つからないならRubyに作ってもらえばいいよ！　　　　- If method_missing, define_method by Ruby - - hp12c]


ここまで来るともう止まりません
はっきり言って2行目も気になります

&gt;|ruby|
 DICTIONARY = WORDS.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
||&lt;

**Version15
しかも頻出ワード辞書というのは汎用性がありそうです
make_freq_dicメソッドとしてArrayに定義しましょう
ええこれは明らかに行き過ぎです
Arrayに定義されるべきメソッドは
あらゆる種類の配列で使われうるメソッドのみを定義すべきです
でももうわたしにも止められないのです！

&gt;|ruby|
 class Array
   def make_freq_dic
     inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
   end
 end
 
 WORDS = ARGF.take_words(/[a-z]+/)
 DICTIONARY = WORDS.make_freq_dic
 p DICTIONARY.top_by_value(30)
||&lt;


すっきりです
ARGFから単語を取り出しWORDSで参照する
WORDSから頻出ワードを作ってDICTIONARYで参照する
DICTIONARYから頻出トップ30を取って出力する
１つのオブジェクトに１つのメソッド
さすがにもう気が済みました
わたしの暴走を許してくださりありがとうございます


([http://d.hatena.ne.jp/keyesberry/20090418/p1:title=次回に続く])

</body>
</day>
<day date="2009-04-18" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その12)
でも待ってください
そこまで汎用性がある汎用性があるって言うのなら...


クラスにでもしたらどうですか？
それならArrayクラスにも迷惑は掛かりませんし
なるほどいい考えかもしれません


ではテキストファイルを受け取ると
英単語頻度辞書を生成するWordDictionaryクラスを作りましょう
まず現在のスクリプト全体を掲載します
&gt;|ruby|
 module Enumerable
   def take_by(nth)
     sort_by { |elem| yield elem }.take(nth)
   end
 end
 
 class Hash
   def top_by_value(nth, &amp;blk)
     take_by_value(nth, lambda { |v| -v }, &amp;blk)
   end
 
   def bottom_by_value(nth,&amp;blk)
     take_by_value(nth, lambda { |v| v }, &amp;blk)
   end
 
   private
   def take_by_value(nth, sort_opt)
     select { |key, val| block_given? ? yield(val) : val }.take_by(nth) { |key, val| sort_opt[val] }
   end
 end
 
 class &lt;&lt; ARGF
   def take_words(regexp)
     read.downcase.scan(regexp)
   end
 end
 
 class Array
   def make_freq_dic
     inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
   end
 end
 
 WORDS = ARGF.take_words(/[a-z]+/)
 DICTIONARY = WORDS.make_freq_dic
 p DICTIONARY.top_by_value(30)
||&lt;

**Version16
これらのコードにおける各メソッドを
WordDictionaryクラスに実装します
このクラスはARGFオブジェクトを引数に取って
そこからワード辞書オブジェクトを生成します
Enumerableのtake_byはWordDictionary以外でも
使えそうなのでこのまま残します


上のスクリプトは次のように生まれ変わりました
&gt;|ruby|
 module Enumerable
   def take_by(nth)
     sort_by { |elem| yield elem }.take(nth)
   end
 end
 
 class WordDictionary
   include Enumerable
 
   def initialize(argf)
     @words = argf.read.downcase.scan(/[a-z]+/)
     @freq_dic = @words.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
   end
 
   def each
     @freq_dic.each { |elem| yield elem }
   end
 
   def top_by_frequency(nth, &amp;blk)
     take_by_value(nth, lambda { |v| -v }, &amp;blk)
   end
 
   def bottom_by_frequency(nth, &amp;blk)
     take_by_value(nth, lambda { |v| v }, &amp;blk)
   end
 
   private
   def take_by_value(nth, sort_opt)
     @freq_dic.select { |key, val| block_given? ? yield(val) : val }.take_by(nth) { |key, val| sort_opt[val] }
   end
 end
 
 wdic = WordDictionary.new(ARGF)
 p wdic.top_by_frequency(30)
 p wdic.bottom_by_frequency(30) { |val| val &gt; 100 }
||&lt;


ざっと眺めてみると先のコードが
大体そのまま移管されているのが分かると思います
top_by_valueとbottom_by_valueは
目的を分かりやすくするために名前をそれぞれ
top_by_frequencyとbottom_by_frequencyに変えました

 
変わったところを列挙してみます
-WordDictionaryクラス
-include Enumerable
-initializeメソッド
-eachメソッド

 
クラス定義はキーワードclassに続き
大文字で始まるクラス名を指定して行います
スクリプトが実行されたとき
このクラス定義からそのクラス名で参照可能な
クラスオブジェクトが生成されます


include EnumerableによってEnumerableモジュールに追加した
take_byメソッドが使えるようになります


initializeメソッドはWordDictionaryクラスを生成する
newメソッドが呼ばれたときに自動で実行されるメソッドです
通常ここにオブジェクトの初期化処理を書きます


WordDictionaryでは単語を切り出してその結果の配列を
@wordsというインスタンス変数で参照できるようにします
次いで頻出ワード辞書を作り出しその結果のハッシュを
@freq_dicインスタンス変数で参照できるようにしています


eachメソッドにはちょっとしたマジックがあります
Enumerableモジュールには繰り返し処理のための
便利なメソッドが多数存在しますが
eachメソッドをうまく定義すれば
WordDictionaryで生成されるオブジェクトでも
これらの便利なメソッドが使えるようになるのです
例をあとで示します


スクリプトの最後の3行で
このWordDictionaryクラスの使い方が分かると思います


ARGFを引数に取ったnewメソッドを
WordDictionaryクラスに送り
これによって単語辞書オブジェクトを生成します


「newメソッドなんて定義してないのに何故呼べるの？」
と考えた人は鋭いです
理由はこうです


すべてのクラスは何らかのクラスの継承クラスです
明示的に継承元クラスを指定する場合は
class WordDictionary &lt; Hash
のようにします
明示的な指定がない場合Rubyは
自動でObjectクラスをその継承元クラスとして指定します
ですからWordDictionaryクラスは
Objectクラスの被継承者です
そして被継承者は継承元のメソッドすべてを
自由に使えるのです


さて
eachメソッドのマジックを１つ見せます

&gt;|ruby|
 wdic = WordDictionary.new(ARGF)
 wdic.group_by { |word, freq| word.length }.select { |len, word| len &gt; 14 }.each { |len, word| print &quot;#{len} =&gt; #{word.transpose.first}\n&quot;}

 #&gt; 15 =&gt; [&quot;representations&quot;, &quot;merchantibility&quot;, &quot;accomplishments&quot;, &quot;acknowledgments&quot;, &quot;inconsistencies&quot;, &quot;conscientiously&quot;, &quot;superintendence&quot;, &quot;congratulations&quot;, &quot;thoughtlessness&quot;, &quot;recommendations&quot;, &quot;uncompanionable&quot;, &quot;disappointments&quot;, &quot;condescendingly&quot;, &quot;transformations&quot;, &quot;transfiguration&quot;, &quot;ecclesiasticism&quot;, &quot;notwithstanding&quot;, &quot;representatives&quot;, &quot;appropriateness&quot;, &quot;characteristics&quot;, &quot;contemporaneous&quot;, &quot;unrighteousness&quot;, &quot;remorselessness&quot;, &quot;comprehensively&quot;]
 16 =&gt; [&quot;unenforceability&quot;, &quot;superciliousness&quot;, &quot;incomprehensible&quot;, &quot;discontentedness&quot;, &quot;inextinguishable&quot;, &quot;internationalism&quot;]
 17 =&gt; [&quot;disinterestedness&quot;, &quot;misrepresentation&quot;, &quot;communicativeness&quot;, &quot;congregationalist&quot;, &quot;indestructibility&quot;]
||&lt;


Enumerableモジュールに定義されているgroup_byメソッドを
WordDictionaryクラスのオブジェクトで使った例です
ワード長が15以上のものをグループ別に表示させています
自作のクラスがこれでずっと高級になりました
Enumerableモジュールが持っているメソッドは以下で調べられます


[http://rbref.heroku.com/:title=Ruby 1.9.2 Methods List]


([http://d.hatena.ne.jp/keyesberry/20090419:title=次回に続く])

</body>
</day>
<day date="2009-04-19" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その13)
**Version17

次にVersion07で示したような
最長ワードトップ30を出力するメソッド
top_by_lengthも定義しましょう
&gt;|ruby|
 class WordDictionary
   def top_by_length(nth, &amp;blk)
     list = take_by_key(nth, lambda { |key| -key.length }, &amp;blk)
     list.map { |word, freq| [word, freq, word.length] }
   end
 
   private
   def take_by_value(nth, sort_opt)
     @freq_dic.select { |key, val| block_given? ? yield(val) : val }.take_by(nth) { |key, val| sort_opt[val] }
   end
 
   def take_by_key(nth, sort_opt)
     @freq_dic.select { |key, val| block_given? ? yield(val) : val }.take_by(nth) { |key, val| sort_opt[key] }
   end
 end

 wdic = WordDictionary.new(ARGF)
 p wdic.top_by_length(30) { |val| val &gt; 100 }
||&lt;


ここでは将来に備えて
take_by_valueと同じようにtake_by_keyを定義して
top_by_lengthはこれを使うようにします


top_by_lengthはその語と出現数に加えて
語長を返すようにしています
Arrayクラスのmapメソッドをここでは使っています
mapメソッドはinjectメソッド同様とても便利なメソッドです
配列の各要素の内容をブロックの処理結果で置き換えます
上の例は list.map { |item| item &lt;&lt; item[0].length }
でもいいです


出力はこんな感じです
&gt;|ruby|
#&gt; [[&quot;illustration&quot;, 160, 12], [&quot;therefore&quot;, 127, 9], [&quot;catherine&quot;, 126, 9], [&quot;jerusalem&quot;, 120, 9], [&quot;gutenberg&quot;, 285, 9], [&quot;elizabeth&quot;, 636, 9], [&quot;prophecy&quot;, 322, 8], [&quot;together&quot;, 105, 8], [&quot;anything&quot;, 117, 8], [&quot;pleasure&quot;, 103, 8], [&quot;judgment&quot;, 134, 8], [&quot;believe&quot;, 110, 7], [&quot;collins&quot;, 180, 7], [&quot;between&quot;, 114, 7], [&quot;wickham&quot;, 194, 7], [&quot;bingley&quot;, 306, 7], [&quot;replied&quot;, 136, 7], [&quot;history&quot;, 189, 7], [&quot;himself&quot;, 178, 7], [&quot;against&quot;, 164, 7], [&quot;because&quot;, 116, 7], [&quot;however&quot;, 179, 7], [&quot;through&quot;, 185, 7], [&quot;nothing&quot;, 235, 7], [&quot;sabbath&quot;, 215, 7], [&quot;herself&quot;, 312, 7], [&quot;another&quot;, 144, 7], [&quot;project&quot;, 262, 7], [&quot;without&quot;, 263, 7], [&quot;thought&quot;, 215, 7]]
||&lt;


**Version18
またも問題発生！
DRY違反です！

&gt;|ruby|
   def take_by_value(nth, sort_opt)
     @freq_dic.select { |key, val| block_given? ? yield(val) : val }.take_by(nth) { |key, val| sort_opt[val] }
   end
 
   def take_by_key(nth, sort_opt)
     @freq_dic.select { |key, val| block_given? ? yield(val) : val }.take_by(nth) { |key, val| sort_opt[key] }
   end
||&lt;


take_by_key_or_valメソッドを定義して
これを回避します
&gt;|ruby|
   def take_by_value(nth, sort_opt, &amp;blk)
     val = lambda { |key, val| val }
     take_by_key_or_val(nth, sort_opt, val, &amp;blk)
   end
 
   def take_by_key(nth, sort_opt, &amp;blk)
     key = lambda { |key, val| key }
     take_by_key_or_val(nth, sort_opt, key, &amp;blk)
   end
 
   def take_by_key_or_val(nth, sort_opt, by)
     @freq_dic.select { |key, val| block_given? ? yield(val) : val }.take_by(nth) { |key, val| sort_opt[by[key, val]] }
   end
||&lt;
ふぅ


**Version19
さて次は何ですか？
そうですね...


せっかくクラスを作ったのに
コマンド引数しか取れないっていうのは寂しいです
では次はWordDictionaryクラスが
ファイル名か文字列を直接受け取れるようにしましょう


そのためにinput_to_stringメソッドを定義し
initializeメソッドで入力を適切に変換するようにします
&gt;|ruby|
 class WordDictionary
   def initialize(input)
     input = input_to_string(input)
     @words = input.downcase.scan(/[a-z]+/)
     @freq_dic = @words.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
   end
   
   private
   def input_to_string(input)
    case input
    when String
      begin
        File.open(input, &quot;r&quot;) { |f| return f.read }
      rescue
        puts &quot;Argument has assumed as a text string&quot; 
        input
      end
    when ARGF.class
      input.read
    else
      raise &quot;Wrong argument. ARGF, file or string are acceptable.&quot;
    end
   end
 end

 wdic1 = WordDictionary.new(ARGF)
 wdic2 = WordDictionary.new('11.txt')
 wdic3 = WordDictionary.new(&lt;&lt;-EOS)
 It was all very well to say 'Drink me,' but the wise little Alice was not going to do THAT in a hurry. 'No, I'll look first,' she said, 'and see whether it's marked &quot;poison&quot; or not'; for she had read several nice little histories about children who had got burnt, and eaten up by wild beasts and other unpleasant things, all because they WOULD not remember
 the simple rules their friends had taught them: such as, that a red-hot poker will burn you if you hold it too long; and that if you cut your finger VERY deeply with a knife, it usually bleeds; and she had never forgotten that, if you drink much from a bottle marked 'poison,' it is almost certain to disagree with you, sooner or later.
EOS
 p wdic1.top_by_frequency(10)
 p wdic2.top_by_frequency(10)
 p wdic3.top_by_frequency(10)
 
 #&gt; [[&quot;the&quot;, 4507], [&quot;to&quot;, 4243], [&quot;of&quot;, 3728], [&quot;and&quot;, 3658], [&quot;her&quot;, 2225], [&quot;i&quot;, 2069], [&quot;a&quot;, 2012], [&quot;in&quot;, 1936], [&quot;was&quot;, 1848], [&quot;she&quot;, 1710]]
 [[&quot;the&quot;, 1818], [&quot;and&quot;, 940], [&quot;to&quot;, 809], [&quot;a&quot;, 690], [&quot;of&quot;, 631], [&quot;it&quot;, 610], [&quot;she&quot;, 553], [&quot;i&quot;, 545], [&quot;you&quot;, 481], [&quot;said&quot;, 462]]
 [[&quot;it&quot;, 5], [&quot;you&quot;, 5], [&quot;and&quot;, 5], [&quot;that&quot;, 4], [&quot;had&quot;, 4], [&quot;a&quot;, 4], [&quot;if&quot;, 3], [&quot;she&quot;, 3], [&quot;to&quot;, 3], [&quot;not&quot;, 3]]
||&lt;


input_to_stringにおいて
case式を使って入力の種類を切り分けました
when Stringでは最初ファイル名として処理できるか試み
できない場合は文字列として処理できるようにしました
うまくいっているようです


WordDictionary.new(&lt;&lt;-EOS)...は
ヒアドキュメントという記法を使っています
任意記号EOSで挟まれた行が
文字列として解釈されます


([http://d.hatena.ne.jp/keyesberry/20090420:title=次回に続く])

</body>
</day>
<day date="2009-04-20" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その14)
**Version20
ここまで来たらもう一歩


小説データは元々ネットにあるんですから
いちいちファイルにダウンロードしないで
直接ネットから取れたらうれしいです


open-uriライブラリというのを使うと
httpに簡単にアクセスできるようになります

&gt;|ruby|
  require &quot;open-uri&quot;
  class WordDictionary

	private
    def input_to_string(input)
     case input
     when /^http/
       begin
         open(input) { |f| return f.read }
       rescue Exception =&gt; e
         puts e
         exit
       end
     when String
       begin
         File.open(input, &quot;r&quot;) { |f| return f.read }
       rescue
         puts &quot;Argument has assumed as a text string&quot; 
         input
       end
     when ARGF.class
       input.read
     else
       raise &quot;Wrong argument. ARGF, file or string are acceptable.&quot;
     end
    end
  end
  wdic = WordDictionary.new('http://www.gutenberg.org/files/245/245.txt')
  p wdic.top_by_length(30)

#&gt; [[&quot;inconsequentialities&quot;, 1, 20], [&quot;straightforwardly&quot;, 1, 17], [&quot;unenforceability&quot;, 1, 16], [&quot;acquaintanceship&quot;, 3, 16], [&quot;reproachlessness&quot;, 1, 16], [&quot;misunderstanding&quot;, 1, 16], [&quot;stenographically&quot;, 1, 16], [&quot;preposterousness&quot;, 1, 16], [&quot;responsibilities&quot;, 1, 16], [&quot;incomprehensible&quot;, 1, 16], [&quot;charlottesville&quot;, 1, 15], [&quot;acknowledgments&quot;, 1, 15], [&quot;unrighteousness&quot;, 2, 15], [&quot;multitudinously&quot;, 1, 15], [&quot;unphilosophical&quot;, 1, 15], [&quot;impossibilities&quot;, 2, 15], [&quot;inconspicuously&quot;, 1, 15], [&quot;inconsequential&quot;, 2, 15], [&quot;conscientiously&quot;, 1, 15], [&quot;notwithstanding&quot;, 3, 15], [&quot;merchantibility&quot;, 1, 15], [&quot;architecturally&quot;, 2, 15], [&quot;daguerreotypist&quot;, 1, 15], [&quot;representations&quot;, 1, 15], [&quot;unhandkerchiefs&quot;, 1, 15], [&quot;correspondingly&quot;, 3, 15], [&quot;picturesqueness&quot;, 2, 15], [&quot;proportionately&quot;, 1, 15], [&quot;unconsciousness&quot;, 1, 15], [&quot;exemplification&quot;, 1, 15]]
||&lt;


open-uriライブラリをrequireして
input_to_stringに新しい分岐条件を加えます
ネットアクセスがうまくいかない場合は
エラーメッセージを表示してスクリプトの実行を終了します


これで一層便利になりました
**Version21
もう少し実用的なメソッドも追加しましょう


オブジェクトを読みやすいかたちで出力するto_sメソッドと
オブジェクトの部分オブジェクトを返すselectメソッドを定義します

&gt;|ruby|
 class WordDictionary
   def to_s
     @freq_dic.to_s
   end

   def select(regexp)
     text = @words.select { |key, val| key =~ regexp }.join(&quot; &quot;)
     WordDictionary.new(text)
   end
 end
||&lt;


次の例はselectメソッドにより
先頭がxyzの何れかで始まる語の集合からなる
新しいWordDictionaryオブジェクトを生成し
これをto_sメソッドで出力しています
&gt;|ruby|
 wdic = WordDictionary.new(ARGF)
 puts xyz_dic = wdic.select(/^[xyz]/)
 p xyz_dic.top_by_length(5)

#&gt; {&quot;you&quot;=&gt;2071, &quot;yes&quot;=&gt;90, &quot;zealand&quot;=&gt;1, &quot;your&quot;=&gt;597, &quot;yourself&quot;=&gt;60, &quot;yesterday&quot;=&gt;18, &quot;yet&quot;=&gt;163, &quot;young&quot;=&gt;144, &quot;yer&quot;=&gt;4, &quot;ye&quot;=&gt;90, &quot;yelp&quot;=&gt;1, &quot;youth&quot;=&gt;17, &quot;yawned&quot;=&gt;3, &quot;zigzag&quot;=&gt;1, &quot;yours&quot;=&gt;26, &quot;yards&quot;=&gt;2, &quot;year&quot;=&gt;124, &quot;yawning&quot;=&gt;3, &quot;x&quot;=&gt;2, &quot;yelled&quot;=&gt;1, &quot;xi&quot;=&gt;1, &quot;xii&quot;=&gt;3, &quot;yard&quot;=&gt;1, &quot;years&quot;=&gt;226, &quot;zip&quot;=&gt;3, &quot;youngest&quot;=&gt;15, &quot;younger&quot;=&gt;30, &quot;yielding&quot;=&gt;4, &quot;yield&quot;=&gt;8, &quot;yawn&quot;=&gt;2, &quot;york&quot;=&gt;13, &quot;yourselves&quot;=&gt;5, &quot;younge&quot;=&gt;4, &quot;youths&quot;=&gt;1, &quot;yielded&quot;=&gt;5, &quot;yale&quot;=&gt;4, &quot;zeph&quot;=&gt;3, &quot;zephaniah&quot;=&gt;1, &quot;zech&quot;=&gt;2, &quot;zion&quot;=&gt;4, &quot;zealots&quot;=&gt;3, &quot;zinzendorf&quot;=&gt;6, &quot;xxxiii&quot;=&gt;1, &quot;xxv&quot;=&gt;3, &quot;xxvi&quot;=&gt;1, &quot;y&quot;=&gt;8, &quot;zama&quot;=&gt;1, &quot;zealous&quot;=&gt;2, &quot;xiii&quot;=&gt;8, &quot;yea&quot;=&gt;6, &quot;zinzendorfs&quot;=&gt;1, &quot;xenophon&quot;=&gt;3, &quot;youthful&quot;=&gt;1, &quot;yearly&quot;=&gt;2, &quot;xxix&quot;=&gt;1, &quot;xh&quot;=&gt;1, &quot;zoroaster&quot;=&gt;2, &quot;xciii&quot;=&gt;1, &quot;zeal&quot;=&gt;2, &quot;zambezi&quot;=&gt;1, &quot;xerxes&quot;=&gt;11, &quot;xv&quot;=&gt;1, &quot;yellow&quot;=&gt;1, &quot;xxiii&quot;=&gt;1}
[[&quot;zinzendorfs&quot;, 1, 11], [&quot;zinzendorf&quot;, 6, 10], [&quot;yourselves&quot;, 5, 10], [&quot;zoroaster&quot;, 2, 9], [&quot;zephaniah&quot;, 1, 9]]
||&lt;


さてずいぶんと長い道のりを来ました
スクリプトは一時僅か3行にまで短くできたのに
現在80行を超えるまでに肥大化しました
ワードエコではありません


ここで最初のコードと3行のコードと
現在のコードとを見比べてみましょうか


Version01
&gt;|ruby|
 dic = Hash.new(0)
 while line = ARGF.gets
   line.downcase!
   while line.sub!(/[a-z]+/, &quot;&quot;)
     word = $&amp;
     dic[word] += 1
   end
 end
 p dic.sort { |a, b| b[1] &lt;=&gt; a[1] }[0...30]
||&lt;

Version03
&gt;|ruby|
 WORDS = ARGF.read.downcase.scan(/[a-z]+/)
 DICTIONARY = WORDS.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
 p DICTIONARY.sort { |a, b| b[1] &lt;=&gt; a[1] }[0...30]
||&lt;

Version21
&gt;|ruby|
 require 'open-uri'
 module Enumerable
   def take_by(nth)
     sort_by { |elem| yield elem }.take(nth)
   end
 end
 
 class WordDictionary
   include Enumerable
 
   def initialize(input)
     input = input_to_string(input)
     @words = input.downcase.scan(/[a-z]+/)
     @freq_dic = @words.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
   end
 
   def each
     @freq_dic.each { |elem| yield elem }
   end
 
   def top_by_frequency(nth, &amp;blk)
     take_by_value(nth, lambda { |v| -v }, &amp;blk)
   end
 
   def bottom_by_frequency(nth, &amp;blk)
     take_by_value(nth, lambda { |v| v }, &amp;blk)
   end
 
   def top_by_length(nth, &amp;blk)
     list = take_by_key(nth, lambda { |key| -key.length }, &amp;blk)
     list.map { |word, freq| [word, freq, word.length] }
   end
 
   def to_s
     @freq_dic.to_s
   end
 
   def select(regexp)
     text = @words.select { |key, val| key =~ regexp }.join(&quot; &quot;)
     WordDictionary.new(text)
   end
 
   private
  def input_to_string(input)
   case input
   when /^http/
     begin
       open(input) { |f| return f.read }
     rescue Exception =&gt; e
       puts e
       exit
     end
   when String
     begin
       File.open(input, &quot;r&quot;) { |f| return f.read }
     rescue
       puts &quot;Argument has assumed as a text string.&quot; 
       input
     end
   when ARGF.class
     input.read
   else
     raise &quot;Wrong argument. ARGF, file or string are acceptable.&quot;
   end
  end
 
   def take_by_value(nth, sort_opt, &amp;blk)
     val = lambda { |key, val| val }
     take_by_key_or_val(nth, sort_opt, val, &amp;blk)
   end
 
   def take_by_key(nth, sort_opt, &amp;blk)
     key = lambda { |key, val| key }
     take_by_key_or_val(nth, sort_opt, key, &amp;blk)
   end
 
   def take_by_key_or_val(nth, sort_opt, by)
     @freq_dic.select { |key, val| block_given? ? yield(val) : val }.take_by(nth) { |key, val| sort_opt[by[key, val]] }
   end
 end

 wdic = WordDictionary.new(ARGF)
 p wdic.top_by_frequency(20)
||&lt;


確かにスクリプトは肥大化しています
果たして今までの労力は無駄だったんでしょうか
ワードエコでなくなった分
よくなったことがあるんでしょうか


はいあります
それは単語辞書が
単なる制御構造からオブジェクトになったことです


オブジェクトになった利点の１つは
コードがポータブルになるということです
つまりそれが持つデータを維持しながら
他のオブジェクトに送って相互作用させたり
データベースに保存したりできます
同時に内容の異なる複数の辞書オブジェクトを生成し
これらを相互に連携して結果を得る(内容の比較とか)
といったこともできるようになります
これらはネットワーク越しであってもかまいません


他の利点は機能の追加が容易になる点です
クラスにメソッドを追加することで
単語辞書を対象にした新たな機能が容易に追加できます
既にいくつかの機能追加を見てきました


最初のヴァージョンのスクリプトに
機能を追加することを想像頂ければ
この利点は明らかでしょう
このようにオブジェクトは
機能追加のフレームワークになっているのです


今までの苦労も
未来に対する投資というかたちで報われそうです
そろそろ幕を閉じるときが来たようです


([http://d.hatena.ne.jp/keyesberry/20090421:title=次回に続く])

</body>
</day>
<day date="2009-04-21" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その15)
っと
その前に...
アウトプットのしょぼさに
今さらながら気が付いてしまいました

&gt;|ruby|
 wdic = WordDictionary.new(ARGF)
 p wdic.top_by_frequency(20)

#&gt; [[&quot;the&quot;, 16077], [&quot;of&quot;, 9823], [&quot;and&quot;, 7482], [&quot;to&quot;, 7098], [&quot;in&quot;, 4456], [&quot;a&quot;, 3841], [&quot;that&quot;, 3161], [&quot;was&quot;, 3040], [&quot;it&quot;, 2919], [&quot;i&quot;, 2881], [&quot;her&quot;, 2550], [&quot;she&quot;, 2313], [&quot;as&quot;, 2134], [&quot;you&quot;, 2071], [&quot;not&quot;, 2057], [&quot;be&quot;, 2044], [&quot;is&quot;, 2033], [&quot;his&quot;, 2009], [&quot;he&quot;, 1940], [&quot;for&quot;, 1927]]
||&lt;

**Version22
これが上司に対する
報告か何かの類いのものならまず却下です
これをもう少しマシなものにしましょう

&gt;|ruby|
 wdic = WordDictionary.new(ARGF)
 wdic.top_by_frequency(20).each { |word, freq| puts &quot;#{freq}:#{word}&quot; }
#&gt;
 16077:the
 9823:of
 7482:and
 7098:to
 4456:in
 3841:a
 3161:that
 3040:was
 2919:it
 2881:i
 2550:her
 2313:she
 2134:as
 2071:you
 2057:not
 2044:be
 2033:is
 2009:his
 1940:he
 1927:for
||&lt;


これだけでも大分よくなりました
しかし上司はもっと視覚的にアピールするもの
を好むでしょうね
**Version23
単語の出現数を*の数で視覚化する
pretty_printメソッドを定義しましょう
&gt;|ruby|
 def pretty_print(data)
   max_stars = 60
   max_value = data.max_by { |key, val| val }.slice(1)
   data.each do |word, freq|
     stars = &quot;*&quot; * (max_stars * (freq/max_value.to_f)).ceil
     printf &quot;%5d:%-5s %s\n&quot;, freq, word, stars
   end
 end
 
 wdic = WordDictionary.new(ARGF)
 pretty_print wdic.top_by_frequency(20)
||&lt;


出力は次のようになります
&gt;|ruby|
16077:the   ************************************************************
 9823:of    *************************************
 7482:and   ****************************
 7098:to    ***************************
 4456:in    *****************
 3841:a     ***************
 3161:that  ************
 3040:was   ************
 2919:it    ***********
 2881:i     ***********
 2550:her   **********
 2313:she   *********
 2134:as    ********
 2071:you   ********
 2057:not   ********
 2044:be    ********
 2033:is    ********
 2009:his   ********
 1940:he    ********
 1927:for   ********
||&lt;
いい感じですね


prinftを使って出力をフォーマットしています
フォーマットについては
公式マニュアルの以下の頁が参考になります


[http://doc.okkez.net/191/view/method/Kernel/m/sprintf:title=module function Kernel.#format]


「おいおい未だにCUIかよ！」
いつか言われると思いました
**GUI Version
だから先回りして
GUIヴァージョンを用意しておきました
[f:id:keyesberry:20090421090356p:image]


ShoesというRubyのGUIフレームワークで書いています
もちろんWordDictionaryクラスで生成したオブジェクトを使い
Shoesではその描画だけをしています


実装は褒められたものじゃありませんが
これも合せて公開しておきます
実行にはShoesのインストールが必要です


[http://gist.github.com/93900:title=gist: 93900 - GitHub]

[http://shoooes.net/:title=Shoes &amp;#8226; Colorful programs for Mac OS X, Linux and Windows]


([http://d.hatena.ne.jp/keyesberry/20090422:title=次回に続く])

</body>
</day>
<day date="2009-04-22" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その16)
さてGUIで出力も魅力的なものになりました
もうやり残すことはなさそうです
当初単なる制御構造であったスクリプトが
WordDictionaryという立派なクラスになりました
これで将来このクラスを拡張したり
このクラスをベースにしたアプリケーションを作れます


で
将来っていつ？
...


そうです
DogYearのこの時代に
いつ来るか分からない将来を待っている
ゆとりなんて私たちにはないのです！
自分たちから未来に向かって進むのです！
何らかの形ある結果を残すのです！！
...


ということで...
なんか息巻いている人がいるので
もう少し進みましょう
**Version24
まずはもう少し機能拡張しましょう
WordDictionaryクラスから生成した
複数の単語辞書オブジェクトを
相互作用させるような機能があったら楽しそうです


まずは2つのオブジェクトを結合する
 +メソッドを定義しましょう
&gt;|ruby|
 class WordDictionary
   attr_reader :words

   def +(other)
     result = (@words + other.words).join(&quot; &quot;)
     WordDictionary.new(result)
   end
   protected :words
 end
||&lt;


 +メソッドは他の単語辞書オブジェクトを引数に取って
自身と引数の単語を結合した単語辞書オブジェクトを返します
つまりAオブジェクトにrubyという単語が32個あり
Bオブジェクトに18個あった場合
これらを結合したCオブジェクトには
rubyは50個あることになります


attr_reader :wordsは
 +メソッドの実装において他のオブジェクトの
@wordsインスタンス変数にアクセスできるようにします
protected :wordsにおいてその可視性を
同系のオブジェクトからのアクセスに限定します


 +メソッドのresultには2つの単語オブジェクトの単語を
スペースで結合してなる文字列が入り
その文字列でWordDictionaryクラスの
オブジェクトを作って返り値とします
@wordsは配列を指していますから
実装においては配列の+メソッドが使えます


これによって通常の算術演算のような記法で
2つの単語辞書オブジェクトを結合できるようになりました
&gt;|ruby|
 alice = WordDictionary.new('public/alice.txt')
 romeo_juliet = WordDictionary.new('public/romeo_juliet.txt')
 p alice.top_by_length(10) { |val| val &gt; 10 }
 p romeo_juliet.top_by_length(10) { |val| val &gt; 10 }
 p (alice + romeo_juliet).top_by_length(10) { |val| val &gt; 10 }

 #&gt; [[&quot;caterpillar&quot;, 28, 11], [&quot;everything&quot;, 14, 10], [&quot;adventures&quot;, 12, 10], [&quot;foundation&quot;, 25, 10], [&quot;electronic&quot;, 27, 10], [&quot;paragraph&quot;, 11, 9], [&quot;anxiously&quot;, 14, 9], [&quot;beautiful&quot;, 13, 9], [&quot;agreement&quot;, 18, 9], [&quot;trademark&quot;, 11, 9]]
 [[&quot;distributed&quot;, 18, 11], [&quot;shakespeare&quot;, 17, 11], [&quot;electronic&quot;, 19, 10], [&quot;therefore&quot;, 23, 9], [&quot;gentleman&quot;, 14, 9], [&quot;gutenberg&quot;, 24, 9], [&quot;gentlemen&quot;, 11, 9], [&quot;copyright&quot;, 16, 9], [&quot;benvolio&quot;, 17, 8], [&quot;daughter&quot;, 17, 8]]
Argument has assumed as a text string
 [[&quot;distribution&quot;, 16, 12], [&quot;shakespeare&quot;, 18, 11], [&quot;caterpillar&quot;, 28, 11], [&quot;opportunity&quot;, 11, 11], [&quot;information&quot;, 13, 11], [&quot;distributed&quot;, 22, 11], [&quot;everything&quot;, 15, 10], [&quot;adventures&quot;, 12, 10], [&quot;foundation&quot;, 25, 10], [&quot;permission&quot;, 16, 10]]
||&lt;

**Version25
じゃあ次に-メソッドを定義しましょう
ついでに&amp;メソッドと|メソッドも定義しましょう
 -メソッドは2つのオブジェクトの差分を
&amp;メソッドと|メソッドはそれぞれそれらの積と和を出力します
なお先のrubyの例を-メソッドに適用した場合
Cオブジェクトのrubyの個数は14でなく0になります
&gt;|ruby|
 class WordDictionary
   attr_reader :words

   def +(other)
     result = (@words + other.words).join(&quot; &quot;)
     WordDictionary.new(result)
   end
   protected :words

   def -(other)
     result = (@words - other.words).join(&quot; &quot;)
     WordDictionary.new(result)
   end
 
   def &amp;(other)
     result = (@words &amp; other.words).join(&quot; &quot;)
     WordDictionary.new(result)
   end
 
   def |(other)
     result = (@words | other.words).join(&quot; &quot;)
     WordDictionary.new(result)
   end
 end
||&lt;


さて次にやるべきことは分かってますね？
そう
Don't Repeat Yourself!です

**Version26
上の4つの演算はその中の演算子が異なるだけです
先の例のようにこれをブロックやオブジェクト化して渡す
方法がありますがここではもっとスマートに
シンボルを使って渡してみましょう
&gt;|ruby|
 class WordDictionary
   attr_reader :words

   def +(other)
     arithmetics(:+, other)
   end
 
   def -(other)
     arithmetics(:-, other)
   end
 
   def &amp;(other)
     arithmetics(:&amp;, other)
   end
 
   def |(other)
     arithmetics(:|, other)
   end
 
   private
   def arithmetics(op, other)
     result = (@words.send op, other.words).join(&quot; &quot;)
     WordDictionary.new(result)
   end
 end
||&lt;


arithmeticsメソッド内で
sendメソッドを使っている点がポイントです
sendメソッドは
シンボルで表現されたメソッドを実行できるようにします
これでコードがすっきりしました


([http://d.hatena.ne.jp/keyesberry/20090423/p1:title=次回に続く])

</body>
</day>
<day date="2009-04-23" title="">
<body>
*p1*Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(最終回)
さてこれらの演算子を使って
何かしたいですね...


いいのを思いつきました


ある小説を元にしたオブジェクトから
基本単語からなるオブジェクトを差し引けば
その小説にユニークな単語が抽出できるかもしれません
**Version27
&gt;|ruby|
 class WordDictionary
   def select(regexp)
     text = @freq_dic.select { |word, freq| word =~ regexp }.select { |word, freq| block_given? ? yield(freq) : freq }.map { |word, freq| &quot;#{word} &quot; * freq }.join(&quot; &quot;)
     WordDictionary.new(text, true)
   end

   def uniq_words(n, *base)
     base.inject(self) { |_self, b| _self - b.select(/./) { |freq| freq &gt;= 10 }  }.top_by_frequency(n)
   end
 end
||&lt;


uniq_wordsは個数nと複数の基本単語オブジェクトbaseを取って
そのオブジェクトに固有のワードトップnを出力します
injectメソッドのブロックの中で
先ほど定義した-メソッドを使っています


ここでselectメソッドを使ってbaseオブジェクトにおける
対象単語をその頻度が10以上のものに限定することで
baseオブジェクトにおけるゴミ(基本単語でないもの)を
ある程度排除するようにしています
そのためselectメソッドをブロックを取れるように修正しました


さて早速「不思議の国のアリス」の
ユニークなワードを出力してみましょう
&gt;|ruby|
 if $0 == __FILE__
  base = WordDictionary.new('public/base.txt')
  alice = WordDictionary.new('public/alice.txt')
  p alice.uniq_words(40, base)
 end 

 &gt;# Argument has assumed as a text string
 Argument has assumed as a text string
 [[&quot;alice&quot;, 403], [&quot;turtle&quot;, 59], [&quot;mock&quot;, 56], [&quot;hatter&quot;, 56], [&quot;gryphon&quot;, 55], [&quot;rabbit&quot;, 51], [&quot;got&quot;, 45], [&quot;mouse&quot;, 44], [&quot;duchess&quot;, 42], [&quot;tone&quot;, 40], [&quot;dormouse&quot;, 40], [&quot;cat&quot;, 37], [&quot;hare&quot;, 31], [&quot;caterpillar&quot;, 28], [&quot;jury&quot;, 22], [&quot;sort&quot;, 20], [&quot;tea&quot;, 19], [&quot;soup&quot;, 18], [&quot;bill&quot;, 17], [&quot;hastily&quot;, 16], [&quot;bit&quot;, 16], [&quot;doesn&quot;, 16], [&quot;didn&quot;, 14], [&quot;dinah&quot;, 14], [&quot;anxiously&quot;, 14], [&quot;baby&quot;, 14], [&quot;footman&quot;, 14], [&quot;trying&quot;, 14], [&quot;cook&quot;, 13], [&quot;wouldn&quot;, 13]]
||&lt;


なんかいい感じじゃないですか！


なお最後のif $0 == __FILE__ はこのスクリプトを
他のスクリプトからrequireしたときにはこの部分が
require先で実行されないようにするための技法です
$0はrubyインタプリタに渡したスクリプト名
__FILE__はこのスクリプト名を参照します

**Version28
でも
さっきからうっとうしい文字が
一緒に出力されていますね
オブジェクトを内部で再構築するとき
文字列を渡すのでそれが原因です
フラグを立ててこれに対処します


WordDictionaryクラス内部でオブジェクトを生成するときは
inner_callにtrueを渡して
&quot;Argument has...&quot;のメッセージがでないようにします


ついでに最後の仕上げとして
クラスは入力データの名前nameを受け取れるようにし
また総単語種数を出力するsizeメソッドも定義しましょう
&gt;|ruby|
 class WordDictionary
   att_reader :words, :name
   def initialize(input, name=&quot;none&quot;, inner_call=false)
     input = input_to_string(input, inner_call)
     @name = name
   end

   def select(regexp)
     text = @freq_dic.select { |word, freq| word =~ regexp }.select { |word, freq| block_given? ? yield(freq) : freq }.map { |word, freq| &quot;#{word} &quot; * freq }.join(&quot; &quot;)
     WordDictionary.new(text, @name, true)
   end
   
   def size
     @freq_dic.length
   end

   private
   def input_to_string(input, inner_call)
    case input
    when String
      begin
        File.open(input, &quot;r&quot;) { |f| return f.read }
      rescue
        puts &quot;Argument has assumed as a text string&quot; unless inner_call
        input
      end
    end
   end

   def arithmetics(op, other)
     result = (@words.send op, other.words).join(&quot; &quot;)
     WordDictionary.new(result, '', true)
   end
 end
||&lt;


さあこれで完成です！
完成したスクリプト全体を眺めてみましょう
&gt;|ruby|
 require &quot;open-uri&quot;
  module Enumerable
    def take_by(nth)
      sort_by { |elem| yield elem }.slice(0...nth)
    end
  end
  
  class WordDictionary
    include Enumerable
    attr_reader :name, :words
 
    def initialize(input, name= 'none', inner_call=false)
      input = input_to_string(input, inner_call)
      @words = input.downcase.scan(/[a-z']+/)
      @freq_dic = @words.inject(Hash.new(0)) { |dic, word| dic[word] += 1 ; dic }
      @name = name
    end
  
    def each
      @freq_dic.each { |elem| yield elem }
    end
  
    def top_by_frequency(nth, &amp;blk)
      take_by_value(nth, lambda { |v| -v }, &amp;blk)
    end
  
    def bottom_by_frequency(nth, &amp;blk)
      take_by_value(nth, lambda { |v| v }, &amp;blk)
    end
  
    def top_by_length(nth, &amp;blk)
      list = take_by_key(nth, lambda { |word| -word.length }, &amp;blk)
      list.map { |word, freq| [word, freq, word.length] }
    end
  
    def select(regexp)
      text = @freq_dic.select { |word, freq| word =~ regexp }.select { |word, freq| block_given? ? yield(freq) : freq }.map { |word, freq| &quot;#{word} &quot; * freq }.join(&quot; &quot;)
      WordDictionary.new(text, @name, true)
    end
 
    def to_s
      @freq_dic.to_s
    end
    
    def size
      @freq_dic.length
    end
    
    def +(other)
      arithmetics(:+, other)
    end
    
    def -(other)
      arithmetics(:-, other)
    end
    
    def &amp;(other)
      arithmetics(:&amp;, other)
    end
    
    def |(other)
      arithmetics(:|, other)
    end
    
    def uniq_words(nth, *base)
      base.inject(self) { |_self, b| _self - b.select(/./) { |freq| freq &gt;= 10 }  }.top_by_frequency(nth)
    end
	
    protected :words 
    private
    def input_to_string(input, inner_call)
     case input
     when /^http/
       begin
         open(input) { |f| return f.read }
       rescue Exception =&gt; e
         puts e
         exit
       end
     when String
       begin
         File.open(input, &quot;r&quot;) { |f| return f.read }
       rescue
         STDERR.puts &quot;Argument has assumed as a text string&quot; unless inner_call
         input
       end
     when ARGF.class
       input.read
     else
       raise &quot;Wrong argument. ARGF, file or string are acceptable.&quot;
     end
    end
   
    def take_by_value(nth, sort_opt, &amp;blk)
      val = lambda { |key, val| val }
      take_by_key_or_val(nth, sort_opt, val, &amp;blk)
    end
  
    def take_by_key(nth, sort_opt, &amp;blk)
      key = lambda { |key, val| key }
      take_by_key_or_val(nth, sort_opt, key, &amp;blk)
    end
  
    def take_by_key_or_val(nth, sort_opt, by)
      @freq_dic.select { |key, val| block_given? ? yield(val) : val }.take_by(nth) { |key, val| sort_opt[by[key, val]] }
    end
    
    def arithmetics(op, other)
      result = (@words.send op, other.words).join(&quot; &quot;)
      WordDictionary.new(result, '', true)
    end
  end
  
  def pretty_print(data)
    max_stars = 60
    max_value = data.max_by { |word, freq| freq }.slice(1)
    data.each do |word, freq|
      stars = &quot;*&quot; * (max_stars * (freq/max_value.to_f)).ceil
      printf &quot;%5d:%-5s %s\n&quot;, freq, word, stars
    end
  end
 
 if $0 == __FILE__
  base = WordDictionary.new('public/base.txt')
  alice = WordDictionary.new('public/alice.txt', &quot;Alice's Adventures in Wonderland&quot;)
  jp_history = WordDictionary.new('public/japanese_history.txt')
  p alice.uniq_words(40, base)
  p jp_history.uniq_words(40, base)
 end
||&lt;


英文小説の最頻出ワードを見つける旅はこれで終わりです
長い道のりでした
でもわたしは楽しめました
そして大変勉強になりました


そう
このチュートリアルは皆様のためにではなく
実は私自身のために書かれたものなのです
Rubyのエキスパートが余裕を持って書いたものではなく
プログラム新人が学び試行錯誤しながら
その知力の限界を引き出して書いたものなのです((そんなことは百も承知ですね))


でも一方で
このチュートリアルを役に立ったと言ってくれる人が
いつか現れると信じてもいるのです
それがRubyを学びその成果をブログで公開する
わたしのエンジンになっているのです((もういくつか星を頂きました。ありがとうございます))


最後にこのWordDictionaryクラスを使った
Webアプリケーションを構築してみました
これが今回のチュートリアルの一応の成果です
よろしければアクセスしてみてください


[http://words-in-books.heroku.com/:title=WORDS in Books]
[f:id:keyesberry:20090423065907p:image]


機能は次の3つだけです
-いくつかの英文小説の特徴、つまりタイトル、総単語種数(Total Words in Kind)、最頻出ワードtop30(Most Used Words)、最ワード長top10(Longest Words)、特徴ワード20(Characteristic Words)を表示します
-小説タイトルをクリックするとその文章の頁に遷移します
-右端の入力欄に英文または英文の置かれたURLを入れることで、その文章の特徴を抽出して表示します


サイトの構築には
[http://www.sinatrarb.com/:title=Sinatra]というWebフレームワークと
[http://heroku.com/:title=heroku]というサービスを使いました


すべてのスクリプトは以下に公開しています
[http://gist.github.com/93900:title=gist: 93900 - GitHub]

</body>
</day>
<day date="2009-04-25" title="">
<body>
*p1*Ruby+Shoesでスキャニメーションを作ろう！
本屋にいったら「[asin:4499282292:title]」という
絵本がありました
表紙に窓があって中に馬の絵が描かれています
ページを開いていくとその馬が突然走り出しました
よく見るとページの開閉に連動して
スリット入りのマスクが絵に対して動いて
動画を形成していることがわかりました
暫し見入ってページを開いたり閉じたりしました


家に帰ってネットを調べてみると
これがスキャニメーションという技術であることがわかりました
少し検索を掛けると動いて見える仕組みは直ぐにわかりました
紙に図形の位置をずらした4枚の絵とマスクを作って
自分でもやってみました
単純な絵でしたがなんとなく動いてるように見えました


RubyのGUIフレームワークであるShoesに
描画をマスクする機能があるのを思い出しました
これで図とマスクを作るスクリプトと
それを再生するスクリプトを書いてみたら
果たしてうまくいきました


欲が出て
この結果をネットに公開したいと思いました
ネットで馬の連続写真を探して
Gimpでその輪郭を取って
Shoesのスクリプトで図とマスクを作り
これをキャプチャしてWebページを作ったら
果たしてうまくいきました


これを公開しましたので遊んでみてください
ブラウザのウィンドウをリサイズするか
グリッドを移動すれば馬が走り出します


[http://scananimation.heroku.com/:title=ScanAnimation]


[f:id:keyesberry:20090425152212p:image]


雑になぞったので馬はあまりキレイではありません
スクリプトおよび作り方は次回書きます


(参考)
[http://gokan-note.jugem.jp/?eid=750:title=絵本ナビでお買い物♪しかけえほん「ギャロップ!!」 | 五感ノート♪]
[http://blog.goo.ne.jp/5522eyes/e/e5ef5edfeca340b38fbf4489486c9bc7:title=昔の子供用絵本　ギャロップ - ５５２２の眼]
[http://labaq.com/archives/51062608.html:title=らばQ:このアイデアに脱帽、動き出す紙の本『Gallop!』]


[asin:4499282292:detail]
</body>
</day>
<day date="2009-04-27" title="">
<body>
*p1*Ruby+Shoesでスキャニメーションを作ろう！（その2)
&gt;&gt;
（追記：2010/7/10）
Rubyだけで画像を生成する方法を用意しました
[http://d.hatena.ne.jp/keyesberry/20100710/p1:title=Rubyでスキャニメーションを作ろう！ - hp12c] 
&lt;&lt;


「[asin:4499282292:title]」に触発されて
ScanAnimationというサイトを作りました
サイトでは馬が走る絵とカンガルーが跳ねる写真と
文字が動いて見えるページを用意しています


[http://scananimation.heroku.com/:title=ScanAnimation]


見ての通りこれは
複数枚の画像を重ねてできる一枚の合成画像に対して
マスク画像を動かすことで動画を構成しています
この合成画像とマスク画像を作れれば
誰でも先のようなサイトを作ることができます
ここではこれらの画像の作り方を説明します


なお作成にはRubyおよびShoesのインストールが必要です
インストールは各サイトから行えます
ターミナルあるいはコンソールで
Ruby -vおよびShoes -vとすれば
インストールの有無が確認できます


[http://www.ruby-lang.org/ja/:title=オブジェクト指向スクリプト言語 Ruby]


[http://shoooes.net/:title=Shoes &amp;#8226; Colorful programs for Mac OS X, Linux and Windows]


**合成画像の作り方
+連続画像を用意し、0から始まる連番付きのファイル名とします(ex. horse0.png, horse1.png, horse2.png..)
+[http://gist.github.com/1981:title=gist: 1981 - GitHub]から拙作scan_animaker.rb,scan_animator.rb,animator.rbを入手します。他のファイルは無視してください
+各スクリプトのNUM_IMGSに画像数をセットします。MASK_WIDTHで合成画像の粗さを変えることもできます
+Shoesでanimator.rbを起動してダイアログで先頭画像(0番)を選び、画像がうまく動画になるか確認します。スクリプトのanimateの数字を変えることで再生速度を調整できます
+確認できたら次にShoesでscan_animaker.rbを開き、ダイアログで先頭画像を選ぶと合成画像とマスクが生成されます
+これらを個別にキャプチャして保存します(ex. horse.png, mask_horse.png)。MacではCommand+Shift+4でキャプチャできます
+Shoesでscan_animator.rbを開き、ダイアログで合成画像(ex. horse.png)を選んで動きを確認します。スクリプトのanimateの数字を変えることで再生速度を調整できます
+画像処理ソフトでマスク画像の白色部分を透過させます。GIMPでは「色-&gt;色を透明度に」でできます


以上で終わりです


これらのソフトおよびスクリプトは無償・無保証です
</body>
<comments>
<comment>
<username>ガラム</username>
<body>素晴らしいです。私も前々からスキャニメーションを作りたいのですが、理解が乏しく未だ実現ならずです…。トライしてみます！</body>
<timestamp>1264954578</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt; ガラムさん&lt;br&gt;コメントどうもです。ちょっとツールが使い辛くて申し訳ありませんが、トライしてみてください！</body>
<timestamp>1264992815</timestamp>
</comment>
<comment>
<username>ガラム</username>
<body>ものすごく初歩的な質問してもよろしいでしょうか…！？&lt;br&gt;連続画像は描画ソフトなどで作成するのですか？？すみません。</body>
<timestamp>1265020298</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt; ガラムさん&lt;br&gt;僕は連続画像を書く技量がないので、ネットから拝借しそれをGIMPという画像処理ソフトで加工しました。それからデジカメで取った写真をベースにしました。</body>
<timestamp>1265075568</timestamp>
</comment>
<comment>
<username>ガラム</username>
<body>度々すみませんでした。参考になります。</body>
<timestamp>1265104782</timestamp>
</comment>
</comments>
</day>
<day date="2009-04-30" title="">
<body>
*p1*Ruby.Sinatra.Git.Heroku  #=&gt; &quot;Happy Web Development!&quot;
**Ruby
10年前にRubyといえば7月の誕生石のことか
5.5ポイント活字のことでした
でも今はGoogleを30頁めくっても
妻に誕生石をプレゼントすることはできません
宝石店のSEO対策は
日本人の作った言語セットの前では無力なのです


この点PerlのLarryさんは巧妙にやりました
Pearlは今も6月の誕生石の地位を守っています
ここにLarryの奥さんは6月生まれであり
Matzの奥さんは7月生まれでないとの仮説が成り立ちます


**Sinatra
なぜWebフレームワークの名前を
[http://www.sinatrarb.com/:title=Sinatra]としたのか皆目検討も付きません
シナトラハットがトレードマークですから
そうなんでしょうがそれにしても...
Railsとは違うMyWayを行くという意味でしょうか
それとも裏社会との繋がりを暗示しているのでしょうか
まさか「[http://www.google.co.jp/search?client=safari&amp;rls=ja-jp&amp;q=%E6%94%AF%E9%82%A3%E8%99%8E&amp;esrch=BetaShortcuts&amp;ie=UTF-8&amp;oe=UTF-8:title=支那虎]」ですか？


ー名は体を表すー といいますが
これほどに体をイメージし辛い名も滅多にありません
改名を強く望みます
Googleで「[http://www.google.co.jp/search?client=safari&amp;rls=ja-jp&amp;q=sinatra&amp;esrch=BetaShortcuts&amp;ie=UTF-8&amp;oe=UTF-8:title=Sinatra]」と打って
このWebフレームワークがトップに来た日が
その命日にならないことを祈りつつ


**Git
[http://git-scm.com/:title=Git]は「ぎっと」と発音します
意味はこうです
&gt;|ruby|
 git  {名} : まぬけ、ばか、あほ、役立たず、無能な人
||&lt;
Linusさんにそう言われれば
返す言葉は何もありません
でも消沈する必要はありません
「git」とググられて
わたしやあなたの名前はもう出てこないのですから
これは[http://en.wikipedia.org/wiki/Google_bomb:title=GoogleBomb]ではなくGooglePieceなのです
ですから誰か早く
ヴァージョン管理システム「[http://www.google.co.jp/search?client=safari&amp;rls=ja-jp&amp;q=ass%20hole&amp;esrch=BetaShortcuts&amp;ie=UTF-8&amp;oe=UTF-8:title=ass hole]」
を作って我が国の首相を救ってください！


**Heroku
[http://heroku.com/:title=Heroku]は「Her-OH-koo」と発音します
Google App Engineほどつまらない名前はないですが
その意味に辿り着けないというのもまたつまらないものです
でもわたしはその答えにおそらく辿り着けました
ヒントはプライスリストです


[http://heroku.com/pricing#blossom-2:title=Heroku | Pricing]


彼らもまた東洋の神秘に見せられていたのです！
でも答えは「奥歯」じゃありません
韓流にハマっている妻に付き合っていた意味が
今顕在化したのです...


Herokuはハングルで「&amp;#54616;&amp;#50725;」と書きます
意味は「下獄」つまり
「罪人を牢屋に入れること」です
つまりHerokuユーザは
知らずのうちに罪人とされていたのです！
わたしも気が付くのが遅すぎました
暫く刑に服そうと思います
「[http://www3.nhk.or.jp/kaigai/tamo/:title=チェオクの剣]」でも見ながら...


Sinatraを使って無機能Webカレンダーを作ります
それをGitでHerokuにデプロイします
OSX+Terminal+TextMateを前提に書きます


あなたも罪人になってみませんか？


**Ruby+Sinatra
Sinatraをインストールします
現時点でRuby1.9には完全には対応していません
&gt;|ruby|
 % sudo gem install sinatra
||&lt;


mycalフォルダにmycal.rbファイルを作ります
&gt;|ruby|
 % mkdir mycal
 % cd mycal/
 mycal% mate mycal.rb
||&lt;


mycal.rbを編集します
&gt;|ruby|
 require &quot;rubygems&quot;
 require &quot;sinatra&quot;
 
 get '/' do
   @year = Time.now.year
   @ycal = `cal #{@year}`
   erb :index
 end
 
 __END__
 @@index
 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot;
   &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;
 &lt;html&gt;
   &lt;head&gt;
     &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
     &lt;title&gt;mycal&lt;/title&gt;
   &lt;/head&gt;
   &lt;body id=&quot;mycal&quot;&gt;
     &lt;pre&gt;&lt;%= @ycal %&gt;&lt;/pre&gt;
   &lt;/body&gt;
 &lt;/html&gt;
||&lt;
`(バッククオート)でシェルコマンドcalを呼んでいます
__END__以降にerbテンプレートを書きます
@@indexがラベルです


calが使えない環境の場合
ふなばただよしさんのcal.rbが使えます


[http://www.funaba.org/ruby.html#cal:title=cal.rb]


その場合cal.rbをrequireして
@ycal = `cal...を以下に変えます
&gt;|ruby|
 require 'cal'
 cal = Cal.new
 cal.opt_y(mon ? false : true)
 @ycal = cal.print(year, mon)
||&lt;


mycal.rbを実行します
&gt;|ruby|
 mycal% ruby mycal.rb
||&lt;


Webサーバが起動するので
ブラウザでhttp://localhost:4567/にアクセスします
カレンダーが表示されます


サーバを起動したまま
mycal.rbに以下を追加します
&gt;|ruby|
 get '/:year' do |year|
   @year = year.to_i
   @ycal = `cal #{@year}`
   erb :year
 end
||&lt;


__END__以下を次のように変えます
&gt;|ruby|
 __END__
 @@layout
 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot;
   &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;
 &lt;html&gt;
   &lt;head&gt;
     &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
     &lt;title&gt;mycal&lt;/title&gt;
   &lt;/head&gt;
   &lt;body id=&quot;mycal&quot;&gt;
     &lt;pre&gt;&lt;%= yield %&gt;&lt;/pre&gt;    
   &lt;/body&gt;
 &lt;/html&gt;
 
 @@index
 &lt;%= @ycal %&gt;
 
 @@year
 &lt;%= @ycal %&gt;
||&lt;
つまり＜pre＞＜/pre＞内にyieldを置いて
layoutと実体を分けます


ブラウザでhttp://localhost:4567/1999にアクセスします
1999年のカレンダーが表示されます


mycal.rbに以下を追加します
&gt;|ruby|
 get '/:year/:mon' do |*ym|
   @year, @mon = ym.map { |x| x.to_i  }
   @mcal = `cal #{@mon} #{@year}`
   erb :mon
 end
 
 __END__
 
 @@mon
 &lt;%= @mcal %&gt;
||&lt;


ブラウザでhttp://localhost:4567/1999/12にアクセスします
1999年12月のカレンダーが表示されます


helpersを使って`cal...を一ヶ所にまとめます
&gt;|ruby|
 get '/' do
   @year = Time.now.year
   @ycal = cal(@year)
   erb :index
 end
 
 get '/:year' do |year|
   @year = year.to_i
   @ycal = cal(@year)
   erb :year
 end
 
 get '/:year/:mon' do |ym|
   @year, @mon = ym.map { |x| x.to_i  }
   @mcal = cal(@year, @mon)
   erb :mon
 end
 
 helpers do
   def cal(*date)
     year, mon = date
     `cal #{mon} #{year}`
   end
 end
||&lt;


年カレンダーの月にリンクを張ります
&gt;|ruby|
 helpers do
   MONTHS = %w(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)  
   def cal(*date)
     year, mon = date
     cal = `cal #{mon} #{year}`
     cal.gsub(/((#{MONTHS.join('|')})\w*)/) do
       %Q{&lt;a href=&quot;/#{year}/#{MONTHS.index($2)+1}&quot;&gt;#{$1}&lt;/a&gt;}
     end
   end
 end
||&lt;


gsubで月の文字列にマッチさせます
ブラウザでhttp://localhost:4567/にアクセスします
Aprilのリンクをクリックして
4月のカレンダーが表示されるか確かめます


ロードの度にTerminalに以下の警告が表れています
&gt;|ruby|
 ./mycal.rb:23: warning: already initialized constant MONTHS
||&lt;


MONTHS定義をconfigureに移して対処します
&gt;|ruby|
 configure do
   MONTHS = %w(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)  
 end
||&lt;
configureブロックのコードは
最初に一度起動されるだけです
ctrl+cでWebサーバを停止し
ruby mycal.rbで再起動して有効にします


layoutをバナーとメインに分けます
バナーにはタイトルと前年・翌年のリンクを置きます
&gt;|ruby|
 __END__
 @@layout
 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot;
   &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;
 &lt;html&gt;
   &lt;head&gt;
     &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
     &lt;title&gt;mycal&lt;/title&gt;
     
   &lt;/head&gt;
   &lt;div id=&quot;banner&quot;&gt;
     &lt;h1&gt;&lt;a id='title' href='/'&gt;Web Calendar&lt;/a&gt;&lt;/h1&gt;
     &lt;div id=&quot;year_pred&quot;&gt;&lt;a href=&quot;/&lt;%= @year-1 %&gt;&quot;&gt;Previous Year&lt;/a&gt;&lt;/div&gt;
     &lt;div id=&quot;year_next&quot;&gt;&lt;a href=&quot;/&lt;%= @year+1 %&gt;&quot;&gt;Next Year&lt;/a&gt;&lt;/div&gt;
   &lt;/div&gt;
   &lt;div id=&quot;main&quot;&gt;
     &lt;pre&gt;&lt;%= yield %&gt;&lt;/pre&gt;    
   &lt;/div&gt;
 &lt;/html&gt;
||&lt;
ブラウザでhttp://localhost:4567/にアクセスして
Previous Year/Next Yearを適当にクリックします
タイトルをクリックして本年に戻るか確認します


**Git
そろそろGitでHerokuにデプロイしてみます


念のためmycal.rbの全体を載せます
&gt;|ruby|
 require &quot;rubygems&quot;
 require &quot;sinatra&quot;
 
 get '/' do
   @year = Time.now.year
   @ycal = cal(@year)
   erb :index
 end
 
 get '/:year' do |year|
   @year = year.to_i
   @ycal = cal(@year)
   erb :year
 end
 
 get '/:year/:mon' do |ym|
   @year, @mon = ym.map { |x| x.to_i  }
   @mcal = cal(@year, @mon)
   erb :mon
 end
 
 configure do
   MONTHS = %w(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)  
 end
 
 helpers do
   def cal(*date)
     year, mon = date
     cal = `cal #{mon} #{year}`
     cal.gsub(/((#{MONTHS.join('|')})\w*)/) do
       %Q{&lt;a href=&quot;/#{year}/#{MONTHS.index($2)+1}&quot;&gt;#{$1}&lt;/a&gt;}
     end
   end
 end
 
 __END__
 @@layout
 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot;
   &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;
 &lt;html&gt;
   &lt;head&gt;
     &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
     &lt;title&gt;mycal&lt;/title&gt;
     
   &lt;/head&gt;
   &lt;body id=&quot;mycal&quot;&gt;
     &lt;div id=&quot;banner&quot;&gt;
       &lt;h1&gt;&lt;a id='title' href='/'&gt;Web Calendar&lt;/a&gt;&lt;/h1&gt;
       &lt;div id=&quot;year_pred&quot;&gt;&lt;a href=&quot;/&lt;%= @year-1 %&gt;&quot;&gt;Previous Year&lt;/a&gt;&lt;/div&gt;
       &lt;div id=&quot;year_next&quot;&gt;&lt;a href=&quot;/&lt;%= @year+1 %&gt;&quot;&gt;Next Year&lt;/a&gt;&lt;/div&gt;
     &lt;/div&gt;
     &lt;div id=&quot;main&quot;&gt;
       &lt;pre&gt;&lt;%= yield %&gt;&lt;/pre&gt;    
     &lt;/div&gt;
   &lt;/body&gt;
 &lt;/html&gt;
 
 @@index
 &lt;%= @ycal %&gt;
 
 @@year
 &lt;%= @ycal %&gt;
 
 @@mon
 &lt;%= @mcal %&gt;
||&lt;


Gitのインストールはこの辺を参考にします

[http://hikariworks.jp/blog/2008/06/18/macports%E3%81%A7git%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/:title=hikariworks::blog&amp;#160;&amp;#187;&amp;#160; MacPortsでgitをインストール]

[http://docs.heroku.com/git#installing:title=Heroku | Using Git]


Webサーバを止めて
Gitをセットアップします
&gt;|ruby|
 mycal% git init
||&lt;
.gitフォルダができます


以下の内容のconfig.ruを作ります
&gt;|ruby|
 require 'mycal'
 run Sinatra::Application
||&lt;


&gt;|ruby|
 mycal% echo &quot;require 'mycal' ; run Sinatra::Application&quot; &gt; config.ru
||&lt;


Gitにファイルを追加します
&gt;|ruby|
 mycal% git add .
||&lt;


コミットします
&gt;|ruby|
 mycal% git commit -m &quot;first commit&quot;
||&lt;


**Heroku
Herokuにアカウントが無ければ作ります


[http://heroku.com/:title=Heroku]


次にHeroku gemをインストールします
&gt;|ruby|
 mycal% sudo gem install heroku
||&lt;


Herokuではsshを使うので
ssh keyが無ければ作っておきます
&gt;|ruby|
 % ssh-keygen -t rsa
||&lt;


この辺を参考にします

[http://docs.heroku.com/git#setting-up-ssh-public-keys:title=Heroku | Using Git]
[http://www.atmarkit.co.jp/flinux/rensai/linuxtips/432makesshkey.html:title=＠IT：Linuxでsshの鍵を作成するには]


Herokuにレポジトリを作ります
&gt;|ruby|
 mycal% heroku create
||&lt;


任意のレポ名が割り当てられます
レポ名.heroku.comがurlになります
heroku create myappとして
レポ名を指定できます(mycalは取得されています)
heroku rename newnameでリネイムできます


初回だけemailとpasswordを聞かれます
初回だけkeyのアップロードの要否が聞かれます


そしてHerokuにコードをpushします
&gt;|ruby|
 mycal% git push heroku master
||&lt;
次回以降masterは不要です


これでデプロイできました
アプリケーションにアクセスしましょう
&gt;|ruby|
 mycal% heroku open
||&lt;


以下のようなカレンダーが表示されたら成功です
[f:id:keyesberry:20090430100819p:image]


([http://d.hatena.ne.jp/keyesberry/20090501/p1:title=次回に続く])


(参考リンク)
[http://github.com/sinatra/heroku-sinatra-app/tree/master:title=sinatra's heroku-sinatra-app at master - GitHub]

[http://docs.heroku.com/:title=Heroku | Heroku Documentation]

[http://www.slideshare.net/myles_byrne/heroku-sinatra:title=Heroku &amp; Sinatra]

[http://blog.zerosum.org/2008/7/2/clone-pastie-with-sinatra-datamapper-redux:title=zerosum dirt(nap) - Clone Pastie with Sinatra &amp; DataMapper 0.9]

[http://herokugarden.com/:title=Heroku Garden]

[http://www8.atwiki.jp/git_jp/pub/Documentation.ja/tutorial.html:title=git チュートリアル (バージョン 1.5.1 以降用)]

[http://cheat.errtheblog.com/s/git:title=$ cheat git]

</body>
</day>
<day date="2009-05-01" title="">
<body>
*p1*Ruby.Sinatra.Git.Heroku #=&gt; &quot;Happy Web Development!&quot;　(後編)
mycal.rbに戻ってもう少し機能を増やします
日表示のための以下のコードを追加します
&gt;|ruby|
 get '/:year/:mon/:day' do |*ymd|
   @year, @mon, @day = ymd.map { |x| x.to_i }
   @dcal = cal(@year, @mon)
   @message = 'Webカレンダー完成予定日'
   erb :day
 end
 
 __END__
 
 @@day
 &lt;%= @year %&gt;年&lt;%= @mon %&gt;月&lt;%= @day %&gt;日
 &lt;%= @message %&gt;
 &lt;%= @dcal %&gt;
||&lt;


Webサーバを起動します
&gt;|ruby|
 mycal% ruby mycal.rb
||&lt;


http://localhost:4567/1993/2/24にアクセスして
1993年2月24日の頁が表示されるか確認します


頁のカレンダーにおいて
対象の日の色付けを行うためタグを挿入します
メッセージもグレードアップします
先のコードを以下のように修正します
&gt;|ruby|
 get '/:year/:mon/:day' do |*ymd|
   @year, @mon, @day = ymd.map { |x| x.to_i }
   @dcal = cal(@year, @mon).sub(/\s#{@day}(?=\D)/, '&lt;span id=&quot;target&quot;&gt;\0&lt;/span&gt;')
   @message = 'Webカレンダー完成予定日'
   @message += '&lt;br/&gt;って、期限過ぎてるじゃん！' if Time.local(*ymd) - Time.now &lt; 0
   erb :day
 end
||&lt;
subを使って日にマッチさせタグを挿入しています


http://localhost:4567/1998/5/14にアクセスします
メッセージを確認します
頁のソースを表示して14日にタグが挿入されているか確認します


表示形式が頁によって異なっているので
divで要素を識別できるようにテンプレートを修正します
&gt;|ruby|
 __END__
 @@layout
 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot;
   &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;
 &lt;html&gt;
   &lt;head&gt;
     &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
     &lt;title&gt;mycal&lt;/title&gt;
     
   &lt;/head&gt;
   &lt;body id=&quot;mycal&quot;&gt;
     &lt;div id=&quot;banner&quot;&gt;
       &lt;h1&gt;&lt;a id='title' href='/'&gt;Web Calendar&lt;/a&gt;&lt;/h1&gt;
       &lt;div id=&quot;year_pred&quot;&gt;&lt;a href=&quot;/&lt;%= @year-1 %&gt;&quot;&gt;Previous Year&lt;/a&gt;&lt;/div&gt;
       &lt;div id=&quot;year_next&quot;&gt;&lt;a href=&quot;/&lt;%= @year+1 %&gt;&quot;&gt;Next Year&lt;/a&gt;&lt;/div&gt;
     &lt;/div&gt;
     &lt;div id=&quot;main&quot;&gt;
       &lt;%= yield %&gt;
     &lt;/div&gt;
   &lt;/body&gt;
 &lt;/html&gt;
 
 @@index
 &lt;div id=&quot;index&quot;&gt;
   &lt;pre class=&quot;ycal&quot;&gt;&lt;%= @ycal %&gt;&lt;/pre&gt;
 &lt;/div&gt;
 
 @@year
 &lt;div id=&quot;year&quot;&gt;
   &lt;pre class=&quot;ycal&quot;&gt;&lt;%= @ycal %&gt;&lt;/pre&gt;
 &lt;/div&gt;
 
 @@mon
 &lt;div id=&quot;mon&quot;&gt;
   &lt;pre class=&quot;mcal&quot;&gt;&lt;%= @mcal %&gt;&lt;/pre&gt;
 &lt;/div&gt;
 
 @@day
 &lt;div id=&quot;day&quot;&gt;
   &lt;h3 id=&quot;date&quot;&gt;&lt;%= @year %&gt;年&lt;%= @mon %&gt;月&lt;%= @day %&gt;日&lt;/h3&gt;
   &lt;p id=&quot;message&quot;&gt;&lt;%= @message %&gt;&lt;/p&gt;
   &lt;pre class=&quot;dcal&quot;&gt;&lt;%= @dcal %&gt;&lt;/pre&gt;
 &lt;/div&gt;
||&lt;
yield回りの＜pre＞を削除し
各実体頁側で対応するようにします


年のカレンダーにおいて月単位でのデータ処理を実現するため
各月のカレンダーを生成し個別のdivで管理するようにします
helpersを以下のように修正します
&gt;|ruby|
 helpers do
   def cal(*date)
     year, mon = date
     cal = if mon
       calendar(mon, year)
     else
       (1..12).inject(&quot;&quot;) do |s, m|
         monthly_cal = &quot;&lt;div class='mon_cal' id='mon_#{m}'&gt;&quot; + calendar(m, year) + &quot;&lt;/div&gt;&quot;
         s &lt;&lt; monthly_cal
       end
     end
     cal.gsub(/((#{MONTHS.join('|')})\w*)/) do
       %Q{&lt;a href=&quot;/#{year}/#{MONTHS.index($2)+1}&quot;&gt;#{$1}&lt;/a&gt;}
     end
   end
   
   def calendar(m, y)
     `cal #{m} #{y}`
   end
 end
||&lt;
calコマンドはcalendarメソッドとして別にします
この時点でhttp://localhost:4567/にアクセスすると
表示は崩れていますが表示がなされていれば先に進みます


今日の日付にタグを付けます
calメソッドのelse節を次のようにします
&gt;|ruby|
 (1..12).inject(&quot;&quot;) do |s, m|
   monthly_cal = &quot;&lt;div class='mon_cal id='mon_#{m}&gt;&quot; + calendar(m, year) + &quot;&lt;/div&gt;&quot;
   #make today tag
   today = Time.now
   if m == today.mon and year == today.year
     monthly_cal.sub!(/\s#{today.day}(?=\D)/, '&lt;span id=&quot;today&quot;&gt;\0&lt;/span&gt;')          
   end
   s &lt;&lt; monthly_cal
 end
||&lt;


更に各日付に該当頁のリンクタグを挿入します
else節に追加します
&gt;|ruby|
 (1..12).inject(&quot;&quot;) do |s, m|
   monthly_cal = &quot;&lt;div class='mon_cal id='mon_#{m}&gt;&quot; + calendar(m, year) + &quot;&lt;/div&gt;&quot;
   #make days link
   monthly_cal.gsub!(/(\s([1-3]?[0-9](?=\D)))/) do
     %Q{&lt;a class=&quot;days_link&quot; href=&quot;/#{year}/#{m}/#{$2}&quot;&gt;#{$1}&lt;/a&gt;}
   end
   #make today tag
   today = Time.now
   if m == today.mon and year == today.year
     monthly_cal.sub!(/\s#{today.day}(?=\D)/, '&lt;span id=&quot;today&quot;&gt;\0&lt;/span&gt;')          
   end
   s &lt;&lt; monthly_cal
 end
||&lt;


最後にテンプレートに以下のスタイルを挿入して完成です

&gt;|css|
 __END__
 @@layout
 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot;
   &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;
 &lt;html&gt;
   &lt;head&gt;
     &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
     &lt;title&gt;mycal&lt;/title&gt;
     &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt;
       * { margin: 0; padding: 0;}
       body {background:#eed;}
       #banner { margin:20px; margin-left:auto; margin-right:auto; width:700px; color:#906; }
       #title { margin-left:250px;}
       #year_pred { float:left; }
       #year_next { float:right; }
 
       #main { position:absolute; left:50%; margin:30px 0 0 -360px; height:60%;}
       .ycal { color:#514; font-weight:bold;}
       .mon_cal { float:left; margin:5px 10px 5px 10px;}
       #mon_5, #mon_9 {clear:left;}
       #mon { margin-left:100px;}
       .mcal { color:#217; font-size:32pt; margin-top:10px; clear:right; }
       #day { margin-left:250px;}
       .dcal { color:#217; font-size:16pt; clear:right; }
       h3#date { font-size:24pt; color:#c06;}
       #message { font-size:14pt; color:#360; margin:30px 0 30px 0;}
       #target { color:#c06;}
       a {text-decoration:none; color:#514;}
       a.days_link:link, a.days_link:visited { color:#217;}
       a:hover, a.days_link:hover { color:#383;}
       #today { color:#060;}
     &lt;/style&gt;
   &lt;/head&gt;
   &lt;body id=&quot;mycal&quot;&gt;
     &lt;div id=&quot;banner&quot;&gt;
       &lt;h1&gt;&lt;a id='title' href='/'&gt;Web Calendar&lt;/a&gt;&lt;/h1&gt;
       &lt;div id=&quot;year_pred&quot;&gt;&lt;a href=&quot;/&lt;%= @year-1 %&gt;&quot;&gt;Previous Year&lt;/a&gt;&lt;/div&gt;
       &lt;div id=&quot;year_next&quot;&gt;&lt;a href=&quot;/&lt;%= @year+1 %&gt;&quot;&gt;Next Year&lt;/a&gt;&lt;/div&gt;
     &lt;/div&gt;
     &lt;div id=&quot;main&quot;&gt;
       &lt;%= yield %&gt;
     &lt;/div&gt;
   &lt;/body&gt;
 &lt;/html&gt;
||&lt;
http://localhost:4567/にアクセスします
Previous Yearを5回クリックしてAugustをクリックします
2004年8月のカレンダーが表示されているのを確認します
そこからNext Yearを3回クリックして
Octoberの15日をクリックします
2007年10月15日のカレンダーが表示されているのを確認します
そこからNext Yearを3回クリックしてMayの3日をクリックします
2010年5月3日のカレンダーが表示されているのを確認します


カレンダーが完成したのでcommitしてHerokuにpushします
&gt;|ruby|
 mycal% git commit -m &quot;second commit&quot;
 mycal% git push heroku
 mycal% heroku open
||&lt;


以下のようなカレンダーがブラウザに表示されたら成功です
[f:id:keyesberry:20090501093355p:image]


こちらで作成したサイトには以下からアクセスできます


[http://mycal.heroku.com/:title=mycal]



コードは以下にあります

[http://gist.github.com/104362:title=gist: 104362 - GitHub]


[http://d.hatena.ne.jp/keyesberry/20090425/p1:title=前回]と[http://d.hatena.ne.jp/keyesberry/20090407/p1:title=前々回]のチュートリアルで作成した
アプリケーションのURLも貼っておきます


ScanAnimation
http://scananimation.heroku.com/


WORDS in Books
http://words-in-books.heroku.com/

</body>
</day>
<day date="2009-05-18" title="">
<body>
*p1*100円ショップでiPod touchスタンドを見つける秘訣
iPod touchは革命的コンピュータである
それが何故革命的なのかと言うと
ポケットに入れて携帯できるからではない


それがベットの上で寝ながら使えるからである


寝ながらブログを読む
寝ながらゲームをする
寝ながらビデオを観る
怠け者たちの夢が今叶う


縦110cm横62cm重さ115gのコンピュータが
就寝前の読書という習慣を壊し
その書籍の独占市場に今割り込んできたのだ


しかし問題がないわけではない
怠け者にとって115gは意外と重い
30分もビデオを観ていると腕がつる
せめて手の位置をもう少し降ろしたい...



聞きたいCDがあるときに
図書館-TSUTAYA DISCAS-Amazon
と辿るのがわが家の買物不文律である
同様にiPodアクセサリが欲しいとき
100円ショップ-ハンズ-ヨドバシ
と辿る不文律がある


この絶対的不文律に従って
今日も100円ショップへ向かう
目を凝らし先入観を捨てて
くまなくショップ内を見て回る


果たして目的のブツが見つかった
100円ショップに理想的な
iPod touch用スタンドがあったのだ！
その名も「げんきくん」

[f:id:keyesberry:20090518204146j:image]
[f:id:keyesberry:20090518194034j:image]


吸盤でiPod touchの背面にピタッと
[f:id:keyesberry:20090518194033j:image]


そう簡単に外れそうもない
[f:id:keyesberry:20090518213806j:image]


机上スタンドとしても機能する
[f:id:keyesberry:20090518194037j:image]


向きだって自在だ
[f:id:keyesberry:20090518194035j:image]


予備の吸盤も一つ付いている
すばらしい！


100円ショップは宝の山である
しかしいいものを見つけるにはコツがいる
それは「目的を持って探す」ことだ


そのことはRuby作者のMatzさんも認めている
ここに引用しよう

&gt;&gt;
100円ショップで逸品を見つける秘訣
　もう1つは、「目的を持って探す」ことです。何かを見つけようと思って100円ショップを探せば、効果的に理解して知識を得ることができます。例えば、「最近買った耕耘機の分解洗浄棒を探す」とか、「このショップ系列がどのようにガラクタコレクションを陳列しているか」とか、「なぜこのショップ系列はこんなに姑息に商売するのか」とかです。商売の教科書にある店舗は非常に小規模なものが多く、枠組みを理解することはできますが、実用的な店舗でどのような問題が発生するか、あるいはそれらの問題にどう対処するかについては、あまり教えてくれません。実際に動いている100円ショップは、そのような「教科書が教えてくれないグッズ」の宝庫なのです。
&lt;&lt;


ちょっと違った

&gt;&gt;
[http://www.itmedia.co.jp/enterprise/articles/0712/26/news015.html:title=まつもとゆきひろのハッカーズライフ：第10回　ソースを読もう (1/2) - ITmedia エンタープライズ]
ソースコード読解の秘訣
　もう1つは、「目的を持って読む」ことです。何かを学ぼうと思ってソースコードを読めば、効果的に読解して知識を得ることができます。例えば、「再帰下降構文解析の実装法を学ぶ」とか、「この処理系がどのようにガーベジコレクションを実装しているか」とか、「なぜこの処理系はこんなに高速に動作するのか」とかです。プログラミングの教科書にあるコードは非常に小規模なものが多く、枠組みを理解することはできますが、実用的なプログラムでどのような問題が発生するか、あるいはそれらの問題にどう対処するかについては、あまり教えてくれません。実際に動いているプログラムは、そのような「教科書が教えてくれない話」の宝庫なのです。
&lt;&lt;
でもまあ趣旨は同じだ


購入は自己責任で願う
iPod touchが降ってきて
鼻血を出しても責任は負えないが
そのときはティッシュホルダーとして
使いなさい
</body>
<comments>
<comment>
<username>yukichi</username>
<body>100円SHOPで売ってる組み立て棚用のフックをペンチで・・・&lt;br&gt;棚にひっかける部分を広げて(ここにiPodをさす)&lt;br&gt;iPodを立ててみて、普通 物をぶら下げる部分をちょうどいい角度に、手で角度を曲げて 出来上がり</body>
<timestamp>1266763537</timestamp>
</comment>
<comment>
<username>neokazu0726</username>
<body>いいですねー&lt;br&gt;これって、手に持ってみるってことですね？&lt;br&gt;置いてみるだけなら、１００円ＳＨＯＰのフォト＆ピクチャースタンド（足だけのやつ）が縦も横も行けますよー&lt;br&gt;ずれないようにひっかけが付いてる物を選んでね。&lt;br&gt;携帯性もあって、海外にも持って行けるし、ホテルの机やベッドの枕元のテーブルにおいて、映画鑑賞や音楽鑑賞も出来ますよ。&lt;br&gt;iPod touchにスリープタイマーがほしくなりますね。</body>
<timestamp>1286760455</timestamp>
</comment>
</comments>
</day>
<day date="2009-08-26" title="">
<body>
*p1*Rubyのブロック(クロージャ)はローカル変数をインスタンス変数に変えるマジックだ！

[http://d.hatena.ne.jp/yuki_rinrin/20090825/1251210051:title=Ruby クロージャ - ソースコード備忘録]を読んで
自分のRubyにおけるブロックと変数の理解が怪しいことがわかった
でちょっと普通とは違うアプローチからの整理を試みて
理解できた気がするので書いてみます
誤りを教えてくれればうれしいです


**ローカル変数
プログラムコードはプログラマの意思をインタプリタに伝えるものだ
Rubyでは
オブジェクトに処理を依頼する形でプログラムを組成するけど
そのとき変数はプログラマが
対象のオブジェクトを指し示すためのラベルとして用いられる
すなわち変数はオブジェクト参照ラベルだ


複数の手続きブロックで構造化される
現代のプログラミングにおいては
1つの変数の適用範囲は
それが定義されている手続きブロックに限定されるのが普通だ


Rubyにおいてメソッド定義は
この手続きブロックを新たに作る
だから以下の例でcounterメソッド内の変数nは
未定義となる

&gt;|ruby|
 n = 0
 def counter
   n += 1
 end
 
 counter # =&gt; 
 # ~&gt; -:3:in `counter': undefined method `+' for nil:NilClass (NoMethodError)
 # ~&gt; 	from -:6
||&lt;

つまりトップレベルとcounterメソッドとは
別の手続きブロックであり
トップレベルで定義した変数nは
counterメソッド内で参照できない


このようにその適用範囲が
それが定義されている手続きブロックに限定される変数は
ローカル変数と呼ばれる


メソッドの壁を越えて
ローカル変数を参照できるようにするには
変数をメソッドの引数として渡す必要がある

&gt;|ruby|
 n = 0
 def counter(x)
   x + 1
 end
 n = counter(n) # =&gt; 1
 n = counter(n) # =&gt; 2
 n = counter(n) # =&gt; 3
||&lt;

**インスタンス変数
一方Rubyには
インスタンス変数という適用範囲がより広い変数がある
インスタンス変数は手続きブロックを超えて
それが定義されるオブジェクトの範囲で有効となる変数だ
つまりRubyインタプリタは
インスタンス変数の有効範囲に関し
オブジェクトを一つの手続きブロックとみなす


だから上のコードのローカル変数nを
インスタンス変数@nに変えれば
counterメソッドから変数@nが見える

&gt;|ruby|
 @n = 0
 def counter
   @n += 1
 end
 
 counter # =&gt; 1
 counter # =&gt; 2
 counter # =&gt; 3
 
 instance_variable_get :@n # =&gt; 3
||&lt;

ここでRubyのトップレベルは
Objectクラスのインスタンスであるmainオブジェクトの
コンテキストを持っているので
上のコードはインスタンス変数nに関し以下と等価だ

&gt;|ruby|
 class Object
   def initialize
     @n = 0
   end
   def counter
     @n += 1
   end
 end
 
 main = Object.new
 main.counter # =&gt; 1
 main.counter # =&gt; 2
 main.counter # =&gt; 3
 
 main.instance_variable_get :@n # =&gt; 3
||&lt;

上のコードにより
1つのメソッド内で定義されたインスタンス変数@nが
オブジェクト全体で有効であることがよりはっきり分かる


前に書いたように
インスタンス変数は変数の有効範囲をオブジェクトにまで拡張する
しかしその一方でそのクラスまでは拡張しない
つまり同一のクラスから生成される複数のオブジェクト間で
インスタンス変数が共有されることはないんだ

&gt;|ruby|
 class Object
   def initialize
     @n = 0
   end
   def counter
     @n += 1
   end
 end
 
 main = Object.new
 main.counter # =&gt; 1
 main.counter # =&gt; 2
 main.counter # =&gt; 3
 main.instance_variable_get :@n # =&gt; 3
 
 main2 = Object.new
 main2.counter # =&gt; 1
 main2.counter # =&gt; 2
 main2.instance_variable_get :@n # =&gt; 2
||&lt;

ここでObjectクラスのmainオブジェクトとmain2オブジェクトは
それぞれがインスタンス変数@nを持つけれども
それらの有効範囲は
それぞれのオブジェクト内に限られていることがわかる

**クラス変数
Rubyにはさらに有効範囲の広い変数がある
@@ではじまるクラス変数だ
クラス変数はその有効範囲をクラスにまで拡張する
つまりRubyインタプリタはクラス変数の有効範囲に関し
クラスを一つの手続きブロックとみなす

&gt;|ruby|
 class Object
   def initialize
     @@n ||= 0
   end
   def counter
     @@n += 1
   end
 end
 
 main = Object.new
 main.counter # =&gt; 1
 main.counter # =&gt; 2
 main.counter # =&gt; 3
 
 main2 = Object.new
 main2.counter # =&gt; 4
 main2.counter # =&gt; 5
||&lt;

この例からObjectクラスの複数のインスタンスmain,main2間で
1つのクラス変数@@nが共有されていることがわかる


変数の有効範囲が広がると
プログラマが予期しない問題が起こることがある
Rubyではクラス変数の有効範囲が
サブクラスのインスタンスにも拡張する点留意が必要だ

&gt;|ruby|
 class Object
   def initialize
     @@n ||= 0
   end
   def counter
     @@n += 1
   end
 end
 
 main = Object.new
 main.counter # =&gt; 1
 main.counter # =&gt; 2
 main.counter # =&gt; 3
 
 main2 = Object.new
 main2.counter # =&gt; 4
 main2.counter # =&gt; 5
 
 'string'.counter # =&gt; 6
 [].counter # =&gt; 7
 class MyClass; end
 MyClass.new.counter # =&gt; 8
||&lt;

この例ではObjectクラスにクラス変数が定義され
それがメモリ上のすべてのクラスのインスタンスで
参照・変更できることが示されている
この場合クラス変数はグローバル変数とほぼ等価になる
だからRubyのトップレベルでクラス変数を定義するときは
グローバル変数を定義していると理解したほうがいい


変数の有効範囲をインスタンスやサブクラスに広げずに
それが定義されたクラスオブジェクトに限定したい場合
クラスオブジェクトの文脈でインスタンス変数が使える
&gt;|ruby|
 class Super
   @n = 0
   def self.counter
     @n += 1
   end
 end

 class Sub &lt; Super; end

 Super.counter # =&gt; 1
 Super.counter # =&gt; 2
 Super.counter # =&gt; 3

 Sub.counter # =&gt; # !&gt; instance variable @n not initialized

 main = Super.new
 main.counter # =&gt; undefined method
||&lt;

**クロージャ
Rubyには{}またはdo endで挟むことによって
手続きのまとまりを表現するブロックという
メソッド類似の構文がある
ブロックはそれ単独ではメモリ上に存在できない

&gt;|ruby|
 n = 0
 { n += 1 } # =&gt; Error
||&lt;
だけれどもメソッドに伴われるかたちなら存在できるようになる

&gt;|ruby|
 n = 0
 1.times { n += 1 }
 1.times { n += 1 }
 n # =&gt; 2
||&lt;

Rubyのブロックはメソッドによる手続きブロックとは異なって
ブロックの外側で定義されたローカル変数を
ブロック内で参照・変更できるという性質を有する((ただブロック内で定義された変数はその外側で参照できない))


さらにRubyのブロックはそれ自身をオブジェクト化することができ
そうすることによってメモリ上に独立して存在できるようになる
&gt;|ruby|
 lambda { n += 1 } # =&gt; #&lt;Proc:0x0001f57c@-:27&gt;
||&lt;

ブロックをオブジェクト化したものは
Procクラスのインスタンスであり
callメソッドを呼ぶことによって
ブロック内の手続きを呼び出すことができる
そしてこの場合でもブロックがその外側で定義された
ローカル変数を参照できるという性質は保たれる
このようなブロックの性質はクロージャと呼ばれる

&gt;|ruby|
 n = 0
 main = lambda { n += 1 }
 main.call # =&gt; 1
 main.call # =&gt; 2
 main.call # =&gt; 3
||&lt;

これは先に示したインスタンス変数の例と良く似ている
callメソッドを別名定義すれば類似性がよりはっきりする
&gt;|ruby|
 n = 0
 main = lambda { n += 1 }
 def main.counter
   self.call
 end
 main.counter # =&gt; 1
 main.counter # =&gt; 2
 main.counter # =&gt; 3
 
 #インスタンス変数の例
 class Object
   def initialize
     @n = 0
   end
   def counter
     @n += 1
   end
 end
 
 main = Object.new
 main.counter # =&gt; 1
 main.counter # =&gt; 2
 main.counter # =&gt; 3
||&lt;

ここでローカル変数nはインスタンス変数@nのように機能し
オブジェクトmainの状態を保持している
つまりブロックによって
ローカル変数がインスタンス変数のように働いている


そう
つまりブロック(クロージャ)は
ローカル変数をインスタンス変数に変えるマジックなんだ!


(追記:2009/8/27) ブロックにおける変数の有効範囲の説明を訂正しました。
(追記:2009/8/27) クラスオブジェクトでインスタンス変数を使う説明を追加しました。

</body>
<comments>
<comment>
<username>yuki_rinrin</username>
<body>トラックバックありがとうございます。&lt;br&gt;&gt;しかしメソッドによる手続きブロックとは異なって&lt;br&gt;&gt;Rubyのブロックは変数の新たな有効範囲を作らない&lt;br&gt;&gt;つまり上の例のようにブロックの外側で定義された&lt;br&gt;&gt;ローカル変数nをブロック内で参照・変更できる&lt;br&gt;ブロックでも変数の新たなスコープはできますよ。&lt;br&gt;参考URL http://www.ruby-lang.org/ja/man/html/FAQ_CAD1BFF4A1A2C4EABFF4A1A2B0FABFF4.html&lt;br&gt;ただ、その時にクロージャがあることによってブロックを定義した環境のローカル変数を使えるようになるのではないでしょうか。&lt;br&gt;&gt;m = 1&lt;br&gt;&gt;func1 = lambda {&lt;br&gt;&gt;        n = 3&lt;br&gt;&gt;        p n, m&lt;br&gt;&gt;    }&lt;br&gt;&gt;func1.call&lt;br&gt;&gt;p m&lt;br&gt;&gt;p n&lt;br&gt;の場合、最後の行はエラーになるとおもいます。&lt;br&gt;ブロックが変数のスコープを作らないのなら、&lt;br&gt;エラーがでないことにならないでしょうか。&lt;br&gt;rubyは勉強中の身なので間違っているかもしれませんが、&lt;br&gt;参考になれば幸です。</body>
<timestamp>1251300916</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;yuki rinrinさん&lt;br&gt;そうですね、ブロックが変数の新たなスコープを作らないというのは言いすぎでした。ただ、個人的にはそれが外側のローカル変数を参照できる限り、新たなスコープを作るとは言いづらいんですよね。いずれにしても、明らかな間違いなので本文訂正しました。ご指摘ありがとうございます。</body>
<timestamp>1251327846</timestamp>
</comment>
</comments>
</day>
<day date="2009-09-01" title="">
<body>
*p1*RubyのProcオブジェクトはキューティーハニーだ!

RubyのブロックとそのオブジェクトであるProcオブジェクトは
とても魅惑的だ
優しそうでいてなかなか複雑だ
外からは浅そうに見えて
中に入ると底が見えてこない


単純に見えて使い方は実に多様だ
あるときはイテレータであり
またあるときはコールバック関数である
あるときはフィルターであり
またあるときはジェネレーターである


Procオブジェクトに関し試してみたことを書いてみます
きっと勘違いがあるので指摘してくれるとうれしいです

**あるときはSingletonメソッド・ジェネレータになる

Rubyのブロックはメソッドと同じように手続きの塊を作り
それはlambdaでオブジェクト(Procオブジェクト)化できる
このときProcオブジェクトは外側の変数の参照を
自身の状態として取りこめる
ブロック内の手続きは
Proc#callメソッドを呼ぶことによって実行される
こんな感じだ

&gt;|ruby|
 name = &quot;taro&quot;
 party = &quot;jimin&quot;
 
 pm = lambda do
   puts name
   puts party
   puts &quot;Hello, I'm #{name} of #{party}&quot;
 end
 pm.call
 
 # &gt;&gt; taro
 # &gt;&gt; jimin
 # &gt;&gt; Hello, I'm taro of jimin
 
 name = &quot;yukio&quot;
 party = &quot;minshu&quot;
 pm.call
 
 # &gt;&gt; yukio
 # &gt;&gt; minshu
 # &gt;&gt; Hello, I'm yukio of minshu
||&lt;

外側の変数(name,party)の参照先が変わると
それに合わせてProcオブジェクト(pm)の状態も変わる


pmはオブジェクトだからユーザがメソッドを追加してもいい
こんなときsingletonクラス(特異クラス)が使える
&gt;|ruby|
 name = &quot;taro&quot;
 party = &quot;jimin&quot;
 
 pm = lambda do
   class &lt;&lt; pm
     attr_reader :name, :party
     def init(name, party)
       @name, @party = name, party
     end
     def greeting
       &quot;Hello, I'm #@name of #@party&quot;
     end
   end
   pm.init(name, party)
 end
 
 pm.call
 pm.name # =&gt; &quot;taro&quot;
 pm.party # =&gt; &quot;jimin&quot;
 pm.greeting # =&gt; &quot;Hello, I'm taro of jimin&quot;
 
 name = &quot;yukio&quot;
 party = &quot;minshu&quot;
 
 pm.call
 pm.name # =&gt; &quot;yukio&quot;
 pm.party # =&gt; &quot;minshu&quot;
 pm.greeting # =&gt; &quot;Hello, I'm yukio of minshu&quot;
||&lt;
例では先の例のブロック内の各文をメソッドで呼べるようにしている
singletonクラスの参照オブジェクトをpmとしメソッドを定義して
Proc#callでinitメソッドが実行されるようにする


ただ上のコードはブロックの内部で変数pmを参照しているので
pmの参照先が変わると問題が起きる
ブロックの引数として対象のオブジェクトを渡して問題を解決しよう
&gt;|ruby|
 name = &quot;taro&quot;
 party = &quot;jimin&quot;
 
 pm = lambda do |obj|
   class &lt;&lt; obj
     attr_reader :name, :party
     def init(name, party)
       @name, @party = name, party
     end
     def greeting
       &quot;Hello, I'm #@name of #@party&quot;
     end
   end
   obj.init(name, party)
 end
 
 pm[pm]
 pm.name # =&gt; &quot;taro&quot;
 pm.party # =&gt; &quot;jimin&quot;
 pm.greeting # =&gt; &quot;Hello, I'm taro of jimin&quot;
 
 name = &quot;yukio&quot;
 party = &quot;minshu&quot;
 
 pm[pm]
 pm.name # =&gt; &quot;yukio&quot;
 pm.party # =&gt; &quot;minshu&quot;
 pm.greeting # =&gt; &quot;Hello, I'm yukio of minshu&quot;
||&lt;
ブロックを実行するpm[pm](これはpm.call(pm)と等価)のところが
ちょっと変な感じがする


別のオブジェクトをブロック引数として渡したらどうなるんだろう
&gt;|ruby|
 class Person
 end
 me = Person.new
 name = 'Charlie'
 party = 'N/A'
 
 pm[me]
 me.name # =&gt; &quot;Charlie&quot;
 me.party # =&gt; &quot;N/A&quot;
 me.greeting # =&gt; &quot;Hello, I'm Charlie of N/A&quot;
||&lt;
Personクラスのオブジェクトmeに先のメソッドが追加された


そうかpmオブジェクトは任意のオブジェクトに
singletonメソッドを追加するジェネレータとして機能するんだ
じゃあもっとそれっぽく作ってみよう
&gt;|ruby|
 singleton_generator = lambda do |obj, properties|
   class &lt;&lt; obj
     def init(properties)
       meta = class &lt;&lt; self; self end
       meta.class_eval do
         properties.each do |p, v|
           define_method(p) { instance_variable_set(&quot;@#{p}&quot;, v) }
         end
       end
     end
   end
   obj.init(properties)
 end
 
 class Person
   attr_reader :fname, :lname
   def initialize(fname, lname)
     @fname, @lname = fname, lname
   end
 end
 usp = Person.new('Barack', 'Obama')
 
 singleton_generator[usp, :mname =&gt; 'Hussein', :party =&gt; 'Democratic']
 
 puts &quot;44th President of the United States is #{usp.fname} #{usp.mname} #{usp.lname} of #{usp.party} party.&quot;
 
  #&gt;&gt; 44th President of the United States is Barack Hussein Obama of Democratic party.
||&lt;

singletonメソッドを生成するsingleton_generatorオブジェクトに
ブロック引数として対象のオブジェクトと
任意のプロパティをハッシュで渡せるようにした
この例ではPersonクラスのオブジェクトuspに対して
mnameとpartyメソッドを追加する例を示した
これでsingletonメソッド・ジェネレーターの完成だ！


もっとも同じことは別にメソッドでもできるので
意味はなさそうだけど…
&gt;|ruby|
 def singleton_generator(obj, properties)
   class &lt;&lt; obj
     def init(properties)
       meta = class &lt;&lt; self; self end
       meta.class_eval do
         properties.each do |p, v|
           define_method(p) { instance_variable_set(&quot;@#{p}&quot;, v) }
         end
       end
     end
   end
   obj.init(properties)
 end
||&lt;


**あるときは再帰オブジェクトになる

以下のブログでY-Combinatorを使って
再帰的な関数を手続きオブジェクトにするやり方が書かれている


[http://rubyist.g.hatena.ne.jp/muscovyduck/20060524/p1:title=「再帰的な関数」を手続きオブジェクトにする - バリケンのRuby日記 - Rubyist]


解説はとても丁寧になされていてとてもためになる
でもY-Combinatorについては
どうにも僕の頭がついていってくれないので
別の方法がないか考えてみた
&gt;|ruby|
 fact = lambda do |n|
   if n.zero?
     1
   else
     n * fact[n-1]
   end
 end
 
 fact[10] # =&gt; 3628800
||&lt;

ここでブロック内の変数を無くすために
手続きオブジェクトをブロック引数として渡すようにする
&gt;|ruby|
 fact = lambda do |f, n|
   if n.zero?
     1
   else
     n * f[f, n-1]
   end
 end
 
 fact[fact, 10] # =&gt; 3628800
||&lt;
うまくいった
でもfactを呼ぶときfactを引数で渡すのは格好悪い


Ruby1.9のProcオブジェクトにはcurryというメソッドがあって
引数の一部を先に渡して
そのオブジェクトに部分適用してくれるものがある
関数に対するこのような作用を
論理学者ハスケル・カリーに因んでカリー化というらしい


これが使えるかもしれない
&gt;|ruby|
 fact = lambda do |f, n|
   if n.zero?
     1
   else
     n * f[f, n-1]
   end
 end.curry
 
 fact_maker = fact[fact] # =&gt; #&lt;Proc:0x5becf8 (lambda)&gt;
 fact_maker[10] # =&gt; 3628800
||&lt;
factオブジェクトをカリー化し
最初にブロック引数としてfactオブジェクトだけを渡して
fact_makerオブジェクトを作る
こうすればfact_makerに対する引数は1つだけになって
目的は達成できる


でもまだブロック内のelse節でProcオブジェクトを渡してる
これも消したい
&gt;|ruby|
 fact = lambda do |f, n|
   if n.zero?
     1
   else
     n * f[n-1]
   end
 end.curry
 
 fact_maker = fact[fact] # =&gt; #&lt;Proc:0x5becf8 (lambda)&gt;
 fact_maker[10] #=&gt; TypeError:Proc can't be coerced into Fixnum
||&lt;
もちろんエラーが出る
エラーがでないようにするためにはブロックに渡す引数は
factオブジェクトじゃなくて既にfactを渡して生成した
Procオブジェクトつまりfact_makerじゃなくちゃいけない


そこでバリケンさんにあったアイディアをもらって
fact_makerを次のようにしてみる
&gt;|ruby|
 fact = lambda do |f, n|
   if n.zero?
     1
   else
     n * f[n-1]
   end
 end.curry
 
 fact_maker = lambda do |m|
   fact[fact_maker, m]
 end
 
 fact_maker[10] # =&gt; 3628800
||&lt;
うまくいった
さらにfactにつけたcurryをfact_maker内に移動する
&gt;|ruby|
 fact = lambda do |f, n|
   if n.zero?
     1
   else
     n * f[n-1]
   end
 end
 
 fact_maker = lambda do |m|
   fact.curry[fact_maker, m]
 end
 
 fact_maker[10] # =&gt; 3628800
||&lt;
fact_makerをY-Combinatorのようにメソッドにしてみる
&gt;|ruby|
 fact = lambda { |f, n| n.zero? ? 1 : n * f[n-1] }
 
 def my_combinator(func)
   f = lambda { |m| func.curry[f, m] }
 end
 
 fact = my_combinator(fact)
 fact[10] # =&gt; 3628800
||&lt;
フィボナッチでも試してみる
&gt;|ruby|
 fib = lambda do |f, n|
   case n
   when 0 then 0
   when 1 then 1
   else f[n-1] + f[n-2]
   end
 end
 
 def my_combinator(func)
   f = lambda { |m| func.curry[f, m] }
 end
 
 fib = my_combinator(fib)
 fib[10] # =&gt; 55
||&lt;

ここまで来たらProcのメソッドにもしてみる
&gt;|ruby|
 class Proc
   def recur
     f = lambda { |m| curry[f, m] }
   end
 end

 fact = fact.recur
 fact[10] # =&gt; 3628800 

 fib = fib.recur
 fib[10] # =&gt; 55
||&lt;
トンチンカンなことやってないか心配だ…


**あるときはcaseの判定ラベルになる
Ruby1.9ではProc#callの別名としてProc#===が用意されている
それを用いた楽しいサンプルを
Dave Thomasさんのブログで見つけた


[http://pragdave.blogs.pragprog.com/pragdave/2008/09/fun-with-procs.html:title=PragDave: Fun with Procs in Ruby 1.9]

&gt;|ruby|
 is_weekday = lambda {|day_of_week, time| time.wday == day_of_week}.curry  
   
 sunday    = is_weekday[0]  
 monday    = is_weekday[1]  
 tuesday   = is_weekday[2]  
 wednesday = is_weekday[3]  
 thursday  = is_weekday[4]  
 friday    = is_weekday[5]  
 saturday  = is_weekday[6]  
   
 case Time.now  
 when sunday   
   puts &quot;Day of rest&quot;  
 when monday, tuesday, wednesday, thursday, friday  
   puts &quot;Work&quot;  
 when saturday  
   puts &quot;chores&quot;  
 end  
||&lt;
sunday, monday..はis_weekdayに曜日数値だけを
適用して生成されたProcオブジェクトだ
これをcaseの条件におくと
Proc#===つまりcallメソッドが呼ばれて
Time.nowを引数としてis_weekdayのブロックが評価される
そしてブロックの評価結果はcaseの条件になる


case式において比較条件の詳細が隠ぺいされていて簡潔だ
自分でも何か書いてみよう
&gt;|ruby|
 Person = Struct.new(:name, :height, :weight)
 
 p1 = Person.new('ichiro', 1.75, 60)
 p2 = Person.new('jiro', 1.65, 90)
 p3 = Person.new('saburo', 1.90, 78)
 
 BMI = lambda do |min, max, person|
    (min..max).cover?(person.weight / person.height**2)
 end.curry
 
 upper = BMI[23, 25]
 middle = BMI[21, 23]
 lower = BMI[18.5, 21]
 
 messages = [p1,p2,p3].map do |testee|
   result = 
     case testee
     when upper
       &quot;You are in upper&quot;
     when middle
       &quot;You are great!&quot;
     when lower
       &quot;You are in lower&quot;
     else
       &quot;Problem!&quot;
     end
     {testee.name =&gt; result}
 end
 
 puts messages
 
 #&gt;&gt; {&quot;ichiro&quot;=&gt;&quot;You are in lower&quot;}
 #&gt;&gt; {&quot;jiro&quot;=&gt;&quot;Problem!&quot;}
 #&gt;&gt; {&quot;saburo&quot;=&gt;&quot;You are great!&quot;}
||&lt;
upper,middle,lowerはBMIオブジェクトにそれぞれの
許容範囲の最大値、最小値を部分適用したProcオブジェクトだ
それらはcase式において各testeeの身長と体重を参照して
各許容範囲と比較し結果を返す


もう少し面白い例が思いつけばよかったんだけど…


こんなふうにProcオブジェクトはその使い方によって
さまざまな形に化ける


そう
RubyのProcオブジェクトは
状況に応じて七変化するキューティーハニーだったんだ!

</body>
</day>
<day date="2009-10-01" title="">
<body>
*p1*Rubyで写真にタイトルを付けてFlickrにアップしよう!
毎回食事の写真を撮ってタイトル付きでFlickrにアップしている
タイトルは「Lunch Sep 29 2009」のように
食事の種別と日付にしている
毎食となると月に100以上も写真をアップすることになるので
このタイトル付けは結構しんどい
何の目的もなく食事の写真を撮っているのでやめてもいいんだけど
こういうことは一旦始めるとやめるのにも覚悟がいる
そこで覚悟を先送りにしたい自分の結論はこうなる


こういう面倒なことはRubyにやってもらおう!


**Exifデータの取得
デジカメで撮った写真データにはExifというメタデータが付いている
Exifには撮影日時のデータが含まれているので
これを読み出せれば上記のようなタイトルの構築は簡単だ


Rubyにはこの目的にexifrというライブラリがある
これをインストールして使ってみよう
(Mac OSX Tigerを前提に書いています)

&gt;|ruby|
 % sudo gem install exifr
||&lt;

まずはirbで

&gt;|ruby|
 % irb -rexifr
 irb(main):001:0&gt; p01 = EXIFR::JPEG.new &quot;RIMG0001.JPG&quot;
 =&gt; #&lt;EXIFR::JPEG:0x5ef948 @bits=8, @height=2448, @width=3264, @exif=[{:image_desc ription=&gt;&quot;&quot;, :make=&gt;&quot;RICOH&quot;, :model=&gt;&quot;GR Digital&quot;, :orientation=&gt;#&lt;EXIFR::TIFF::O rientation:0x5fcd3c @value=1, @type=:TopLeft&gt;, :x_resolution=&gt;(72/1), :y_resoluti on=&gt;(72/1), :resolution_unit=&gt;2, :date_time=&gt;2009-09-29 19:37:07 +0900, :ycb_cr_positioning=&gt;2, :copyright=&gt;&quot;(C) by GR Digital User&quot;, :exposure_time=&gt;(1/9), :f_number=&gt;(12/5), :exposure_program=&gt;2, :iso_speed_ratings=&gt;154, :date_time_original=&gt;2009-09-29 19:37:07 +0900, :date_time_digitized=&gt;2009-09-29 19:37:07 +0900, :compressed_bits_per_pixel=&gt;(14/5), :aperture_value=&gt;(5/2), :brightness_value=&gt;(858993455/2), :exposure_bias_value=&gt;(0/1), :max_aperture_value=&gt;(12/5), :metering_mode=&gt;5, :light_source=&gt;0, :flash=&gt;16, :focal_length=&gt;(59/10), :color_space=&gt;1, :pixel_x_dimension=&gt;3264, :pixel_y_dimension=&gt;2448, :exposure_mode=&gt;0, :white_balance=&gt;0, :scene_capture_type=&gt;0, :sharpness=&gt;0}, {:compression=&gt;6, :x_resolution=&gt;(72/1), :y_resolution=&gt;(72/1), :resolution_unit=&gt;2, :jpeg_interchange_format=&gt;25361, :jpeg_interchange_format_length=&gt;5397}]&gt; 

 irb(main):002:0&gt; p01.date_time_original
 =&gt; 2009-09-29 19:37:07 +0900

 irb(main):003:0&gt; p01.date_time_original.class
 =&gt; Time
||&lt;

ほうこりゃ簡単だ
EXIFR::JPEG#date_timeはTimeクラスを返すので
Time#strftimeが使える
&gt;|ruby|
 irb(main):004:0&gt; p01.date_time_original.strftime(&quot;%b %d %Y&quot;)
 =&gt; &quot;Sep 29 2009&quot;
||&lt;


**Flickrへのアップロード
次にFlickrへのアップロードだ
FlickrにはFlickr上の写真を操作するためのAPIが用意されている
APIには写真をFlickrにアップするためのメソッドもある
このAPIを使うには自分のFlickrアカウントにリンクした
API Keyを事前に取得しておく必要がある


Flickr Services
http://www.flickr.com/services/


また写真をアップするためにはそのプログラムを
対象アカウントに認証させるためのトークンの取得が必要になる


Rubyにはrflickrというライブラリがあり
認証トークンの取得および写真のアップロードの機能を持っている
これをインストールして使ってみよう

&gt;|ruby|
 % sudo gem install rflickr
||&lt;

更新が止まっていてRuby1.9には対応していない
添付のGETTING-STARTEDにはトークン取得のためのサンプルコードがある((Macでは /opt/local/lib/ruby/gems/1.8/gems/rflickr-2006.02.01/GETTING-STARTED))

&gt;|ruby|
  flickr = Flickr.new(token_cache_file,MY_APPLICATION_KEY,MY_SHARED_SECRET)
  unless flickr.auth.token
    flickr.auth.getFrob
    url = @flickr.auth.login_link
    puts &quot;You must visit #{url} to authorize this application.  Press enter&quot;+
     &quot; when you have done so. This is the only time you will have to do this.&quot;
    gets
    flickr.auth.getToken
    flickr.auth.cache_token
  end
||&lt;

このコードを実行してターミナルに表示されたURLにアクセスし
そこでこのプログラムに対する認証を行えば
token_cache_fileに認証トークンが保存されるようだ
二度目からは取得した認証トークンを使って
プログラムの認証が行われる


以上の知識を使ってFlickrPhotoクラスを書いてみた


使い方は以下のようにする
1.FlickrPhoto.set_tokenでプログラムを認証させる
2.FlickrPhoto.newで写真のオブジェクトを生成する
3.タイトルなど必要な属性をセットする
4.FlickrPhoto#uploadで写真をアップロードする


&lt;script src=&quot;http://gist.github.com/197856.js&quot;&gt;&lt;/script&gt;
保証はありませんが同じようなことで
お困りの方がおられたら使ってください


(参考)
digital:pardoe - Using rFlickr
http://digitalpardoe.co.uk/blog/show/87


Ruby を使って Flickr へ写真をアップロード - まちゅダイアリー(2008-10-20)
http://www.machu.jp/diary/20081020.html#p01


(追記:2009/10/11)撮影日を取得するのにdate_timeではなくdate_time_originalを使うよう修正しました。API KeyをPitを使って管理するようにしました。

&lt;a href=&quot;http://subtech.g.hatena.ne.jp/cho45/20080102/1199257680&quot;&gt;アカウント情報を管理するコマンド pit - 冬通りに消え行く制服ガールは、夢物語にリアルを求めない。 - subtech&lt;/a&gt;

</body>
</day>
<day date="2010-01-21" title="">
<body>
*p1*Rubyで最短経路を探索しよう！
[http://okajima.air-nifty.com/b/2010/01/post-abc6.html:title=人生を書き換える者すらいた。: 人材獲得作戦・４　試験問題ほか]

次に同じ質問がきたときに
「1時間いらないっしょ、こんなの」
と是非ともほざくために
今から勉強します


**ダイクストラ法による最短経路探索
[f:id:keyesberry:20100202222812g:image]


図におけるＳ点からＧ点に到達するための最短経路を求めたい
各ノードを結ぶエッジを糸としてＳ点をゆっくりと持ち上げた場合
緊張する糸が変移しながら最終的にＳ－Ｂ－Ｄ－Ｇを結ぶ糸が緊張して
これが最短経路と分かる((http://ja.wikipedia.org/wiki/%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E6%B3%95))
計算機上でこの現象をシミュレートしたものを
ダイクストラ法というらしい


今各ノードとそこから伸びるエッジの情報(コストと接続先)を渡して
その最短経路および総コストを出力するプログラムを考えてみよう

&gt;|ruby|
data = {
 :s =&gt; [[5, :a], [4, :b], [2, :c]],
 :a =&gt; [[5, :s], [2, :b], [6, :g]],
 :b =&gt; [[4, :s], [2, :a], [3, :c], [2, :d]],
 :c =&gt; [[2, :s], [3, :b], [6, :d]],
 :d =&gt; [[2, :b], [6, :c], [4, :g]],
 :g =&gt; [[6, :a], [4, :d]]
 }

g = Graph.new(data)
g.print_route(:s, :g) # =&gt; s(0) -&gt; b(4) -&gt; d(6) -&gt; g(10)
||&lt;


各ノードをエッジ情報を備えたNodeクラスのオブジェクトとし
エッジ情報をEdgeクラスのオブジェクトとしてそれぞれ表現し
Graphクラス内で生成するようにしよう
各ノードオブジェクトには経路探索の経過および結果を保持するため
cost, done(確定ノードフラグ), from(直前ノードid)を用意する

&gt;|ruby|
class Node
  attr_accessor :id, :edges, :cost, :done, :from
  def initialize(id, edges=[], cost=nil, done=false)
    @id, @edges, @cost, @done = id, edges, cost, done
  end
end

class Edge
  attr_reader :cost, :nid
  def initialize(cost, nid)
    @cost, @nid = cost, nid
  end
end

class Graph
  def initialize(data)
    @nodes =
      data.map do |id, edges|
        edges.map! { |edge| Edge.new(*edge) }
        Node.new(id, edges)
      end
  end
end
||&lt;


スタートsidからゴールgidまでの最短経路を求めるrouteメソッドと
その印刷用のprint_routeを定義しよう

&gt;|ruby|
class Graph
  def route(sid, gid)
    dijkstra(sid)
    base = @nodes.find { |node| node.id == gid }
    @res = [base]
    while base = @nodes.find { |node| node.id == base.from }
      @res &lt;&lt; base
    end
    @res
  end

  def print_route(sid, gid)
    route(sid, gid)
    puts @res.reverse.map { |node| &quot;#{node.id}(#{node.cost})&quot; }.join(&quot; -&gt; &quot;)
  end
end
||&lt;


任意点nidのコストを求めるcostメソッドも定義しよう

&gt;|ruby|
class Graph
  def cost(nid, sid)
    dijkstra(sid)
    @nodes.find { |node| node.id == nid }.cost		
  end
end
||&lt;

	
そして探索アルゴリズムの核心であるdijkstraメソッドを定義しよう

&gt;|ruby|
class Graph
  private
  def dijkstra(sid)
    @nodes.each do |node|
      node.cost = node.id == sid ? 0 : nil
      node.done = false
      node.from = nil
    end
    loop do
      done_node = nil
      @nodes.each do |node|
        next if node.done or node.cost.nil?
        done_node = node if done_node.nil? or node.cost &lt; done_node.cost
      end
      break unless done_node

      done_node.done = true
      done_node.edges.each do |edge|
        to = @nodes.find{ |node| node.id == edge.nid }
        cost = done_node.cost + edge.cost
        from = done_node.id
        if to.cost.nil? || cost &lt; to.cost
          to.cost = cost 
          to.from = from
        end
      end
    end
  end
end
||&lt;


dijkstraメソッドでは次の処理をする
(1)スタートノードにコスト0をセットする
(2)確定ノードdone_nodeに最少コストのノードをセットする
(3)確定ノードのエッジの中からその接続先への総コストが最小となるよう接続先のコストを更新する
(4)未確定ノードがなくなるまで(2)(3)を繰り返す


じゃあデータを入れてみよう！

&gt;|ruby|
data = {
 :s =&gt; [[5, :a], [4, :b], [2, :c]],
 :a =&gt; [[5, :s], [2, :b], [6, :g]],
 :b =&gt; [[4, :s], [2, :a], [3, :c], [2, :d]],
 :c =&gt; [[2, :s], [3, :b], [6, :d]],
 :d =&gt; [[2, :b], [6, :c], [4, :g]],
 :g =&gt; [[6, :a], [4, :d]]
 }

g = Graph.new(data)
g.print_route(:s, :g)
puts g.cost(:d, :s)
g.print_route(:a, :c)

# &gt;&gt; s(0) -&gt; b(4) -&gt; d(6) -&gt; g(10)
# &gt;&gt; 6
# &gt;&gt; a(0) -&gt; b(2) -&gt; c(5)
||&lt;
いいみたいだ


**試験問題
Graphクラスがあればあの試験問題が解けるはずだ
まずは方針を考えよう
(1)迷路データを二次元配列として読み込む
(2)迷路上の各マス(スペースの箇所)をその座標がidである((スタートとゴールはその文字))ノードオブジェクトとしてノードデータを生成しGraphオブジェクトを生成する
(3)最短ルートを求め該当ノードを＄マークに置き換えた迷路を出力する


まずは迷路を読み込もう

&gt;|ruby|
maze = DATA.readlines.map { |line| line.chomp.split(//) }

__END__
**************************
*S* *                    *
* * *  *  *************  *
* *   *    ************  *
*    *                   *
************** ***********
*                        *
** ***********************
*      *              G  *
*  *      *********** *  *
*    *        ******* *  *
*       *                *
**************************
||&lt;


次にその座標がidになるようにノードデータを作り
それをGraphクラスに渡そう
隣接するノードのデータedgesを作るのにちょっと工夫がいる

&gt;|ruby|
nodes = {}
maze.each.with_index do |line, y|
  line.each.with_index do |data, x|
    next if data == '*'
    id = data.match(/\w/) ? $&amp; : &quot;#{y}_#{x}&quot;
    edges =
      [[-1, 0], [1, 0], [0, -1], [0, 1]].inject([]) do |mem, (_y, _x)|
        _x += x; _y += y
        case maze[_y][_x]
        when /\w/ then mem &lt;&lt; $&amp;
        when /\s/ then mem &lt;&lt; &quot;#{_y}_#{_x}&quot;
        else mem
        end
      end.map { |nid| [1, nid] }
    nodes[id] = edges
  end
end

g = Graph.new(nodes)
||&lt;


最後に最短経路を求めて
元の迷路データ上に＄マークをマッピングしよう

&gt;|ruby|
route = g.route('S', 'G')

maze.each_with_index do |line, y|
  line.each_with_index do |data, x|
    print route.find { |pos| pos.id == &quot;#{y}_#{x}&quot; } ? '$' : data
  end
  print &quot;\n&quot;
end
||&lt;

&gt;||
**************************
*S* *$$$$$               *
*$* *$ * $*************  *
*$*$$$*  $$************  *
*$$$ *    $$$$$          *
**************$***********
* $$$$$$$$$$$$$          *
**$***********************
* $$$$$*$$$$$$$$$$$$$$G  *
*  *  $$$ *********** *  *
*    *        ******* *  *
*       *                *
**************************
||&lt;

なんかよさげだ


[http://gist.github.com/282664:title=http://gist.github.com/282664]


参考：
&lt;a href=&quot;http://www.deqnotes.net/acmicpc/dijkstra/&quot;&gt;ダイクストラ法（最短経路問題）&lt;/a&gt;
&lt;a href=&quot;http://ja.wikipedia.org/wiki/%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E6%B3%95&quot;&gt;ダイクストラ法 - Wikipedia&lt;/a&gt;

</body>
</day>
<day date="2010-01-23" title="">
<body>
*p1*Termtter is a Sandbox for Rubyists!
Termtter　それはTwitterクライアント
名前を聞けば　誰でもわかる
ターミナル用　Twitterとすぐわかる


Termtter　gem install termtterでOKだ
軽やかにtermtterと　打ち込めば
ターミナルに広がる　ANSI color


Termtter　それはRubyで書かれてる
だから僕にも　きっとわかる
Rubie((RubieはRuby+newbieからなる造語です))の僕にも いつかはわかる


Termtter　それはプラグインでできている
基本機能も　ユーザコードも
コマンド全部が　プラグインでできている


$
listだって　aliasだって
updateだって　openだって
そう
Termtter is a Sandbox for Rubyists!


Termtter　だから無限に拡張できる
基本機能も　変更できる
アイデア次第で　どこまでも


shellだって　fibだって
irbだって　gだって
そう
Termtter is a Sandbox for Rubyists!


D.S.（$に戻って繰り返し）
そう
Termtter is a Sandbox for Rubyists!


～Termtter開発チームへの感謝に代えて～

[http://termtter.org/:title=Termtter]
[http://jugyo.org/blog/2931:title=System.Exit &amp;#8211; Termtter &amp;#8211; ターミナルエミュレータ上で動作する Twitter クライアント]


**この2週間のつぶやき
http://twitter.com/merborne

-(10/01/06 11:19) hello from rubytter!
-(10/01/06 11:47) termtterを入れてみたのだけど、api.rb#try_authでこける。 
-(10/01/06 11:52) try again from rubytter
-(10/01/07 11:01) Helo from termtter
-(10/01/07 11:02) おー Termtter
-(10/01/07 11:04) ライブラリがちゃんとインストールされてなかったみたい。ruby19をdeactivateしたらうまくいっ た。
-(10/01/07 14:23) termtter is colorized on screen but tmux.
-(10/01/08 10:13) なんか日本語入力がうまくいかない
-(10/01/09 21:03) hi from rubytter!
-(10/01/13 09:55) termtterでリンクを開くのはuri-open pluginを使えばいいんだ。
-(10/01/13 09:59) ε=&amp;#8932;&amp;#8933;
-(10/01/13 10:00) ε=&amp;#8932;&amp;#8933;&amp;#8932;&amp;#8933;&amp;#8932;&amp;#8933;&amp;#8932;&amp;#8933;&amp;#8932;&amp;#8933;&amp;#8932;&amp;#8933;&amp;#8932;&amp;#8933;&amp;#8932;&amp;#8933;&amp;#8932;&amp;#8933;&amp;#8932;&amp;#8933;
-(10/01/13 10:32) train plugin...
-(10/01/13 11:33) 芸術 爆発しろ!
-(10/01/13 13:11) 爆発くろ 爆発しろ!
-(10/01/13 13:12) 爆発あか！ 爆発しろ!
-(10/01/13 13:12) !ろし発爆 爆発しろ!
-(10/01/13 13:13) plugin bomb 爆発しろ!
-(10/01/13 13:24) Listening now: 雪の華 (6:01) パク・ヒョシン Sorry, I love you
-(10/01/13 13:26) iTunes plugin
-(10/01/13 13:26) Listening now: God (4:10) John Lennon John Lennon/Plastic Ono Band
-(10/01/13 14:03) #termtterが壊れた [ERROR] Rubytter::APIError: Rate limit exceeded. Clients may not make more than 150 requests per hour. web
-(10/01/13 14:06) jugyo: @merborne API limit ですね  (reply_to [$ca])
-(10/01/13 14:21) @jugyo どうもです。followersコマンドしたら固まったのが原因かな。termtter楽しいです。勉強 になります。  (reply_to [$bz]) web
-(10/01/13 15:06) #termtter息を吹き返す
-(10/01/13 19:45) termtterの中でirbも使える!
-(10/01/13 22:32) termtterの中でgも使える! g (1..10).inject(:*)とか interactive g?
-(10/01/14 18:13) termtterで使っているTermColorライブラリ面白い
-(10/01/14 18:16) irb -rtermcolorとしてputs &quot;&lt;on_green&gt;&lt;red&gt;&lt;underline&gt;Hello, TermColor!&lt;/underline&gt;&lt;/red&gt;&lt;/on_green&gt;&quot;.termcolorとか
-(10/01/14 18:17) puts TermColor.colorize('hello', 'red')とか
-(10/01/14 18:28) でTermColorはHighLineというライブラリを使っていて、こちらはerbを使う。irb -rhighline/importしして say &quot;Hello, &lt;%= color('HighLine!', :red, :on_green, :underline) %&gt;とか
-(10/01/14 18:42) HighLineにはinput validationもあってans = ask(&quot;love or hate?: &quot;){|q| q.in = %w(love hate)}とかできる
-(10/01/14 19:15) termtterの色を変える方法を未だ発見できず...blueが見づらいので
-(10/01/14 19:20) jugyo: @merborne eval config.plugins.stdout.colors = , :magenta, :cyan ] みたいにすると使う色を変えられます  (reply_to [$bq])
-(10/01/14 19:29) @jugyo できました　ありがとうございます  (reply_to [$cb])
-(10/01/15 09:27) TerminalのANSIカラーを調整できるツールを見つけた これでtermtterを一層キレイに! http://www.culater.net/software/TerminalColors/TerminalColors.php
-(10/01/15 09:29) TerminalColors leopard版も http://niw.at/articles/2007/11/02/TerminalColoreopard/ja
-(10/01/15 09:54) termtterでurlを短くするにはtinyurl pluginを使えばいいんだ #termtter Termtter&gt; 
-(10/01/15 10:00) termtter上でtinyurlを展開して表示するにはexpand-tinyurl pluginを使えばいいんだ
-(10/01/15 10:19) termtterで特定のポストのurlを開くにはopen pluginを使って o ID とすればいいんだ
-(10/01/15 11:26) termtterでポストを削除するにはdel [ID]とすればいいんだ 直前のポストならdel とだけすればいいんだ
-(10/01/15 11:31) termtterでポスト前にconfirmationするにはconfirm pluginを使えばいいんだ config.confirm=trueも試してみたけど動かなかった
-(10/01/15 11:33) jugyo: @merborne config.confirm=true が動かないのはおかしいですねぇ..  (reply_to [$bb])
-(10/01/15 15:17) termtterで写真をポストするにはtwitpic pluginを使って twitpic [message] /path/to/a/photo.jpg とすればいいんだ(要twitpic gem)
-(10/01/15 19:01) termtterで日本語が長くなると挙動が変になる やっぱ環境がおかしい ruby入れ直そうかな
-(10/01/17 15:25) termtterで20件以上のポストを見たい場合は l -40 とかすればいいんだ
-(10/01/17 15:27) termtterで古いポストを遡りたいときは list_with_opts pluginを使って l -p=2とかすればいいんだ
-(10/01/17 21:48) termtterでステータスのurlを開くにはuri-open pluginを使えばいいんだ
-(10/01/17 22:01) uri-openでは uo in $arとしても uo listか ら=&gt; uo 3としても uo allとしてもいいんだ
-(10/01/18 09:04) termtterで日本語を入力するときに行の折り返し位置で挙動がおかしくなっていたのはTerminal.appのエミュレーション設定で行の折り返しを逆にするがオンになっていたからだったた
-(10/01/18 19:01) hello_from_frfx_w_tmtr
-(10/01/22 19:14) termtterでhashtagを付けてupdateするときは hashtag add termtterとすればpromptがtag付きになりupdateに自動でhashtagが付くんだ
-(10/01/22 19:18) hashtag listで一覧 hashtag clearで消去 一時的にhashtagを付けたくないときはraw_updateでポ ストすればいいんだ
-(10/01/22 19:29) termtterでコマンドを短くしたいときはalias li uri-open listとするかconfigにconfig.plugins.alias.aliases={:li=&gt;'uri-open list'}とすればいいんだ

</body>
</day>
<day date="2010-01-25" title="">
<body>
*p1*Termtterでuriを開こう！ - uri-openの紹介と改良
Termtterにはstatus内のuriを開くための
uri-openという便利なpluginがある
&gt;|ruby|
&gt; uri-open list または uo list
||&lt;
とすればstatusのuriが連番付きでリスト表示されるので
次いで
&gt;|ruby|
&gt; uri-open 3
||&lt;
などとして対象のuriを選べばいい
このときexpand-tinyurlというpluginを使って
リスト表示されるuriを短縮形から直しておくのがいい


Termtterには入力のタブ補完機能があるので
長いcommand入力も苦にはならないけど
良く使うcommandにはaliasを割り当てるのが便利だ
.termtter/configファイルで以下のようにする
&gt;|ruby|
config.plugins.alias.aliases = {
  :o =&gt; 'uri-open',
  :ul =&gt; 'uri-open list',
}
||&lt;


また各statusには$amのようなIDが付いているので
&gt;|ruby|
&gt; o in $am
||&lt;
とすればstatusを指定してopenできる
最も新しいstatusを開く場合は単に
&gt;|ruby|
&gt; o
||&lt;
とすればいい


個別のuriを開くのが面倒ならば
不要なuriを
&gt;|ruby|
&gt; o delete 5
||&lt;
などとしてから
&gt;|ruby|
&gt; o all
||&lt;
とすればすべて一度にopenすることもできる


uri-open allは確かに便利だけれど
listに大量のuriが入っている場合大変なことになる
そこで僕はuri-openを少しいじって
いくつかのuriをopenするsomeコマンドを追加してみた

&gt;|ruby|
uri-open.rb

7d6
&lt; config.plugins.uri_open.set_default :some, 5
46,51d44
&lt;   when /^some\s*(\d*)$/
&lt;     some = $1.empty? ? config.plugins.uri_open.some : $1.to_i
&lt;     some.times do
&lt;       return unless uri = public_storage[:uris].shift
&lt;       open_uri(uri)
&lt;     end
83c75
&lt;   %w(all list delete clear in some).grep(/^#{Regexp.quote arg}/).map {|a| &quot;#{cmd} #{a}&quot; }
---
&gt;   %w(all list delete clear in).grep(/^#{Regexp.quote arg}/).map {|a| &quot;#{cmd} #{a}&quot; }
||&lt;


これにより
&gt;|ruby|
&gt; o some
||&lt;
で最新の5つのuriがopenする
&gt;|ruby|
&gt; o some 10
||&lt;
とすれば10のuriがopenする


.termtter/configに
&gt;|ruby|
config.plugins.uri_open.some = 3
||&lt;
とすればdefaultの5つを変更できる
またconfigに
&gt;|ruby|
config.plugins.alias.aliases = {
  :some= =&gt; 'eval config.plugins.uri_open.some='
}
||&lt;
とaliasを追加すれば
&gt;|ruby|
&gt; some= 10
||&lt;
で一時的にdefaultを変更できる((someと=の間にspaceを空けない))


それからuri-open in $am で個別にopenするときに
$を省略して
&gt;|ruby|
&gt; o in am
||&lt;
と打てるようにもしてみた

&gt;|ruby|
uri-open.rb

68d60
&lt;    id = Termtter::Client.typable_id_to_data(id) unless id =~ /\d+/
||&lt;


Termtterはこういった改良を簡単にできるので
便利だし勉強にもなる

</body>
</day>
<day date="2010-01-30" title="">
<body>
*p1*リアルタイム共有の勝者はだれ？
Twitterは何故成功したのか
いろいろなことが言われているけれども
その理由ははっきりしている
140文字という字数制限なんかじゃない
followというユーザ連係の仕組みでもない


それは入力インタフェースにある
Twitterにはその入力インタフェースとして
１つのテキストフィールドしかない((正確には一対のテキストフィールドとボタン))
ユーザがそのサービスを利用するために
向き合うのは１つのテキストフィールドだけだ


人間がなかなか新しいことを始められないのは
自分の中の無意識が自分が知らないということを忌避するからだ
込み入ったインタフェースを見ると人の脳は
この無意識によって機能不全に陥る


だけどそこに１つのテキストフィールドしかなければ
ただそこに文字を打つしかない
人はその事実をすぐに悟り
それが恐怖を消し去り安心感を与える
１つのテキストフィールドは誰も無知にしない
入力インタフェースとしての最も広い間口なんだ


一方熟練ユーザは常に多くのことをサービスに求める
その圧力に屈した一部のサービスは
追加フィールド　サイドバー　タブメニューを追加し
タイトル　キーワード　任意オプション付けを可能にする　
そうしてそのサービスは終わりの始まりを迎える
つまり奥深くなったサービスの間口は
その分だけ狭くなってしまう


だけど今のところTwitterは違う


Twitterは１つのテキストフィールドのスタイルを堅持し
そこで熟練ユーザの要求に応えるようにした
１つのテキストフィールドに入力された文字列を解析し
その結果に応じて返信　私信　引用　キーワード付けを可能にした
つまりサービスの間口を狭くすることなく
それを奥深いものにすることに成功したんだ


しかしそんなTwitterにも今のところ
１つの欠点がある


それが検索インタフェースだ


実はTwitterにはテキストフィールドが２つある
その第２のテキストフィールドが検索インタフェースだ


リアルタイム検索の重要性は日々増している
なぜならリアルタイム検索は時間を共有するツールであり
人々は本能的にそれを必要としているからだ
Googleは知識を共有するためのツールであり
残念ながらその要求に応えることはできない


人々がGoogleで頻繁に検索するように
リアルタイム検索をする日はそう遠くはない
そのときTwitterにおける現在の検索フィールドは
その要求には答えられない


その要求に応えられるインタフェースというものが
どういったものかはまだ見えないけれども
それを制するものがリアルタイム検索
延いてはリアルタイム共有の勝者になる
そう僕は思うんだ

*p2*Termtterで写真を投稿しよう！ - twitpic plugin
Termtterにはtwitpicというpluginが付属していて
これを使えば写真が投稿できる
twitpicはTwitterに連係されたサービスで
Twitterのアカウントがあれば無料で利用できる

twitpic pluginを使うために
&gt;||
&gt; plug twitpic
||&lt;
して((または.termtter/configでtwitpicを有効にする))
&gt;||
&gt; twitpic this is me! /path/to/the/file.png
||&lt;
とすればtwitpicへ写真がポストされ
timelineもupdateされる((fileパスはフルパスで))
また
&gt;||
&gt; twitpic my desktop!
||&lt;
のようにfileパスを付けなければ
マウスカーソルがcaptureモードになるので
click&amp;dragで範囲を決めればdesktopがcaptureされ
それが投稿画像になる


ただcaptureモードにはちょっとバグがあるので
うまくいかない場合は以下を追加する((tmp directoryが存在しない場合))
&gt;|ruby|
twitpic.rb
15d14
&lt; require &quot;fileutils&quot;
28d26
&lt;     FileUtils.mkdir_p(File.dirname(path)) unless File.exist?(File.dirname(path))
||&lt;

</body>
</day>
<day date="2010-02-03" title="">
<body>
*p1*Rubyでアニメーション・グラフを作ろう！
[f:id:keyesberry:20100203194757g:image]


[http://d.hatena.ne.jp/syou6162/20090625/1245895885:title=ベルマンフォードのアルゴリズムで実行される結果も逐次表示 - Seeking for my unique color.]


を見てGraphVizの出力からアニメーションgifを作りたくなった
Rubyにはruby-graphvizというGraphVizのinterface libraryと
RMagickというImageMagickのinterface libraryがあり
これらを使えば目的は達成できるみたいだ


ruby-graphvizのinterfaceは自分にはわかり辛かったので
これをラップする形でGraphAz((Graph Animatize?))というクラスを書いて
上のアニメーションgifを出力してみた
用途が限定的で実装にも問題がありそうだけれど
GraphVizのDOTデータの出力としても使えるので
無責任無保証で使ってくれる人がいればうれしい


**使い方
コードを見るのが早いと思うので
簡単な例を示した
まずはDOTデータを作る例
&gt;|ruby|
require &quot;graphaz&quot;

routes = [
  ':main =&gt; :parse =&gt; :execute',
  ':main =&gt; :init',
  ':main =&gt; :cleanup',
  ':execute =&gt; :make_string',
  ':execute =&gt; :printf',
  ':init =&gt; :make_string',
  ':main =&gt; :printf',
  ':execute =&gt; :compare'
  ]

ga = GraphAz.new(:G)
routes.each { |route| ga.add route }
ga.print_graph
||&lt;
GraphAz.newでオブジェクトを生成し
addメソッドで用意したルートを追加する
addメソッドは対応するノードとエッジを同時に生成する
最後にprint_graphメソッドを呼べば
DOTデータが標準出力に出力される


コマンドラインから以下のように実行すれば
DOTファイルが生成される
&gt;|ruby|
&gt; ruby small_graph.rb &gt; small_graph.dot
||&lt;


[http://www.pixelglow.com/graphviz/:title=pixelglow | graphviz]
などのツールで開けば以下のような
グラフが得られるはずだ


[f:id:keyesberry:20100203194922p:image]



今度はアニメーションgifを作成してみる
コードを示す
&gt;|ruby|
require &quot;graphaz&quot;

routes = [
  ':main =&gt; :parse =&gt; :execute',
  ':main =&gt; :init',
  ':main =&gt; :cleanup',
  ':execute =&gt; :make_string',
  ':execute =&gt; :printf',
  ':init =&gt; :make_string',
  ':main =&gt; :printf',
  ':execute =&gt; :compare'
  ]

ga = GraphAz.new(:G)
routes.each { |route| ga.add route }
ga.lap

color = 'tomato'
ga.node('main', :style =&gt; 'filled', :fillcolor =&gt; color)
ga.lap

ga.edge('main_parse', :color =&gt; color)
ga.node('parse', :style =&gt; 'filled', :fillcolor =&gt; color)
ga.lap

ga.edge('parse_execute', :color =&gt; color)
ga.node('execute', :style =&gt; 'filled', :fillcolor =&gt; color)
ga.lap

ga.edge('execute_make_string', 'execute_compare', 'execute_printf', :color =&gt; color)
ga.node('make_string', 'compare', 'printf', :style =&gt; 'filled', :fillcolor =&gt; color)
ga.lap

ga.write
||&lt;
15行目までは同じで
16行目でprint_graphに代えてlapメソッドを使う
lapメソッドはそこまでのコードに基づいて
グラフをimageファイルとしてcurrent directoryに出力する((defaultでファイル名はout0.png))


次にnodeまたはedgeメソッドを使って
グラフの属性を変化させる
node,edgeメソッドは
複数のnode, edgeおよび属性を取ることができる
その後lapメソッドを使ってそこまでの変化を出力する


これを繰り返し
最後にwriteメソッドを呼ぶことによって
lapメソッドで出力したファイルを読み込み
１つのgifファイルout.gifを生成する
他のimageファイルはdefaultでは削除される


out.gifをブラウザなどで開き
アニメーションgifが完成しているか確認する


[f:id:keyesberry:20100203194956g:image]



ノードを後から追加するなどイメージデータのサイズが変わると
うまくいかないなどの問題があります

(追記：2010-02-04) タイトルとrubyclass_graph.rbを修正しました
(追記：2010-02-18) Ruby1.9対応です。それ以前のRubyで使うときはnodeとedgeメソッドの第一引数の*を削除して配列を渡すようにしてください
(追記：2010-10-24) graphvizの0.9.9以降のヴァージョンではうまく動作しません。version0.9.8を使ってください
(追記：2010-10-25) graphviz ver.0.9.18に対応しました。clusterを表現できるようになりました。


[http://github.com/melborne/graphaz:title=melborne's graphaz at master - GitHub]


*p2*Termtterで検索しよう!
飛ぶ鳥落とす勢いの　Twitter！
猫も杓子もつぶやくよ　Twitter！
今起きた　もう寝ます
はら減った　めし食った


飛ぶ鳥落とす勢いの　Twitter！
自分も鳥だよ　Twitter！
渋谷なう　バイトなう
カレーなう　ユニクロなう


飛ぶ鳥落とす勢いの　Twitter！
アキレス腱は検索だ　Twitter！
オプションいっぱい　窓小さい
説明どこにも　見当たらない


飛ぶ鳥落とす勢いの　[http://termtter.org/:title=Termtter]！
Twitterの救世主　Termtter！
ポストもサーチも　コマンドも
コマンドラインで　一括処理


飛ぶ鳥落とす勢いの　Termtter！
正しい発音　ターマッター？((発音には諸説あるそうです http://twitter.com/jugyo/status/8493182880))
みんなで一緒に　ターマッター？
みんなで一緒に　検索しよう！


AND検索をする
&gt;|ruby|
&gt; s ruby termtter
||&lt;


OR検索をする
&gt;|ruby|
&gt; s ruby OR termtter
||&lt;


topic検索をする
&gt;|ruby|
&gt; s #ruby
||&lt;


特定ユーザのpost内で検索する
&gt;|ruby|
&gt; s ruby from:yukihiro_matz from:yugui
||&lt;


特定ユーザのすべてのpostを見る
&gt;|ruby|
&gt; s from:jugyo　または list @jugyo
||&lt;


特定ユーザを除外して検索する
&gt;|ruby|
&gt; s ruby -from:merborne
||&lt;


特定ユーザへのreplyを見る
&gt;|ruby|
&gt; s to:merborne
||&lt;


自分へのreplyを見る
&gt;|ruby|
&gt; r
||&lt;


特定ユーザへの言及を見る
&gt;|ruby|
&gt; s @ujm OR @jugyo
||&lt;


使用clientを特定して検索する
&gt;|ruby|
&gt; s termtter source:termtter
||&lt;


自分がしたretweetを見る
&gt;|ruby|
&gt; retweeted_by_me
||&lt;


friendsがしたretweetを見る
&gt;|ruby|
&gt; retweeted_to_me
||&lt;


自分がretweetされたものを見る
&gt;|ruby|
&gt; retweets_of_me
||&lt;


特定postのretweet状況を知る
&gt;|ruby|
&gt; retweets ID
||&lt;


自分はさらにstandard_commands.rbに少し変更を加えて
以下のことができるようにしました


検索結果の件数を指定して検索する
&gt;|ruby|
&gt; ruby -30
||&lt;


検索結果の次頁以降を表示する
&gt;|ruby|
&gt; ruby #2
||&lt;


hashtagモードのとき検索queryがなければ
そのhashtagで検索する
&gt;|ruby|
&gt; hashtag add termtter
#termtter&gt; s
||&lt;


.termtter/configで検索結果のhighlight色を指定できるようにする
&gt;|ruby|
 config.search.colors = [:underline]
||&lt;


&gt;|ruby|
standard_commands.rb
128d127
&lt;   config.search.set_default(:colors, [:on_magenta, :white])
133,142d131
&lt;       arg.gsub!(/\s*([-#])(\d+)/) do
&lt;         case $1
&lt;         when '-' then search_option[:rpp] = $2
&lt;         when '#' then search_option[:page] = $2
&lt;         end
&lt;         ''
&lt;       end
&lt;       if arg.empty? &amp;&amp; tags = public_storage[:hashtags]
&lt;         arg = tags.to_a.join(&quot; &quot;) 
&lt;       end
150c139
&lt;     :help =&gt; [&quot;search,s TEXT [-COUNT] [#PAGE]&quot;, &quot;Search for Twitter&quot;]
---
&gt;     :help =&gt; [&quot;search,s TEXT&quot;, &quot;Search for Twitter&quot;]
156,159c145
&lt;       text.gsub(/(#{query})/i) do |q|
&lt;         config.search.colors.each { |color| q = TermColor.colorize(q, color) }
&lt;         q
&lt;       end
---
&gt;       text.gsub(/(#{query})/i, '&lt;on_magenta&gt;&lt;white&gt;\1&lt;/white&gt;&lt;/on_magenta&gt;')
||&lt;

</body>
</day>
<day date="2010-02-04" title="">
<body>
*p1*Rubyでカラフルにグラフを書こう！ ーGraphViz色見本
GraphVizを使ったグラフ作りは楽しい
でも以外と時間が掛かる
特に時間を取られるのは色選びだ


GraphVizで使える色は豊富だけれども
豊富過ぎて名前を見ただけでは色がわからない
だから[http://d.hatena.ne.jp/keyesberry/20100203/p1:title=前回]作ったGraphAzで
色見本を作ってみた
これで色選びもばっちり！


[f:id:keyesberry:20100204190753p:image]



作成コードも貼っておきます


[http://gist.github.com/294499:title=gist: 294499 - GitHub]
</body>
<comments>
<comment>
<username>alifeclub</username>
<body>いつも楽しく観ております。&lt;br&gt;また遊びにきます。&lt;br&gt;ありがとうございます。</body>
<timestamp>1281084310</timestamp>
</comment>
</comments>
</day>
<day date="2010-02-05" title="">
<body>
*p1*Rubyでいろんなかたちと矢印のグラフを書こう！ ーGraphViz Shape&amp;Arrow見本
GraphVizを使ったグラフ作りは楽しい
でも以外と時間が掛かる
特に時間を取られるのはノードのかたちと
エッジの矢印選びだ


GraphVizで使えるかたちと矢印は豊富だけれども
豊富過ぎて名前を見ただけではそれがわからない
だから[http://d.hatena.ne.jp/keyesberry/20100203/p1:title=前々回]作ったGraphAzで見本を作ってみた
これでかたちと矢印選びもばっちり！


[f:id:keyesberry:20100205155010g:image]


&lt;script src=&quot;http://gist.github.com/294499.js&quot;&gt;&lt;/script&gt;
</body>
</day>
<day date="2010-02-06" title="">
<body>
*p1*Rubyのランダムをグラフ化しよう！


「1～100までの数字をランダムに繋ぐ」


そんな単純なことでも
それが視覚化されると不思議な存在になる
ツリーの頂点にある数字が特異点に思えてくる
互いに繋がりあった２つの数字に友愛数のような
意味付けを求めたくなる
並びの偶然性に純粋に美を感じる
あるいはそこから
なんらかのゲームを発見するかもしれない


さあ　ランダムグラフを作ろう！


[f:id:keyesberry:20100206211238p:image]


[f:id:keyesberry:20100206211240p:image]


[f:id:keyesberry:20100206211241p:image]


[f:id:keyesberry:20100206211237p:image]


&lt;script src=&quot;http://gist.github.com/296691.js&quot;&gt;&lt;/script&gt;


関連記事：[http://d.hatena.ne.jp/keyesberry/20100203/p1:title=Rubyでアニメーション・グラフを作ろう！ - hp12c]


*p2*Rubyで属性を指定してグラフを書こう！ ーGraphViz属性リスト
GraphVizを使ったグラフ作りは楽しい
でも以外と時間が掛かる
特に時間を取られるのは属性選びだ


GraphVizで使える属性は豊富だけれども
豊富過ぎて何がなんだかわからない
だから[http://d.hatena.ne.jp/keyesberry/20100203/p1:title=前々々回]作ったGraphAzで
ノード　エッジ　グラフの属性リストを作ってみた
これで属性選びもばっちり！


node属性
[f:id:keyesberry:20100206082304p:image]


edge属性
[f:id:keyesberry:20100206082343p:image]


graph属性
[f:id:keyesberry:20100206082344p:image]


&lt;script src=&quot;http://gist.github.com/294499.js&quot;&gt;&lt;/script&gt;
</body>
</day>
<day date="2010-02-07" title="">
<body>
*p1*TermtterならGoogle検索だってできる
Termtterはpluginによる拡張ができる
パッケージには最初からたくさんのpluginが含まれているので
自分の好みに合わせて機能拡張ができるだけでなく
自分でpluginを書くときの参考としても利用できる


Termtter本体のコードは僕には難易度が高いけれども
pluginならなんとかいけそうだ


pluginとして登録できる機能には
コマンドラインから実行させるCommand
Termtterの動作をフックするHook
出力をフィルタするFilter
簡単なCommandを登録するMacro
Commandエイリアスを登録するaliasなどがある


pluginはRubyによるDSLのようになっていて
Termtter::Clientモジュールのregister_commandメソッドや
register_hookメソッドにHashの値を渡すようにして記述できる

&gt;|ruby|
Termtter::Client.register_command(
  :name =&gt; :fib,
  :exec =&gt; lambda {|arg|
    n = arg.to_i
    text = &quot;fib(#{n}) = #{fib n}&quot;
    Termtter::API.twitter.update(text)
    puts &quot;=&gt; &quot; &lt;&lt; text
  }
)
||&lt;
http://termtter.org/plugins


**Google検索plugin
Termtterは検索の使い勝手がいいので
ここでGoogleも検索できたらきっと面白い
少し調べるとgoogle-searchというRubyのライブラリがあったので
これを使って作ってみた
使ってくれる人がいたらうれしい
なおuri-open pluginが必要になる


[f:id:keyesberry:20100207230009p:image]


使い方はgsearchコマンドに続けてクエリーを打つ
&gt;|ruby|
&gt; gsearch termtter または gs termtter
||&lt;


8件の結果が番号付きでリストされるので
&gt;|ruby|
&gt; 3
||&lt;
のように番号を指定して開く


次の8件の検索結果を見たいときは
&gt;|ruby|
&gt; gnext または gn
||&lt;
とする


.termtter/configで設定を少し変更できる
&gt;|ruby|
 config.plugins.gsearch.colors = ['red','on_green','underline']  # defaultは ['green']
 config.plugins.gsearch.verbose = false                  # defaultは true
 config.plugins.gsearch.lang = :en                       # defaultは :ja
 config.plugins.gsearch.size = :small                    # defaultは :large
||&lt;
colorsで検索結果の色を変更できる
verbose=falseでtitleとuriだけの表示になる
langで対象言語を指定できる
size=:smallで表示数が4件になる(:largeは8)


また.termtter/configで
&gt;|ruby|
 config.plugins.gsearch.site = 'd.hatena.ne.jp/keyesberry'
||&lt;
のように特定のサイトを指定した場合 -s(または-site) optionが働いて
&gt;|ruby|
&gt; gs -s ruby または gs -site ruby
||&lt;
で指定サイト内の検索ができる
自分の過去の投稿を検索するとき重宝する


いくつか問題点があります
-日本語検索ができない
-uriを１つ開くと一覧の番号と開く番号がずれる
-シングルクオートなどが文字化けする
-uri_openのuriバッファを汚す


(追記：2010/2/8) コードのupdateと対応する説明を追加しました
(追記：2010/2/8) サイト指定検索のコードと説明を追加しました


[http://gist.github.com/297408:title=gist: 297408 - Termtter plugins- GitHub]


*p2*Rubyで素数とフィボナッチを視覚化しよう！　ーGraphAzサンプル

数字のランダムグラフができたなら
次にやることは決まってる
そうみんな大好き
素数とフィボナッチだ


最初のグラフは素数グラフ
1～100の間にある25個の素数を順番に色付けする
[f:id:keyesberry:20100207132156g:image]


次のグラフはフィボナッチグラフ
50番目までのフィボナッチ数を順番に色付けする
[f:id:keyesberry:20100207144522g:image]


 *グラフはクリックすると拡大します


関連記事：
[http://d.hatena.ne.jp/keyesberry/20100203/p1:title=Rubyでアニメーション・グラフを作ろう！ - hp12c]
[http://d.hatena.ne.jp/keyesberry/20100206/p1:title=Rubyのランダムをグラフ化しよう！ - hp12c]


&lt;script src=&quot;http://gist.github.com/296691.js&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2010-02-08" title="">
<body>
*p2*Termtterでmoreしようよ
[http://d.hatena.ne.jp/keyesberry/20100208/p1:title=前回] Termtterのlistコマンドとsearchコマンドを改良して
&gt;|ruby|
&gt; list #2
&gt; search #2
||&lt;
のように次頁以降をリストできるようにした


でも#数字って打ち辛いよね


そこでredoコマンドを参考にして
moreコマンドを実装してみた


listまたはsearchコマンドを実行した後
&gt;|ruby|
&gt; more
||&lt;
とすればその続き((時系列ではそれ以前))をリストできる
moreを繰り返せば
席を外している間に流れてしまったTimelineを
どこまでも遡れるんだ


これはなかなか便利！


さらに[http://d.hatena.ne.jp/keyesberry/20100207/p1:title=TermtterならGoogle検索だってできる - hp12c] 
で追加したgoogle検索にもmoreを対応させたよ(追記:2010/2/9)


&lt;script src=&quot;https://gist.github.com/297408.js?file=default_replace.rb&quot;&gt;&lt;/script&gt;

*p1*TermtterでコマンドのDefault挙動を変更する
以前の投稿でTermtterのsearchなどのDefaultの挙動を
直接Termtterのコードを書き換えることで行った


[http://d.hatena.ne.jp/keyesberry/20100125/p1:title=Termtterでuriを開こう！ - uri-openの紹介と改良 - hp12c]
[http://d.hatena.ne.jp/keyesberry/20100203/p2:title=Termtterで検索しよう! - hp12c]


だけどこの方法はよくない
トラブル回避のために元のコードをどこかに保存しなきゃいけないし
Termtterのversion upで変更は消えてしまう


幸いTermtterは基本コマンドまでもが
pluginで作られているので
同名のコマンドのpluginを用意すれば
基本コマンドの上書きが可能になる


そこで自分は基本コマンドの変更versionを
default_replaceというpluginファイルにまとめて
これをpluginの最後で読み込むようにした


変更点は以下の通り
- searchコマンドで search ruby #2 などと次頁以降の結果を表示
- hashtag addしたときqueryなしでsearchするとそのhashtagをqueryとして検索
- search wordのハイライト表示をunderlineに変更
- listコマンドで list #2 などとして次頁以降を表示
- uri-openコマンドで some あるいは some 10 などとして5あるいは10のuriのみを開く


[http://gist.github.com/297408:title=gist: 297408 - Termtter plugins- GitHub]

</body>
</day>
<day date="2010-02-10" title="">
<body>
*p1*Termtterならニュース検索だってできる

gsearch pluginを改良してGoogle News Searchにも対応しました
ただheadline newsは見れません
config.plugins.gsearch.verbose = trueとすることで
contents表示モードになります


[f:id:keyesberry:20100210153209p:image]


関連記事：[http://d.hatena.ne.jp/keyesberry/20100207/p1:title=TermtterならGoogle検索だってできる - hp12c ]


[http://gist.github.com/297408:title=gist: 297408 - Termtter plugins- GitHub]
</body>
</day>
<day date="2010-02-12" title="">
<body>
*p1*TermtterならBlogだってVideoだってPatentだって
gsearch pluginを改良して以下のGoogle検索に対応させました
-Google Web Search
-Google Blog Search
-Google Book Search
-Google Image Search
-Google Video Search
-Google News Search
-Google Patent Search

&lt;del datetime=&quot;2010-02-15T09:22:46+09:00&quot;&gt;なお日本語検索ができないという致命的な問題があります&lt;/del&gt;
(追記：2009/2/15)日本語検索に対応しました

**使い方
***Google Web Search
Web検索は以下のようにする
&gt;|ruby|
&gt; google_web ruby または google ruby または gs ruby
||&lt;
[f:id:keyesberry:20100212095148p:image]


起動optionとして l(lang) v(verbose) p(page_size)があって
&gt;|ruby|
&gt; gs -l en -v true -p small ruby
||&lt;
とすると結果は以下のようになる
[f:id:keyesberry:20100212095138p:image]


site指定もできる
&gt;|ruby|
&gt; gs termtter site:d.hatena.ne.jp/keyesberry
||&lt;
[f:id:keyesberry:20100212095139p:image]


.termtter/configでsiteのdefault値を予め以下のようにしておけば
&gt;|ruby|
 config.plugins.google.site = 'd.hatena.ne.jp/keyesberry'
||&lt;
 --siteオプションが使える  
&gt;|ruby|
&gt; gs termtter --site
||&lt;

もちろんTermtterのaliasを使ってサイト指定してもいい
&gt;|ruby|
 config.plugins.alias.aliases = {
    :amazon =&gt; 'gs site:www.amazon.co.jp',
    :wiki      =&gt; 'gs site:ja.wikipedia.org'
 }
||&lt;
こうしておけばAmazonコマンドでAmazonの書籍検索が
wikiコマンドでwikipediaの検索ができるようになる


結果のリストはuri-open pluginで開くことができるが
以下に添付のdefault_replace pluginを使えば
&gt;|ruby|
&gt; 3
||&lt;
と番号を指定して開いたり
&gt;|ruby|
&gt; some 5
||&lt;
として0～4を一度に開くことができる

***Google Blog Search
Blog検索は以下のようにする
&gt;|ruby|
&gt; google_blog google buzz または gb google buzz
||&lt;
[f:id:keyesberry:20100212095147p:image]


起動optionはWebと同じ
&gt;|ruby|
&gt; gb -l ch -v true -p small google buzz
||&lt;

***Google Book Search
Book検索は以下のようにする
&gt;|ruby|
&gt; google_book ruby または gbk ruby
||&lt;
[f:id:keyesberry:20100212095141p:image]


起動optionは lとp
&gt;|ruby|
&gt; gbk -l en -p small ruby
||&lt;
[f:id:keyesberry:20100212095142p:image]


***Google Image Search
Image検索は以下のようにする
&gt;|ruby|
&gt; google_image flower または gi flower
||&lt;
[f:id:keyesberry:20100212095146p:image]


起動optionは -lvpに加えて c(color) t(image_type) f(file_type) s(image_size)がある
&gt;|ruby|
&gt; gi flower -c blue -t clipart -f gif -s large
||&lt;
[f:id:keyesberry:20100212095144p:image]


選択肢は以下のとおり
&gt;|ruby|
  # :image_size = :icon, :small, :medium, :large, :xlarge, :xxlarge, :huge
  # :image_type = :face, :photo, :clipart, :lineart
  # :file_type = :jpg, :png, :gif, :bmp
||&lt;

***Google Video Search
Video検索は以下のようにする
&gt;|ruby|
&gt; google_video rubyconf または gv rubyconf
||&lt;
[f:id:keyesberry:20100212102205p:image]


起動optionは -lvp

***Google News Search
News検索は以下のようにする
&gt;|ruby|
&gt; google_news google buzz または gn google buzz
||&lt;
[f:id:keyesberry:20100212095140p:image]


起動optionは -vpに加えて e(edition) t(topic) r(relative_to)がある
&gt;|ruby|
&gt; gn -e us -t entertainment -r NY people
||&lt;
[f:id:keyesberry:20100212095143p:image]


選択肢は以下のとおり
&gt;|ruby|
  # :news_edition = ex. :jp, :us, :uk, :fr_ca..
  # :news_topic = :headlines, :world, :business, :nation, :science,
  #               :elections, :politics, :entertainment, :sports, :health
  # :news_relative_to = ex. city, state, province, zipcode..
||&lt;

***Google Patent Search
Patent検索は以下のようにする
&gt;|ruby|
&gt; google_patent programmig multithread または gp programmig multithread
||&lt;
[f:id:keyesberry:20100212095145p:image]


起動optionは -vpに加えて i(issued_only)がある
&gt;|ruby|
&gt; gp multithread -i true
||&lt;

***設定
検索のdefault設定は以下のようになっている
&gt;|ruby|
  :verbose            =&gt; false
  :colors             =&gt; ['green']
  :lang               =&gt; :ja
  :page_size          =&gt; :large
  :news_edition       =&gt; :jp
  :news_topic         =&gt; :headlines
  :patent_issued_only =&gt; false
||&lt;


これらdefault値は.termtter/configで変更できる
&gt;|ruby|
 config.plugins.google.verbose = true
 config.plugins.google.colors = ['red', 'on_blue', 'underline']
 config.plugins.google.lang = :en
        :
        :
||&lt;
[f:id:keyesberry:20100212095149p:image]


コードはすべてTermtter licenseに準拠します


(追記：2010/2/21)aliasについての記述を追加しました


[http://gist.github.com/297408:title=gist: 297408 - Termtter plugins- GitHub]

</body>
</day>
<day date="2010-02-16" title="">
<body>
*p1*Termtterなら暗号だって回文だって
Twitterが流行ってます
床屋さんにＴＬが流れる光景も普通になりました
そんなわけでTermtter用update_mirror commandを作りました
&gt;|ruby|
&gt; update_mirror hello world from termtter! または um hello...
 =&gt; &quot;update !rettmret morf dlrow olleh #mirrormessage&quot;
||&lt;


Twitterが流行ってます
短い文章に慣れると回文をいちいち打つのがめんどうになります
そんなわけでupdate_mirrorに回文optionをつけました((ハイフンのあとは任意の文字列))
&gt;|ruby|
&gt; update_mirro -t なんてしつけいいこ
 =&gt; &quot;update なんてしつけいいこいいけつしてんな #mirrormessage&quot; 
||&lt;
キータイプが半分になります


Twitterが流行ってます
2010年TwitterはHALになれるのでしょうか
そんなわけでupdate_scooch commandを作りました((scoochとはずらすという意味です))
&gt;|ruby|
&gt; update_scooch HAL またはus HAL
 =&gt; &quot;update IBM #scoochmessage&quot;
||&lt;


optionでずらす数を指定できます
&gt;|ruby|
&gt; us -3 Twitter
 =&gt; &quot;update Wzlwwhu #scoochmessage3&quot;
||&lt;
hashtagの末尾の数字が暗号を解くカギとなります
もちろん日本語もずれます
&gt;|ruby|
&gt; us 日本をずらす
 =&gt; &quot;update 旦札んせりず #scoochmessage&quot; 
||&lt;


Twitterが流行ってます
公の場で秘密のmessageを送り合うなんて素敵です
そんなわけでupdate_rot13 commandを作りました
&gt;|ruby|
&gt; u13 I need you!
 =&gt; &quot;update V arrq lbh! #rot13message&quot; 
||&lt;

この暗号文の優れたところは
termtter上のirbですぐに復号ができることです
&gt;|ruby|
&gt; irb
irb(main):001:0&gt; 'V arrq lbh!'.rot13
 =&gt; &quot;I need you!&quot;
||&lt;


日本語も大丈夫です((このブログ上では文字化けしています。Ruby18環境では漢字は変換しません))
&gt;|ruby|
&gt; u13 hello, 私は日本人デス!
 =&gt;&quot;update uryyb, 僮う&amp;#36536;&amp;#36863;〓ヰモ! #rot13message&quot;

&gt; irb
irb(main):001:0&gt; 'uryyb, 僮う&amp;#36536;&amp;#36863;〓ヰモ!'.rot13
 =&gt; &quot;hello, 私は日本人デス!&quot;
||&lt;


Twitterが流行ってます
あなたのfollowerが共通の秘密を知っている人かを
知りたいってことよくありますよね
そんなわけでupdate_crypt commandを作りました
&gt;|ruby|
&gt; update_crypt -sugar ひらけごま  または uc -sugar ..
 =&gt; &quot;update suoeTmvbcdlX. #cryptmessagesugar&quot;
||&lt;
messageを受け取ったあなたはirbを開いて
彼が友人であるか確認ができます
hashtagの末尾がsaltです
&gt;|ruby|
&gt; irb
&gt; irb(main):001:0&gt; 'ひらけごま'.crypt 'sugar'
 =&gt; &quot;suoeTmvbcdlX.&quot;
||&lt;


Termtterってやっぱり便利ですね!


すべてのcommandは添付のugly_update.rbにあります
termtterのpluginディレクトリにコピーして
plug ugly_updateしてください


(追記：2010/2/20)update_rot13に日本語を追加しました
(追記：2010/2/21)Ruby1.8に対応しました


[http://gist.github.com/297408:title=gist: 297408 - Termtter plugins- GitHub]

</body>
</day>
<day date="2010-02-19" title="">
<body>
*p1*TermtterならGOOGだってAAPLだって
Twitterが流行ってます
ＴＬには新しい製品やサービスの情報がぞくぞく流れてきます
そうなるとその会社の株価も気になりますよね?
ええ当然気になります
そんなわけで株価を表示するTermtter pluginを作りました


stock_price (またはstp) コマンドのあとにTicker Symbolを打ちます
[f:id:keyesberry:20100219075804p:image]


realtimeの情報が知りたければ -r オプションを付けます
[f:id:keyesberry:20100219075800p:image]


Ticker Symbolは複数渡せます
[f:id:keyesberry:20100219075803p:image]


でも株価を知りたいけど
Ticker Symbolが分からないってことありますよね?
そんなときは stock_find (またはstf) コマンドが使えます
[f:id:keyesberry:20100219075802p:image]


そしてその会社に興味を持ったなら
当然株価の履歴情報も知りたくなります
そんなときは stock_history (またはsth) コマンドを使ってください
日付指定なしでここ一週間ほどの履歴が表示されます

[f:id:keyesberry:20100219075801p:image]


では日付指定してYHOOの黄金期を見てみましょう
[f:id:keyesberry:20100219075805p:image]


Termtterってやっぱり便利ですね!


&lt;del datetime=&quot;2010-03-03T19:05:08+09:00&quot;&gt;残念ながら日本のマーケットには対応していませんorz..&lt;/del&gt;

(追記:2010/3/3)日本のマーケットに対応しました！
[http://d.hatena.ne.jp/keyesberry/20100302/p1:title=Ruby製ノコギリで株価を切り刻もう! - hp12c]


使用にはyahoo_stock libraryが必要です
gem install yahoo_stock してください
すべてのcommandは添付のstock.rbにあります
termtterのpluginディレクトリにコピーして
plug stockしてください
ライセンスはTermtterに準拠します


[http://gist.github.com/297408:title=gist: 297408 - Termtter plugins- GitHub]

</body>
</day>
<day date="2010-02-21" title="">
<body>
*p1*TermtterならGmailだって
朝起きてパソコンを起動して最初にすることは何ですか?


ええもうわかってますよ
Terminalを開いてtermtterコマンドを打って
『今起きた。』ってTweetするんですよね


そして次にBrowserでGmailを開いて
大したメールが来ていなことを確認して
またTermtterに戻って『昨日は飲みすぎた。』とか
『今日は寒い』とかってTweetするんですよね


そんな人のためにgmail pluginを作りました


&gt;|ruby|
&gt; gmail または gm
||&lt;
とすればusernameとpasswordを確認後
gmailから未読メールをフェッチしてきて
それらのsenderとsubjectをリストします
メールの未読状態は維持されます


.termtter/configにusernameとpasswordを
登録しておけばLoginは省略されます
&gt;|ruby|
 config.plugins.gmail.username = 'username'
 config.plugins.gmail.password = 'password'
||&lt;


これで詰らないメールのために
いちいちBrowserを開く必要がなくなるので
Termtterに貼り付いていられますね


運悪く読まなきゃならないメールが来ていたら
&gt;|ruby|
&gt; gmail_open または gmo
||&lt;
としてgmailを立ち上げてください


Termtterってやっぱり便利ですね!


&lt;del datetime=&quot;2010-05-17T18:22:31+09:00&quot;&gt;Ruby1.8.7でのみ動作します
原因はわかりませんがRuby1.9ではSSLの認証に失敗してしまいます&lt;/del&gt;
gmail_openコマンドにはuri_open pluginが必要です
ファイルは添付のgmail.rbです
termtterのpluginディレクトリにコピーして
plug gmailしてください
ライセンスはTermtterに準拠します


[http://gist.github.com/297408:title=gist: 297408 - Termtter plugins- GitHub]

(追記：2010/5/17)Ruby1.9に対応しました

</body>
</day>
<day date="2010-02-22" title="">
<body>
*p1*Termtterで#nowplaying
Twitterで#nowplayingというタグを付けて
今聞いてる曲とかをポストするのが流行ってますね


Termtterにはitunesというpluginが添付されていて
これを使えばiTunesで今聞いてる曲を簡単にポストできます
&gt;|ruby|
&gt; listening_now または ln
 =&gt; Listening now: Tequila sunrise (3:28) Eagles Hell Freezes Over #iTunes #listening
||&lt;


それで折角だから
これにLast.fmの該当曲へのlinkを付けました
&gt;|ruby|
&gt; ln
 =&gt; Listening now: A DAY FOR YOU (3:58) LOVE PSYCHEDELICO The Greatest Hits http://www.last.fm/music/LOVE+PSYCHEDELICO/_/A+DAY+FOR+YOU #iTunes #nowplaying
||&lt;


これで誰でもあなたの聞いてる曲にすぐアクセスできますね


Termtterってやっぱり便利ですね!


ファイルは添付のitunes2.rbです
termtterのpluginディレクトリにコピーして
plug itunes2してください


[http://gist.github.com/297408:title=gist: 297408 - Termtter plugins- GitHub] 

</body>
</day>
<day date="2010-03-02" title="">
<body>
*p1*Ruby製ノコギリで株価を切り刻もう!
株式投資は社会人のたしなみである
投資をせずしてリアル経済を知ることはできない
ところが就業中に君がWebにアクセスして
株価をチェックしていると上司は怒る
場合によっては君を解雇する
そんなばかなことはあってはならない


**yahoo_stockライブラリ
君がRubyを使えるなら上司に気づかれずに
株価をチェックできるかもしれない
幸いRubyにはyahoo_stockというライブラリがある


[http://nasir.wordpress.com/2009/10/28/ruby-gem-for-finance-data/:title=Ruby gem for stock / finance data &amp;#171; Nasir Jamal]


yahoo_stockはYahoo!Financeが提供するCSVデータにアクセスする
gem install yahoo_stockでインストールして((ruby1.9対応版はこちらを使用してください。https://github.com/nas/yahoo_stock))
Terminalを開いて以下のように使う
&gt;|ruby|
% irb -r yahoo_stock
irb&gt; YahooStock::Quote.new(:stock_symbols =&gt; &quot;GOOG&quot;).results.output

=&gt; &quot;&quot;3/1/2010&quot;,532.69\r\n&quot;
||&lt;


もう少し詳しい情報が必要なら以下のようにする
&gt;|ruby|
irb&gt; q = YahooStock::Quote.new(:stock_symbols =&gt; &quot;GOOG&quot;)
irb&gt; q.standard
irb&gt; q.results(:to_hash).output

=&gt; [{:ask=&gt;&quot;533.25&quot;, :average_daily_volume=&gt;&quot;3013950&quot;, :bid=&gt;&quot;532.75&quot;, :bid_size=&gt;&quot;113.302&quot;, :change=&gt;&quot;+5.89&quot;, :change_in_percent=&gt;&quot;+1.12%&quot;, :change_with_percent_change=&gt;&quot;+5.89 - +1.12%&quot;, :day_high=&gt;&quot;533.29&quot;, :day_low=&gt;&quot;527.74&quot;, :day_range=&gt;&quot;527.74 - 533.29&quot;, :last_trade_date=&gt;&quot;3/1/2010&quot;, :last_trade_price_only=&gt;&quot;532.69&quot;, :last_trade_time=&gt;&quot;4:00pm&quot;, :last_trade_with_time=&gt;&quot;4:00pm - &lt;b&gt;532.69&lt;/b&gt;&quot;, :name=&gt;&quot;Google Inc.&quot;, :open=&gt;&quot;530.07&quot;, :previous_close=&gt;&quot;526.80&quot;, :symbol=&gt;&quot;GOOG&quot;, :ticker_trend=&gt;&quot;&amp;nbsp;++--==&amp;nbsp;&quot;, :volume=&gt;&quot;2238234&quot;}]
||&lt;


証券Symbolがわからないなら以下のようにする
&gt;|ruby|
irb&gt; YahooStock::ScripSymbol.new('microsoft').results.output

=&gt; &quot;MSFT.MX,MICROSOFT,369.50,Stock,,MEX\r\nMS-U.TI,MICROSOFT,21.21,Stock,,TLO\r\nMSF.AS,MICROSOFT,28.75,Stock,,AMS\r\nMSF.BE,MICROSOFT,20.96,Stock,,BER\r\nMSF.DE,MICROSOFT,21.37,Stock,,GER\r\nMSF.DU,MICROSOFT,21.01,Stock,,DUS\r\nMSF.F,MICROSOFT,21.41,Stock,,FRA\r\nMSF.HA,MICROSOFT,21.25,Stock,,HAN\r\nMSF.HM,MICROSOFT,21.31,Stock,,HAM\r\nMSF.MU,MICROSOFT,21.06,Stock,,MUN\r\nMSF.NX,MICROSOFT,28.92,Stock,,ENX\r\nMSF.SG,MICROSOFT,21.35,Stock,,STU\r\nMSFT.BA,MICROSOFTCORP.,22.85,Stock,,BUE\r\n4338.HK,MICROSOFT-T,217.00,Stock,,HKG\r\nMSFT,MicrosoftCorporation,29.02,Stock,ApplicationSoftware,NMS&quot;
||&lt;


株価履歴情報が知りたいなら以下のようにする
&gt;|ruby|
irb&gt; st = Date.parse('2010/2/1')
irb&gt; ed = Date.parse('2010/2/10')
irb&gt; h = YahooStock::History.new(:stock_symbol =&gt; 'MSFT', :start_date =&gt; st, :end_date =&gt; ed)
irb&gt; h.results(:to_hash).output

=&gt; [{:date=&gt;&quot;2010-02-10&quot;, :open=&gt;&quot;28.03&quot;, :high=&gt;&quot;28.24&quot;, :low=&gt;&quot;27.84&quot;, :close=&gt;&quot;27.99&quot;, :volume=&gt;&quot;48591300&quot;, :adj_close=&gt;&quot;27.86&quot;}, {:date=&gt;&quot;2010-02-09&quot;, :open=&gt;&quot;27.97&quot;, :high=&gt;&quot;28.34&quot;, :low=&gt;&quot;27.75&quot;, :close=&gt;&quot;28.01&quot;, :volume=&gt;&quot;59195800&quot;, :adj_close=&gt;&quot;27.88&quot;}, {:date=&gt;&quot;2010-02-08&quot;, :open=&gt;&quot;28.01&quot;, :high=&gt;&quot;28.08&quot;, :low=&gt;&quot;27.57&quot;, :close=&gt;&quot;27.72&quot;, :volume=&gt;&quot;52820600&quot;, :adj_close=&gt;&quot;27.59&quot;}, {:date=&gt;&quot;2010-02-05&quot;, :open=&gt;&quot;28.00&quot;, :high=&gt;&quot;28.28&quot;, :low=&gt;&quot;27.57&quot;, :close=&gt;&quot;28.02&quot;, :volume=&gt;&quot;80960100&quot;, :adj_close=&gt;&quot;27.89&quot;}, {:date=&gt;&quot;2010-02-04&quot;, :open=&gt;&quot;28.38&quot;, :high=&gt;&quot;28.50&quot;, :low=&gt;&quot;27.81&quot;, :close=&gt;&quot;27.84&quot;, :volume=&gt;&quot;77850000&quot;, :adj_close=&gt;&quot;27.71&quot;}, {:date=&gt;&quot;2010-02-03&quot;, :open=&gt;&quot;28.26&quot;, :high=&gt;&quot;28.79&quot;, :low=&gt;&quot;28.12&quot;, :close=&gt;&quot;28.63&quot;, :volume=&gt;&quot;61397900&quot;, :adj_close=&gt;&quot;28.50&quot;}, {:date=&gt;&quot;2010-02-02&quot;, :open=&gt;&quot;28.37&quot;, :high=&gt;&quot;28.50&quot;, :low=&gt;&quot;28.14&quot;, :close=&gt;&quot;28.46&quot;, :volume=&gt;&quot;54413700&quot;, :adj_close=&gt;&quot;28.33&quot;}, {:date=&gt;&quot;2010-02-01&quot;, :open=&gt;&quot;28.39&quot;, :high=&gt;&quot;28.48&quot;, :low=&gt;&quot;27.92&quot;, :close=&gt;&quot;28.41&quot;, :volume=&gt;&quot;85931100&quot;, :adj_close=&gt;&quot;28.28&quot;}]
||&lt;

これで上司に悟られずに株価をチェックできる!


えっ? 日本市場が見られない?
君がまだ日本株に興味があるなんて知らなかった


**Nokogiriライブラリ
残念なことにYahoo!ファイナンスは
APIやCSVデータを用意してくれてはいない


でも消沈する必要はないRubyにはNokogiriがある


Nokogiriは取得したHTMLを解析するためのライブラリだ
gem install nokogiriでインストールして
以下のように使う

&gt;|ruby|
% irb -rnokogiri -ropen-uri
irb&gt; uri = 'http://finance.yahoo.co.jp'
irb&gt; n = Nokogiri::HTML(open uri)
irb&gt; n.css('div.content').each do |node|
irb*     puts node.search('img')
irb&gt; end
&lt;img alt=&quot;TOPIX&quot; src=&quot;http://gchart.yahoo.co.jp/s?s=998405.T&quot;&gt;
&lt;img alt=&quot;日経平均株価&quot; src=&quot;http://gchart.yahoo.co.jp/s?s=998407.O&quot;&gt;
&lt;img alt=&quot;ジャスダックインデックス&quot; src=&quot;http://gchart.yahoo.co.jp/s?s=23337.Q&quot;&gt;
&lt;img alt=&quot;TOPIX先物1限月&quot; src=&quot;http://gchart.yahoo.co.jp/s?s=5040468.T&quot;&gt;
&lt;img alt=&quot;日経平均先物1限月&quot; src=&quot;http://gchart.yahoo.co.jp/s?s=5040469.O&quot;&gt;
&lt;img alt=&quot;アメリカ　ドル / 日本　円&quot; src=&quot;http://gchart.yahoo.co.jp/z?s=....&quot;&gt;
||&lt;

ノコギリがあれば株価だろうがニュースだろうが
天気だろうがなんでも切り刻める

**yahoojp_stockライブラリ
Nokogiriを使ってYahoo!ファイナンスから
株価を取得する簡単なライブラリyahoojp_stockを書いてみた
これは以下のように使う
&gt;|ruby|
% irb -ryahoojp_stock
irb&gt; YahooJPStock::Quote.new('7203').output

=&gt; {:current_price=&gt;[&quot;現在値（11:00）&quot;, &quot;3,290&quot;], :day_range=&gt;[&quot;値幅制限&quot;, &quot;2,595～3,995（03/02）&quot;], :year_high=&gt;[&quot;年初来高値&quot;, &quot;4,235（10/01/21）&quot;], :pbr=&gt;[&quot;PBR（実績）&quot;, &quot;(連) 1.03倍（11:00）&quot;], :last_trade_price=&gt;[&quot;前日終値&quot;, &quot;3,295（03/01）&quot;], :market_cap=&gt;[&quot;時価総額&quot;, &quot;11,343,912百万円（11:00）&quot;], :year_low=&gt;[&quot;年初来安値&quot;, &quot;2,750（09/01/26）&quot;], :open_price=&gt;[&quot;始値&quot;, &quot;3,285（09:00）&quot;], :eps=&gt;[&quot;EPS（実績）&quot;, &quot;(連) -139.13（2009/03）&quot;], :volume=&gt;[&quot;出来高&quot;, &quot;3,901,200株（11:00）&quot;], :shares=&gt;[&quot; 発行済株式数&quot;, &quot;3,447,997,492株（03/02）&quot;], :outstand_margin_buy=&gt;[&quot;信用買残&quot;, &quot;11,390,600株（02/19）&quot;], :day_high=&gt;[&quot;高値&quot;, &quot;3,315（09:16）&quot;], :bps=&gt;[&quot;BPS（実績）&quot;, &quot;(連) 3,180.36（2009/09）&quot;], :div_yield=&gt;[&quot;配当利回り（実績）&quot;, &quot;3.04%（11:00）&quot;], :margin_buy_week_change=&gt;[&quot;前週比&quot;, &quot;+1,259,200株（02/19）&quot;], :day_low=&gt;[&quot;安値&quot;, &quot;3,285（09:00）&quot;], :minimum_cost=&gt;[&quot;最低購入 代金&quot;, &quot;329,000（11:00）&quot;], :name=&gt;[&quot;名称&quot;, &quot;トヨタ自動車(株)&quot;], :symbol=&gt;[&quot;コード&quot;, &quot;7203&quot;], :dividend=&gt;[&quot;1株配当（実績）&quot;, &quot;100.00（2009/03）&quot;], :oustand_margin_sell=&gt;[&quot;信用売残&quot;, &quot;4,218,100株（02/19）&quot;], :exchange=&gt;[&quot;市場&quot;, &quot;東証1部&quot;], :trade_amount=&gt;[&quot;売買代金&quot;, &quot;12,860,783千円（11:00）&quot;], :minimum_shares=&gt;[&quot;単元株数&quot;, &quot;100株&quot;], :day_change=&gt;[&quot;前日比&quot;, &quot;-5（-0.15%）&quot;], :per=&gt;[&quot;PER（実績）&quot;, &quot;(連) ---倍（11:00）&quot;], :margin_sell_week_change=&gt;[&quot;前週比&quot;, &quot;-1,513,600株（02/19）&quot;]}
||&lt;

証券コードが分らなければ以下のようにする
&gt;|ruby|
irb&gt; YahooJPStock::Find.new('toyota').output

=&gt; [[&quot;コード&quot;, &quot;市場&quot;, &quot;名称&quot;, &quot;取引値&quot;, &quot;前日比&quot;, &quot;出来高&quot;], [&quot;7203&quot;, &quot;東証1部&quot;, &quot;トヨタ自動車(株)&quot;, &quot;3,290(11:00)&quot;, &quot;-5(-0.15%)&quot;, &quot;3,901,200&quot;], [&quot;3116&quot;, &quot;東証1部&quot;, &quot;トヨタ紡織(株)&quot;, &quot;1,515(11:00)&quot;, &quot;-22(-1.43%)&quot;, &quot;349,800&quot;], [&quot;8015&quot;, &quot;東証1部&quot;, &quot;豊田通商(株)&quot;, &quot;1,275(11:00)&quot;, &quot;-7(-0.55%)&quot;, &quot;156,800&quot;], [&quot;6201&quot;, &quot;東証1部&quot;, &quot;(株)豊田自動織機&quot;, &quot;2,380(10:59)&quot;, &quot;+19(+0.80%)&quot;, &quot;429,100&quot;], [&quot;7221&quot;, &quot;東証1部&quot;, &quot;トヨタ車体(株)&quot;, &quot;1,459(11:00)&quot;, &quot;+30(+2.10%)&quot;, &quot;170,100&quot;]]
||&lt;

履歴情報が知りたければ以下のようにする
&gt;|ruby|
irb&gt; YahooJPStock::History.new('7203', '2010/2/1', '2010/2/10').output

=&gt; [[&quot;日付&quot;, &quot;始値&quot;, &quot;高値&quot;, &quot;安値&quot;, &quot;終値&quot;, &quot;出来高&quot;, &quot;調整後終値*&quot;], [&quot;2010年2月10日&quot;, &quot;3,390&quot;, &quot;3,415&quot;, &quot;3,330&quot;, &quot;3,390&quot;, &quot;18,972,600&quot;, &quot;3,390&quot;], [&quot;2010年2月9日&quot;, &quot;3,265&quot;, &quot;3,415&quot;, &quot;3,260&quot;, &quot;3,375&quot;, &quot;28,934,300&quot;, &quot;3,375&quot;], [&quot;2010年2月8日&quot;, &quot;3,335&quot;, &quot;3,355&quot;, &quot;3,265&quot;, &quot;3,280&quot;, &quot;19,349,000&quot;, &quot;3,280&quot;], [&quot;2010年2月5日&quot;, &quot;3,255&quot;, &quot;3,350&quot;, &quot;3,250&quot;, &quot;3,315&quot;, &quot;45,835,400&quot;, &quot;3,315&quot;], [&quot;2010年2月4日&quot;, &quot;3,260&quot;, &quot;3,295&quot;, &quot;3,195&quot;, &quot;3,280&quot;, &quot;56,511,500&quot;, &quot;3,280&quot;], [&quot;2010年2月3日&quot;, &quot;3,535&quot;, &quot;3,540&quot;, &quot;3,400&quot;, &quot;3,400&quot;, &quot;35,380,300&quot;, &quot;3,400&quot;], [&quot;2010年2月2日&quot;, &quot;3,610&quot;, &quot;3,650&quot;, &quot;3,595&quot;, &quot;3,605&quot;, &quot;23,837,300&quot;, &quot;3,605&quot;], [&quot;2010年2月1日&quot;, &quot;3,495&quot;, &quot;3,505&quot;, &quot;3,415&quot;, &quot;3,450&quot;, &quot;22,342,100&quot;, &quot;3,450&quot;]]
||&lt;

これで日本株もばっちりだ!


えっ?こんなんじゃ使いづらい?
それなら[http://termtter.org/:title=Termtter]を使おう


**Termtterなら日本株だって
以前にyahoo_stockライブラリを使って
Termtterで株価情報を取得するコマンドを作った


[http://d.hatena.ne.jp/keyesberry/20100219/p1:title=TermtterならGOOGだってAAPLだって - hp12c]


だけれどもそれは
日本のマーケットには対応していないという
致命的な欠陥を持っていた
だからyahoojp_stockライブラリを作って
Termtterでも日本株の情報が取得できるようにしてみた


以前作った3つのコマンドstock_price stock_find stock_historyを
それぞれ拡張して日本株にも対応するようにした


stock_price(またはstp)コマンドでは
証券Symbolを渡せば
Yahoo!Financeにアクセスして米国等株情報を取得し
証券コードを渡せば
Yahoo!ファイナンスにアクセスして日本株情報を取得する

&gt;|ruby|
&gt; stock_price 4689 7203
||&lt;

[f:id:keyesberry:20100302132909p:image]


stock_find(またはstf)コマンドでは
大文字で始まる英単語を渡せば
Yahoo!Financeにアクセスして証券Symbolを取得し
小文字で始まる英単語または日本語を渡せば
Yahoo!ファイナンスにアクセスして証券コードを取得する

&gt;|ruby|
&gt; stock_find toyota
||&lt;
[f:id:keyesberry:20100302132911p:image]


stock_history(またはsth)コマンドでも
証券Symbolを渡せば
Yahoo!Financeにアクセスして米国等株情報を取得し
証券コードを渡せば
Yahoo!ファイナンスにアクセスして日本株情報を取得する
日本株については:daily :weekly :monthlyの指定ができる((defaultは:daily))

&gt;|ruby|
&gt; stock_history 4689 2008/1/1 2009/1/1 :monthly
||&lt;

[f:id:keyesberry:20100302132910p:image]


さらに日本株についてはポートフォリオの現在価値を計算する
stock_portfolio(またはstpo)コマンドを用意した
予め自分のポートフォリオ情報を.termtter/configに
証券コード 持株数 平均取得単価の順にセットして使う
&gt;|ruby|
 config.plugins.stock = [['4689.t', 1000, 28000], ['7203.t', 3500, 6520.30]]
||&lt;
[f:id:keyesberry:20100302141638p:image]


Termtterなら就業時間中に使っても怒られることはない


出力がうまく整列できていないところはご勘弁を


yahoojp_stockライブラリは以下のリンクにあります
このライブラリはYahoo!ファイナンスの配置構成や
色などの仕様に依存している微妙な作りになっています
従ってサイトのデザイン上の仕様が変更されただけで機能しなくなります
このライブラリはRubyライセンスにより提供されます


(追記：2010/3/9）stock_portfolioコマンドにIndex情報を追加しました。

[http://gist.github.com/297408:title=gist: 297408 - Termtter plugins- GitHub] 

</body>
</day>
<day date="2010-03-07" title="">
<body>
*p1*Termtterでupdateコマンドを省略する
Termtterが他のTwitterクライアントと違うことの１つは
ユーザが入力した文字列を
Twitterへの投稿文字列とは解釈しないところだ


Termtterは常にそれをコマンド(+引数)として解釈する


だからそのことを忘れて投稿文字列を打つと
以下のように言われる
&gt;|ruby|
&gt; 誰か僕の代わりに仕事してくれないかなあ
[ERROR] Termtter::CommandNotFound: 誰か僕の代わりに仕事してくれないかなあ
||&lt;
知ってるよ！そんなコマンドあるわきゃない！


つまり投稿文字列を打つときも
その先頭にコマンドが必要になる
&gt;|ruby|
&gt; update 誰か僕の代わりに仕事してくれないかなあ
||&lt;


updateにはuというショートカットがあるので
&gt;|ruby|
&gt; u 誰か僕の代わりに仕事してくれないかなあ
||&lt;
とできる


それでも僕はしばしばこのuを忘れて
リターンキーを押してからuが無いのに気付く


だから僕が少し長い文章を打ったら
それは単にuを忘れてるんだと解釈して欲しい


そんな想いからclient.rbを少しいじってみました

&gt;|ruby|
150,158c150,151
&lt;           
&lt;           unless command = find_command(text)
&lt;             if text.length &gt; 20 and config.confirm
&lt;               text = 'update ' + text
&lt;               retry
&lt;             else
&lt;               raise CommandNotFound, text
&lt;             end
&lt;           end
---
&gt;           command = find_command(text)
&gt;           raise CommandNotFound, text unless command
||&lt;


(追記：2010/5/20) Ruby1.9ではretryがrescueの外では使えないようなので以下のようにしました。
&gt;|ruby|
150,158c150,151
&lt;
&lt;          begin
&lt;            raise unless command = find_command(text)
&lt;          rescue
&lt;            if text.length &gt; 15 &amp;&amp; config.confirm
&lt;              text = 'update ' + text
&lt;              retry
&lt;            else
&lt;              raise CommandNotFound, text
&lt;            end
&lt;          end
---
&gt;           command = find_command(text)
&gt;           raise CommandNotFound, text unless command
||&lt;


(追記：2010/5/29) Termtter1.8.0では添付のeasy_post pluginで同様のことができるようになっています。command_not_foundをフックすればいいんですね。
&gt;|ruby|
module Termtter::Client
  register_hook(:easy_post, :point =&gt; :command_not_found) do |text|
    execute(&quot;update #{text}&quot;)
  end
end
||&lt;
ただ自分は先のパッチのようにupdateの省略をconfirm=trueかつテキストが長いときに限定したいので、別のplugin(default_replace.rb)に以下を追加して対応することにしました。
&gt;|ruby|
module Termtter::Client
  register_hook(:easy_post, :point =&gt; :command_not_found) do |text|
    if config.confirm &amp;&amp; text.length &gt; 15
      execute(&quot;update #{text}&quot;)
    else
      raise Termtter::CommandNotFound, text
    end  
  end
end
||&lt;


[http://gist.github.com/297408:title=gist: 297408 - Termtter plugins- GitHub] 

</body>
</day>
<day date="2010-03-15" title="">
<body>
*p1*ApplescriptとRubyでもう僕は移動しない
忙しい社会では無駄な労力というのはとても嫌われます
そしてコンピュータネットワークの発達した現代では
「移動」は無駄な労力の１つとみなされています


ネット世界の住人は特に移動を嫌います
物を買うにも友と語らうにも移動を避けます
移動は無駄に時間を消費するからです
そう現代ではマウスクリック１つで問題は解決するのです


ところが彼らの中にはそれでは満足できない一群がいました
彼らは言うのです
「マウスに腕を伸ばすのも時間の無駄である」
極論ですが一理あります
確かにマウスの使用は腕の移動を伴います


そんなわけでＧＵＩに完全に制圧されたこの世界でも
キーボードだけで何とか事を解決しようと試みる人たちはいます


彼らは[http://www.blacktree.com/:title=QuickSilver]でアプリを立上げ
[http://code.google.com/p/macvim-kaoriya/:title=Vim]や[http://homepage.mac.com/zenitani/emacs-j.html:title=Emacs]でエディットし
[https://addons.mozilla.org/ja/firefox/addon/4891:title=Vimperator]でブラウズし
[http://reader.livedoor.com/reader/:title=livedoorReader]でブログを読み
[http://termtter.org/:title=Termtter]でツウィットし
[http://www.yellowmug.com/sk4it/:title=SizzlingKeys]でiTunesをコントロールし
&amp;#8984;+tabや[http://www.manytricks.com/witch/:title=Witch]でアプリを切換え
Spacesや[http://virtuedesktops.info/:title=VirtueDesktops]でウィンドウを切換え
[http://pqrs.org/macosx/keyremap4macbook/index.html.ja:title=KeyRemap4MacBook]でkeybindingを変更し
そして最後にQuickSilverでshuとタイプして一日を終えるのです


しかし彼らにも一日に何度か
マウスを使わざるを得ない場面というのがやってきます
例えばそれはコンピュータで
「見ながら書く」という行動を取るときです
ネット上の解説を参考にTerminalでコマンドを打ったり
PDFに載っているサンプルコードをVimに写したりするとき
２つのウィンドウをそれらが重ならないようにするには
マウスを使わざるを得ません((Vimには:winposというウィンドウの位置を変える関数があります。自分のMacVimでは機能しませんでした。))
堪え難い屈辱的瞬間です


しかし簡単に諦めるわけにはいけません
何しろ移動は時間の無駄なのですから


幸いMacVimやTerminalには奥の手があります
そうウィンドウの透過です
これらのウィンドウにはtransparencyという
そのbackgroundの透過度を調整する設定があります
これを使えばウィンドウの向こう側を「透かし見る」ことができるので
マウスを使ってウィンドウを動かす必要はなくなります


しかし一方でジレンマがあります
この透過度を上げ過ぎると普段ウィンドウの向こう側が目障りになり
下げ過ぎると向こう側の文字が良く読めません
うまくいかないものです


よい方法はないのでしょうか


それがあるのです
そう透過度をkeyboardで調整できるようにすればいいのです！
これなら万事がうまくいくに違いありません


以下はMacVim, [http://iterm.sourceforge.net/:title=iTerm], Terminalにおいて
keyboardでそれらの透過度を調整するため
自分が取った試行錯誤を紹介します
不完全ですが一応の成果は得られたので公開します


**MacVim
Vimにはtransparencyという設定項目があり
それを:set transparency=で変更できます
ですから単に以下を.gvimrcに記述すればいいです

&gt;|ruby|
nmap + :set transparency+=5&lt;CR&gt;
nmap _ :set transparency-=5&lt;CR&gt;
||&lt;
この設定でnomal modeで+を押す度に透過度が上がり
_を押す度に透過度が下がるようになります
やはりVimはただ者ではありません

**iTerm
***Applescriptその１
iTermはApplescriptをサポートしています
ですからその透過度をApplescriptを使って変更できそうです
問題は未経験の自分がそれをサポートできるかです...


幸いiTermのサイトにsampleがありました
これを参考にコードを書いてみました
（そう、まさにこういうときのために透過させたいのです！）
&gt;|ruby|
tell application &quot;iTerm&quot;
    activate
    tell current session of current terminal
      	set transparency to &quot;0.3&quot;
    end tell
end tell
||&lt;
このscriptはiTermをactivateし
現在のterminalの現在のsessionの透過度を0.3にします
これを例えばtransparency_to03.scptとして保存します


iTermで以下のようにすれば動作が確認できます
&gt;|ruby|
% osascript transparency_to03.scpt
||&lt;


同様に元に戻すためのtransparency_to005.scptを用意します
&gt;|ruby|
tell application &quot;iTerm&quot;
    activate
    tell current session of current terminal
      	set transparency to &quot;0.05&quot;
    end tell
end tell
||&lt;

***scriptのメニュー登録とkeyboard shortcutの割り当て
次にこれらのscriptをkeyboard shortcutで呼び出せるようにします
１つの方法はiTermのスクリプトメニューにscriptを登録し
それにshortcutを割り当てる方法です


スクリプトメニューはそのapplicationの専用フォルダに
scriptを置くことで出現します((Scriptsフォルダがない場合は作ります))
&gt;|ruby|
% mv transparency_to03.scpt transparency_to005.scpt ~/Library/Application Support/iterm/Scripts/
||&lt;

次にシステム環境設定&gt;キーボードとマウス&gt;キーボードショートカットを開き
 +ボタンを押してショートカットの登録ダイアログを開きます
アプリケーション、メニュータイトル、ショートカットを設定します

[f:id:keyesberry:20100315094407p:image]


同様にしてtransparency_to005.scptを登録します
これによって登録したショートカットで
iTermの透過度を変えることができるようになります

***Applescriptその２
それにしても固定値のscriptを２つというのは酷過ぎます
これじゃ単なるマクロです
Applescript未経験とはいえ
自由に値くらい変えられるようにしたいものです


調査の結果runハンドラというのを使えば
scriptに引数を渡せることがわかりました
scriptは以下のようになります
&gt;|ruby|
on run argv
  tell application &quot;iTerm&quot;
      activate
      tell current session of the last terminal
          set transparency to item 1 of argv
      end tell
  end tell
end run
||&lt;
引数群をargvで受けその最初のものをtransparencyに渡します


&gt;|ruby|
% osascript transparency.scpt '0.4'
||&lt;

ところがこれをkeyboard shortcutに登録する方法が見当たりません


悩んだ揚げ句shell commandを呼ぶApplescriptを書いて
これを登録する方法を考えました
do shell scriptはApplescript内でshell commandを実行します 


transparency_to03.scpt
&gt;|ruby|
do shell script &quot;osascript ~/Library/Application Support/iterm/Scripts/transparency.scpt 0.3'&quot;
||&lt;

transparency_to005.scpt
&gt;|ruby|
do shell script &quot;osascript ~/Library/Application Support/iterm/Scripts/transparency.scpt '0.05'&quot;
||&lt;

しかしどういうわけか自分のTiger環境では
これらを先のapplicationのフォルダに置いて実行すると
ハングしてうまくいきませんでした


**AppleScriptユーティリティ
Applescriptの別の置き場所としては
メニューバーのスクリプトアイコンで表示されるエリアがあります
このアイコンを出現させるには
Application&gt;ApplescriptにあるAppleScriptユーティリティを開いて
メニューバーにスクリプトメニューを表示するをチェックします


iTermをactiveにした状態でアイコンをクリックし
スクリプトフォルダを開く&gt;iTermスクリプトフォルダを開くを選んで
開かれたフォルダにscriptを置けば
このメニューからscriptを起動できるようになります
ちなみにこのフォルダは
~/library/Scripts/Applications/iTerm/になります

[f:id:keyesberry:20100315094408p:image]


ここでは先のscriptは正常に動作しました
しかしこのフォルダ内のscriptに
keyboard shortcutを割り当てる方法は
残念ながら見つかりませんでした

[f:id:keyesberry:20100315094409p:image]

**QuickSilverを使う
こうなるとQuickSilverの出番です
QuickSilverで目的のscriptをrunする
という方法もありますが
QuickSilverにはTriggersという機能があって
これを使えば任意のactionに
keyboard shortcutを割り当てることができます


&amp;#8984;+'でPreferenceのTriggersを開き
+&gt;Hotkeyと辿ってscriptを追加するダイアログを開きます
script名を打ってitemに設定しtriggerをダブルクリックして
keyboard shortcutを登録します
これで無事目的を達成できました

[f:id:keyesberry:20100315094410p:image]


ただ問題が１つあってQuickSilverを使うと
shortcutがiTerm専用ではなくグローバルになってしまいます
そのため同じような透過設定を複数のアプリケーション
例えばiTermとTerminalで実現する場合には
これらには別のshortcutを割り当てる必要があります
現時点で解決方法は見つかっていません
ご存知の方は是非ともコメントを下さい


**Rubyを使う
Applescriptでは２つの設定を切換えるscriptを書きましたが
できればMacVimでしたように
キーを押す度に透過度が段階的に変わるものがほしいです
Applescriptでこれを実現するのは難しいことではないでしょう
でも自分はこれ以上Applescriptに時間を割きたくはありません...


そう何をするにもRubyを使いたいのです！


幸いRubyにはrb-appscriptというライブラリがあります
これはAppleEventをブリッジして
macなアプリをrubyから制御できるようにします


[http://appscript.sourceforge.net/rb-appscript/index.html:title=rb-appscript]


gem install rb-appscriptして
早々irbで試してみます

&gt;|ruby|
% irb -rappscript
irb&gt; include Appscript
  =&gt; Object
irb&gt; itunes = app &quot;iTunes&quot;
  =&gt; app&quot;/Applications/iTunes.app&quot;
irb&gt; itunes.current_track.name.get
  =&gt; &quot;I'd Like To&quot;
irb&gt; itunes.current_track.artist.get
  =&gt; &quot;Corinne Bailey Rae&quot;
||&lt;
最後のgetというのがアレですがrubyしてます


それではrubyでiTermの透過度調整コードを書いてみます
iterm_opac.rb
&gt;|ruby|
#!/usr/bin/env ruby -Ku
# -*- encoding: utf-8 -*-

require &quot;appscript&quot;

begin 
  iterm_opac = Appscript::app('iTerm').current_terminal.current_session.transparency
  interval = 0.3
  op = ARGV[0] == '-' ? :- : :+
  
  iterm_opac.set(iterm_opac.get.to_f.send(op, interval))
rescue =&gt; e
  require 'g'
  g e
end
||&lt;
scriptに渡される引数が'-'か否かで
getした現在値にintervalを減算または加算されるようにします
そして新たな値をsetします


これをapplescriptで呼べるようにしましょう


iterm_opac.scpt
&gt;|ruby|
do shell script &quot;ruby ~/path/to/file/iterm_opac.rb&quot;
||&lt;


iterm_opac-.scpt
&gt;|ruby|
do shell script &quot;ruby ~/path/to/file/iterm_opac.rb -&quot;
||&lt;

そして先ほどと同様にQuickSilverで
keyboard shortcutを登録すれば完了です

**Terminal用Ruby Script
Terminalでも透過度を調整できるように
rubyのコードを書きました

&gt;|ruby|
#!/usr/bin/env ruby -Ku
# -*- encoding: utf-8 -*-

require &quot;appscript&quot;
begin 
  term_color = Appscript::app('Terminal').windows.get.
                  detect { |w| w.frontmost.get == true }.background_color
  
  interval = 10000
  op = ARGV[0] == '-' ? :- : :+

  r, g, b, opac = term_color.get
  term_color.set([r, g, b, opac.send(op, -interval)])
rescue =&gt; e
  require 'g'
  g e
end
||&lt;
基本はiTermのものと同じですが
対象のwindowとその透過度を取得するやり方が違います

**ASDictionary
ネットには思いの外rb-appscriptに関する情報がありません
そのため対象Macアプリで使える
commandとpropertyを見つけるのに苦労します
以下のサイトは数少ない情報源の１つです


[http://onrails.org/articles/2007/11/28/scripting-the-leopard-terminal:title=Scripting the Leopard Terminal]



しかしASDictionaryというツールがあるのでなんとかなります


[http://appscript.sourceforge.net/tools.html:title=appscript : tools]


このツールはMacアプリ毎のcommandやpropertyなどを
plain textまたはhtmlのかたちで出力できます
しかしより有用なのはこのツールをインストールすると
rb-appscriptはこの辞書に基づいたhelpシステムを構築するのです


[http://appscript.sourceforge.net/rb-appscript/doc/appscript-manual/04_gettinghelp.html:title=rb-appscript manual | 4. Getting Help]


見てみましょう
&gt;|ruby|
% irb -rappscript
irb&gt; term = Appscript.app &quot;Terminal&quot;
  =&gt; app&quot;/Applications/Utilities/Terminal.app&quot;
irb&gt; term.help '-h'
==============================================================================
Help (-h)
Help Manual
Syntax:

    reference.help(flags)

The optional flags argument is a string containing one or more of the following:

    -h -- show this help
    -o -- overview of all suites, classes and commands
    -k -- list all built-in keywords (type names)
    -u [suite-name] -- summary of named suite or all suites
    -t [class-or-command-name] -- terminology for named class/command or current reference/command
    -i [class-name] -- inheritance tree for named class or all classes
    -r [class-name] -- one-to-one and one-to-many relationships for named class or current reference
    -s [property-or-element-name] -- values of properties and elements of object(s) currently referenced

    Values shown in brackets are optional.
(略)
For example, to print an overview of TextEdit, a description of its make command and the inheritance tree for its document class:

    app('TextEdit.app').help('-o -t make -i document')
==============================================================================
||&lt;

&gt;|ruby|
irb&gt; term.help '-t'
==============================================================================
Help (-t)
------------------------------------------------------------------------------
Description of reference

Terminology for application class

Class: application -- The Terminal program
  Plural:
    applications
  See also:
    Standard Suite
  Inherits from:
    item (in Standard Suite)
  Properties:
    class_ (r/o) : type_class -- The class of the object.
    frontmost (r/o) : boolean -- Is this the frontmost (active) application?
    name (r/o) : unicode_text -- The name of the application.
    version (r/o) : unicode_text -- The version of the application.
    properties_ : anything -- every property of the Terminal program
  Elements:
    documents -- by name, index, relative, range, test
    windows -- by name, index, relative, range, test, id
==============================================================================
||&lt;
これでTerminalにはwindowsというElementがあり
個々のwindowにはnameやindexでアクセスできることがわかります
そしてwindowがどのようなpropertyを持っているか調べるには
次のようにします

&gt;|ruby|
irb&gt; term.windows[0].help '-t'
==============================================================================
Help (-t)

Reference: app(&quot;/Applications/Utilities/Terminal.app&quot;).windows[0]
------------------------------------------------------------------------------
Description of reference

Element: windows -- by name, index, relative, range, test, id

Terminology for window class

Class: window -- A Terminal window
  Plural:
    windows
  See also:
    Standard Suite
  Inherits from:
    item (in Standard Suite)
  Properties:
    class_ (r/o) : type_class -- The class of the object.
    closeable (r/o) : boolean -- Whether the window has a close box.
    document (r/o) : document -- The document whose contents are being displayed in the window.
    floating (r/o) : boolean -- Whether the window floats.
    id_ (r/o) : integer -- The unique identifier of the window.
    index : integer -- The index of the window, ordered front to back.
    miniaturizable (r/o) : boolean -- Whether the window can be miniaturized.
    miniaturized : boolean -- Whether the window is currently miniaturized.
    modal (r/o) : boolean -- Whether the window is the application's current modal window.
    name : unicode_text -- The full title of the window.
    resizable (r/o) : boolean -- Whether the window can be resized.
    titled (r/o) : boolean -- Whether the window has a title bar.
    visible : boolean -- Whether the window is currently visible.
    zoomable (r/o) : boolean -- Whether the window can be zoomed.
    zoomed : boolean -- Whether the window is currently zoomed.
    background_color : anything -- the background color for the window
    bold_text_color : anything -- the bold text color for the window
    bounds : anything -- the boundary rectangle for the window, relative to the upper left corner of the screen
    busy (r/o) : boolean -- Is the window busy running a process?
    contents (r/o) : unicode_text -- the currently visible contents of the window
    cursor_color : anything -- the cursor color for the window
    custom_title : unicode_text -- the custom title for the window
    frame : anything -- the origin and size of the window
    frontmost : boolean -- Is the window in front of the other Terminal windows?
    history (r/o) : unicode_text -- the contents of the entire scrolling buffer of the window
    normal_text_color : anything -- the normal text color for the window
    number_of_columns : integer -- the number of columns in the window
    number_of_rows : integer -- the number of rows in the window
    origin : anything -- the lower left coordinates of the window, relative to the lower left corner of the screen
    position : anything -- the upper left coordinates of the window, relative to the upper left corner of the screen
    processes (r/o) : unicode_text -- a list of the currently running processes
    properties_ : anything -- every property of the window
    size : anything -- the width and height of the window
    title_displays_custom_title : boolean -- Does the title for the window contain a custom title?
    title_displays_device_name : boolean -- Does the title for the window contain the device name?
    title_displays_file_name : boolean -- Does the title for the window contain the file name?
    title_displays_shell_path : boolean -- Does the title for the window contain the shell path?
    title_displays_window_size : boolean -- Does the title for the window contain the window size?
==============================================================================
=&gt; app&quot;/Applications/Utilities/Terminal.app&quot;windows[0]
||&lt;
これで個々のwindowはbackground_colorという
propertyを持っていることがわかりました


そしてこの値を取得するには以下のようにします
&gt;|ruby|
irb&gt; term.windows[0].background_color.get
=&gt; [0, 0, 0, -4718]
||&lt;


値を変更するには以下のようにします
&gt;|ruby|
irb&gt; term.windows[0].background_color.set([0,0,0,-6718])
=&gt; nil
||&lt;

**ASTranslate
もしrubyよりもAppscriptに明るいのなら
ASTranslateが便利です


[http://appscript.sourceforge.net/rb-appscript/doc/appscript-manual/04_gettinghelp.html:title=rb-appscript manual | 4. Getting Help]


Applescriptを上のペインに貼り付け
&amp;#8984;+rすれば対応するruby scriptができてしまいます

[f:id:keyesberry:20100315094411p:image]


説明がずいぶんと冗長になってしまいました
より良い方法をご存知ならコメント頂ければ助かります

</body>
</day>
<day date="2010-03-18" title="">
<body>
*p1*Yet Another Ruby FizzBuzz
FizzBuzzはプログラムする人の最初のfilterプログラムだ(([http://www.aoky.net/articles/jeff_atwood/why_cant_programmers_program.htm:title=どうしてプログラマに・・・プログラムが書けないのか?]))
だからプログラムをするのならFizzBuzzを解かなきゃならない
こうしてプログラムする人の数だけFizzBuzzが生まれる
そして今日もまた別のFizzBuzzが生まれた
&gt;|ruby|
module Enumerable
  def fizzbuzz(opt)
    map do |num|
      opt.to_a.sort_by{|i, _| -i}.push([1, num])
      .detect {|i, _| (num % i).zero?}.last
    end
  end
end

puts (1..100).fizzbuzz(3 =&gt; 'Fizz', 5 =&gt; 'Buzz', 15 =&gt; 'FizzBuzz')
||&lt;

</body>
</day>
<day date="2010-03-24" title="">
<body>
*p3*Yet Another Ruby FizzBuzz その4
&gt;|ruby|
class Fixnum
  def fizzbuzz
    w = {Fizz: 3, Buzz: 5}.select { |_, base| (self%base).zero? }
    w.empty? ? self : w.keys.join
  end
end

(1..100).each { |i| print &quot;#{i.fizzbuzz} &quot; }
||&lt;

Enumerable#injectのほうがいいかな
&gt;|ruby|
class Fixnum
  def fizzbuzz
    w = {Fizz: 3, Buzz: 5}.inject(&quot;&quot;) { |mem, (word, base)| (self%base).zero? ? mem &lt;&lt; word : mem }
    w.empty? ? self : w
  end
end

(1..100).each { |i| print &quot;#{i.fizzbuzz} &quot; }
||&lt;

*p1*Yet Another Ruby FizzBuzz その3
&gt;|ruby|
divisible_by = lambda { |base, num| (num % base).zero? }.curry
divisible_by_15 = divisible_by[15]
divisible_by_3 = divisible_by[3]
divisible_by_5 = divisible_by[5]

(1..100).each do |i|
  puts case i
       when divisible_by_15 then 'FizzBuzz'
       when divisible_by_3 then 'Fizz'
       when divisible_by_5 then 'Buzz'
       else i
       end
end
||&lt;
*p2*Yet Another Ruby FizzBuzz その2

&gt;|ruby|
class Fixnum
  def self.fizzbuzzize
    alias org_to_s to_s
    def to_s
      if    self%15 == 0 then &quot;FizzBuzz&quot;
      elsif self%3  == 0 then &quot;Fizz&quot;
      elsif self%5  == 0 then &quot;Buzz&quot;
      else self.org_to_s
      end
    end
  end

  def self.unfizzbuzzize
    undef to_s
    alias to_s org_to_s
  end
end

Fixnum.fizzbuzzize
(1..100).each { |i| print &quot;#{i} &quot; }
puts
Fixnum.unfizzbuzzize
(1..100).each { |i| print &quot;#{i} &quot; }

||&lt;

[http://d.hatena.ne.jp/keyesberry/20100318/p1:title=Yet Another Ruby FizzBuzz - hp12c]

</body>
</day>
<day date="2010-05-27" title="">
<body>
*p1*Rubyでマリオを奏でよう！ ～_whyのbloopsaphoneの紹介
2009年8月19日Ruby界の鬼才_why((http://en.wikipedia.org/wiki/Why_the_lucky_stiff:title))が
ネットから忽然と姿を消しました((http://www.rubyinside.com/why-the-lucky-stiff-is-missing-2278.html:title))
この突然の出来事にRubyist達は驚きそして困惑しました
なぜなら彼自身がただネットから消えたのではなく
_whyはネット上の彼の痕跡も同時にすべて消し去ったのです！


Rubyのガイドブック　ブログ　音楽　カートゥーン
そしてアクティブなライブラリを含む多数のプログラムコード
camping hpricot redcloth shoes TryRuby metaid...
_whyは削除コマンドを実行して
_whyの作品群をクラウドのメモリーから削除しました


このような行動に対しネット上には賛否両論がありましたが
多くの人はそこに至った_whyの心情を悲しみました


そう_whyは_whyの手によって抹殺されたのです...


しかし


_whyにも削除できない記憶域がありました
それはクラウドの向こう側にいる人々の脳内記憶でした
_whyというユニークなペルソナを
人々の記憶から消し去ることは彼にもできなかったのです


その結果としてコミュニティにより
_whyの作品群はネット上に再生されました


[http://viewsourcecode.org/why/:title=_why's Estate]


ポストモダン時代の天才として
_whyの軌跡を追う記事が最近書かれました


[http://www.smashingmagazine.com/2010/05/15/why-a-tale-of-a-post-modern-genius/:title=Why: A Tale Of A Post-Modern Genius]


改めて_whyのユニークさを実感します


そう_whyは今も生きているのです...


**bloopsaphone
先の記事で_whyのbloopsaphoneというライブラリを知りました
以下ではその使い方を簡単に説明したいと思います


bloopsaphoneはファミコンサウンドのような
電子音を作るためのRubyとCのライブラリです


[http://github.com/mental/bloopsaphone:title=mental's bloopsaphone at master - GitHub]


まずはbloopsaphoneで作った音を聞いてください


[http://dl.dropbox.com/u/58702/sample.mp3:sound]


これはライブラリに付属の次のコードを再生したものです

&gt;|ruby|
test.rb
require 'bloops'

# the song object
b = Bloops.new
b.tempo = 320

# an instrument
saw = b.sound Bloops::SINE
#saw = b.sound Bloops::SAWTOOTH

# assign a track to the song
b.tune saw, &quot;c5 c6 b4 b5 d5 d6 e5 e6b&quot;

# make it go
b.play
sleep 1 while !b.stopped?

# a percussion
beat = b.sound Bloops::NOISE
beat.repeat = 0.6

# assign a track to the song
b.tune beat, &quot;4 4 b4 4 d5 4 e5 e6&quot;

# make it go
b.play
sleep 1 while !b.stopped?
||&lt;
ライブラリにはドキュメントがないですが
サンプルコードを見れば大体使い方がわかります


手順としては次のようになります
+Bloops.newでsongオブジェクトを作り(Bloopsクラスのインスタンス生成)
+tempoメソッドでテンポを決め
+soundメソッドで楽器(音)を選び(Soundクラスのインスタンス生成)
+setterメソッドで音質調整をし
+tuneメソッドで楽譜をセットして(Trackクラスのインスタンス生成)
+playメソッドで再生する


複数トラックの再生が可能で
この例では１回目は１トラック
２回目は２トラックで再生しています


楽器(sound)にはSQUARE SAWTOOTH SINE NOISEの４種があって
そのベース音に対して音質調整用メソッド(ここではrepeat)で
音質調整して最終的な音質を決めます


楽譜はRTTTL(Ring Tone Transfer Language)((http://en.wikipedia.org/wiki/Ring_Tone_Transfer_Language:title))を
ベースにした記法の文字列を渡します
音符の音価(長さ)と音高と音程(オクターブ)を
数字・アルファベット・数字の組で表します
例えば&quot;8:F#4&quot;は&quot;８分音符F#(ファ#)オクターブ４&quot;を表します
音価と音程は省略可能でありその場合はデフォルト値が使われます
オクターブは&quot;+&quot;または&quot;-&quot;で表すこともできます
また&quot;:&quot;は省略可能です
休符は数字のみで表されて例えば&quot;4&quot;は&quot;４分休符&quot;を表します


(READMEにある)シンプソンのテーマは次のようになります
&gt;||
32 + C E F# 8:A G E C - 8:A 8:F# 8:F# 8:F# 2:G
||&lt;


これは以下を表しています
&gt;||
32分休符 １オクターブ上げ 4分C 4分E 4分F# 8分A 4分G 4分E 4分C
１オクターブ下げ 8分A 8分F# 8分F# 8分F# 2分G
||&lt;


**インストール
OSXへのインストールは以下のようにします((Installing _why's Bloopsaphone on OS X http://deaddeadgood.com/2010/2/13/installing-_why-s-bloopsaphone-on-os-x/))
&gt;||
sudo port install portaudio
sudo gem install bloopsaphone -- --with-opt-lib=/opt/local/lib --with-opt-include=/opt/local/include
||&lt;
bloopsaphoneはportaudioというオーディオI/Oライブラリに依存しています


**音質調整メソッド
音質調整はBloops#soundメソッドで生成されるSoundクラスの
インスタンスメソッドで行います
それぞれ0.0～1.0の値をセットします

&gt;|ruby|
lead = b.sound Bloops::SQUARE
lead.volume = 0.5
lead.attack = 0.02
lead.sustain = 0.4
lead.decay = 0.7
lead.phase = 0.0
lead.psweep = 0.0
lead.vibe = 0.0
lead.vspeed = 0.5
||&lt;

各メソッドの機能は名前から推測できるものもありますが
そうでないものもあります
値を調整して試してみるほかないようです


音質調整は設定ファイルをロードして行うこともできます
&gt;|ruby|
require 'bloops'

bases = Dir[&quot;../../sounds/*.blu&quot;]

b = Bloops.new

bases.each do |base|
  puts &quot;** playing scale using #{base[/\w+.blu/]}&quot;
  sound = b.load base
  b.tune sound, &quot;c c# d eb e f f# g ab a bb b + c&quot;
  b.play
  sleep 1 while !b.stopped?
  b.clear
end
||&lt;
このコードはライブラリに添付の複数の設定ファイルを読み出し
各音質で同じコードを再生するものです
音質調整で様々な音が再現できることが分かると思います


[http://dl.dropbox.com/u/58702/sample2.mp3:sound]


ここで再生した各設定ファイルは以下の通りです

&gt;||
dart.blu
type    noise
punch   0.524
sustain 0.160
decay   0.367
freq    0.296
slide  -0.373
vibe    0.665
vspeed  0.103
phase   0.141
psweep -0.005
||&lt;

&gt;||
error.blu
type      square
sustain   0.333
decay     0.380
freq      0.336
slide     0.292
square    0.289
sweep     0.020
vibe      0.002
lpf       0.220
lsweep    0.015
resonance 0.875
aspeed    0.035
repeat    0.551
||&lt;

&gt;||
ice.blu
type    square
punch   0.441
sustain 0.067
decay   0.197
freq    0.499
||&lt;

&gt;||
jump.blu
type    square
sustain 0.266
decay   0.187
freq    0.268
slide   0.179
square  0.326
vibe    0.227
vspeed  0.231
||&lt;

&gt;||
pogo.blu
type      square
volume    0.977
punch     0.190
sustain   0.165
slide     0.100
dslide    0.030
square    0.048
sweep    -0.055
vibe      0.437
vspeed    0.310
lpf       0.355
resonance 0.185
hpf       0.205
hsweep    0.255
arp       0.677
aspeed    0.275
phase     0.200
psweep   -0.565
repeat    0.500
||&lt;

&gt;||
stun.blu
type    sawtooth
sustain 0.306
decay   0.477
freq    0.429
slide   0.217
repeat  0.677
||&lt;


**メソッド一覧
bloopsaphoneのメソッド群は次のようになります
&gt;||
Bloopsクラス
 instance methods: clear, load, play, sound, stopped?, tempo, tempo=, tune
 constants: SQUARE, SAWTOOTH, SINE, NOISE

Soundクラス
 instance methods: arp, arp=, aspeed, aspeed=, attack, attack=, decay, decay=, dslide, dslide=, freq, freq=, hpf, hpf=, hsweep, hsweep=, limit, limit=, lpf, lpf=, lsweep, lsweep=, phase, phase=, psweep, psweep=, punch, punch=, repeat, repeat=, resonance, resonance=, slide, slide=, square, square=, sweep, sweep=, sustain, sustain=, type, type=, vibe, vibe=, vspeed, vspeed=, vdelay, vdelay=, volume, volume=

Trackクラス
 instance methods: to_s
||&lt;


**BloopSong DSL
bloopsaphoneで長い楽譜を再生しようとすると
以下のような問題がありました
+CPUの占有率が徐々に上がって途中で再生不能になる
+トラック数が増えるとコードの可読性が下がる
+トラック数を変えたり楽譜の一部の小節だけを再生をするのに手間が掛かる


そこでこれらの問題に対応するために
BloopSongという簡単なＤＳＬを書きました

&gt;|ruby|
require &quot;bloops&quot;

class BloopSong
  def self.init(tempo)
    @bloops = Bloops.new
    @bloops.tempo = tempo
    yield self
    self
  end

  def self.play(score, opt={})
    score = read_score(score)
    tunes = Array(opt[:tune] || :lead)
    range_max = score[tunes.first].length-1

    for i in range(opt[:range], range_max)
      tunes.each do |tune|
        @bloops.tune send(tune), score[tune][i]
      end
      @bloops.play
      sleep 0.01 until @bloops.stopped?
      @bloops.clear
    end
  end

  def self.define_class_method(name)
    (class &lt;&lt; self; self end).module_eval { define_method(name) { yield } }
  end

  def self.sound(name=:lead, type)
    self.instance_variable_set(&quot;@#{name}&quot;, @bloops.sound( Bloops.module_eval(type.to_s) ))
    define_class_method(name) { self.instance_variable_get(&quot;@#{name}&quot;) }
    yield send(name) if block_given?
    @bloops
  end

  def self.read_score(score)
    q = Hash.new([])
    flag = :lead
    score.each_line do |line|
      next if line =~ /^\s*$/
      case line
      when /^:(\w+)/ then flag = $1
      else
        q[flag.to_sym] += [line]
      end
    end
    q
  end

  def self.range(opt, max)
    if !opt
      (0..max)
    elsif opt.end &gt; max || opt.end &lt; 0
      (opt.begin..max)
    else
      opt
    end
  end
end
||&lt;


以下のように使います

&gt;|ruby|
require_relative &quot;bloopsong&quot;

mario =
  BloopSong.init(216) do |b|
    b.sound(:lead, :SQUARE) do |s|
      s.volume  = 0.4
      s.punch   = 0.441
      s.sustain = 0.067
      s.decay   = 0.297
      s.freq    = 0.499
    end
  
    b.sound(:lead2, :SQUARE) do |s|
      s.volume  = 0.4
      s.punch   = 0.441
      s.sustain = 0.067
      s.decay   = 0.297
      s.freq    = 0.499
    end

    b.sound(:base, :SQUARE) do |s|
      s.volume  = 0.4
      s.punch   = 0.641
      s.sustain = 0.197
      s.decay   = 0.197
      s.freq    = 0.499
    end
  end

mario.play(DATA, :range =&gt; 0..-1, :tune =&gt; [:lead, :lead2, :base])

__END__
:lead
 8E5 8E5 8 8E5 8 8C5 4E5    4G5 4 4G4 4           4C5 8 8G4 4 4E4          8 4A4 4B4 8A#4 4A4
 6G4 6E5 6G5 4A5 8F5 8G5    8 4E5 8C5 8D5 4B4 8   4C5 8 8G4 4 4E4          8 4A4 4B4 8A#4 4A4
 6G4 6E5 6G5 4A5 8F5 8G5    8 4E5 8C5 8D5 4B4 8   4 8G5 8F#5 8F5 4D#5 8E5  8 8G#4 8A4 8C5 8 8A4 8C5 8D5
 4 8G5 8F#5 8F5 4D#5 8E5    8 4C6 8C6 4C6 4       4 8G5 8F#5 8F5 4D#5 8E5  8 8G#4 8A4 8C5 8 8A4 8C5 8D5

:lead2
 8F#4 8F#4 8 8F#4 8 8F#4 4F#4   4G4 4 4G4 4          4E4 8 8E4 4 4C4         8 4C4 4D4 8C#4 4C4
 6C4 6E4 6B4 4C5 8A4 8B4        8 4A4 8E4 8F4 4D4 8  4E4 8 8E4 4 4C4         8 4C4 4D4 8C#4 4C4
 6C4 6E4 6B4 4C5 8A4 8B4        8 4A4 8E4 8F4 4D4 8  4 8E5 8D#5 8D5 4B4 8C5  8 8E4 8F4 8A4 8 8C4 8E4 8F4
 4 8E5 8D#5 8D5 4B4 8C5         8 4G5 8G5 4G5 4      4 8E5 8D#5 8D5 4B4 8C5  8 8E4 8F4 8A4 8 8C4 8E4 8F4

:base
 8D3 8D3 8 8D3 8 8D3 4D3   4G3 4 4G3 4           4G3 8 8E3 4 4C3         8 4F3 4G3 8F#3 4E3
 6E3 6C4 6E4 4F4 8D4 8E4   8 4C4 8A3 8B3 4G3 8   4G3 8 8E3 4 4C3         8 4F3 4G3 8F#3 4E3
 6E3 6C4 6E4 4F4 8D4 8E4   8 4C4 8A3 8B3 4G3 8   4C3 8 8G3 4 4C4         4F3 8 8C4 4C4 4F3
 4C3 8 8E3 4 8G3 8C4       2 4 4G3               4C3 8 8G3 4 4C4         4F3 8 8C4 4C4 4F3 
||&lt;


BloopSong.initの引数にテンポを渡し
そのブロック内で各楽器の設定を行います
楽器を指定するsoundメソッドの引数には
楽器名とその種類をシンボルで渡し
そのブロック内で音質調整を行います


楽譜はplayメソッドの第1引数に文字列として渡します
渡す文字列においてパート名はシンボル表記します
省略すると:leadが自動的にセットされます


BloopSong.playメソッドは
 :rangeと:tuneの２つキーワード引数を取ります
rangeは楽譜の再生行(小節ではない)を指定します
例のようにするか省略した時にはすべてを再生します
tuneで指定したパートのみを再生します


[http://dl.dropbox.com/u/58702/mario_theme.mp3:sound]


コードは以下のリンクにあります


[http://github.com/melborne/bloopsong:title=melborne's bloopsong at master - GitHub] 


(追記：2010-12-4)bloopsongの修正に伴い、コードおよび一部記述を修正しました。


[関連サイト]
[http://www.urbanhonking.com/ideasfordozens/2009/05/early_8bit_sounds_from__whys_b.html:title=Early 8-bit Sounds from _why's Bloopsaphone]
[http://www.aanandprasad.com/1901:title=A chiptune cover of Phoenix’s “1901”]
[http://adminmyserver.com/articles/ruby-pong-with-shoes-and-bloopsaphone:title=AdminMyServer - ruby pong with shoes and bloopsaphone]

</body>
</day>
<day date="2010-06-10" title="">
<body>
*p1*Termtterなら友だちだって見つけられる！
Twitterにおけるfollower数はその人の戦闘力を表すらしい((あたしンちのおとうさんのtumblr http://atasinti.tumblr.com/post/642439101/16-6))
だからこの戦場で生き抜くためにはfollower数を増やさなきゃいけない
将来起こるであろう有名人や名の知れたプログラマとの戦いのために
今から少しずつfollower数を増やさなきゃいけない


follower数を増やすための正攻法はfollowing数を増やすことだ
followした人の何人かに一人はfollowを返してくれる
これを地道に続ければ君の戦闘力は少しずつ上がる


だけど無闇にfollowingを増やすとTimelineが汚れる
わけのわからないつぶやきでTimelineが埋まる
だからできれば自分と共通の関心を持っている人だけをfollowして
Timelineが汚れないようにしたい


**Searchコマンド
Termtterのsearchコマンドを使えば共通の関心を持った人
そう友だち！を見つけられるかもしれない


&gt;|ruby|
 % search iPad
  =&gt; 
[$lj] mstearne: CHART OF THE DAY: iPad Browser ...
[$lk] UNZAN: 電子機器の操作音って嫌いなので基本オフで ...
[$ll] Clean_Inside: Now Hiring Ipad Testers htx...
[$lm] javilabbe: RT @Alyssa_Milano: Apple secu...
[$ln] OpiesClub: Should I Worry About the Appl...
[$lo] sansonso: IPadはなかなかよい、ね。重さやら、大...
[$lp] SuePolinsky: Friend wants gift for wife, ...
[$lq] melamorsicata: La RAI sta per lanciare un...
[$lr] P3Linz: RT @Alyssa_Milano: Apple security...
[$ls] moraimon: Bloomberg Anywhere for iPadも近...
[$lt] joycem137: AT&amp;T releases email addresses...
[$lu] opn1: iPadを往年の一体型マッキントッシュやiBo...
[$lv] book_bee: Ebook news:: iBook modder find...
[$lw] kakocom: どっちかというと判を押したように「値段...
[$lx] oyvindrobertsen: Thinking of having a fr...
||&lt;


でもsearchコマンドの出力はつぶやき単位なので
その中から特定のユーザを見つけ出すのは容易じゃないし
うまくいかない場合もある

&gt;|ruby|
 % search termtter
  =&gt; 
[$dm] lingr_termtter: Sora Harakami: ！ #termt...
[$dn] lingr_termtter: jugyo: 確かにそんなエラーに...
[$do] lingr_termtter: jugyo: なんなんですかねー #...
[$dp] lingr_termtter: hitode909: 前は動いてたのに...
[$dq] lingr_termtter: jugyo: API が変わったとかじ...
[$dr] lingr_termtter: hitode909: http://apiwik....
[$ds] lingr_termtter: hitode909: 前と変わりなさそ...
[$dt] lingr_termtter: hitode909: list系のAPIにp...
[$du] lingr_termtter: hitode909: list listとか...
[$dv] lingr_termtter: jugyo: じゃ、Twitter 側の...
[$dw] lingr_termtter: hitode909: こちらからはど ...
[$dx] hinatter: クソンドクソンプトでtermtterはキ...
[$dy] igrep: もっかいフォローボタン押してみ。termt ...
[$dz] aibou: @c_cha termtter Termtter       ...
[$ea] jugyo: RT @ujm: I was demonstrating ho...
||&lt;


**User Searchコマンド
user searchコマンドを使えばより効率的に
友だちを見つけられるかも知れない
&gt;|ruby|
 % user search steve jobs
  =&gt; 
@_FakeSteveJobs (Fake Steve Jobs): Let's see...
@ceoSteveJobs (Steve Jobs): I don't care wha...
@FSJ (Fake Steve Jobs): Dude, I invented the...
@stevejobs (_):                             
@fatstevejobs (Steve Jobs++): Bigger and Bad...
@FakeSteveJobs (Fake Steve Jobs):           
@f_stevejobs (Fake Steve Jobs): I am meant t...
@applehot (steve jobs): Apple Computer news 
@Steve_Jobs_Is (Steve_Jobs_Is): To the best ...
@stevejobsiphone (Steve Jobs' iPhone):      
@SJQOTD (Steve Jobs Quotes): NOT RUN BY STEV...
@SteveVV (Steve Jobs):                      
@Zombie_Steve (Zombie Steve Jobs): iLife sta...
@ninggiree (Steve Jobs Big Fan): iPhone &amp; An...
@stevewritingjob (Steve Writing Jobs): I wor...
@sJobs (Steve Jobs): Soy el jefe y salvador ...
...
||&lt;


でもuser searchコマンドはユーザ名とscreen nameにだけヒットして
その人のプロフィールとかつぶやきにはヒットしない

&gt;|ruby|
 % user search termtter
 =&gt;
@termtter (termtter): 
@lingr_termtter (lingr_termtter):
||&lt;


つまりuser searchでは
特定の事項に関心のある人を見つけることは難しい
僕が見つけたいのは「勝間和代さんに関心のある人」であって
名前が「勝間」の人じゃない！

&gt;|ruby|
 % user search 勝間
 =&gt; 
@antikatsumah (アンチ　勝間): アンチ勝間和代がどれ...
@gkatsuma (勝間　豪): 島根出身の田舎者！東京怖いよ...
@jf1wkx (勝間　伸雄): 
@ROCOJUNIOR (勝間　裕紀子): 
@katsumaFC (勝間): 
@nisekatsuma (勝間): 
@koolkings57 (勝間): 
||&lt;

**Fuzzy Findコマンド
そんなわけでfuzzy find(またはff)コマンドを作りました
ffではユーザのprofileページを検索するので
その人の名前だけでなく
何となく(fuzzyに)profileやつぶやきにもヒットします


[f:id:keyesberry:20100610075958p:image]

defaultで10件をリストアップし
上記のように-l[NUM]で件数を変えられます
リストアップされたprofileページを開きたいなら
uri-open all するか数字をヒットします


これなら効率的にTermtterer((Termtter使い))を探せますね！


vオプションでverbose(冗長)モードになります

[f:id:keyesberry:20100610075959p:image]

この場合uri-openではそのユーザのHOMEサイトが開きます


これなら効率的にカツマーを探せますね！


Termtterなら友だち探しも完璧です！


以下のサイトからtwitter_search.rb fuzzy_find.rbをDLして
.termtter/pluginに配置し plug fuzzy_find してください
このライブラリはRubyライセンスにより提供されます


[http://gist.github.com/297408:title=gist: 297408 - Termtter plugins- GitHub] 

</body>
</day>
<day date="2010-06-11" title="">
<body>
*p1*オープンソース・プログラマも知っておきたい商標のこと（その１）
オープンソース・プログラミング言語Perlの商標が
第三者によって登録されたことが話題になっている


[http://neta.ywcafe.net/001096.html:title=北畠徹也氏、「Ｐｅｒｌ／パール」を手中に] 


この者はPerlのみならずRUBY Python Apache
OPENSOURCE Jakartaなどについても申請をしている


[http://neta.ywcafe.net/001095.html:title=北畠徹也氏が「RUBY（ルビー）」と「Apache（アパッチ）」を商標登録している件] 


これに対してどうやらPerl Rubyコミュニティでは
専門家を交えて何らかの対策を検討しているようだ


[http://twitter.com/lestrrat/status/15770448730:title=Twitter / Daisuke Maki:] 
&gt;&gt;
Perl商標に関しては「気持ち悪い」ということ以外 事実上問題はない、というのが現在の認識。ただし、だからといって何もしないというわけではないですよ。すでに先日よりあちこちに連絡を取ったりはして動き始めています
&lt;&lt;

[http://twitter.com/yukihiro_matz/status/15760265274:title=Twitter / Yukihiro Matsumoto:] 
&gt;&gt;
登録商標について。Rubyはおそらく成立しないだろうけど、阻止すべくアクションを取ることに(有料)。いろいろ聞いたけど、結論としては、早急にアクションを取るべきはむしろPerlの方ではないかと。詳細はここには書かないけど。
&lt;&lt;

オープンソースの社会的役割が増すにつれ
この種の問題は今後も増えていくことが予想される


一方


オープンソース・プログラマの商標についての知識は
現状では相当イタい


[http://blog.livedoor.jp/dankogai/archives/51457930.html:title=404 Blog Not Found:All your name are belong to Tetsuya Kitahata!? (lol) ]
&gt;&gt;
先に行っておくと、Perlに関しては多分安心していい。すでに「本家」である The Perl Foundation が国際商標登録しているのだ。
&lt;&lt;
「出願」を「登録」と勘違いするなんて
「free」を「無料」と訳すようなものである


[http://d.hatena.ne.jp/keyesberry/20090223/p1:title=ストールマンは謳う ～正しさと　困難さと　心強さと - hp12c] 


こっちも知識に相当ホコリが積もっているけれど
このまま見過ごすこともできないので
ここで少し商標の基礎知識を解説して
オープンソース・プログラマの知識レベルの向上を図りたいと思う
しっかりと学んでおくように！

**商標とは商品・サービスの識別標識である

商品には普通固有の名前が付いている
商取引においては名前がないと困るからだ
&gt;&gt;
君：「えっと、あの画面をタッチして演奏したり絵を描いたりできるやつ。大きいほうの。」
店員：「ああ、わかりました。LLですね。トモダチコレクションも一緒に如何ですか？」
&lt;&lt;
サービスについても同様だ
&gt;&gt;
友だち：「情弱って何？」
君：「ネット最大検索れ、カス！」
&lt;&lt;

また異なる商品に同じ名前が付いていても困る
&gt;&gt;
君：「iPadをポチした」
Amazon：「今回はASUS製とさせて頂きました！」
&lt;&lt;

市場において特定の名称が特定の商品にしか付けられない
つまり「iPad」がApple社のあの商品にしか付けられない
ということが保証されれば
商取引において消費者を迷わすことはない
このために企業や団体は商標を取得する
自社の商品を間違いなく手にして欲しいからだ


商標の多くは文字で構成されるけど
それは図形であってもいい
リンゴマークだって商品の識別標識として機能するからね
また商標は文字と図形の組み合わせであってもいい

[f:id:keyesberry:20100611190709p:image]

ただこの場合はこれらのセットで１つの商標になる点注意が必要だ
そのセットとその一方とは厳密には別の商標になる


英語では商品につけた商標をtrademark(トレードマーク)といい
サービスにつけた商標をservicemark(サービスマーク)という
日本では商標と言ったら両方を指す


よく名前の後にゴミみたいに(R) (TM) (SM)とか付いてることがある
(R)はregistered(登録済み)を表しTM SMは登録前を一般に表す
これは米国では権利者の一部義務となっているようだけど
日本では慣行的に用いられているに過ぎない
著作権表記の(C)(copyright)なんてのも同類だ


**出願と登録は別物である

商標の権利を取得したい者は書類を一式揃えて
特許庁に申請しなければならない
申請に際しては何の商品(またはサービス)に
どんな商標を使いたいのかを明示しなければならない
これを出願という(商標法第５条)


しかし出願されたものがすべて
自動的に権利になるかと言えばそうではない
出願された商標が権利に適うものかを調べて
そうでないものは拒絶したり修正させたりする
これを審査という(商標法第１５条)


何を調べるかといえば「いろいろ」である
いろいろではあるが重要なのは３つだ


まずその商標が「商標足り得るか」ということを調べる
これは商標法第３条に書いてある
つまりその商標を対象の商品に付けたときに
他の商品との間で「識別標識」として機能するかを調べる
例えば「コンピュータプログラム」という商品や
「コンピュータプログラムの設計・作成・保守」というサービスに
「プログラミング言語」という商品名・サービス名を付けても
識別標識としては機能し得ないから審査官はこれを拒絶する


特に識別標識として機能するか否かは
それが付される商品によって変わるということが重要だ
例えば「コンピュータプログラム」という商品に
「Perl」とか「Ruby」という商品名を付ければ
それは識別標識として機能するだろうけれども
「宝石」という商品にこれらの商品名を付けても機能しない
わかるよね？


次に第三者によって同じような商標が
既に取得されていないかを調べる
これは商標法第４条１項１１号と第８条に書いてある
これも商標の機能からいって当然のことだけれども
ここで難しいのは「同じような」ってところだ
法律では「同一又は類似」と表現される
例えば「perl」と「perls」「Ruby」と「Ruppy」「Apache」と「Adache」
これらが類似かどうかの判断は
専門家をして必ずしも容易ではない
同一又は類似の解説だけで分厚い本一冊が書けるくらいだ
基本はその音(称呼)で判断するけど
いろいろなヴァラエティがあるのでここでは説明しない
そういえば昔「Fender」ならぬ「Founder」
「Gibson」ならぬ「Gabson」ってギターメーカーあったっけ


ここで同じ商品同じ商標について２つの出願があった場合は
当然先に出願したほうに優先権がある
では同じ日にあった場合はどうなるか
話し合いで決めさせる
じゃあ話し合いが物別れになったら？
この答えは宿題としよう


それからもう一点注意が必要なのは
仮に２つの商標が全く同じでも
これらの商品やサービスが全く別なものである場合には
２つの出願は双方が登録され得るという点だ
これについては後で述べる


次にその業界で既に広く使われているものと同じような商標か
それと混同するような商標か否かを調べる
簡単に書くとこういうことなんだけれども
おそらくオープンソース・プログラマにとっては
最重要規定になると思うのでここに法律を引用しておく

&gt;&gt;
（商標登録を受けることができない商標）
第４条　次に掲げる商標については、前条の規定にかかわらず、商標登録を受けることができない。
10．他人の業務に係る商品若しくは役務を表示するものとして需要者の間に広く認識されている商標又はこれに類似する商標であつて、その商品若しくは役務又はこれらに類似する商品若しくは役務について使用をするもの
15．他人の業務に係る商品又は役務と混同を生ずるおそれがある商標（第10号から前号までに掲げるものを除く。）
19．他人の業務に係る商品又は役務を表示するものとして日本国内又は外国における需要者の間に広く認識されている商標と同一又は類似の商標であつて、不正の目的（不正の利益を得る目的、他人に損害を加える目的その他の不正の目的をいう。以下同じ。）をもつて使用をするもの（前各号に掲げるものを除く。）
&lt;&lt;

まずリファクタリングが必要だな
４条１項１０号と１９号は

&gt;|ruby|
def 周知商標(area=日本国内)
  &quot;他人の業務に係る商品類を表示するものとして#{area}において需要者の間に広く認識されている商標&quot;
end

def 商品類
  &quot;商品若しくは役務&quot;
end

def 同じような商品類
  &quot;同一又はこれらに類似する商品類&quot;
end

def 同じような商標
  &quot;同一又はこれに類似する商標&quot;
end

def 不正の目的
 &quot;不正の利益を得る目的、他人に損害を加える目的その他の不正の目的&quot;
end

alias 役務 サービス

10．周知商標と同じような商標であつて、その商品類と同じような商品類について使用をするもの
19．周知商標(日本国内又は外国)と同じような商標であつて、不正の目的をもつて使用をするもの（前各号に掲げるものを除く。）
||&lt;

業界で周知の商標について
第三者が出願をしても登録を受けることはできない


きっとここでみんな胸をなで下ろしていると思う
この規定があればオープンソースは守られると
基本的にその感覚は正しい


そうすると次に疑問が湧いてくる
「じゃあなぜ件のPerlは登録されたんだい？」


ここでは２つの可能性を上げておく
１つ目は
「審査官はこれらの判断をしていない又はできない」ということだ
最初の２つの審査(商標法第３条と第４条１項１１号)と
この３つ目の審査(４条１項１０他)との違いは何か
それは最初の２つは特許庁の内部資料で処理できるけれども
３つ目はいわゆるフィールドワークが必要であるということだ
つまり審査においてその商標が
「需要者の間に広く認識されている」とか
「混同を生ずるおそれがある」とか
「不正の目的をもって使用する」とか
の事項を判断するためにはその業界人の声が必要である


２つ目の可能性は
「業界で周知なPerlはプログラミング言語としてのPerlであって
プログラムに関連するサービスで周知なわけではない」という判断だ
件の商標登録はその指定された商品が以下のようになっている
&gt;&gt;
 第42類　電子計算機のプログラムの設計・作成又は保守、電子計算機の貸与、電子計算機プログラムの提供
&lt;&lt;

少し分かりにくいけれどもこれらは
コンピュータおよび
そのプログラムに関連したサービス業務を示している
金融系システム開発とかＷｅｂサイト作成代行業とか
Ｗｅｂサービス業などが絡みそうだ
一方でPerlは確かにプログラミング言語としては有名だけれども
これらのサービスの名称として業界に広く知られているとは言えない
そのように判断された可能性を考えることもできる((計算機プログラムの提供とプログラミング言語のプログラムは類似するから、この可能性は低いけど))


それから個人的にはこの商標がなんで登録されたのか
別の理由(４条１項１１号)でちょっと疑問がある
その説明は後日することになると思う


と書いた後で
既に同じ疑問を提示している方発見！
もう僕の言うことなし


[http://nplll.com/mutter/archives/2010/06/perl_1.php:title=Perlの商標の件について業界の友人に聞いてみた - nplll: Mutter] 


商標の出願というのは年間で大体１２万件ある
３００件／１日だ
特許庁の審査官は１３００人くらいはいるらしいけど
そのうち商標の担当がどれくらいなのかはわからない
きっと１００人もいないよ((140人くらいいるそうです))
だからフィールドワークなんて現実的じゃない
ちなみに特許は年間で３５万件
１０００件／１日だ


特許と違って商標の登録率
つまり登録件数／出願件数は８割以上と高いけど
これは出願前の事前調査で登録の可能性が読みやすいのと
審査の過程で対象の商品を絞り込むことがよく行われるからだと思う
ストレートに行けば登録までは半年
そうでない場合は何年も掛かることがある


ちょっと長くなっちゃったけど要するに
３つ目の審査はスルーされる可能性が高い
ということを是非とも頭に入れておいて頂きたい

(次回に続く)

</body>
</day>
<day date="2010-06-12" title="">
<body>
*p1*オープンソース・プログラマも知っておきたい商標のこと（その２）


**商標の権利は商品・サービス単位である
無事審査官のお眼鏡に適った商標は登録される
登録されると登録番号が付いて
出願人は商標権者になる
ちなみに出願をすると出願番号というものが付くけど
それは単なる受付番号であってこの登録番号とは価値が全然違う
間違わないように！


権利者になると何がいいのかというと
その商標の使用を独占できるっていうことだ
つまり他人が勝手にその商標を使ったら
「使うな」とか「カネよこせ」とか
「いい子にするなら使わせてやる」とか
「お前はクズだ」とか言える


だけど無制限にそんな暴君が許されるわけじゃない


権利の範囲は書類に列挙した商品・サービスに限られる
当然だよね
仮に誰かが「JAVASCRIPT」という商標の権利を持っていて
その書類には商品として
「電子計算機プログラム」だけが記載されている場合
君が「電気式ワックス磨き機」とか「映写フィルム」とか
「電線」とか「犬笛」とかに
「JAVASCRIPT」という名称を付けて商売を始めても
その権利者は一切文句を言えないので
君は安心して商売を続けることができるというわけだ


具体例を見てみよう

[f:id:keyesberry:20100612182836p:image]


ここでこの権利の商品は「電子応用静電複写機用感光ドラム」
「コンピュータプリンター用感光体ドラム」となっている
従ってこれら以外の商品・サービス
例えば「コンピュータプログラム」について
「Ruby」という商標を使用する行為は原則権利の外の行為になる
ちょっと歯がゆい言い方をしていて申し訳ないけど
その理由は先を読んで納得してほしい


でも注意すべきことがある
法律は基本的に権利者寄りであることと
権利者は基本的に強欲であるということだ


つまり商標の権利はその商標その商品・サービスだけじゃなく
それと同じような商標同じような商品・サービスにも及ぶ
&gt;&gt;
（侵害とみなす行為）
第三十七条
　次に掲げる行為は、当該商標権又は専用使用権を侵害するものとみなす。
一　指定商品若しくは指定役務についての登録商標に類似する商標の使用又は指定商品若しくは指定役務に類似する商品若しくは役務についての登録商標若しくはこれに類似する商標の使用
&lt;&lt;

また「類似」だ
商標の類似というのが相当厄介なものであることは前にも書いたけど
商品・サービスの類似っていうのもそれに劣らず厄介な代物である
これで本一冊書ける
なお「みなす」ってのは
「オレ(法)がそう決めたんだからそうだ。反論一切ナシ！」ってことだ


商品・サービスの類似に関しては
国際条約で定められた「類似群コード」というのがある
世の中の各商品・サービスには大体
この類似群コードというのが振られていて
商品・サービスの類似に関して
１つの類似群コードに属する商品・サービス同士は
審査においてはもっぱら類似と判断される


具体的に見てみよう

[f:id:keyesberry:20100612182837p:image]


ここにある
&gt;&gt;
【類似群】　42P02 42X11
&lt;&lt;
というやつが類似群コードだ


そしてこの類似群コードに含まれる商品・サービスが
同じような商品として判断される可能性がある範囲だ
類似群コードに含まれ得る商品・サービスは
特許庁のサイトで調べることができる((類似群コード: http://www.jpo.go.jp/cgi/link.cgi?url=/shiryou/kijun/kijun2/ruiji_kijun9.htm))


ちょっと話がややこしくなってきたけど
もう少し辛抱してほしい
さらに厄介なのはこの類似群コードを超えて
類似の範囲が及ぶと判断される場合があるということだ


[f:id:keyesberry:20100612182838p:image]


備考を見てほしい
「電子計算機用プログラム」の類似群コードは
11C01なんだけれども
この42X11の「電子計算機用プログラムの提供」に類似
と判断される可能性が高い


そしてさらに一つ厄介な話を付け加える
類似群コードというのは基本的に特許庁における審査の指針であって
実際の紛争があった場合に裁判所が
これをどう判断するかはわからない
つまり裁判所は類似群コードに拘束されない！


あーもうやめよう！
ここで類似を理解するのは諦めて！
紙面の無駄だよ


「類似」という概念は商標制度における迷宮だ
プログラミングにおける「文字コード」のようなもの
と言えば済むだろう
専門家だって意見がばらばらだ


１つだけ覚えておいてほしいのは
「類似」というのは究極的には
「消費者がその商品の提供元を取り違える可能性」
つまり「Ａ社の商品だと思ってＢ社の商品を買っちゃうかも」
の範囲を追求する概念だということだ


したがって現状でこの「類似」という厄介な代物に
僕たちができることは
代理となる専門家に業界の常識を正しく理解してもらう努力
彼をenergizeさせる努力
そして
裁判官　審査官そして権利者の
適切な判断への良識を祈ることだけだ


次に権利者は基本的に強欲であるということを説明する


世の中には無数の商品・サービスがあるけれど
特許庁ではそれをおおまかに４５の区分に分けて
各区分に属する商品・サービスを適当に例示してる((商品区分: http://www.jpo.go.jp/cgi/link.cgi?url=/shiryou/kijun/kijun2/ruiji_kijun9.htm))
それを商品区分っていうんだけど
基本的に出願はこの単位で行われていて((追加料金を払えば複数区分を含んで出願可能である))
その区分内であればいくつ商品・サービスを選んでもいい
また複数の商品を含む上位概念的な用語を使ってもいい


こんなルールの下
君が出願人だったらどうする？
そりゃ可能な限りの商品・サービスを選ぶわな
将来その商品についても使うかもしれないし


現実に多くの出願人はそういう判断をする
さあ現実を直視して

[f:id:keyesberry:20100612182839p:image]


「電線」にJAVASCRIPT？
「犬笛」にJAVASCRIPT？
ええ、そりゃ有りうりますよ、確かに...でもねぇ
犬笛って...


そんなわけで以上をまとめると
商標の権利は商品・サービス単位である
けれどもその範囲は
あなたが思っている以上に広いということだ


(次回に続く）

</body>
</day>
<day date="2010-06-14" title="">
<body>
*p1*オープンソース・プログラマも知っておきたい商標のこと（その３）


**商標の権利は国単位である
法律は国が定める
日本の商標法は日本が定めた
アメリカの商標法はアメリカが定めた
国ごとに商標法があってそれぞれの国が定めるから
それらはよく似ていてもちょっとずつ違う


そんな状況で日本でとった商標権が
「アメリカでも有効である」というのは理に合わない
しかし商標法には「商標権の効力は日本国内に限る」とは
わざわざ書いてない
それは言わずもがなだからである


それはちょうど日本にいて「首相は誰？」と聞かれたら
日本の首相「菅直人」が正解であることと同じようなものだ((この記述は2010年6月14日にされましたが、一月後の正解を保証しません))
だから「マイクロソフト株式会社」っていったら
誰が何と言おうとシアトルじゃなくて日本なんだよ((すいません。意味不明なことを言って))


こういう考えは「属地主義」といわれる
ちなみに刑法にはこのことが明記されている
&gt;&gt;
刑法第１条第１項
（国内犯）
第１条　この法律は、日本国内において罪を犯したすべての者に適用する。
&lt;&lt;

刑法でわざわざ規定を置いているのは
国際関係上のごたごたがいろいろとあるからなんだろうね


さて本筋に戻ろう
要するに特定の国で商標権を取得したければ
その国で出願をし審査を経て登録を受けなければならない
君が日本だけじゃなくアメリカ　フランス　ドイツ　オーストラリアで
「Ruby」ラーメンを独占的に売りたければ
それぞれの国の特許商標庁に対して
商品「ラーメン」について
「Ruby」の商標の申請をしなければならない


それぞれの出願はそれぞれの国の判断で
登録されたり拒絶されたりする
結果として同じ商品・同じ商標について
国によって権利者が異なるという事態が普通に起こる


成立した権利についても
国によって侵害の判断の基準が異なり
結果として一国で侵害と認定された行為が
他国ではお咎めナシとなり得る
それは想像がつくだろう


「国際商標」とか「世界特許」とかいう言葉をたまに耳にする
そういった理想はあるものの
現状ではその種の権利は存在しない
だからこういう言葉を耳にしたらその発信者には要注意である


しかしこれには２つの例外がある


１つ目は国際条約に基づく商標の国際登録出願だ
これは日本の特許庁に対して
複数の国を指定した１つの国際登録出願をすれば
その指定国において出願したものと取り扱う制度である((マドリッド協定議定書の概要について http://www.jpo.go.jp/seido/s_shouhyou/mado.htm))
ただこの制度は出願手続きを一まとめにするもので
審査つまり何を登録するべきかの判断を一元化するものではないし
複数の国で有効な商標権を成立させるものでもない


２つ目の例外は欧州共同体商標だ
これは国際登録出願とは異なり
欧州共同体商標意匠庁にした１つの商標出願で
ＥＵ加盟国全域をカバーする１つの商標権の取得を可能とする((OHIM - Home http://oami.europa.eu/ows/rw/pages/index.en.do))


そうするとヨーロッパでの商標の取得には３つのルート
つまり（１)各国特許庁への通常出願（２)日本特許庁への国際登録出願
（３)欧州共同体商標意匠庁((ＥＵ加盟国の特許庁でも可))への出願
を検討する必要があることになる
これらをブルジョワジーにパリルートとか
マドプロルートとかＥＵルートとか言えば
一目置かれる　きっと


以上のことをまとめると
原則として商標の権利は国ごとに成立する
複数の国で商売をするならば
各国ごとの商標の取得を検討する必要があるし
第三者による対象商標についての商標権の存在を
意識する必要がある


このことについて通常大きな混乱はない
なぜなら自社商品をどこで売るかは
基本的に自分でコントロールできるからだ
国内の販売が順調にいって外国で販売する段になって
このことを考慮すればいい
そのとき他国での商標が既に他者に取得されていた場合
商品名を変更して販売するなどの対応をとれる


一方でオープンソース・プロダクトの場合
話は厄介だ
ネットワークに乗ったプロダクトは製作者の意図に拘わらず
ユーザのいる国に向かって勝手に拡散し
一瞬にして国境を越える
製作者はそれをまったくコントロールできない((もちろんこれはオープンソース・プロダクトだけの話ではない。すべてのネット上の非パッケージプロダクトおよびサービスに言えることである))
ユーザの国には既に他者の商標権が存在するかもしれない


どうしたらいいのだろうか
可能な限りの国の出願・権利状況を事前調査し
予防的にしかるべき対応とるべきか
それとも厄介なことは忘れて鷹揚に構え
問題が生じたときに対応すればいいとするか


ベストプラクティスはないと思う
ただ次のことはその判断に役立つかもしれない


基本的にこの手の問題はどんなに手を尽くしても
「これで完璧！」とはならない
それはあらゆる予防的対策の本質的な問題で
最後には「諦めの境地」に入らざるを得ない


それから
&gt;|ruby|
'商標権の存在' != '侵害の発生'
||&lt;
である


商標権者が何らかのアクションを取って
初めて事件が顕在化するし
裁判所が認定して初めて侵害が成立する


日本だけで商標権は年間１０万件
特許権は２０万件成立する
著作権は権利の成立に法手続きを要さないから
文字通り無数に存在する
街は権利で溢れているのだ
何かをアウトプットすれば
きっとどこかで誰かの権利に抵触している


だから権利というものに
あまり神経質になりすぎるのもいけないし
急いてはいけないと思う


Paul Grahamの以下のエッセイは
ソフトウェア特許に関するものだけど
商標の権利をどうするべきかという判断をする上でも
一読の価値があると思う


[http://d.hatena.ne.jp/lionfan/20060805:title=ポール・グレアム「ソフトウェア特許は有害か？」 - らいおんの隠れ家] 


一方で
不安で眠れない夜が続くのなら
安定剤を買って飲むことも悪くはない判断だと思う
ただこれは今確実に発生する１の費用を取るか
将来Ｘ％の確率で発生するその数倍から数十倍の費用を取るかの
選択の問題なのだろう


ちなみに少しネットで調べてみたところ
Yet Another Society(The Perl Foundation)では
少なくとも日本　米国　ＥＵ加盟国で「Perl」の商標出願をしており
日本を除く各国で権利が成立しているようだ((それ以外の国については未調査))


日本

[f:id:keyesberry:20100614195902p:image]


米国

[f:id:keyesberry:20100614195859p:image]

&gt;&gt;
Word Mark  	 PERL
Goods and Services 	IC 009. US 021 023 026 036 038. G &amp; S: computer software for use in cross-platform software application, software component and website development; computer software for use in developing, analyzing, coding, checking and controlling other computer software; and computer software that implements a procedural and object-oriented programming language. FIRST USE: 20041113. FIRST USE IN COMMERCE: 20041113
Serial Number 	76629502
Filing Date 	January 27, 2005
Published for Opposition 	September 19, 2006
Registration Number 	3178940
Registration Date 	December 5, 2006
Owner 	(REGISTRANT) Yet Another Society DBA The Perl Foundation NON-PROFIT CORPORATION MICHIGAN P.O. Box 4353 Ann Arbor MICHIGAN 481064353
&lt;&lt;

ＥＵ

[f:id:keyesberry:20100614195900p:image]
[f:id:keyesberry:20100614195901p:image]

&gt;&gt;
Filing date:  	18/12/2007
Date of registration: 	04/12/2008
Expiry Date: 	18/12/2017
Nice Classification: 	9
List of goods and services 	Computer software; computer hardware; computer peripherals; electronic devices; computer software for use in cross-platform development of software applications, software components and websites; computer software for use in developing, analyzing, coding, checking and controlling other computer software; and computer software that implements a procedural and object-oriented programming language.
  	 
Nice Classification: 	16
List of goods and services 	Printed materials; publications; books; magazines; newspapers; newsletters; pamphlets; brochures; computer and software user manuals; computer and software documentation.
  	 
Nice Classification: 	41
List of goods and services 	Educational services related only to computer hardware, software, programming languages and information technology; conducting conferences, seminars, classes, conventions and workshops in the fields of computer hardware, software, programming languages and information technology; computer and software training services.
  	 
Owner
Name: 	Yet Another Society
ID No: 	318035
Country: 	UNITED STATES
&lt;&lt;

(次回に続く？)

</body>
</day>
<day date="2010-06-19" title="">
<body>
*p1*オープンソース・プログラマも知っておきたい商標のこと（その４）


**商標権は不動産のようなものである
商標権は独占権である
つまり同じ権利の範囲内に
複数の権利者がいることはない((１つの権利を複数で所有する(共有という)ことはある))
国内の有効な商標権の数はおそらく２００万件を超えるけど
それらは重なり合うことなくきれいに区画整理されて並んでいる
そう　ちょうど新興住宅街のように！


と言いたいところだけれども現実は違って
誤って登録された権利が多数存在するので
権利が幾十にも重なり合っているだろうし
本来公共用地であるべき土地が私有地になっている
というようなことも数多くあるだろう


自分で買った住宅区画に対する権利と同様に
商標権もまたその権利者にその使用・収益・処分に対する
自由な裁量が委ねられている
つまり商標権者はそこに住んでも(商標権の使用)
その一部または全部を人に貸しても(使用権の付与)
また譲ってもいい(商標権の譲渡)
もちろん何もせずにそのまま放置したっていい


法は商標権者のこのような自由な活動を保証する必要があるけど
それは第三者による
その土地の不法侵入を防止するというかたちで実現されている
これを商標権者の差止請求権という

&gt;&gt;
（差止請求権）
第36条　商標権者又は専用使用権者は、自己の商標権又は専用使用権を侵害する者又は侵害するおそれがある者に対し、その侵害の停止又は予防を請求することができる。
&lt;&lt;


つまり商標権に係る商標をその商品・サービスについて
第三者が無断で使用している場合
商標権者はその者に対して
その使用を直ちに中止するよう求めることができるし
それが受け入れられない場合には
裁判所に打って出ることもできる((もちろん中止の求めをしないで直に裁判を起こしてもよい))


第三者にとってこの権利が恐ろしいのは
商標の場合
土地に対する不法侵入の場合とは違って
その侵入者をして「侵入している」という罪の意識が
通常全く無いか極めて薄弱だからである


前に説明したように
商標権は商品・サービスごとに成立するけれども
その適用範囲は思いの外広くなることがある
そしてその適用範囲の確定は専門家でも容易ではない
だから商人が自分の商品に付けた名前が
事前に第三者の権利を侵害しないように
そのリスクを最小にするという努力は可能だけれども
侵害しないことを確定させることは不可能である


ネットの登場は個人による商業活動を活発にした
無料のソフトウェアを配布する個人
無料のＷｅｂサービスを提供する個人
そしてそれらを支援する個人
それらの無数の個人がネットには存在し
企業による商業製品・サービスと伍し
あるいはそれらを凌駕する品質を提供する


しかし一方で
彼らは自分が「商人」つまり
「商取引を行う者」であるという意識はない
彼らにはその提供する物が「商品」つまり
「商取引の品物」であるという意識はない
このことが一定のリスクを含んでいることは確かだ
しかし実際ネットの出現によってこれらの定義は曖昧になっており
彼らの不知を責めるより
それらを再定義することが望まれる解決策なのかもしれない


さて先に進もう


商標権者はさらに不法侵入によって
自らの商売が邪魔され
結果として利益が下がったと考える場合
本来得られたであろう利益を損害として
その賠償を求めることもできる


例えば商標権者による「iMod」という商品が
毎月コンスタントに10億円利益を生み出していて
誰かが類似の「iMad」を発売し始めたら
突然利益が7億円に下がったというなら
3億円は「iMad」による商標権者の損害である((ええ、わかってます。話が単純すぎますよね))
これは不法行為による損害賠償といって民法に規定されている

&gt;&gt;
（不法行為による損害賠償）
第七百九条 　故意又は過失によって他人の権利又は法律上保護される利益を侵害した者は、これによって生じた損害を賠償する責任を負う。 
&lt;&lt;


また「iMad」の販売者の利益が
商標権者の商標「iMod」の知名度故に
得られたものであるならば
その利益は商標権者に返還され得る
これを不当利得の返還義務という(民法703、704条)


以上をまとめると
商標権は不動産のようなものであり
したがって商標権者にはその使用・収益・処分の自由があり
一方で不法侵入者に対しては
事前および事後的に法的な措置を取ることによって
その権利の維持および損害の補填を図り得るということだ


（次回に続く？）

</body>
</day>
<day date="2010-07-10" title="">
<body>
*p1*Rubyでスキャニメーションを作ろう！

「ギャロップ！！」という仕掛け絵本があります
本を開くと窓の向こうに見える馬が走り出します


[http://www.youtube.com/watch?v=oDSigzI6YKw:movie]


仕組みとしては
連続画像を重ねて作った一枚の絵の上に
スリット入りのマスクを配置し
これを動かすことによって絵が動いているように見せています
この技術はスキャニメーションと呼ばれています


１年くらい前にRubyとShoesを使って
この絵とマスクを作る方法を紹介しました
これでコンピュータ上でスキャニメーションが実現できます


[http://d.hatena.ne.jp/keyesberry/20090425/p1:title=Ruby+Shoesでスキャニメーションを作ろう！ - hp12c] 


でもこの方法は工程が多くて不便でした
そこで今回はRubyだけでこの絵とマスクを作れるようにしました


スキャニメーションの画像ができれば
以下のようなサイトを作ることができます


[http://scananimation.heroku.com/:title=World of ScanAnimation] 


[f:id:keyesberry:20100710134022p:image]



**画像の作り方
***(1)スクリプトをダウンロードする
以下のサイトにある拙作scanimake.rbと
scaniviewer.rbスクリプトをダウンロードします


[http://github.com/melborne/scanimaker:title=melborne's scanimaker at master - GitHub] 


使用に際してはImageMagickとRMagickライブラリが必要になります


***(2)連続画像を用意する
画像編集ソフトを使うなどして以下のような連続画像を用意します


[f:id:keyesberry:20100710134023p:image]


画像の作成・編集にはMacであれば
GimpをベースにしたSeaShoreがおすすめです


[http://seashore.sourceforge.net/The_Seashore_Project/About.html:title=Seashore] 


[http://github.com/melborne/scanimaker:title=melborne's scanimaker at master - GitHub] にはサンプルの画像データも置いてあります


***(3)Rubyスクリプトで画像を生成する

ダウンロードしたscanimake.rbスクリプトに引数として
作成した複数の画像データを渡します


&gt;|ruby|
 $ ruby scanimake.rb images/horse1.png images/horse2.png images/horse3.png ...
||&lt;


これによって画像データのディレクトリに
out.png mask_out.pngという画像が生成されます


scanimake.rbスクリプトのif __FILE__ == $0以降を変更することで
出力ファイル名(ex. horse.png mask_horse.png)と
マスクにおけるスリットの向き(:horizontal)を変えられます


&gt;|ruby|
if __FILE__ == $0
  sm = Scanimake.new(ARGV)
  path = File.expand_path(File.dirname(ARGV[0]))
  sm.create_layered_image(:horizontal).write(&quot;#{path}/horse.png&quot;)
  sm.create_mask_image(:horizontal).write(&quot;#{path}/mask_horse.png&quot;)
  exit
end
||&lt;


***(4)画像を確認する
このスクリプトで作成した画像は
scaniviewer.rbスクリプトで再生することができます
このスクリプトはRubyのGUI frameworkであるShoes用です
Shoesのダウンロードは以下から行います


[http://github.com/shoes/shoes/downloads:title=Downloads for shoes's shoes - GitHub] 


Shoesでこのスクリプトを起動し
最初に開いたダイアログで画像(ex. out.png)を開き
次に開いたダイアログでマスク(ex. mask_out.png)を開きます
画像に問題がなければ絵が動いて見えます


[f:id:keyesberry:20100710140613p:image]


さあ　Rubyでスキャニメーションしましょう！


[asin:0761147632:detail]

</body>
</day>
<day date="2010-07-14" title="">
<body>
*p1*Rubyのクラスとメソッドを全部いっぺんに！ - 再改訂版
Ruby1.9.2には45のClassがあって
28の例外クラスが別にある
Moduleは15あって
Standard Libraryは117ある


各Class・Moduleにはpublic methodとprivate method
public instance methodとprivate instance methodがあって
例えばArrayクラスには82　Hashクラスには51
Stringクラスには106のpublic instance methodがある


Moduleクラスには41　Kernelモジュールには45
Enumerableモジュールには43のpublic instance methodがある
Fileクラスには70ものpublic method(クラスメソッド)がある((これらの数字はきっと正しくありませんが、ここでは正しさを問題としていない点ご了承下さい))


Rubyでプログラムをする人は
その中から目的に合った
適切なクラスおよびメソッドを見つけ出さなければならない


でも僕にはそれらを全部覚えることはできないし
主要なクラスやメソッドの使い方すらすぐに忘れる
だからしょっちゅう
「[http://doc.okkez.net/:title=るりま（Rubyリファレンスマニュアル）]」のお世話になる


でもるりまのコンテンツはリンクで階層的に整理されていて
曖昧な記憶の中から目的のメソッドに辿り着くまでには
リンクを行ったり来たりすることが少なくない


一方で
refeとかriとかruremaとかのるりま検索インタフェースがあるけど
検索ターゲットがはっきりしないいい加減な記憶の持ち主には
あまり役には立たない


だからそんな人の一人として
Rubyにはどんなクラスやメソッドがあるかを
全部ざっと見せてくれて
曖昧な記憶に基づいてそのなかから特定のメソッドをクリックすれば
その解説が読めるようなものがほしい


そんなことから以前
力技で作ったるりまのインタフェースサイトを
少し改善してherokuに移管したので
使ってくれる人がいたらうれしいです


[http://rbref.heroku.com/:title=Ruby Reference Index] 


[f:id:keyesberry:20100714190859p:image]


**特徴
-Ruby186, 187, 191, 192のバージョン
-新Rubyリファレンスマニュアルにリンク
-Ruby1.9で追加されたメソッドを色分け表示
-標準添付ライブラリへのリンクとRuby関連サイトへのリンク


リンクが切れているところもありますがご容赦を


コードは以下にあります


[http://github.com/melborne/rbref:title=melborne's rbref at master - GitHub] 

views/内のコンテンツ(186.erb, 187.erb..)は
lib/のrbref_gen.rbで生成しています
&gt;|ruby|
rbref/lib% ruby186 rbref_gen.rb
||&lt;

上記によりviews/内に186.erbが生成されます

</body>
</day>
<day date="2010-10-12" title="">
<body>
*p1*Rubyでソート・アルゴリズムを表現しよう!
アルゴリズムとその実装には往々にして乖離があります
アルゴリズムが理解できてもその実装が複雑で
理解に苦しむ　ということが少なくありません
原因の１つはプログラミング言語の記述力にあると思います


Rubyは極めて記述力が高い言語です
人間の意志をコードで表現する上での制約が極めて少ないのです
これが動く疑似コードと言われる所以です


ソート・アルゴリズムは配列によるデータ構造を操作します
RubyのArrayクラスは強力だから
Rubyの記述力を証明するいい題材になります
早速　挿入ソート　選択ソート　バブルソート
クイックソート　マージソートをRubyで表現してみましょう


**挿入ソート
挿入ソートはデータの並びを維持しつつ
新たなデータをそこに挿入することでソートを行うアルゴリズムです
具体的には以下の手順を行います
+ソート済みデータ群を格納するデータ構造を用意する
+未整列のデータ群から１つデータをピックアップする
+そのデータをソート済みデータ群の並びの正しい位置に挿入する
+未整列データ群が無くなるまで2-3を繰り返す


これをRubyのArrayクラスに実装してみましょう
&gt;|ruby|
class Array
  def insert_sort
    inject([]) { |mem, var| mem.insert_with_order(var) }
  end

  def insert_with_order(item)
    pos = find_index { |n| item &lt;= n } || length
    insert(pos, item)
  end
end
||&lt;

このコードではinjectメソッドの引数で配列を用意し
injectのブロックに順次渡されるデータを
insert_with_orderメソッドに渡しています
そしてinsert_with_orderにおいてこのデータを
並びの正しい位置に挿入しています
正しい位置はArray#find_indexで求まります


**選択ソート
選択ソートは未整列のデータ群から順次
最小のデータを選択することでソートを行うアルゴリズムです
具体的には以下の手順を行います
+ソート済みデータ群を格納するデータ構造を用意する
+未整列のデータ群から最小(最大)のデータをピックアップする
+そのデータをソート済みデータ群の端に挿入する
+未整列データ群が無くなるまで2-3を繰り返す


Rubyで実装してみましょう
&gt;|ruby|
class Array
  def select_sort
    tmp = self.dup
    res = []
    res.push tmp.delete_min until tmp.empty?
    res
  end

  def delete_min
    min_idx = find_index { |item| item == self.min }
    delete_at(min_idx)
  end
end
||&lt;

このコードではresで参照できる配列を用意し
未整列のデータ群からdelete_minメソッドにより
最小のデータを取り出して用意した配列の末尾に順次格納します
最小値はArray#minで求まります
なおArray#dupで元データは変更しないようにしています


**バブルソート
バブルソートは隣り合うデータを比較して入替えを行い
データ構造の末端に最小(最大)のデータを移動させて
ソートを行うアルゴリズムです
具体的には以下の手順を行います
+ソート済みデータ群を格納するデータ構造を用意する
+未整列のデータ群に対して最小(最大)のデータが末端に来るようバブリングする
+バブリングでは端から順に隣り合うデータの比較・入替えを行う
+末端に来たデータをソート済みデータ群の端に挿入する
+未整列データ群が無くなるまで2-4を繰り返す


Rubyで実装してみましょう
&gt;|ruby|
class Array
  def bubble_sort
    tmp = self.dup
    res = []
    res.push tmp.bubbling until tmp.empty?
    res
  end

  def bubbling
    (length-1).times do |i|
      self[i], self[i+1] = self[i+1], self[i] if self[i] &lt; self[i+1]
    end
    delete_at(-1)
  end
end
||&lt;

このコードではresで参照できる配列を用意し
未整列のデータ群に対してbubblingメソッドを実行し
最小のデータが末尾に来るようにしています
末尾のデータはArray#delete_atで取り出し
用意した配列の末尾に挿入します


**クイックソート
クイックソートは１つのデータを基準に
未整列のデータ群を大小２つに分けることを
そのデータ群が１つになるまで繰り返すことで
ソートを行うアルゴリズムです
具体的には以下の手順を行います
+未整列のデータ群から任意の１つを取り出す
+これを基準に未整列のデータ群を大小２つに分ける
+分割したデータ群について1－2を繰り返す
+データ群が分割できなくなったところで結果を連結する


Rubyで実装してみましょう
&gt;|ruby|
class Array
  def quick_sort
    return self if length &lt;= 1
    base = pop
    smaller, bigger = partition { |e| e &lt; base }
    push base
    smaller.quick_sort + [base] + bigger.quick_sort
  end
end
||&lt;
このコードではArray#partitionでデータを大小に分割し
各分割データsmaller,biggerについて
quick_sortを再帰的に繰り返しています
なおオリジナルを維持するために分割後push baseしています


**マージソート
マージソートは未整列のデータを一旦多数に分割し
各分割データ群でソート・統合を繰り返して
最終的に全体のソートを行うアルゴリズムです


具体的には以下の手順を行います
+未整列のデータ群を半分に分ける操作を繰り返す
+データ群が分割できなくなったところで今度は分割データのマージを繰り返す
+マージはデータが整列するよう行う


Rubyで実装してみましょう
&gt;|ruby|
class Array
  def merge_sort
    tmp = self.dup
    return tmp if tmp.length &lt;= 1
    a, b = self.half.map { |e| e.merge_sort }
    merge(a, b)
  end

  def half
    mid = length/2
    return slice(0...mid), slice(mid..-1)
  end
  
  def merge(a, b)
    res = []
    until a.empty? &amp;&amp; b.empty?
      res &lt;&lt;
        case
        when a.empty? then b.shift
        when b.empty? then a.shift
        when a.first &lt; b.first then a.shift
        else b.shift
        end
    end
    res
  end
end
||&lt;

このコードではhalfメソッドでデータ群を二分割し
分割した各データ群についてmerge_sortを呼ぶことでこれを繰り返します
分割によって双方の配列要素が１になるとa,bが返り
次にmergeメソッドが呼ばれて分割データのマージが始まります
mergeメソッドではcase式によって整列された配列データが得られます

**テスト
これらのアルゴリズムのテストを用意しました
ここでは速度の比較も行っています

&gt;|ruby|
require &quot;test/unit&quot;
require &quot;sorts&quot;

@@result = {}

class TestSorts &lt; Test::Unit::TestCase
  def setup
    num = 1000
    @list = []
    num.times { @list &lt;&lt; rand(num)  }
  end

  def time(name)
    t = Time.now
    res = yield
    @@result[name] = Time.now - t
    res
  end

  def test_insert_sort
    assert_equal(@list.sort, time(:Insert){ @list.insert_sort })
  end
  
  def test_select_sort
    assert_equal(@list.sort, time(:Select){ @list.select_sort })
  end
  
  def test_bubble_sort
    assert_equal(@list.sort, time(:Bubble){ @list.bubble_sort })
  end
  
  def test_quick_sort
    assert_equal(@list.sort, time(:Quick){ @list.quick_sort })
  end
  
  def test_merge_sort
    assert_equal(@list.sort, time(:Merge){ @list.merge_sort })
  end

  def test_sort
    assert_equal(@list.sort, time(:Sort){ @list.sort })
  end

  # def test_keep_self
  #   original = @list.dup
  #   %w(insert select bubble quick merge).each do |name|
  #     @list.send(&quot;#{name}_sort&quot;)
  #     assert_equal(original, @list)
  #   end
  # end
end

END{
  END{
    res = @@result.map { |k, v| [k, v, (v/@@result[:Sort]).to_i ] }.sort_by { |e| e[2] }
    res.each { |k, v, n| puts &quot;#{k}\t=&gt;\t#{v} (#{n})&quot; }
  }
}
||&lt;

&gt;|ruby|
Loaded suite sorts
Started
......
Finished in 42.917957 seconds.

6 tests, 6 assertions, 0 failures, 0 errors, 0 skips

Test run options: --seed 43474
Sort    =&gt;      0.000432(1)
Quick   =&gt;      0.007363(17)
Merge   =&gt;      0.026338(60)
Insert  =&gt;      0.080093(185)
Bubble  =&gt;      0.782067(1810)
Select  =&gt;      42.0075(97239)
||&lt;
クイックソートが最速でArray#sortの17倍
選択ソートが最も遅くsortの97239倍でした
速度はともかく
Rubyの記述力はやっぱりすごいですね


[http://gist.github.com/622151:title=gist: 622151 - GitHub]

</body>
</day>
<day date="2010-10-17" title="">
<body>
*p1*Rubyで文字列検索アルゴリズムを表現しよう!
文字列中のパターンを探し出すメソッドとして
RubyにはString#indexが用意されています

&gt;|ruby|
text = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.&quot;

text.index(&quot;velit&quot;) # =&gt; 285
||&lt;

またRubyの標準ライブラリにはStringScannerクラスがあるので
これを使って以下のようにインデックスを求めることもできます

&gt;|ruby|
require &quot;strscan&quot;
text = StringScanner.new(text)
text.skip_until(/.?(?=#{Regexp.escape(&quot;velit&quot;)})/) # =&gt; 285
||&lt;

ですから今更
文字列検索のアルゴリズムを実装する価値はありません
しかしアルゴリズムを理解してそれを実装する能力は
プログラムする上での基礎力として必須と言われているので((http://itpro.nikkeibp.co.jp/article/Watcher/20070924/282781/))
ここで勉強しておきたいと思います


以下では
文字列検索として代表的なアルゴリズムである
力まかせ検索　ボイヤー-ムーア(ＢＭ)検索
クヌース-モリス-プラット(ＫＭＰ)検索　N-gramインデックス検索
ラビン-カープ(RK)検索の各検索アルゴリズムをRubyで実装します
なお各アルゴリズムはWikipediaその他のネット上の情報((文字列探索 - Wikipedia http://ja.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E5%88%97%E6%8E%A2%E7%B4%A2))を参考に
独自解釈して構成したものです
間違いがあるかも知れません
いやきっとあるでしょう


**力まかせ検索
力まかせ検索はテキストの先頭から
検索パターンを１文字ずつずらして照合を行う検索アルゴリズムです
具体的には以下の手順を行います
+テキストの先頭文字から検索パターンの各文字を照合
+一致しない場合照合位置を１つずらす
+1-2を一致するまで繰り返す


これをRubyのStringクラスに実装してみます

&gt;|ruby|
class String
  def power_search(pattern)
    pos = 0
    until pos &gt; length-pattern.length
      match = compare(pattern, pos)
      return match if match
      pos += 1
    end
  end

  def compare(pattern, pos)
    pattern.each_char.with_index do |chr, i|
      return nil unless chr == self[pos+i]
    end
    pos
  end
end
||&lt;

compareメソッドではパターンとテキストの対応箇所を
先頭から一文字ずつ比較してそのすべてが一致した場合に
先頭のインデックスを返します


StringScannerクラスを使ったcompareメソッドの例も示しておきます

&gt;|ruby|
  def compare_with_scanner(pattern, pos)
    str = StringScanner.new(self)
    str.pos = pos
    pattern.each_char do |chr|
      return nil unless str.scan /#{Regexp.escape(chr)}/
    end
    pos
  end
||&lt;

StringScanner#scanメソッドはマッチする場合には
自動でポインタを進めるので繰り返しのための記述が簡潔になります


**ボイヤー-ムーア(ＢＭ)検索
ＢＭ検索は検索パターンとの照合をパターン末尾から行い
パターン内文字と不一致文字との照合を行うことによって
照合回数を減らす工夫をした検索アルゴリズムです
具体的には以下の手順を行います
+テキストの先頭文字から検索パターンの各文字を後方から照合
+一致しない場合その不一致文字がパターン前方にあるか調べる
+ある場合照合位置をその位置までずらす
+ない場合照合位置を不一致文字の後ろにずらす
+1-4を一致するまで繰り返す
ＢＭ検索では次の照合位置を
後方から調べた不一致位置までずらすことができるので
効率が大変いいです


Rubyで実装してみます
&gt;|ruby|
class String
  def bm_search(pattern)
    pos = 0
    until pos &gt; length-pattern.length
      match, pos = bm_compare(pattern, pos)
      return match if match
    end
  end

  def bm_compare(pattern, pos)
    (pattern.length-1).downto(0) do |i|
      if self[pos+i] != pattern[i]
        shift = pattern[0...i].bm_shift(self[pos+i]) || i + 1
        return nil, pos + shift
      end
    end
    pos
  end

  def bm_shift(chr)
    length.times { |pos| return pos + 1 if self[-1-pos] == chr }
    nil
  end
end
||&lt;

bm_compareではFixnum#downtoメソッドで
インデックスを降順にして
比較をパターン後方から行うようにしています
また力まかせ検索ではパターンのずらし量は１に固定されていましたが
ここではbm_shiftメソッドの結果でその量を決定しています


**クヌース-モリス-プラット(ＫＭＰ)検索
ＫＭＰ検索は検索パターン内に存在する文字パターンを利用して
照合回数を減らす工夫をした検索アルゴリズムです
具体的には以下の手順を行います
+テキストの先頭文字から検索パターンの各文字を照合
+先頭文字で不一致が生じた場合、パターンを１つずらす
+２文字目以降で不一致が生じた場合、不一致箇所以前の部分においてその先頭文字列の繰り返し文字列の有無を調べる
+繰り返し文字列がなければ、不一致箇所にパターンをずらす
+繰り返し文字列がある場合は、その位置にパターンをずらすと共に照合開始位置を繰り返し文字列の次にセットする
+2-5を一致するまで繰り返す
上記よりＫＭＰ検索では検索パターンが繰り返し文字列を含んでおらず
照合の不一致がパターンの後方で多く発生する場合に
効果が大きくなることが分かります
ですから通常の文字列検索ではあまり効率がよくありません


Rubyで実装してみます

&gt;|ruby|
class String
  def kmp_search(pattern)
    pos, from = 0, 0
    until pos &gt; length-pattern.length
      match, pos, from = kmp_compare(pattern, pos, from)
      return match if match
    end
  end

  def kmp_compare(pattern, pos, from)
    (from..(pattern.length-1)).each do |i|
      if self[pos+i] != pattern[i]
        return nil, pos+1, 0 if i == 0
        shift, from = pattern[0...i].count_sequence
        if shift
          return nil, pos+i-shift, from
        else
          return nil, pos+i, 0
        end
      end
    end
    pos
  end

  def count_sequence
    shift = 1
    until shift &gt;= length
      if self[0] == self[shift] 
        match = 1
        until shift+match &gt;= length
          self[match] == self[shift+match] ? match += 1 : break
        end
        return length-shift, match
      end
      shift += 1
    end
  end
end
||&lt;
このコードではcount_sequenceメソッドにおいて
繰り返し文字列の有無を調べています
そして繰り返し文字列の長さに応じて
次の照合の再開位置(from)を決定します
場合分けが多く若干コードが複雑になっていますが
その割に検索の効率が上がらないのが残念です


**N-gramインデックス検索
N-gramインデックス検索はテキスト内文字のインデックスを使って
照合回数を減らす工夫をした検索アルゴリズムです
具体的には以下の手順を行います
+テキストのすべての文字の出現位置を記録した索引を作る
+索引を参照して検索パターンの先頭文字と同じ文字の出現位置を調べる
+照合位置を出現位置に移動して照合を行う
+2-3を一致するまで繰り返す
N-gramインデックス検索では照合箇所を
パターンの先頭文字の出現位置だけに限定できるので
照合回数を激減させることができます
一方で
インデックスの作成のためのコストが大きくかかる問題があります


Rubyで実装してみましょう

&gt;|ruby|
class String
  def ngi_search(pattern, n=1)
    indices = index_table(n)[pattern[0...n]]
    until indices.empty?
      match = ngi_compare(pattern, indices.shift)
      return match if match
    end
  end

  def index_table(n)
    q = Hash.new{ |h, k| h[k] = [] }
    self.split(//).each_cons(n).with_index { |chr, i| q[chr.join] &lt;&lt; i }
    q
  end

  def ngi_compare(pattern, pos)
    pattern.length.times do |i|
      return nil if self[pos+i] != pattern[i]
    end
    pos
  end
end
||&lt;


インデックスの作成はindex_tableで行い
結果はHashに格納しています
デフォルトでインデックスは１文字ですが
複数文字(n)を指定することもできます
パターンのずらし回数はindicesの要素数で決まります


**ラビン-カープ検索(RK)検索
ＲＫ検索は検索パターンとの照合を個々の文字列で行うのではなく
それらのハッシュ値で行うことによって
照合に掛かる時間を効率化する検索アルゴリズムです
パターンのずらし量は１文字ずつで力まかせ検索と同じです
具体的には以下の手順を行います
+検索パターンとその対応箇所のハッシュ値を求め照合する
+一致しない場合テキストの次の照合箇所のハッシュ値を求める
+照合位置を１つずらす
+2-3を一致するまで繰り返す
なお次のハッシュ値の生成はその生成効率を上げるため
前のハッシュ値を利用したローリングハッシュ値((ラビン-カープ文字列検索アルゴリズム - Wikipedia http://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%93%E3%83%B3-%E3%82%AB%E3%83%BC%E3%83%97%E6%96%87%E5%AD%97%E5%88%97%E6%A4%9C%E7%B4%A2%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0))の演算を用います
またハッシュ値が一致しても
生文字列が一致しない場合があるのでその確認もします


Rubyで実装してみます

&gt;|ruby|
class String
  def rk_search(pattern)
    pos = 0
    h_self = self[0...pattern.length].rhash
    h_pattern = pattern.rhash
    until pos &gt; length-pattern.length
      match, h_self = hash_compare(h_self, h_pattern, pattern.length, pos)
      return match if match &amp;&amp; self[pos...pos+pattern.length] == pattern
      pos += 1
    end
  end

  def rhash(base=101)
    (0...length).inject(0) { |mem, i| mem + self[length-1-i].ord*base**(i) }
  end

  def hash_compare(h_self, h_pattern, len, pos)
    h_self == h_pattern ? pos : [nil, next_hash(h_self, len, pos)]
  end

  def next_hash(h_self, len, pos, base=101)
    return nil unless self[pos+len]
    (h_self - self[pos].ord*base**(len-1))*base + self[pos+len].ord
  end
end
||&lt;
ハッシュ値の計算はrhashメソッドで行うようにし
ここでは素数であるbaseを基数とした各文字の
文字コードを足し合わせたものを用います
hash_compareメソッドでハッシュ値が一致しない場合に
next_hashメソッドで次のハッシュ値を求めています
ここでは前のハッシュ値h_selfから先頭文字のハッシュ値を引き
基数を一つずらしてから次の文字のハッシュ値を足しています


**テスト
これらのアルゴリズムをテストしてみます
各メソッドにクラス変数を挟んで照合回数を計算し
同時に各実行時間も求めます

&gt;|ruby|
@@time = []
class TestSearchs &lt; Test::Unit::TestCase
  def setup
    @text = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur ABC ABCDAB ABCDABCDABDE susususususumsu abcdefgabcdefghijabcdefghijk axacacdae sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&amp;&quot; * 100
    @words = [&quot;Lorem&quot;, &quot;sum&quot;, &quot;fugiat&quot;, &quot;ut aliquip&quot;, &quot;&amp;&quot;, &quot;t, c&quot;, &quot; m&quot;, &quot;o &quot;, &quot;ABCDABD&quot;, &quot;acac&quot;]
    @nowords = [&quot;hello&quot;, &quot;ipsumd&quot;, &quot;Velit&quot;, &quot;&amp;.&quot;, &quot;t D&quot;, &quot;veniam,,&quot;, &quot;abcdefghijkabcdefghijk&quot;]
    @st = Time.now
  end

  def teardown
    @@time &lt;&lt; Time.now - @st
  end

  def test_power_search
    @words.each do |wd|
      assert_equal(@text.index(wd), @text.power_search(wd))
    end
    @nowords.each do |wd|
      assert_nil(@text.power_search(wd))
    end
  end
  
  def test_bm_search
    @words.each do |wd|
      assert_equal(@text.index(wd), @text.bm_search(wd))
    end
    @nowords.each do |wd|
      assert_nil(@text.bm_search(wd))
    end
  end
  
  def test_kmp_search
    @words.each do |wd|
      assert_equal(@text.index(wd), @text.kmp_search(wd))
    end
    @nowords.each do |wd|
      assert_nil(@text.kmp_search(wd))
    end
  end
  
  def test_ngi_search
    @words.each do |wd|
      assert_equal(@text.index(wd), @text.ngi_search(wd))
    end
    @nowords.each do |wd|
      assert_nil(@text.ngi_search(wd))
    end
  end

  def test_rk_search
    @words.each do |wd|
      assert_equal(@text.index(wd), @text.rk_search(wd))
    end
    @nowords.each do |wd|
      assert_nil(@text.rk_search(wd))
    end
  end
end

class String
  def self.method_added(name)
    class_variable_set(&quot;@@#{$`}&quot;, 0) if name =~ /_search$/
  end

  def self.counter
    class_variables.sort.inject({}) { |h, cv| h[cv[/\w+/]] = class_variable_get(cv); h }
  end
end

END{END{
  res = String.counter
  res.each do |k, v| 
    print &quot;%s\t%8d times(%.4f) %.4f sec\n&quot; % [k, v, v*1.0/res[&quot;power&quot;], @@time.shift]
  end
}}
||&lt;


結果は以下の通りです
&gt;|ruby|
Loaded suite /Users/keyes/Dropbox/workspace/searchs
Started
..... 
Finished in 16.116971 seconds.

5 tests, 85 assertions, 0 failures, 0 errors, 0 skips
bm         96236 times(0.2480) 1.3565 sec
kmp       382275 times(0.9850) 2.4872 sec
ngi        29977 times(0.0772) 5.3435 sec
power     388089 times(1.0000) 2.6198 sec
rk        370185 times(0.9539) 4.2976 sec
||&lt;
このテストではN-gramインデックス検索(ngi)の
照合回数が際立って少ないことが分かります
しかしインデックス作成のために実行時間は最も遅いです
ハッシュ値で比較するラビン-カープ(RK)検索では
思ったほど比較回数が少なくならず
その結果ハッシュ値生成のためのコストが響いています


ボイヤー-ムーア(ＢＭ)検索が照合回数も少なく最速で
力まかせ(power)検索の倍の速度が出ています
一方で力まかせ検索の結果もそれほど悪くないという印象です


&lt;script src=&quot;http://gist.github.com/630347.js?file=searchs.rb&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2010-11-05" title="">
<body>
*p1*Rubyのモジュール関数を理解しよう！
RubyのMathモジュールには数学関数が定義されていて
それらは以下のようにモジュール・メソッドとして呼び出す使い方と
クラスにモジュールをインクルードして関数的に呼び出す使い方の
２種類の使い方ができるようになっています

&gt;|ruby|
Math.sqrt 4 # =&gt; 2.0
Math.atan2(1, 1) # =&gt; 0.785398163397448

include Math
sqrt 4 # =&gt; 2.0
atan2(1, 1) # =&gt; 0.785398163397448
||&lt;


一方でこれらのメソッドはインクルードした場合
オブジェクトを指定するメソッド形式での呼び出しが
できないようにされています

&gt;|ruby|
Object.new.sqrt 4 # =&gt; private method `sqrt' called for #&lt;Object:0x1a414&gt; (NoMethodError)
||&lt;

このような形式で定義されたメソッドを
Rubyでは「モジュール関数」と呼んでいます
モジュール関数はその利用の態様に応じて使い方を選べるので
その利便性を高めます


早々自分でもモジュール関数redを備えた
Colorモジュールを定義してみます

&gt;|ruby|
module Color
  def self.red
    :red
  end

  private
  def red
    :red
  end
end

Color.red # =&gt; :red

include Color
red # =&gt; :red
Object.new.red # =&gt; private method `red' called for #&lt;Object:0x2272c&gt; (NoMethodError)
||&lt;

Colorモジュールにredインスタンス・メソッドと
redモジュール・メソッドを定義し
インスタンス・メソッドの可視性をprivateにします


モジュール・メソッドは
Singletonクラスを使って定義してもいいですね

&gt;|ruby|
module Color
  class &lt;&lt; self
    def red
      :red
    end
  end

  private
  def red
    :red
  end
end

Color.red # =&gt; :red

include Color
red # =&gt; :red
Object.new.red # =&gt; private method `red' called for #&lt;Object:0x226a0&gt; (NoMethodError)
||&lt;


これで完了！
と言いたいところですが
明らかにこれらのコードには問題があります


そう　ＤＲＹ原則に反しているのです
同じコードの繰り返しはその保守性を下げるのでいけません
改善しましょう
singletonクラスにColorモジュールをインクルードすることによって
コードの重複を回避します

&gt;|ruby|
module Color
  class &lt;&lt; self
    include Color
  end

  private
  def red
    :red
  end
end

Color.red # =&gt; private method `red' called for Color:Module (NoMethodError) 

include Color
red # =&gt; :red
Object.new.red # =&gt; private method `red' called for #&lt;Object:0x230dc&gt; (NoMethodError)
||&lt;

残念ながらredの可視性がprivateにされているので
Colorオブジェクトからredを呼び出せないようです
Singletonクラスへのインクルードはextendと等価ですから
extendも試してみます

&gt;|ruby|
module Color
  extend self
  private
  def red
    :red
  end
end

Color.red # =&gt;  private method `red' called for Color:Module (NoMethodError)

include Color
red # =&gt; :red
Object.new.red # =&gt; private method `red' called for #&lt;Object:0x23190&gt; (NoMethodError)
||&lt;

やはりダメです
さて...


苦肉の策を考えました

&gt;|ruby|
module Color
  class &lt;&lt; self
    include Color
    def Red
      red
    end
  end

  private
  def red
    :red
  end
end

Color.Red # =&gt; :red

include Color
red # =&gt; :red
Object.new.red # =&gt; private method `red' called for #&lt;Object:0x225ec&gt; (NoMethodError)
||&lt;

呼び出しの問題は解決しましたが
２つのメソッド名が異なるという致命的な問題が発生しました


あるいはsendを使って...

&gt;|ruby|
module Color
  extend self
  private
  def red
    :red
  end
end

Color.send :red # =&gt; :red

include Color
red # =&gt; :red
Object.new.red # =&gt; private method `red' called for #&lt;Object:0x227b8&gt; (NoMethodError)
||&lt;

これではとてもモジュール関数とは呼べません
さてどうしたものでしょうか...


こうなったら最後の手段です
そう　メタプログラミングです！


Colorモジュールにmod_funcというモジュール・メソッドを定義して
その引数としてインスタンス・メソッドを渡すと
それを自動でモジュール関数にしてくれるよう実装してみます

&gt;|ruby|
module Color
  def self.mod_func(meth)
    extend self
    private meth
  end

  def red
    :red
  end
  mod_func :red
end

Color.red # =&gt; private method `red' called for Color:Module (NoMethodError)

include Color
red # =&gt; :red
Object.new.red # =&gt; private method `red' called for #&lt;Object:0x22984&gt; (NoMethodError)
||&lt;

最初の試みは失敗に終わりました
mod_func内のprivateでインスタンス・メソッドredだけでなく
モジュール・メソッドredもプライベート化されてしまうようです


今度はdefine_methodを使って
モジュール・メソッドredを別に定義してみます

&gt;|ruby|
module Color
  def self.mod_func(meth)
    extend self
    (class &lt;&lt; self; self end).module_eval do
      alias_method :new_meth, meth
      define_method(meth) do |*args, &amp;block|
        new_meth(*args, &amp;block)
      end
    end
    private meth
  end

  def red
    :red
  end
  mod_func :red
end

Color.red # =&gt; :red

include Color
red # =&gt; :red
Object.new.red # =&gt; private method `red' called for #&lt;Object:0x21bec&gt; (NoMethodError)
||&lt;

今度はうまくいきました！
mod_func内では以下のような処理が実行されます
+extendを使ってColorモジュールの抽象クラスのコンテキストで、redメソッドにアクセスできるようにする
+alias_methodにより、redメソッドをnew_methに別名定義する((aliasではうまくいかない))
+define_methodにより、インスタンス・メソッドと同じ内容のモジュール・メソッドredを定義する
+インスタンス・メソッドredをプライベートにする


mod_funcはモジュールにおいて汎用的に使えるので
これをColorモジュールだけの機能としておくのはもったいないです
Moduleクラスに移しましょう

&gt;|ruby|
class Module
  def mod_func(meth)
    extend self
    (class&lt;&lt;self;self end).module_eval do
      alias_method :new_meth, meth
      define_method(meth) do |*args, &amp;block|
        new_meth(*args, &amp;block)
      end
    end
    private meth
  end
end

module Color
  def red
    :red
  end
  mod_func :red
end

Color.red # =&gt; :red

include Color
red # =&gt; :red
Object.new.red # =&gt; private method `red' called for #&lt;Object:0x22150&gt; (NoMethodError)
||&lt;

すてきです


ええ　もちろん
Rubyはユーザにこんな手間を強いることはありません
Rubyにはモジュール関数を作るために
Module#module_functionというメソッドが用意されています

&gt;|ruby|
module Color
  def red
    :red
  end
  module_function :red
end

Color.red # =&gt; :red

include Color
red # =&gt; :red
Object.new.red # =&gt; private method `red' called for #&lt;Object:0x22240&gt; (NoMethodError)
||&lt;

module_functionが引数を取らない場合
それ以降に定義されたメソッドがモジュール関数の対象になります

&gt;|ruby|
module Color
  module_function
  def red
    :red
  end
end

Color.red # =&gt; :red

include Color
red # =&gt; :red
Object.new.red # =&gt; private method `red' called for #&lt;Object:0x22830&gt; (NoMethodError)
||&lt;
</body>
</day>
<day date="2010-11-07" title="">
<body>
*p1*RubyでANSIカラーシーケンスを学ぼう！
CUIの世界は地味な世界です
真っ黒なターミナル画面に単一色の文字列
それが却って落ち着くという向きもありますが
今となってはその地味さは際立っています


ターミナルで色を使う方法を学ぶことで
新しい世界が開けるかも知れません
ようこそANSIカラーの世界へ

**エスケープシーケンス
ターミナルで色を使うためには
エスケープシーケンスというものを利用します
エスケープシーケンスはターミナル上で色を含む特定の制御を
実現するための特殊な文字列です

&gt;|ruby|
print &quot;\e[31mhello\e[0m&quot;
||&lt;
これによりターミナル上に青文字で「hello」と出力されます
この&quot;\e[31m&quot; &quot;\e[0m&quot;の部分がエスケープシーケンスです
&quot;\e[31m&quot;はそれ以降を青文字で出力する制御命令
&quot;\e[0m&quot;はそれ以降を初期状態へリセットする制御命令です


シーケンス中の数字において
30~37は文字色　40~47は背景色
0~9は文字装飾に割り振られています

&gt;|
Text attributes
0	All attributes off
1	Bold on
4	Underscore (on monochrome display adapter only)
5	Blink on
7	Reverse video on
8	Concealed on

Foreground colors
30	Black
31	Red
32	Green
33	Yellow
34	Blue
35	Magenta
36	Cyan
37	White

Background colors
40	Black
41	Red
42	Green
43	Yellow
44	Blue
45	Magenta
46	Cyan
47	White 
|&lt;

[http://ascii-table.com/ansi-escape-sequences.php:title=ASCII Table - ANSI Escape sequences]


１つの文字列に複数のシーケンスを適用することもできます
&gt;|ruby|
print &quot;\e[31m\e[43m\e[5mhello\e[0m&quot;
||&lt;

これで黄色の背景色上で赤いhelloが点滅します
セミコロンで区切って
複数のシーケンスコードを適用することもできます
これは上のシーケンスと等価です

&gt;|ruby|
print &quot;\e[31;43;5mhello\e[0m&quot;
||&lt;

エスケープシーケンスは端末依存で
端末によって使えないものもあります


**ターミナルカラー・ライブラリ
Rubyでカラーシーケンスを使う場合
そのままでは扱いづらいので
定数などへのマッピングが必要になるでしょう
また文字列終端での復帰にも対応しなければいけません
自作する手もありますが
Rubyには既に便利なライブラリがいくつかあります


**HighLine
[https://github.com/JEG2/highline:title=HighLine]はターミナルの入出力を支援するツール群です
その中にカラーシーケンスを扱うHighLine#colorがあります
gem install highlineでインストールして
以下のように使います

&gt;|ruby|
require 'highline'
h = HighLine.new
puts h.color(&quot;hello&quot;, :green)
||&lt;

色属性として複数の引数を取ることもできます
&gt;|ruby|
puts h.color(&quot;Ruby World&quot;, :red, :on_cyan, :underline)
||&lt;


**TermColor
[https://github.com/jugyo/termcolor:title=TermColor]は文字列中のカラータグを
エスケープシーケンスに変換するライブラリです
gem install termcolorでインストールして
以下のように使います

&gt;|ruby|
require 'termcolor'
puts TermColor.parse(&quot;&lt;green&gt;hello&lt;/green&gt;&quot;)
puts TermColor.parse(&quot;&lt;red&gt;&lt;on_white&gt;&lt;blink&gt;ruby is fun!&lt;/blink&gt;&lt;/on_white&gt;&lt;/red&gt;&quot;)
||&lt;


色指定は１つしかできませんが以下のように使うこともできます
&gt;|ruby|
puts TermColor.colorize(&quot;hello&quot;, :green)
||&lt;


またString#termcolorが用意されているので
以下のようにもできます
&gt;|ruby|
puts &quot;&lt;red&gt;&lt;bold&gt;Ruby is red!&lt;/bold&gt;&lt;/red&gt;&quot;.termcolor
||&lt;

TermColorは[http://termtter.org/:title=Termtter]のjugyoさん作で
Termtterでのカラー表示に使われています


**Rainbow
[https://github.com/sickill/rainbow:title=Rainbow]はStringクラスに
color(foreground), background,bright, blink, inverseなどの
エスケープシーケンスに対応したメソッドを追加します
gem install rainbowでインストールして
以下のように使います

&gt;|ruby|
require 'rainbow'
puts &quot;hello&quot;.color(:red)
puts &quot;hello&quot;.color(255, 0, 0)
puts &quot;hello&quot;.color(:red).background(:green)
puts &quot;hello&quot;.bright.background(:blue).blink
||&lt;


**Term-ANSIColor
[https://github.com/flori/term-ansicolor:title=Term-ANSIColor]は多様な使い方ができるライブラリで
エスケープシーケンスをモジュール関数化したり
Stringクラスのインスタンスメソッドにしたりできます
gem install term-ansicolorでインストールして
以下のように使います


まずはクラスメソッドとして
&gt;|ruby|
require 'term/ansicolor'
class Color
  extend Term::ANSIColor
end

print Color.red, Color.bold, &quot;No Namespace cluttering:&quot;, Color.clear, &quot;\n&quot;
print Color.green + &quot;green&quot; + Color.clear, &quot;\n&quot;
print Color.on_red(Color.green(&quot;green&quot;)), &quot;\n&quot;
print Color.yellow { Color.on_black { &quot;yellow on_black&quot; } }, &quot;\n\n&quot;
||&lt;

次にTerm::ANSIColorのインスタンスメソッドとして

&gt;|ruby|
c = Term::ANSIColor

print c.red, c.bold, &quot;No Namespace cluttering (alternative):&quot;, c.clear, &quot;\n&quot;
print c.green + &quot;green&quot; + c.clear, &quot;\n&quot;
print c.on_red(c.green(&quot;green&quot;)), &quot;\n&quot;
print c.yellow { c.on_black { &quot;yellow on_black&quot; } }, &quot;\n\n&quot;
||&lt;

関数的に
&gt;|ruby|
include Term::ANSIColor

print red, bold, &quot;Usage as constants:&quot;, reset, &quot;\n&quot;
print red(&quot;red&quot;),  on_red(&quot;on_red&quot;), &quot;\n&quot;
print red { bold { &quot;Usage as block forms:&quot; } }, &quot;\n&quot;
||&lt;

Stringのメソッドとして
&gt;|ruby|
class String
  include Term::ANSIColor
end

print &quot;Usage as String Mixins:&quot;.red.bold, &quot;\n&quot;
print &quot;Hello, World\n&quot;.blue.on_yellow.blink
||&lt;


**Wirble
[https://github.com/blackwinter/wirble:title=Wirble]はirb(Interactive Ruby)の支援ツールで
Rubyのシンタックスに合わせたカラーリングすなわち
Syntax Highlightingを実現します
ライブラリとして使う場合は以下のようにします
&gt;|ruby|
require &quot;wirble&quot;
w = Wirble::Colorize
puts w.colorize_string(&quot;Hello, Ruby&quot;, :light_cyan)
puts w.colorize(&quot;hello, :hello, [1, 2, 3], {:a =&gt; 1, :b =&gt; 2}&quot;)
||&lt;


[f:id:keyesberry:20101112083741p:image]

colorizeメソッドでRubyのオブジェクトに応じた
カラーリングが実現できているのが分かります


なおirbで使う場合は.irbrcで以下のように指定します
&gt;|ruby|
  require 'wirble'
  Wirble.init
  Wirble.colorize
||&lt;


**Coderay
[http://coderay.rubychan.de/:title=CodeRay]は複数の言語に対応したSyntax Highlightingライブラリです
Rubyのコードをターミナルでカラーリングする場合は
以下のようにします

&gt;|ruby|
require &quot;coderay&quot;
puts CodeRay.scan(&quot;5.times do\n puts 'hello, ruby'\nend&quot;, :ruby).term
||&lt;


[f:id:keyesberry:20101112083742p:image]


ファイルから読込んでHTML出力するようなこともできます
&gt;|ruby|
puts CodeRay.scan_file(&quot;code.rb&quot;).div(:line_numbers =&gt; :table)
||&lt;

[f:id:keyesberry:20101112083743p:image]


素晴らしいですね！

**Paint
Paintはライブラリでの使い勝手と拡張性を売りにした
非常にユニークな使い方ができるライブラリです
gem install paintでインストールして
以下のように使います


まずはPaint.[]クラスメソッドを使う例です
&gt;|ruby|
 require 'paint'
 Paint['Ruby', :red] #=&gt; &quot;\e[31mRuby\e[0m&quot;
 Paint['Ruby', :red, :bright, :underline] #=&gt; &quot;\e[31;1;4mRuby\e[0m&quot;
 Paint['Ruby', :red, :blue] #=&gt; &quot;\e[31;44mRuby\e[0m&quot;
||&lt;
第3引数以降に現れるカラーは背景色用です


色の指定は多様な方法でできます
&gt;|ruby|
 Paint['Ruby', [100, 255, 5]] #=&gt; &quot;\e[38;5;118mRuby\e[0m&quot;
 Paint['Ruby', &quot;gold&quot;, &quot;snow&quot;] #=&gt; &quot;\e[38;5;226;48;5;231mRuby\e[0m&quot;
 Paint['Ruby', &quot;#123456&quot;] #=&gt; &quot;\e[38;5;24mRuby\e[0m&quot;
 Paint['Ruby', &quot;fff&quot;] #=&gt; &quot;\e[38;5;231mRuby\e[0m&quot;
||&lt;


第2引数以下を省略すると色指定がランダムになり
:inverseをしていすると前景色と背景色を入れ替えます
&gt;|ruby|
 Paint['Ruby'] #=&gt; &quot;\e[37mRuby\e[0m&quot; 
 Paint['Ruby', :inverse] #=&gt; &quot;\e[7mRuby\e[0m&quot;
||&lt;


[f:id:keyesberry:20110721203131p:image]


PaintがユニークなのはPaint::SHORTCUTSを使った
ユーザカラー定義です
&gt;|ruby|
 Paint::SHORTCUTS[:mycolor] = {
     :white =&gt; Paint.color(:black),
     :red   =&gt; Paint.color(:red, :bright),
     :title =&gt; Paint.color(:underline)
   } #=&gt; {:white=&gt;&quot;\e[30m&quot;, :red=&gt;&quot;\e[31;1m&quot;, :title=&gt;&quot;\e[4m&quot;}
||&lt;


上のように登録することで
Paint::Mycolorの名前空間で
white red titleの各クラスメソッドが有効になります
&gt;|ruby|
 Paint::Mycolor.red &quot;Ruby&quot; #=&gt; &quot;\e[31;1mRuby\e[0m&quot;
 Paint::Mycolor.white #=&gt; &quot;\e[30m&quot;
 Paint::Mycolor.title &quot;Ruby&quot; #=&gt; &quot;\e[4mRuby\e[0m&quot;

 include Paint::Mycolor #=&gt; Object
 red &quot;Ruby&quot; #=&gt; &quot;\e[31;1mRuby\e[0m&quot;
 white &quot;Ruby&quot; #=&gt; &quot;\e[30mRuby\e[0m&quot;
||&lt;


それだけでなく
Paint::Mycolor::Stringモジュールをincludeすることにより
あらゆるオブジェクトをユーザ定義に従い
色つき文字列化することもできます
&gt;|ruby|
 include Paint::Mycolor::String #=&gt; Object

 &quot;Ruby&quot;.red #=&gt; &quot;\e[1;31mRuby\e[0m&quot;
 &quot;Ruby&quot;.title #=&gt; &quot;\e[4mRuby\e[0m&quot;
 5.red #=&gt; &quot;\e[31;1m5\e[0m&quot;
 [1, 2].red #=&gt; &quot;\e[31;1m[1, 2]\e[0m&quot;
||&lt;
ちょっとやり過ぎな気もしますが..


グローバルな名前空間が汚染されることを避けたいなら
プレフィクスとして任意のメソッド名を指定することもできます
&gt;|ruby|
 include Paint::Mycolor::Prefix::C #=&gt; Object
 &quot;Ruby&quot;.c(:red) #=&gt; &quot;\e[31;1mRuby\e[0m&quot;
 &quot;Ruby&quot;.c(:title) #=&gt; &quot;\e[4mRuby\e[0m&quot;
 [1, 2].c(:red) #=&gt; &quot;\e[31;1m[1, 2]\e[0m&quot;
||&lt;
なんかスゴイですね！


ご想像のとおりPaintモジュールの内部は
メタプログラミングばりばりです:)


**IRC(Interactive Colors)
最後に上のライブラリを使って
ターミナル上でインタラクティブにカラーチェックができる
irc.rbという簡単なツールを作りました
Term-ANSIColorライブラリを使っています


ruby irc.rbで立上げると
welcomeメッセージに続きirbのようにpromptモードになります
red on_greenなどの色属性をタイプすると
その属性に制御された文字列が表示されます

[f:id:keyesberry:20101107152015p:image]


文字列をリセットしたい場合は
'='に続いて文字列をタイプします
入力できる属性はhelp(h, colors, attrs)で確認できます
終了はexit(q, quit, bye)です

[f:id:keyesberry:20101107152016p:image]


使ってくれる人がいたらうれしいです


(追記：2010-11-8) rainbow commandを追加しました。GNU Readlineに対応しました。

[f:id:keyesberry:20101108075820p:image]


(追記：2010-11-12) WirbleとCodeRayライブラリの記載を追加しました。
(追記：2011-7-20) Paintライブラリの記載を追加しました。


[https://github.com/melborne/irc:title=melborne/irc - GitHub] 

</body>
</day>
<day date="2010-11-10" title="">
<body>
*p1*((Rubyで) 書く (Lisp) インタプリタ)
[http://norvig.com/:title=Peter Norvig]さんの[http://www.aoky.net/articles/peter_norvig/lispy.htm:title][http://www.aoky.net/articles/peter_norvig/lispy.htm:bookmark]
という記事(青木靖さん訳)がすごい
100行ほどのPythonコードで
Schemeのインタプリタの基本部分を書いている
Pythonのコードは見た目がRubyのコードとよく似ているので
Rubyしか知らない僕でも何となく読める


この記事を解読してRuby版Schemeインタプリタを書いたら
インタプリタ　Pyhon　Scheme　それからRubyのことも
もう少し分かるようになるかもしれない
こんなお得な勉強方法はないぞ　きっと


そんなわけで...


以下では上記記事を参照しながら
Ruby版Schemeインタプリタを書いていきます
本文では適宜Norvigさんの解説およびコードを引用しつつ
自分の理解とRubyのコードを
pythonのコードと対応させていきます
Rubyのインタプリタ名はlisr.rbとします


**インタプリタ
インタプリタはSchemeのプログラムを文字の列として読み込み
それを言語の構文規則に沿って
内部表現へ変換する「構文解析(parse)」と
変換した内部表現を言語の意味論規則に基づいて
処理する「実行(eval)」の２つの部分からなります


**構文解析（パーサ)
Schemeの構文はカッコ付きの前置記法である
リストを基本としています
PythonによるパーサがSchemeのリストを
pythonのリストに変換するのと同じ方法で
RubyのArrayへ変換するパーサを作ります


**トークン生成
パーサはまず読込んだプログラムの文字列を
その構文要素であるトークン(token)に分割します


Pythonのコード
&gt;|python|
def tokenize(s):
    &quot;文字列をトークンのリストに変換する。&quot;
    return s.replace('(',' ( ').replace(')',' ) ').split()
||&lt;
カッコの前後に空白を挿入してsplitによる分割が
うまくいくように前処理している点がポイントです


同じことをRubyで実現します
&gt;|ruby|
def tokenize(s)
  s.gsub(/[()]/, ' \0 ').split
end

tokenize &quot;(define plus1 (lambda (n) (+ n 1)))&quot;
  #=&gt; [&quot;(&quot;, &quot;define&quot;, &quot;plus1&quot;, &quot;(&quot;, &quot;lambda&quot;, &quot;(&quot;, &quot;n&quot;, &quot;)&quot;, &quot;(&quot;, &quot;+&quot;, &quot;n&quot;, &quot;1&quot;, &quot;)&quot;, &quot;)&quot;, &quot;)&quot;]
||&lt;
やり方は同じですがここでは
String#gsubに正規表現を渡すことで両カッコの前処理を一度にしています


**トークン列の解析
次にトークンに分割された文字列を
内部で処理できる表現に変換します


PythonではSchemeのリスト　数　シンボルをそれぞれ
Pythonのリスト　数　文字列で表現しています


Pythonのコード
&gt;|python|
def read_from(tokens):
    &quot;トークンの列から式を読み込む。&quot;
    if len(tokens) == 0:
        raise SyntaxError('unexpected EOF while reading')
    token = tokens.pop(0)
    if '(' == token:
        L = []
        while tokens[0] != ')':
            L.append(read_from(tokens))
        tokens.pop(0) # pop off ')'
        return L
    elif ')' == token:
        raise SyntaxError('unexpected )')
    else:
        return atom(token)
||&lt;
このコードは一件複雑そうですが例外処理を除いて
よく見れば処理の構造が見えてきます
基本的にread_fromはトークンのリストを受け取り
先頭から１つづつ再帰的にトークンを解析します


具体的にはその先頭が開きカッコか否かを判定します
そうでない場合それは数かシンボルなのでelse節のatomで
トークンをpythonの対応する表現に変換して返します


開きカッコである場合はリストを用意し
閉じカッコが現れるまでのトークンをここに入れますが
ここでread_fromを再帰的に呼び出すことによって
後続のトークンが適切に処理されるようにします
つまり後続のトークンの先頭が開きカッコである場合は
上記同様リストが用意されてそこに後続トークンを入れる処理がされ
そうでない場合はatomでpythonの表現に変換されます


このコードは再帰を使ったエレガントで強力なアルゴリズムです
以上の処理によりschemeのリストはpythonのリストに変換されます


同じことをRubyでも実現します
RubyではSchemeのリスト　数　シンボルをそれぞれ
RubyのArray　数　シンボルで表現します
&gt;|ruby|
def read_from(tokens)
  raise SytaxError, 'unexpected EOF while reading' if tokens.length == 0
  case token = tokens.shift
  when '('
    l = []
    until tokens[0] == ')'
      l.push read_from(tokens)
    end
    tokens.shift
    l
  when ')'
    raise SyntaxError, 'unexpected )'
  else
    atom(token)
  end
end
||&lt;
コードはほぼPythonと同じですがここでは
if文に代えてcase式を使っています
「閉じカッコが来るまで」はwhileよりもuntilを使うと自然になります


**トークン変換
次にトークンをインタプリタの表現に変換する関数atomを見ます


Pythonのコード
&gt;|python|
def atom(token):
    &quot;数は数にし、それ以外のトークンはシンボルにする。&quot;
    try: return int(token)
    except ValueError:
        try: return float(token)
        except ValueError:
            return Symbol(token)
||&lt;
最初にトークンのintへの変換を試み
次にfloatへの変換を試み
最後にSymbolへの変換を試みています


対応するRubyのコード
&gt;|ruby|
module Kernel
  def Symbol(obj); obj.intern end
end

def atom(token, type=[:Integer, :Float, :Symbol])
  send(type.shift, token)
rescue ArgumentError
  retry
end
||&lt;
同様の書き方もできますがここでは
rescue節でretryを使うことでコードを簡潔にしました
ただSymbolという関数メソッドが未定義なのでこれを用意しています


**パーサ・インタフェース
これらを統合したパーサのインタフェースは次のようになります
Pythonのコード
&gt;|python|
def read(s):
    &quot;文字列からScheme式を読み込む。&quot;
    return read_from(tokenize(s))

parse = read
||&lt;


Rubyのコード
&gt;|ruby|
def read(s)
  read_from tokenize(s)
end
alias :parse :read
||&lt;

Rubyでは関数(メソッド)はオブジェクトではないので
そのまま変数に代入することはできません
別名を付ける場合はalias文かModule#alias_methodを使います
Rubyではあまりこういう書き方を見ない気がするのですが
Pythonでは一般的な手法なのでしょうか


さてパーサが完成しました
成果を見てみましょう

&gt;|ruby|
% irb1.9 -rlisr
&gt;&gt; parse &quot;(+ 3 (* 4 5))&quot;
  # =&gt; [:+, 3, [:*, 4, 5]]
&gt;&gt; parse &quot;(define plus1 (lambda (n) (+ n 1)))&quot;
  # =&gt; [:define, :plus1, [:lambda, [:n], [:+, :n, 1]]]
&gt;&gt; parse &quot;(define area (lambda (r) (* 3.141592653 (* r r))))&quot;
  # =&gt; [:define, :area, [:lambda, [:r], [:*, 3.141592653, [:*, :r, :r]]]]
||&lt;
うまくいっているようです((自分の環境のirbでは:+, :*の表示には問題がありました))


余分ですがStringのメソッド群を使った
強引な(?)パーサ版(brute_parse)も書いてみました
&gt;|ruby|
def brute_parse(s)
  s = tokenize(s).map { |token| 
        if token =~ /[()]/ then token.tr('()', '[]')
        elsif token == '=' then &quot;:'='&quot;
        elsif atom(token).instance_of?(Symbol) then &quot;:#{token}&quot;
        else  token
        end
       }.join(&quot;,&quot;).gsub('[,', '[')
  eval s
end
||&lt;
tokenizeメソッドでプログラムをトークンに分割した後
mapメソッド内で各トークンに適切な処理を施します
カッコは角カッコに変換し
数字以外のトークンはRubyのシンボルに変換します
Rubyでは代入=のシンボル表記:=は許されていないので
表記方法を少し変えています
これらの変換されたトークンをカンマで接続します
最後に開き角カッコの後の不要なカンマを削除します((閉じ角カッコの前のカンマはRubyインタプリタでは無視されます))
一応動作しますがやはり元のパーサのほうがエレガントです


**実行(eval)
パーサが完成したので次にevalです


このSchemeには３つの構文的構成物つまり
変数　定数(数)　手続き呼出しと
６つの特殊形式つまり
クォート(quote)　条件式(if)　代入(set!)
定義(define)　手続き(lambda)　逐次式(begin) しかありません
特殊形式は(set! x y)のように先頭に
上記の何れかのキーワードを持ったリストの形式をとります
リストの先頭が上記キーワードに該当しない場合(例えば(area 3))
それは手続き呼出しとして扱われます


pythonのコード
&gt;|python|
def eval(x, env=global_env):
    &quot;環境の中で式を評価する。&quot;
    if isa(x, Symbol):             # 変数参照
        return env.find(x)[x]
    elif not isa(x, list):         # 定数リテラル
        return x                
    elif x[0] == 'quote':          # (quote exp)
        (_, exp) = x
        return exp
    elif x[0] == 'if':             # (if test conseq alt)
        (_, test, conseq, alt) = x
        return eval((conseq if eval(test, env) else alt), env)
    elif x[0] == 'set!':           # (set! var exp)
        (_, var, exp) = x
        env.find(var)[var] = eval(exp, env)
    elif x[0] == 'define':         # (define var exp)
        (_, var, exp) = x
        env[var] = eval(exp, env)
    elif x[0] == 'lambda':         # (lambda (var*) exp)
        (_, vars, exp) = x
        return lambda *args: eval(exp, Env(vars, args, env))
    elif x[0] == 'begin':          # (begin exp*)
        for exp in x[1:]:
            val = eval(exp, env)
        return val
    else:                          # (proc exp*)
        exps = [eval(exp, env) for exp in x]
        proc = exps.pop(0)
        return proc(*exps)
 
isa = isinstance
 
Symbol = str
||&lt;
evalの中身はif文による
上記の９ケースの場合分け処理になっています
evalに与えられた内部表現(パースされたプログラム文字列)が
リストである場合
特殊形式の何れかの処理でその構成要素が再帰的にeval処理されます
そしてeval対象がシンボルであれば
環境を定義したenvオブジェクトを参照してその実体を返します
シンボルでもリストでもない場合は
数字などの定数としてそのまま返します
eval対象が特殊形式でないリストである場合(else節)
これを手続きとしてその内容を実行します


なおevalの第２引数は環境オブジェクトenvを取ります
これは内部表現を評価する際に
それが定義された環境を区別する必要があるためです
これによって
ローカル変数がグローバルに評価されるようなことがなくなります
初期値はグローバル環境にセットされます


対応するRubyのevaluate((Rubyの組み込み関数evalをbrute_parseで使っているため名前を変えている))は以下のようになりました
&gt;|ruby|
def evaluate(x, env=$global_env)
  case x
  when Symbol
    env.find(x)[x]
  when Array
    case x.first
    when :quote
      _, exp = x
      exp
    when :if
      _, test, conseq, alt = x
      evaluate((evaluate(test, env) ? conseq : alt), env)
    when :set!
      _, var, exp = x
      env.find(var)[var] = evaluate(exp, env)
    when :define
      _, var, exp = x
      env[var] = evaluate(exp, env)
      nil
    when :lambda
      _, vars, exp = x
      lambda { |*args| evaluate(exp, Env.new(vars, args, env)) }
    when :begin
      x[1..-1].inject(nil) { |val, exp| val = evaluate(exp, env) }
    else
      proc, *exps = x.inject([]) { |mem, exp| mem &lt;&lt; evaluate(exp, env) }
      proc[*exps]
    end
  else
    x
  end
end
||&lt;
Rubyではcase式を使って条件分岐を行いました
手続き呼出し(内側のelse節)はPythonではリスト内包を使っていますが
Rubyにはそのような構文はないので代わりに
Enumerable#injectを使います
proc[*exps]はproc.call(*exps)と等価でprocの実行です
Python同様Rubyでも多重代入が便利に使えます


**環境クラス定義
次に環境オブジェクトのためのクラスを定義します

Pythonのコード
&gt;|python|
class Env(dict):
    &quot;環境: ペア{'var':val}のdictで、外部環境(outer)を持つ。&quot;
    def __init__(self, parms=(), args=(), outer=None):
        self.update(zip(parms,args))
        self.outer = outer
    def find(self, var):
        &quot;var が現れる一番内側のEnvを見つける。&quot;
        return self if var in self else self.outer.find(var)
||&lt;
環境クラスENVはdictのサブクラスで
オブジェクト生成時に与えられた変数とその実体を
辞書として保持します
zip関数で変数のリストと実体のリストから辞書を生成しマージします
そのオブジェクトが内部環境を構築するつまり
外部環境を持っている場合
それを第３引数として渡してオブジェクトを生成します
これはeval関数内のlambdaにおける処理で使われています


findメソッドは与えられた変数に対応する実体を返します
その環境で変数が定義されていない場合
その１つ外側の環境で対応する実体を探します


対応するRubyコード
&gt;|ruby|
class Env &lt; Hash
  def initialize(parms=[], args=[], outer=nil)
    h = Hash[parms.zip(args)]
    self.merge!(h)
    @outer = outer
  end
  
  def find(key)
    self.has_key?(key) ? self : @outer.find(key)
  end
end
||&lt;
外部環境outerは
オブジェクトの外からアクセスする必要はないので
インスタンス変数@outerに保持します
Rubyのif修飾子ではelse節を書けないので
代わりに３項演算子?:を使います


**グローバル環境オブジェクト
環境クラスが定義できたので
これを使ってグローバル環境オブジェクトを生成します
グローバル環境にはSchemeの組込み手続きを含めます


pythonのコード
&gt;|python|
def add_globals(env):
    &quot;環境にScheme標準の手続きをいくつか追加する&quot;
    import math, operator as op
    env.update(vars(math)) # sin, sqrt, ...
    env.update(
     {'+':op.add, '-':op.sub, '*':op.mul, '/':op.div, 'not':op.not_,
      '&gt;':op.gt, '&lt;':op.lt, '&gt;=':op.ge, '&lt;=':op.le, '=':op.eq, 
      'equal?':op.eq, 'eq?':op.is_, 'length':len, 'cons':lambda x,y:[x]+y,
      'car':lambda x:x[0],'cdr':lambda x:x[1:], 'append':op.add,  
      'list':lambda *x:list(x), 'list?': lambda x:isa(x,list), 
      'null?':lambda x:x==[], 'symbol?':lambda x: isa(x, Symbol)})
    return env
 
global_env = add_globals(Env())
||&lt;
add_globals関数は環境オブジェクトに
Schemeの組込み手続きを追加します
この外部環境オブジェクトは
グローバル変数global_envで参照できるようにセットされ
その結果どこからでもアクセスできるようになります


対応するRubyのコードです
&gt;|ruby|
def add_globals(env)
  env.merge!({
     :+     =&gt; -&gt;x,y{x+y},      :-      =&gt; -&gt;x,y{x-y},
     :*    =&gt; -&gt;x,y{x*y},       :/     =&gt; -&gt;x,y{x/y},
     :not    =&gt; -&gt;x{!x},        :&gt;    =&gt; -&gt;x,y{x&gt;y}, 
     :&lt;     =&gt; -&gt;x,y{x&lt;y},      :&gt;=     =&gt; -&gt;x,y{x&gt;=y},
     :&lt;=   =&gt; -&gt;x,y{x&lt;=y},      :'='   =&gt; -&gt;x,y{x==y},
     :equal? =&gt; -&gt;x,y{x.equal?(y)}, :eq?   =&gt; -&gt;x,y{x.eql? y},
     :length =&gt; -&gt;x{x.length},  :cons =&gt; -&gt;x,y{[x,y]},
     :car   =&gt; -&gt;x{x[0]},       :cdr    =&gt; -&gt;x{x[1..-1]},
     :append =&gt; -&gt;x,y{x+y},     :list  =&gt; -&gt;*x{[*x]},
     :list?  =&gt; -&gt;*x{x.instance_of?(Array)},
     :null? =&gt; -&gt;x{x.empty?},   :symbol? =&gt; -&gt;x{x.instance_of?(Symbol)}
    })
  env
end

$global_env = add_globals(Env.new)
||&lt;
RubyではPythonのmathモジュールのようなものはないので
すべてlambdaで生成しています
Ruby1.9で導入された-&gt;表記がこういうところでは便利です
Rubyではグローバル変数は変数名の前に$を前置します


ただRubyではあまりこういう書き方は見ません
Rubyistならブロックを使うでしょう
&gt;|ruby|
class Env &lt; Hash
  def initialize(parms=[], args=[], outer=nil)
    h = Hash[parms.zip(args)]
    self.merge!(h)
    self.merge!(yield) if block_given?
    @outer = outer
  end
  
  def find(key)
    self.has_key?(key) ? self : @outer.find(key)
  end
end

$global_env = Env.new do
  {
   :+     =&gt; -&gt;x,y{x+y},      :-      =&gt; -&gt;x,y{x-y},
   :*    =&gt; -&gt;x,y{x*y},       :/     =&gt; -&gt;x,y{x/y},
   :not    =&gt; -&gt;x{!x},        :&gt;    =&gt; -&gt;x,y{x&gt;y}, 
   :&lt;     =&gt; -&gt;x,y{x&lt;y},      :&gt;=     =&gt; -&gt;x,y{x&gt;=y},
   :&lt;=   =&gt; -&gt;x,y{x&lt;=y},      :'='   =&gt; -&gt;x,y{x==y},
   :equal? =&gt; -&gt;x,y{x.equal?(y)},
   :eq?   =&gt; -&gt;x,y{x.eql? y}, :length =&gt; -&gt;x{x.length},
   :cons =&gt; -&gt;x,y{[x,y]},     :car   =&gt; -&gt;x{x[0]},
   :cdr    =&gt; -&gt;x{x[1..-1]},  :append =&gt; -&gt;x,y{x+y},
   :list  =&gt; -&gt;*x{[*x]},
   :list?  =&gt; -&gt;*x{x.instance_of?(Array)},
   :null? =&gt; -&gt;x{x.empty?},
   :symbol? =&gt; -&gt;x{x.instance_of?(Symbol)}
   }
end
||&lt;

**対話的Lispインタプリタ
最後に対話的インタプリタつまり
ユーザからSchemeプログラムの入力に対して
その評価結果をLispの文字列にして出力するものを追加します


Pythonのコード
&gt;|python|
def to_string(exp):
    &quot;PythonオブジェクトをLispの読める文字列に戻す。&quot;
    return '('+' '.join(map(to_string, exp))+')' if isa(exp, list) else str(exp)
 
def repl(prompt='lis.py&gt; '):
    &quot;read-eval-print-loopのプロンプト&quot;
    while True:
        val = eval(parse(raw_input(prompt)))
        if val is not None: print to_string(val)
||&lt;
to_string関数はインタプリタからの出力を
Lisp形式の文字列に変換します
raw_input関数は組み込み関数でpromptを表示して
ユーザの入力を促し入力があった場合それを返します


対応するRubyのコード
&gt;|ruby|
def to_string(exp)
  puts (exp.instance_of?(Array)) ? '(' + exp.map(&amp;:to_s).join(&quot; &quot;) + ')' : &quot;#{exp}&quot;
end

require &quot;readline&quot;
def lepl
  while line = Readline.readline(&quot;lisr&gt; &quot;, true)
    val = evaluate(parse line)
    to_string(val) unless val.nil?
  end
end
||&lt;
Rubyではraw_inputの代わりにReadlineライブラリを使います


以上でRuby版Lispインタプリタの完成です！
早々norvigさんの記事にある演算を試してみましょう

&gt;|ruby|
% ruby1.9 lisr.rb
lisr&gt; (define area (lambda (r) (* 3.141592653 (* r r))))
lisr&gt; (area 3)
28.274333877
lisr&gt; (define fact (lambda (n) (if (&lt;= n 1) 1 (* n (fact (- n 1))))))
lisr&gt; (fact 10)
3628800
lisr&gt; (fact 100)
933262154439441526816992388562667004907159682643816214685929638952175999932299156089414639761565182862536979208272237582
51185210916864000000000000000000000000
lisr&gt; (area (fact 10))
41369087198016.19
lisr&gt; 
||&lt;
うまくいきました！


ところが...
&gt;|ruby|
lisr&gt; (define first car)
lisr&gt; (define rest cdr)
lisr&gt; (define count (lambda (item L) (if L (+ (equal? item (first L)) (count item (rest L))) 0)))
lisr&gt; (count 0 (list 0 1 2 3 0 0))
lisr.rb:17:in `block in add_globals': undefined method `+' for false:FalseClass (NoMethodError)
        from lisr.rb:57:in `[]'
||&lt;
これがうまくいきません...
というかcountの定義が僕には理解できません((ちなみにcsi(Chicken Scheme Interpreter)でもerrorがでました))


自分のcountの定義で試してみると
&gt;|ruby|
lisr&gt; (define first car)
lisr&gt; (define rest cdr)
lisr&gt; (define count (lambda (item L) (if (= 0 (length L)) 0 (if (= item (first L)) (+ 1 (count item (rest L))) (count item (rest L))))))
lisr&gt; (count 0 (list 0 1 2 3 0 0))
3
lisr&gt; (count (quote the) (quote (the more the merrier the bigger the better)))
4
||&lt;
これはうまくいくのですが...
最後にちょっとすっきりしませんけど
十分に勉強になったので
まあいいとしますか


(追記：2010-11-13) Ruby実装の本格的なLispインタプリタを書いている方がいました。gem install nendoでインストールし、nendoで対話型インタプリタが実行できます。すごい！

   [http://oldtype.sumibi.org/show-page/Nendo:title=Nendo -- * Nendo programming languag]e 


&lt;script src=&quot;https://gist.github.com/670793.js?file=lisr.rb&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2010-11-11" title="">
<body>
*p1*Rubyのメソッドに別名があってもいいじゃないか
Rubyのメソッドに別名を付ける方法を勉強したので
ここにまとめておきます

**オブジェクトの別名
Rubyの変数はオブジェクトの参照にすぎないから
オブジェクトに別名を付けるのは簡単だ
&gt;|ruby|
a_friend = 'Charlie'
a_coworker = a_friend

database = DataBase.new
source = database
||&lt;
そう　オブジェクトを参照している変数を
別の変数に代入すればいい


でもRubyではメソッドはオブジェクトではないから
Pythonのようにメソッドを変数に代入することはできない
&gt;|ruby|
def methodA
  :method_is_A
end

a_method = methodA # =&gt; :method_is_A
||&lt;


一見　代入が問題なく行われているように見えるけれども
変数a_methodに代入されているのは
methodAメソッドの実行結果に過ぎない
&gt;|ruby|
a_method.class # =&gt; Symbol
||&lt;


**メソッドの別名
ではどうすればメソッドに別名を付けられるのか


いくつかの方法があって
その代表的な方法はaliasキーワードを使う方法だ
&gt;|ruby|
def base(name, rep)
  ([&quot;Great #{name}!&quot;] * rep).join(&quot;, Yes, &quot;)
end

alias :by_alias :base

parms = ['Charlie', 2]
base(*parms)      # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;

by_alias(*parms)  # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;
||&lt;
aliasには上のようにシンボルかメソッド名を新旧の順で渡す
引数の間にカンマがないのでこれがメソッドではなくて
キーワードだということが分かる


別名を付けるにはModule#alias_methodを利用する方法もある
&gt;|ruby|
module Base
  alias_method :by_alias_method, :base
end
include Base

parms = ['Charlie', 2]
by_alias_method(*parms) # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;
||&lt;


alias_methodは
Moduleクラスのプライベート・インスタンスメソッドなので
モジュールの文脈で呼ぶ必要がある
aliasと異なり引数に文字列を受け取ることができ
そこに式を置くこともできる
&gt;|ruby|
  alias_method :by_alias_method, (if today.sunny? then 'base' else 'base2' end)
||&lt;


またメソッド定義により別名を付ける方法がある
&gt;|ruby|
def by_method(*arg)
  base(*arg)
end

parms = ['Charlie', 2]
by_method(*parms)  # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;
||&lt;
受け取った引数をオリジナルのメソッドに委譲する形だ


またメソッドをオブジェクト化して別名を付ける方法もある
&gt;|ruby|
by_lambda = lambda { |*args| base(*args) }

by_method_obj = method(:base)

parms = ['Charlie', 2]
by_lambda[*parms]     # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;
by_method_obj[*parms] # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;
||&lt;
１つはKernel#lambdaを使って
メソッドをProcオブジェクトにして変数に代入する方法
１つはObject#methodを使って
メソッドをMethodオブジェクトにして変数に代入する方法だ


何れのオブジェクトもcallメソッドを呼ぶことで実行される
各callメソッドには別名としてそれぞれ
Proc#［］ Method#［］が定義されていて
それを使うことで関数呼出しの構文的にその実行ができる


このように複数の別名定義方法があるけれど
注意しなければいけないことが１つある
それはベースのメソッドが再定義されたときの
挙動が異なるという点だ
&gt;|ruby|
def base(name, rep)
  ([&quot;Great #{name}!&quot;] * rep).join(&quot;, Yes, &quot;)
end

alias :by_alias :base

module Base
  alias_method :by_alias_method, (if true then 'base' else 'base2' end)
end
include Base

def by_method(*arg)
  base(*arg)
end

by_lambda = lambda { |*args| base(*args) }

by_method_obj = method(:base)

parms = ['Charlie', 2]
base(*parms)            # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;

by_alias(*parms)        # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;
by_alias_method(*parms) # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;
by_method(*parms)       # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;
by_lambda[*parms]       # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;
by_method_obj[*parms]   # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;

def base(name, rep)
  ([&quot;Poor #{name}!&quot;] * rep).join(&quot;, No, &quot;)
end

parms = ['Charlie', 2]
base(*parms)            # =&gt; &quot;Poor Charlie!, No, Poor Charlie!&quot;

by_alias(*parms)        # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;
by_alias_method(*parms) # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;
by_method(*parms)       # =&gt; &quot;Poor Charlie!, No, Poor Charlie!&quot;
by_lambda[*parms]       # =&gt; &quot;Poor Charlie!, No, Poor Charlie!&quot;
by_method_obj[*parms]   # =&gt; &quot;Great Charlie!, Yes, Great Charlie!&quot;
||&lt;


このコードの結果で分かるように
alias alias_method Methodオブジェクトを使った別名定義では
元のメソッドが実行される
つまりこれらの別名定義ではそのコンテキストを共有できない
従って元のメソッドが定義されたコンテキストを共有したい場合は
メソッド再定義かProcオブジェクトによる
別名の方法を利用する必要がある

</body>
</day>
<day date="2010-11-16" title="">
<body>
*p1*IRB　それはRubyistの魔法のランプ
IRB((正式にはirb))　名前を聞けば誰でもわかる
超有名なライブラリ
IRBを知らなけりゃ　それはもぐりのRubyist


:$
IRB　全部のRubyに付いてくる
あなたとRubyの対話の窓口
できないことがあるのなら　irbと打ってみよう
rubyと打ってもダメですよ


IRB　それはRubyistの魔法のランプ
こすれば何かが現れる
IRB　それはRubyistの魔法のランプ
こすって願いを叶えよう
I RuB you　I RuB you
:TO


IRB　色気がないのはご愛嬌
色がいるなら　.irbrcしてください
補完だってインデントだって
そうしたいならプロンプトだって
あなた色に染まります


IRB　それでも不満があるのなら
wirble fancy_irbが色付けします
デバッグするならpp ap y g -d
table viewにq o c
エディタいるならie((interactive_editor)) sketches使ってね
コマンド足すならbosonあるよ
全部入りならirbtools！


IRB　それはRubyistの魔法のランプ
こすれば何かが現れる
IRB　それはRubyistの魔法のランプ
こすって願いを叶えよう
I RuB you I RuB you


君がいなけりゃ生きてはいけない
君がいなけりゃRubyも要らない
君がいなけりゃ
プログラミングなんてもうやらない
ごめんなさい　いままでおざなりにして
これからはもっと君のこと大切にします


:D.S.


:CODA
IRB　それは
アイルランド共和同盟(Irish republican brotherhood)じゃない
IRB　それは
国際ラグビー評議会(International Rugby Board)でもない
IRB　もちろん
治験審査委員会(Institutional Review Board)でもない((IRB - Wikipedia http://ja.wikipedia.org/wiki/IRB))


IRB　そう　
それは　Interactive Rubyのこと
そう　それはRubyistの魔法のランプ




さて...


irbとその周辺のことを少し調べたので
ここにまとめておきます


**irbの簡単な使い方
ターミナル上でirbと打って
現れたプロンプトでRubyのコードを入力します
&gt;|zsh|
 %irb
 irb(main):001:0&gt; puts &quot;hello, irb!&quot;
 hello, irb!
 =&gt; nil
||&lt;
リターンで式の評価が行われ
結果が返されます


複数行に渡る入力も受け付けます
&gt;|zsh|
 irb(main):004:0&gt; def fib n
 irb(main):005:1&gt; [0,1].include?(n) ? n : fib(n-1) + fib(n-2)
 irb(main):006:1&gt; end
 =&gt; nil
 irb(main):007:0&gt; fib 10
 =&gt; 55
||&lt;
つまりリターン入力時に式が完了していない場合
評価を先送りして　完了した時結果を返します


_(アンダースコア)は前の評価結果を保持します
&gt;|zsh|
 irb(main):008:0&gt; 1 + 2
 =&gt; 3
 irb(main):009:0&gt; _ * 3
 =&gt; 9
 irb(main):010:0&gt; _ / 2.0
 =&gt; 4.5
||&lt;


mオプションを付ければ高度な数学電卓になります
つまりmathnをrequireします
&gt;|zsh|
 % irb -m     
 &gt;&gt; 1/2
 =&gt; (1/2)
 &gt;&gt; Complex(0, -1)
 =&gt; (0-1i)
 &gt;&gt; Prime.each(100) do |pr|
 &gt;* print pr, &quot; &quot;
 &gt;&gt; end
 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 =&gt; nil
||&lt;


rオプションでライブラリを読み込みます
&gt;|zsh|
 % irb -ropen-uri
 &gt;&gt; site = open &quot;http://www.nintendo.co.jp&quot;
 =&gt; #&lt;StringIO:0x76e0a8&gt;
 &gt;&gt; site.read.scan(/&lt;a href.*?&gt;/)
 =&gt; [&quot;&lt;a href=&quot;n00/index.html&quot;&gt;&quot;, &quot;&lt;a href=&quot;schedule/index.html&quot;&gt;&quot;, &quot;&lt;a href=&quot;wii/index.html&quot;&gt;&quot;, &quot;&lt;a href=&quot;ds/index.html&quot;&gt;&quot;, &quot;&lt;a href=&quot;n09/index.html&quot;&gt;&quot;, &quot;&lt;a href=&quot;n10/index.html&quot;&gt;&quot;, &quot;&lt;a href=&quot;corporate/index.html&quot;&gt;&quot;, &quot;&lt;a href=&quot;wii/index.html&quot; class=&quot;wiiLink&quot;&gt;&quot;...]
||&lt;


**DBインタフェース
データベースファイルを読み込めば
DBインタフェースになります
DBを定義したuser.rbにconsoleファイルでアクセスする例を示します


user.rbを作ります
&gt;|ruby|
 require &quot;dm-core&quot;
 require &quot;dm-migrations&quot;
 DataMapper.setup(:default, &quot;sqlite3://#{Dir.pwd}/user.db&quot;)
 
 class User
   include DataMapper::Resource
   property :id, Serial
   property :nickname, String
   property :email, String
 end
 
 DataMapper.auto_upgrade!
||&lt;


consoleファイルを作ります
&gt;|zsh|
 irb -r/path/to/the/user
||&lt;


実行権限を付与します
&gt;|zsh|
 chmod +x console
||&lt;


consoleを実行してUserDBにアクセスします
&gt;|zsh|
 % ./console
 &gt;&gt; User.create(:nickname =&gt; 'Charlie', :email =&gt; 'charlie@abc.com')
 =&gt; #&lt;User @id=1 @nickname=&quot;Charlie&quot; @email=&quot;charlie@abc.com&quot;&gt;
 &gt;&gt; User.create(:nickname =&gt; 'Tommy', :email =&gt; 'tommy@abc.com')
 =&gt; #&lt;User @id=2 @nickname=&quot;Tommy&quot; @email=&quot;tommy@abc.com&quot;&gt;
 &gt;&gt; User.all
 =&gt; [#&lt;User @id=1 @nickname=&quot;Charlie&quot; @email=&quot;charlie@abc.com&quot;&gt;, #&lt;User @id=2 @nickname=&quot;Tommy&quot; @email=&quot;tommy@abc.com&quot;&gt;]
 &gt;&gt; User.first.nickname
 =&gt; &quot;Charlie&quot;
||&lt;


**セッション
irb上でirbコマンドを使うことで
別のセッションを立上げることができます
&gt;|zsh|
 irb(main):009:0&gt; irb
 irb#1(main):001:0&gt; 1 + 2
 =&gt; 3
||&lt;
プロンプトの#番号が目印です


mainのコンテキストで定義したメソッドは
Objectクラスのprivateインスタンスメソッドですから
どこからでも呼ぶことができます
&gt;|zsh|
 irb(main):025:0&gt; Object.private_instance_methods(false).grep(/^f/)
 =&gt; [:fib]
 
 irb(main):007:0&gt; irb
 irb#1(main):001:0&gt; fib 10
 =&gt; 55
||&lt;


しかしセッションはローカル変数を共有しません
&gt;|zsh|
 irb(main):001:0&gt; @a = 1
 =&gt; 1
 irb(main):002:0&gt; b = 2
 =&gt; 2
 irb(main):003:0&gt; irb
 irb#1(main):001:0&gt; @a
 =&gt; 1
 irb#1(main):002:0&gt; b
 NameError: undefined local variable or method `b' for main:Object from (irb#1):2
||&lt;


irbコマンドに任意のコンテキストを渡せば
そのコンテキストでセッションが立ち上がります
&gt;|zsh|
 irb(main):011:0&gt; irb String
 irb#2(String):001:0&gt; def too_long?
 irb#2(String):002:1&gt;   self.size &gt; 10 ? 'Yes, Too Long!!' : 'No problem.'
 irb#2(String):003:1&gt; end
 =&gt; nil
 irb#2(String):004:1&gt; exit
 irb(main):012:0&gt; &quot;Hello, Ruby World!!&quot;.too_long?
 =&gt; &quot;Yes, Too Long!!&quot;
 irb(main):013:0&gt; &quot;hi, ruby&quot;.too_long?
 =&gt; &quot;No problem.&quot;
 irb(main):014:0&gt; 
||&lt;


セッションの一覧はjobs
切換えはfgコマンドで行います
&gt;|zsh|
 irb#2(String):004:0&gt; jobs
 =&gt; #0-&gt;irb on main (#&lt;Thread:0x0bfa68&gt;: stop)
 #1-&gt;irb#1 on main (#&lt;Thread:0x09c57c&gt;: stop)
 #2-&gt;irb#2 on String (#&lt;Thread:0x5d41e8&gt;: running)

 irb#2(String):005:0&gt; fg 0
 =&gt; #&lt;IRB::Irb: @context=#&lt;IRB::Context:0x3df2fc&gt;, @signal_status=:IN_EVAL, @scanner=#&lt;RubyLex:0x3e5cd8&gt;&gt;
 irb(main):015:0&gt; 
||&lt;


セッションの終了はexitまたは
kill [セッション番号]で行います


**Workspace
コンテキストを共有するworkspaceというものもあります
pushb(現在のbindingをpushする)コマンドで
別のworkspaceに移動します
&gt;|zsh|
 irb(main):011:0&gt; str = &quot;hello, ruby&quot;
 =&gt; &quot;hello, ruby&quot;
 irb(main):012:0&gt; pushb str
 =&gt; [main]
 irb(hello, ruby):013:0&gt; reverse!
 =&gt; &quot;ybur ,olleh&quot;
||&lt;


そしてpopb(bindingをpop)で元のworkspaceに戻ります
popによって今いたworkspaceはなくなります
&gt;|zsh|
 irb(ybur ,olleh):014:0&gt; popb
 =&gt; []
 irb(main):015:0&gt; str
 =&gt; &quot;ybur ,olleh&quot;
||&lt;


セッションと異なり別のworkspaceに移るときには
新たなコンテキストを常に引数として渡す必要があります
プロンプトの表示がworkspaceでも目印になります


workspaceでは外側のローカル変数を共有します((内側のローカル変数はできないみたいです))
&gt;|zsh|
 irb(main):016:0&gt; str2 = &quot; world!!&quot;
 =&gt; &quot; world!!&quot;
 irb(main):017:0&gt; pushb str
 =&gt; [main]
 irb(ybur ,olleh):018:0&gt; str2
 =&gt; &quot; world!!&quot;
 irb(ybur ,olleh):019:0&gt; concat str2
 =&gt; &quot;ybur ,olleh world!!&quot;
 irb(ybur ,olleh world!!):020:0&gt; popb
 =&gt; []
 irb(main):021:0&gt; str
 =&gt; &quot;ybur ,olleh world!!&quot;
||&lt;
workspaceはスタックになっているので
セッションのようにジャンプして移動することができません
workspaceの使い道はよくわかりません


**HELP
Ruby Reference Manualを読みたいのならhelpします
空リターンで終了です
&gt;|zsh|
 irb(main):008:0&gt; help
 
 Enter the method name you want to look up.
 You can use tab to autocomplete.
 Enter a blank line to exit.
 
 &gt;&gt; String#reverse
 String#reverse
 
 (from ruby core)
 ---------------------------------------------
   str.reverse   -&gt; new_str
 ---------------------------------------------
 Returns a new string with the characters from str in reverse order.
 
   &quot;stressed&quot;.reverse   #=&gt; &quot;desserts&quot;
 
 &gt;&gt; Array#join
 Array#join
 
 (from ruby core)
 ---------------------------------------------
   ary.join(sep=$,)    -&gt; str
 ---------------------------------------------
 Returns a string created by converting each element of the array to a string,
 separated by sep.
 
   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join        #=&gt; &quot;abc&quot;
   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join(&quot;-&quot;)   #=&gt; &quot;a-b-c&quot;
 
 &gt;&gt; 
 =&gt; nil
 irb(main):009:0&gt; 
||&lt;


**.irbrcによるカスタマイズ
ホームディレクトリに配置した.irbrcに
設定を記述してIRBをカスタマイズできます
&gt;|ruby|
 require &quot;irb/completion&quot;
||&lt;
これでタブ補完が効くようになります


&gt;|ruby|
 require &quot;irb/ext/save-history&quot;
 IRB.conf[:SAVE_HISTORY] = 1000
||&lt;
これで入力コマンドの履歴が1000件分保存されます
保存先はデフォルトでホームディレクトリの.irb_historyです
Ctrl+P Ctrl+N で履歴を辿ります


&gt;|ruby|
 IRB.conf[:EVAL_HISTORY] = 100
||&lt;
これで実行結果の履歴を100件分覚えます


__(アンダースコア2つ)で一覧し
__[line_no]で取り出します
&gt;|zsh|
 irb(main):001:0&gt; 1 + 2
 =&gt; 3
 irb(main):002:0&gt; _ * 4
 =&gt; 12
 irb(main):003:0&gt; _ / 3
 =&gt; 4
 irb(main):004:0&gt; __  &lt;-- 結果の一覧表示
 =&gt; 1 3
 2 12
 3 4
 irb(main):005:0&gt; x = __[2]  &lt;---結果の取り出し
 =&gt; 12
 irb(main):006:0&gt; x
 =&gt; 12
||&lt;


&gt;|ruby|
 IRB.conf[:AUTO_INDENT] = true
||&lt;
これで構文に沿った自動インデントを可能にします


&gt;|zsh|
 irb(main):001:0&gt; def foo
 irb(main):002:1&gt;   :foo
 irb(main):003:1&gt;   end
 =&gt; nil
 irb(main):004:0&gt; 
||&lt;
残念ながらendまではうまく処理できません


プロンプトを変えたいなら
以下のようにします
&gt;|ruby|
 IRB.conf[:PROMPT][:MY_PROMPT] = {
   :PROMPT_I =&gt; &quot;%N(%m)&gt;&gt; &quot;,     # 通常時
   :PROMPT_N =&gt; &quot;|  &quot;,           # インデント時
   :PROMPT_C =&gt; &quot;.&gt; &quot;,           # 式継続時
   :PROMPT_S =&gt; &quot;%l&gt; &quot;,          # 文字継続行
   :RETURN   =&gt; &quot;=&gt; %s \n&quot;       # リターン時
 }
 
 IRB.conf[:PROMPT_MODE] = :MY_PROMPT
||&lt;
%N %m %lはそれぞれ
設定したirb名　コンテキスト　セパレータを表します


セッションごとにプロンプトを変えたいときは
IRB.conf[:IRB_RC]をセットします


例えば以下を.irbrcに追加します
&gt;|ruby|
 IRB.conf[:IRB_RC] = lambda do |conf|
   if conf.irb_name[/\d+/]
     context = &quot;%m(##{$&amp;})&quot;
     puts &quot;-- You are in #{conf.main} --&quot;
   end
   conf.prompt_i = &quot;#{context}&gt;&gt; &quot;
 end
||&lt;


以下のような表示になります
&gt;|zsh|
 &gt;&gt; :main =&gt; :main
 &gt;&gt; irb
 -- You are in main --
 main(#1)&gt;&gt; :main1 =&gt; :main1
 main(#1)&gt;&gt; irb Array
 -- You are in Array --
 Array(#2)&gt;&gt; :array =&gt; :array
 Array(#2)&gt;&gt; 
||&lt;
mainでは&gt;&gt;のみを表示し
サブセッションではコンテキスト名とセッション番号を表示します
サブセッションに入るときコンテキスト名をputsします


.irbrcはRubyのコードとしてirbに読み込まれますから
ここにメソッドなどを定義すれば
トップレベルのメソッドとして使えます
&gt;|ruby|
 def now
   puts Time.now.strftime(&quot;%Y/%m/%d(%a) %H:%M:%S&quot;)
 end
||&lt;


&gt;|zsh|
 &gt;&gt; now #=&gt; nil
 2010/11/16(Tue) 16:52:42
||&lt;


プロンプトを動的に変えたいときは
以下のようにします
&gt;|zsh|
 &gt;&gt; conf.prompt_i = &quot;&gt;&lt;&lt;&lt;&lt;@&gt; &quot; #=&gt; &quot;&gt;&lt;&lt;&lt;&lt;@&gt; &quot;
 &gt;&lt;&lt;&lt;&lt;@&gt; 1 + 2 #=&gt; 3
 &gt;&lt;&lt;&lt;&lt;@&gt; 
 &gt;&lt;&lt;&lt;&lt;@&gt; conf.prompt_mode = :DEFAULT #=&gt; :DEFAULT
irb(main):011:0&gt; 3 * 4 #=&gt; 12
irb(main):012:0&gt; 
||&lt;


しかし.irbrcにメソッドを定義すればもっと便利になります
&gt;|ruby|
 def prompt(type='')
   prmt = [:DEFAULT, :SIMPLE, :IRBTOOLS, :KEYES]
   case type.to_s
   when /^def/i then conf.prompt_mode = prmt[0]
   when /^sim/i then conf.prompt_mode = prmt[1]
   when /^irbt/i then conf.prompt_mode = prmt[2]
   when /^key/i then conf.prompt_mode = prmt[3]
   when /^$/ then conf.prompt_mode
   else STDERR.puts &quot;give one of them: #{prmt.map(&amp;:inspect).join(&quot; &quot;)}&quot;
   end
 end
||&lt;


&gt;|zsh|
 IRB on Ruby1.9.2
 &gt;&gt; prompt  #=&gt; :IRBTOOLS
 &gt;&gt; prompt :defo #=&gt; :DEFAULT
 irb(main):003:0&gt; prompt :SIMPLE #=&gt; :SIMPLE
 &gt;&gt; prompt :new #=&gt; nil
 give one of them: :DEFAULT :SIMPLE :IRBTOOLS :KEYES
 &gt;&gt; 
||&lt;


.irbrcはirb起動時に自動で読み込まれますが
fオプションでこれを無視できます
&gt;|zsh|
 irb -f
||&lt;


**拡張ライブラリ
irbを拡張する複数のライブラリがあります
しかしここでは最強の１つのライブラリを紹介します
それはirbtoolsライブラリです


**irbtoolsライブラリ
[http://rbjl.net/40-irbtools-release-the-power-of-irb:title=irbtools]はirbの主要拡張ライブラリを統合し
さらに細かい多数の機能を追加したライブラリです
gem install irbtoolsでインストールし
.irbrcでrequire 'irbtools'することで使えるようになります


irbtoolsには以下のライブラリが統合されています
wirble fancy_irb fileutils coderay clipboard 
zucker ap yaml g guessmethod interactive_editor
sketches boson hirb


特定のライブラリを外したい場合は.irbrcを以下のようにします
&gt;|ruby|
 #require 'irbtools'
 require &quot;irbtools/configure&quot;
 
 Irbtools.libraries -= %w(fileutils hirb)
 Irbtools.start
||&lt;


**色付けとロケットプロンプト
irbtoolsをrequireしてirbを起動すると
Ruby情報を含むwelcomeメッセージのあと
シンプルなプロンプトが現れます
戻り値はスペースが許す場合入力行の右に
色付けされて出力されます


[f:id:keyesberry:20101116212416p:image]
(クリックで拡大)

返り値が色付けされて右に来ることで
出力も見やすくなります
この機能はwirbleとfancy_irbライブラリによって実現されています((fancy_irbは出力の態様によって問題が出るときがあります))


**多様な出力形式
irbtoolsは多様な出力形式をサポートします


[f:id:keyesberry:20101116212417p:image]
(クリックで拡大)

oは現在の行　ファイル　メソッドを
cはコールスタックを出力します
yはyaml形式　gはgrowlへの出力をします
tableはデータを表形式で出力します
これらの出力形式はawesome_print zucker/debug yaml g hirb
などのライブラリによって実現されています


**コマンド群
irbtoolsによって便利なコマンド群が用意されています
まずls cat mkdir rm touch
その他のファイルユーティリティコマンドがあります
&gt;|zsh|
 &gt;&gt; ls
 =&gt; [&quot;console&quot;, &quot;iphone&quot;, &quot;irbtools.txt&quot;, &quot;lisr&quot;, &quot;lorem.txt&quot;, &quot;math.rb&quot;, &quot;twilog.txt&quot;, &quot;uni.rb&quot;, &quot;unicode.txt&quot;, &quot;user.db&quot;, &quot;user.rb&quot;]
 &gt;&gt; s = cat &quot;lorem.txt&quot;
 =&gt; &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis...&quot;
 &gt;&gt; pwd #=&gt; &quot;/Users/keyes/Dropbox/workspace&quot;
 &gt;&gt; 
||&lt;


Rubyファイルを表示する場合はCodeRayによるrayコマンドがいいです
引数で渡されたファイルがSyntax Highlightで表示されます((ファイルの読み込みは別途requireする必要があります))


[f:id:keyesberry:20101116212418p:image]


もっともCodeRayは本来HTMLを生成するものですから
その例を示したほうがいいですね


user.rbを読み込んでhtmlを生成します
&gt;|zsh|
 &gt;&gt; user_html = CodeRay.scan(cat(&quot;user.rb&quot;), :ruby).page
 =&gt; &quot;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;\n  &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;\n...
||&lt;
結果をuser.htmlファイルに書き込みます
&gt;|zsh|
 &gt;&gt; File.open('user.html','w') {|f| f.write user_html } #=&gt; 6366
||&lt;
ブラウザで見てみます
&gt;|zsh|
 &gt;&gt; system('open', 'user.html') #=&gt; true
 &gt;&gt; 
||&lt;
[f:id:keyesberry:20101117191617p:image]
いいですね


クリップボードとやり取りするための
copy paste copy_inputがあります
copy_inputはirbの全セッションをコピーします
&gt;|zsh|
 &gt;&gt; site = paste #=&gt; &quot;http://d.hatena.ne.jp/keyesberry/&quot;
 &gt;&gt; copy Math::PI #=&gt; &quot;3.141592653589793&quot;
 &gt;&gt; copy_input  #=&gt; &quot;The session input history has been copied to the clipboard.&quot;
 &gt;&gt; 
||&lt;


requireとloadのショートカットrqとld
requireし直すrerequireがあります
&gt;|zsh|
 &gt;&gt; rq:mathn #=&gt; true
 &gt;&gt; rq:'open-uri' #=&gt; true
 &gt;&gt; ld:json #=&gt; true
||&lt;


入力履歴を出力するsession_history
irbにログインし直すreset!
画面をフラッシュするclearがあります
&gt;|zsh|
 &gt;&gt; Math::PI #=&gt; 3.141592653589793
 &gt;&gt; puts 'helo' #=&gt; nil
 helo
 &gt;&gt; 1 + 3 #=&gt; 4
 &gt;&gt; %w(apple grape orange) #=&gt; [&quot;apple&quot;, &quot;grape&quot;, &quot;orange&quot;]
 &gt;&gt; session_history 4 #=&gt; &quot;puts 'helo'\n1 + 3\n%w(apple grape orange)&quot;
 &gt;&gt; reset!
 IRB on Ruby1.9.2
 &gt;&gt; clear
||&lt;


OSやRubyのバージョンを調べる
OS RubyEngine RubyVersionがあります
&gt;|zsh|
 &gt;&gt; OS #=&gt; darwin8
 &gt;&gt; RubyEngine  #=&gt; mri
 &gt;&gt; RE #=&gt; mri
 &gt;&gt; RubyVersion  #=&gt; 1.9.2
 &gt;&gt; RV #=&gt; 1.9.2
 &gt;&gt; 
 &gt;&gt; OS.windows? #=&gt; false
 &gt;&gt; OS.linux? #=&gt; false
 &gt;&gt; OS.mac? #=&gt; true
 &gt;&gt; RE.jruby? #=&gt; false
 &gt;&gt; RE.rubinius? #=&gt; false
||&lt;

これらの機能はzucker Clipboardライブラリで実現されます


**エディタ支援
irbからエディタを呼び出し
そこで編集した内容をirb上に返す機能があります
vi vim emacs mate ed((環境変数$EDITORにセットしたエディタが起動します))などのコマンドで
エディタが起動し一時ファイルを開きます
編集後エディタを閉じればirb内でそのコードを利用できます


同じセッションで同じコマンドを使えば
同じ一時ファイルが開いて再編集ができるようになります
コマンドに特定のファイルを渡すこともできます
これはInteractive_editorライブラリにより実現されています


同じような目的でSketchesライブラリがあります
こちらはエディタを閉じることなく
内容をirbに反映させることができます


.irbrcでsketchesで使用するエディタをセットします

&gt;|ruby|
 Sketches.config :editor =&gt; 'mate', :background =&gt; true
||&lt;
上記設定をしない場合は
環境変数$EDITORが参照されます


skecthコマンドで指定エディタが起動します
エディタを閉じずに内容を保存します
これでirbにコードが反映されます
名前付きスケッチも作れます
sketchesでスケッチの一覧を表示します
save_sketchでスケッチをファイルに保存することもできます

&gt;|zsh|
 IRB on Ruby1.9.2
 &gt;&gt; sketch #=&gt; nil
 &gt;&gt; fact 20 #=&gt; 2432902008176640000
 &gt;&gt; sketch :fib #=&gt; nil
 &gt;&gt; fib 20 #=&gt; 6765
 &gt;&gt; sketches #=&gt; nil
 #1
 
   def fact(n)
     (1..n).inject(:*)
   end  ...
 #2: fib
   def fib(n)
     [0,1].include?(n) ? n : fib(n-1) + fib(n-2)
   end
   ...
 &gt;&gt; name_sketch 1, :fact #=&gt; nil
 &gt;&gt; save_sketch :fib, &quot;fib.rb&quot; #=&gt; nil
 &gt;&gt; 
||&lt;


**コマンドの登録
bosonライブラリを使うことによって
効率的にコマンドを登録管理できます
どんなbosonコマンドがあるか確認するには
commandsコマンドを使います

&gt;|
 &gt;&gt; commands  #=&gt; true
 +--------------+----------+--------+------------+
 | full_name    | lib      | usage  | description|
 +--------------+----------+--------+------------+
 | render       | core     | [object| Render any |
 | menu         | core     | [arr] [| Provide a m|
 | usage        | core     | [comman| Print a com|
 | commands     | core     | [query=| List or sea|
 | libraries    | core     | [query=| List or sea|
 | load_library | core     | [librar| Load a libr|
 | get          | web_core | [url] [| Gets the bo|
 | post         | web_core | [url] [| Posts to a |
 | build_url    | web_core | [url] [| Builds a ur|
 | browser      | web_core | [*urls]| Opens urls |
 | install      | web_core | [url][-| Installs a |
 +--------------+----------+--------+------------+
 11 rows in set
 &gt;&gt; 
|&lt;
テーブルはターミナルの幅に合わせてtruncateされます((ブログ掲載のため項目を削っています))


irbではそのままコマンドを使えます
&gt;|zsh|
 &gt;&gt; site = get &quot;http://d.hatena.ne.jp/&quot;
 =&gt; &quot;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\r\n&lt;html&gt;\r\n&lt;head&gt;\r\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=euc-jp&quot;&gt;\n&lt;meta http-equiv=&quot;Content-Style-Type&quot;
||&lt;


独自のコマンドを追加してみましょう
bosonのインストールでできた~/.boson/commandsディレクトリに
以下のようなRubyモジュールを作ります
&gt;|zsh|
 vi .boson/commands/mymath.rb
||&lt;
&gt;|ruby|
 module MyMath
   #calculate fibonacci
   def fib(n)
     n = Integer(n)
     [0, 1].include?(n) ? n : fib(n-1) + fib(n-2)
   rescue
     only_positive_error_msg
   end
 
   #calculate factorial
   def fact(n)
     n = Integer(n)
     raise if n &lt;= 0
     n == 1 ? 1 : n * fact(n-1)
   rescue
     only_positive_error_msg
   end
 
   private
   def only_positive_error_msg
     STDERR.puts &quot;Only accept POSITIVE integer!&quot;
   end
 end
||&lt;


再度コマンド一覧を見ます
&gt;|zsh|
 &gt;&gt; commands 
 +--------------+----------+--------+------------+
 | full_name    | lib      | usage  | description|
 +--------------+----------+--------+------------+
 | render       | core     | [object| Render any |
 | menu         | core     | [arr] [| Provide a m|
 | usage        | core     | [comman| Print a com|
 | commands     | core     | [query=| List or sea|
 | libraries    | core     | [query=| List or sea|
 | load_library | core     | [librar| Load a libr|
 | get          | web_core | [url] [| Gets the bo|
 | post         | web_core | [url] [| Posts to a |
 | build_url    | web_core | [url] [| Builds a ur|
 | browser      | web_core | [*urls]| Opens urls |
 | install      | web_core | [url][-| Installs a |
 | fib          | mymath   | [n]    | calculate f|
 | fact         | mymath   | [n]    | calculate f|
 +--------------+----------+--------+------------+
 13 rows in set
 &gt;&gt; 
||&lt;
mymathライブラリの２つのコマンドが追加されています


実行してみましょう
&gt;|zsh|
 &gt;&gt; fib 10 #=&gt; 55
 &gt;&gt; fact 15 #=&gt; 1307674368000
 &gt;&gt; fib :hello #=&gt; nil
 Only accept POSITIVE integer!
 &gt;&gt; fact 'hi' #=&gt; nil
 Only accept POSITIVE integer!
 &gt;&gt; 
||&lt;


bosonの優れたところは
これらのコマンドをShellでも使える点にあります
shellではbosonを前置してコマンドを実行します
&gt;|zsh|
 &gt;&gt; exit
 % boson fib 10
 55
 % boson fact 15
 1307674368000
 % boson fib :hello
 Only accept POSITIVE integer!
 % boson fact 'hi'
 Only accept POSITIVE integer!
 % 
||&lt;


**テーブル／ツリー出力
先にも書きましたがtableコマンドは
データを表形式で出力します
これはデータベースと共に使うと更に便利です
先に出てきたUserDBにhomepageのpropertyを追加して表示します

&gt;|zsh|
 IRB on Ruby1.9.2
 &gt;&gt; rq:user #=&gt; true
 &gt;&gt; User.all
 =&gt; [#&lt;User @id=1 @nickname=&quot;Charlie&quot; @email=&quot;charlie@abc.com&quot; @homepage=&quot;http://www.nintendo.com&quot;&gt;, #&lt;User @id=2 @nickname=&quot;Tommy&quot; @email=&quot;tommy@abc.com&quot; @homepage=&quot;http://twitter.com/merborne/&quot;&gt;, #&lt;User @id=3 @nickname=&quot;Alice&quot; @email=&quot;alice@xyz.com&quot; @homepage=&quot;http://d.hatena.ne.jp/keyesberry/&quot;&gt;]
||&lt;


これをtable表示します
&gt;|zsh|
&gt;&gt; table User.all #=&gt; true
+----+----------+-----------------+----------------+
| id | nickname | email           | homepage       |
+----+----------+-----------------+----------------+
| 1  | Charlie  | charlie@abc.com | http://www.nin |
| 2  | Tommy    | tommy@abc.com   | http://twitter |
| 3  | Alice    | alice@xyz.com   | http://d.haten |
+----+----------+-----------------+----------------+
3 rows in set
||&lt;


条件で絞り込みます
&gt;|zsh|
 &gt;&gt; table User.all(:email.like=&gt;&quot;%@abc.com&quot;) #=&gt; true
 +----+----------+-----------------+---------------+
 | id | nickname | email           | homepage      |
 +----+----------+-----------------+---------------+
 | 1  | Charlie  | charlie@abc.com | http://www.nin|
 | 2  | Tommy    | tommy@abc.com   | http://twitter|
 +----+----------+-----------------+---------------+
 2 rows in set
 &gt;&gt; 
||&lt;


menuというコマンドを使うと表から値を抽出できます
以下の例ではTommyとAliceのhomepageを抽出して
それをbrowserコマンドに渡して開いています

&gt;|zsh|
 &gt;&gt; choices = menu User.all, :fields=&gt;[:nickname, :homepage], :two_d=&gt;true
 +--------+----------+----------------------------+
 | number | nickname | homepage                   |
 +--------+----------+----------------------------+
 | 1      | Charlie  | http://www.nintendo.com    |
 | 2      | Tommy    | http://twitter.com/merborn |
 | 3      | Alice    | http://d.hatena.ne.jp/keye |
 +--------+----------+----------------------------+
 3 rows in set
 Specify individual choices (4,7), range of choices (1-3) or all choices (*).
 Default field: nickname
 Choose: 2,3:h
 =&gt; [&quot;http://twitter.com/merborne/&quot;, &quot;http://d.hatena.ne.jp/keyesberry/&quot;]
 &gt;&gt; browser *choices #=&gt; true
 &gt;&gt; 
||&lt;


ツリー表示を実現するviewというコマンドもあります
Rubyのクラスツリーを作ってみます
&gt;|zsh|
 &gt;&gt; class_tree = [[0,:Object],[1,:Array],[1,:Binding],[1,:Continuation],[1,:Data],[1,:Dir],[1,:Hash],[1,:IO],[2,:File],[2,:BasicSocket],[3,:IPSocket],[3,:UNIXSocket],[3,:Socket],[4,:TCPSocket],[4,:UDPSocket],[4,:UNIXServer],[5,:TCPServer],[1,:MatchData],[1,:Method],[1,:Module],[2,:Class],[1,:Numeric],[2,:Float],[2,:Integer],[3,:Bignum],[3,:Fixnum],[1,:Proc],[1,:Range],[1,:Regexp],[1,:String],[1,:Struct],[1,:Symbol],[1,:Thread],[1,:ThreadGroup],[1,:Time]]
 =&gt; [[0, :Object], [1, :Array], [1, :Binding], [1, :Continuation], [1, :Data], [1, :Dir], [1, :Hash], [1, :IO], [2, :File], [2, :BasicSocket], [3, :IPSocket], [3, :UNIXSocket], [3, :Socket], [4, :TCPSocket], [4, :UDPSocket], [4, :UNIXServer], [5, :TCPServer], [1, :MatchData], [1, :Method], [1, :Module], [2, :Class], [1, :Numeric], [2, :Float], [2, :Integer], [3, :Bignum], [3, :Fixnum], [1, :Proc], [1, :Range], [1, :Regexp], [1, :String], [1, :Struct], [1, :Symbol], [1, :Thread], [1, :ThreadGroup], [1, :Time]]
 &gt;&gt; view class_tree, :class=&gt;:tree, :type=&gt;:directory #=&gt; true
 Object
 |-- Array|-- Binding|-- Continuation
 |-- Data
 |-- Dir
 |-- Hash
 |-- IO
 |   |-- File
 |   `-- BasicSocket
 |       |-- IPSocket
 |       |-- UNIXSocket
 |       `-- Socket
 |           |-- TCPSocket
 |           |-- UDPSocket
 |           `-- UNIXServer
 |               `-- TCPServer
 |-- MatchData
 |-- Method
 |-- Module
 |   `-- Class
 |-- Numeric
 |   |-- Float
 |   `-- Integer
 |       |-- Bignum
 |       `-- Fixnum
 |-- Proc
 |-- Range
 |-- Regexp
 |-- String
 |-- Struct
 |-- Symbol
 |-- Thread
 |-- ThreadGroup
 `-- Time
 &gt;&gt; 
||&lt;

これらはHirbというライブラリで実現しますが
このライブラリは奥が深そうです


[http://tagaholic.me/2009/03/18/ruby-class-trees-rails-plugin-trees-with-hirb.html:title=Tagaholic - Ruby Class and Rails Plugin Trees With Hirb]


**irbtoolsにおける若干のカスタマイズ
プロンプトの形と出力の色は
以下のようにしてカスタマイズできます
&gt;|ruby|
 #require 'irbtools'
 require &quot;irbtools/configure&quot;
 Irbtools.libraries -= %w(fancy_irb)
 Irbtools.start
 
 require &quot;fancy_irb&quot;
 FancyIrb.start(
  :rocket_prompt   =&gt; '&gt;&lt;&lt;&lt;&lt;@&gt; ',
 # :result_prompt   =&gt; '=&gt; ',
  :colorize =&gt; {             
    :rocket_prompt =&gt; :yellow,
 #   :result_prompt =&gt; :blue,
 #   :input_prompt  =&gt; nil,
 #   :irb_errors    =&gt; :red,
 #   :stderr        =&gt; :light_red,
    :stdout        =&gt; :cyan,
 #   :input         =&gt; nil,
 #   :output        =&gt; true,
  }
 )
||&lt;
fancy_irbをirbtoolsから外し独立してrequireします
FancyIrb.startの引数に自分の設定を渡します((もしかしたらもう少しスマートなやり方があるかも知れません))


[f:id:keyesberry:20101116212419p:image]


welcomeメッセージを変えることもできます
&gt;|ruby|
 #require 'irbtools'
 require &quot;irbtools/configure&quot;
 Irbtools.welcome_message = &quot;IRB on Ruby#{ RUBY_VERSION }&quot;
 Irbtools.start
||&lt;

irbtoolsライブラリを入れることで
irbはかなり強力なものになります
是非とも試してみてください


非常に長くなりました
最後までお付き合いありがとうございます！


**参考URLs
[http://doc.okkez.net/192/view/library/irb:title=library irb]


[http://rbjl.net/40-irbtools-release-the-power-of-irb:title=irbtools / Release the power of irb!] 
[http://pablotron.org/software/wirble/:title=Pablotron: Wirble] 
[https://github.com/janlelis/fancy_irb:title=janlelis's fancy_irb at master - GitHub] 
[http://coderay.rubychan.de/:title=CodeRay] 
[http://rubyzucker.info/:title=Ruby Zucker 8] 
[https://github.com/michaeldv/awesome_print:title=michaeldv's awesome_print at master - GitHub] 
[https://github.com/jugyo/g:title=jugyo's g at master - GitHub] 
[https://github.com/jberkel/interactive_editor:title=jberkel's interactive_editor at master - GitHub] 
[http://sketches.rubyforge.org/:title=Sketches - About] 
[http://tagaholic.me/2009/10/14/boson-command-your-ruby-universe.html:title=Boson - Command Your Ruby Universe] 
[http://tagaholic.me/2009/03/13/hirb-irb-on-the-good-stuff.html:title=Hirb - Irb On The Good Stuff] 


(追記：2010-11-17) CodeRayのHTML出力について記述を追加しました
(追記：2010-11-18) CodeRayの記述の間違いを修正しました
(追記：2010-11-20) .irbrcへのメソッド定義についての記述を追加しました

</body>
</day>
<day date="2010-11-27" title="">
<body>
*p1*キー配列を最適化してプログラミングの生産性を倍にしよう！　OSX限定
現代のキーボードの配列は
アルファベットを中心にしたQWERTYが主流です
これは1882年に完成されたそうです((http://ja.wikipedia.org/wiki/QWERTY配列))
もちろんコンピュータが生まれる以前です


一方プログラミングでは
アルファベット以外の記号を頻繁に打鍵します
例えばRubyでは _ = - + : [ { ( . ? ' &quot;
などの記号の使用頻度はとても高いです
ところがUSキーボードを使っている場合
上記のうち : [ { . ? ' &quot; は良いですが
_ = - + ( が最上段に位置していて
タッチタイピングしづらいです


[http://en.wikipedia.org/wiki/File:Apple_iMac_Keyboard_A1242.JPG:title=US Keyboard]


これはプログラムの生産性に大きく影響しそうです
なぜならこれらのキー入力が出現するたびに
目視でその位置を確認するか当て推量で外すかして
それによって入力のリズムが崩れてしまうからです


つまりこれらのキーの配列を
ホームポジションで所掌できる範囲内に収めることができれば
プログラムの生産性は飛躍的に向上すると思われます((それ以前の問題がいろいろとありますが..))


きっと...


そんなわけで
ここでは自分が取っているキー配列とその実現方法を書きます
環境はMac OS X Tiger + Apple keyboard(US)です
なおMacVimとTextMateとTerminalでこれらのキーバインドを
使えるようになることが前提となっています


まだTigerかよ！というツッコミは無視して..


**USキーボードを使う
USキーボードはJISに比べて美しく使いやすいです
しかしCtrlキーが最下段で使いづらいという点と
IMEの切換えが不便という欠点があります
以下によりこれを解決・緩和します


-Caps LockキーにCtrlキーを割り当てる
これは
[システム環境設定-&gt;キーボードとマウス-&gt;キーボード-&gt;修飾キー]
と辿って設定変更できます
-IMEのon/offをCtrl+Jに割り当てる
これは同じく
[キーボードとマウス-&gt;キーボードショートカット]と辿って
入力メニューにおける[前の入力ソースを選択する]のショートカットを
Ctrl+Jにすることで変更できます


**_と;を入れ替える
Rubyではアンダースコアを頻繁に打つ一方で
セミコロンはほとんど使わないのでこれらを入れ替えます


HOMEディレクトリ下にある
DefaultKeybindig.dictに以下を追記します
ファイルがなければ作成します
~/Library/KeyBindings/DefaultKeybinding.dict
&gt;|applescript|
{
	/* customize single stroke key */
    &quot;;&quot;  =	(&quot;insertText:&quot;, &quot;_&quot;);     
    &quot;_&quot;  =	(&quot;insertText:&quot;, &quot;;&quot;);     
}
||&lt;

これで右小指をそのまま打つだけで
アンダースコアが打てるようになるので
Rubyでコードを書く場合は非常に便利です


**KeyRemap4MacBookを使う
Macにおけるキー配列の変更になくてはならないツールです


[http://pqrs.org/macosx/keyremap4macbook/source.html.ja:title=KeyRemap4MacBook]


-シフトキーをスペースキーに割り当てる
[Remap Space Key]の[Space to Shift_L (+ When you type Space only, send Space)]にチェックを入れます


これによって
スペースキーがシフトキーのModifierとしての役割をします
つまりスペースを押しながら
アルファベットを押せば大文字になります
一方でスペースキーを単独で押したときは
元通りにスペースを入力します
これに慣れるとアルファベットの位置に応じて
左シフトを押したり右シフトを押したりしていた煩わしさが
何だったのかと感じるようになります


-=(equal) -(minus) +(plus) ( (round bracket)の移動
これらのキーの設定は以下の通りです
+Ctrl+;で=
+Ctrl+'で-
+Ctrl+Shift+'で+
+Ctrl+Shift+iで(
+Ctrl+Shift+oで)


KeyRemap4MacBookではちょっと手数を要しますが
未定義のキーバインドを定義することができます((このことはTwitterで@splhackさんに教えて頂きました))
上記のキーについてはこれを利用します
なおこれらの設定は上記のDefaultKeybinding.dictでもできますが
MacVimではそれが反映されなかったためこちらを利用します


詳細は本家に譲りますが概略をここに書いておきます
基本はソースを取得し定義ファイルを書き換えて再ビルドします
なおSnow Leopard向けヴァージョンでは
ソースのビルドをすることなく
設定の変更ができるようになっているようです


まずソースを取得して
その中のfiles/prefpane/checkbox.xmlの最後に
以下の項目を追加します((正確には&lt;/list&gt;&lt;/root&gt;の直前です))

&gt;|xml|
 &lt;item&gt;
   &lt;name&gt;My Custom Keys&lt;/name&gt;
   &lt;list&gt;
     &lt;item&gt;
       &lt;name&gt;Remap Ctrl+Semicolon to Equal&lt;/name&gt;
       &lt;sysctl&gt;remap.ctrlsemicolon2equal&lt;/sysctl&gt;
       &lt;autogen&gt;--KeyToKey-- KeyCode::SEMICOLON, VK_CONTROL, KeyCode::EQUAL&lt;/autogen&gt;
     &lt;/item&gt;
     &lt;item&gt;
       &lt;name&gt;Remap Ctrl+Shift+Quote to Plus&lt;/name&gt;
       &lt;sysctl&gt;remap.ctrlshiftquote2plus&lt;/sysctl&gt;
       &lt;autogen&gt;--KeyToKey-- KeyCode::QUOTE, VK_CONTROL | ModifierFlag::SHIFT_L, KeyCode::KEYPAD_PLUS&lt;/autogen&gt;
     &lt;/item&gt;
     &lt;item&gt;
       &lt;name&gt;Remap Ctrl+Quote to Minus&lt;/name&gt;
       &lt;sysctl&gt;remap.ctrlquote2minus&lt;/sysctl&gt;
       &lt;autogen&gt;--KeyToKey-- KeyCode::QUOTE, VK_CONTROL, KeyCode::MINUS&lt;/autogen&gt;
     &lt;/item&gt;
     &lt;item&gt;
       &lt;name&gt;Remap Ctrl+Shift+i_and_o to RoundBracket&lt;/name&gt;
       &lt;sysctl&gt;remap.ctrlshiftsquarebracket2roundbracket&lt;/sysctl&gt;
       &lt;autogen&gt;--KeyToKey-- KeyCode::I, VK_CONTROL | ModifierFlag::SHIFT_L, KeyCode::KEY_9, ModifierFlag::SHIFT_L&lt;/autogen&gt;
       &lt;autogen&gt;--KeyToKey-- KeyCode::O, VK_CONTROL | ModifierFlag::SHIFT_L, KeyCode::KEY_0, ModifierFlag::SHIFT_L&lt;/autogen&gt;
     &lt;/item&gt;
   &lt;/list&gt;
 &lt;/item&gt;
||&lt;


+My Custom Keysはグルーピングの名前です
+各itemにはname, sysctl, autogenの項目があってautogenでキーの割り当てを定義します
+修飾キーがある場合はKeyCodeの後にカンマで区切って書きます
+修飾キーが複数ある場合は | で繋ぎます
+KeyCodeの定義名は src/core/kext/keycode.hppで定義されています
+１つのitemに複数のautogenを定義できます
+itemのname項目はパネルにおける各表題名になります
+itemのsysctlはよくわかりませんが内部関数名か何かになると思います
+VK_CONTROLとModifierFlag::CONTROL_Lの使い分けはよくわかりません


本家の[設定の追加方法]の手順に従ってビルド・パッケージ化して
アプリケーションを再インストールします


自分は定義ファイルを何度も書き換えてビルドを繰り返していたので
以下のようなRubyスクリプトを用意してバッチ処理していました

keyremap_pkg.rb
&gt;|ruby|
#!/opt/local/bin/ruby1.9
#-*-encoding: utf-8-*-
# Build KeyRemap4MacBook pkg
def keyremap_pkg
  root = Dir.pwd

  Dir.chdir(root+&quot;/src/core/kext&quot;)
  if system(&quot;make&quot;) &amp;&amp; system(&quot;make reload&quot;)
    Dir.chdir(root+ &quot;/files/prefpane&quot;)
    if system(&quot;make install&quot;)
      Dir.chdir(root)
      system(&quot;make&quot;)
      system(&quot;open #{Dir[&quot;KeyRemap4MacBook*.pkg&quot;][0]}&quot;)
    end
  end
end
keyremap_pkg
||&lt;

このファイルをダウンロードしたソースのルートに配置し
以下を実行すればパッケージのインストール手前まで完了します

&gt;|zsh|
sudo ruby keyremap_pkg.rb
||&lt;

パッケージのインストール後に再起動が必要になります


以上により次のようなキー配列が得られます
+;で_
+CapsLock+;で=
+CapsLock+'で-
+CapsLock+Space+'で+
+CapsLock+Space+iで(
+CapsLock+Space+oで)


その結果
Rubyで良く使う _ = - + : [ { ( . ? ' &quot;
のキーはタッチタイプできるエリア内に収まりました


これで明日からは生産性が倍になりますね！
きっと...


なお実はアンダースコアとセミコロンの入れ替えも
KeyRemap4MacBookで実現したかったのですが
2つのキーを入れ替えるという方法がわからなかったので
DefaultKeybinding.dictのほうでこれを実現しました
分かる方がいましたら教えてください


(追記：2010-11-28)iTermではCapsLock+Space+'が動きません。一方でどこで設定されているのか、iTermに限らずCapsLock+Space+;で+が入力できるようになっています。そのため自分の環境ではRemap Ctrl+Shift+Quote to Plusの設定は不要かも知れません。
(追記：2010-11-29)Ctrl+Shift+[はTextMate上のkeybindとconflictしていたため、round bracketの設定先をCtrl+Shift+iおよびoに変えました。

[関連記事]
[http://d.hatena.ne.jp/keyesberry/20070312/p4:title=hp12c Macのキーバインドをいじる]
[http://d.hatena.ne.jp/keyesberry/20070313/p2:title=hp12c オートペアリングをキーバインドしようよ]
[http://d.hatena.ne.jp/keyesberry/20070313/p3:title=hp12c グリフをキーバインドしようよ]

</body>
</day>
<day date="2010-12-02" title="">
<body>
*p1*Rubyでcalをカラフルに
世界はすっかりＧＵＩに支配されました
コンピュータといったらWindowシステムのことです
人々を魅了したのはその操作性だけではありません
人々はそのカラフルな世界に魅了されたのです


確かにCUIの世界には色はありません
辛うじて環境変数LSCOLORSをセットして
色の付いたファイル名を眺めるだけの
暗くて地味な
そしてそれを使う人を孤独にさせる世界です


しかしそんな世界に[http://termtter.org/:title=Termtter]が登場しました
TermtterはANSIカラーを引き連れて
CUIの世界に一条の光を差しました
まるでＧＢ末期に登場したポケモンの如くに！((よく知りませんけど))


それ以来　&lt;del datetime=&quot;2010-12-02T22:19:40+09:00&quot;&gt;僕の中&lt;/del&gt;ちまたでは
ターミナルのカラー化が流行しています


[http://d.hatena.ne.jp/keyesberry/20101107/p1:title][http://d.hatena.ne.jp/keyesberry/20101107/p1:bookmark] 


どこかで誰かが叫ぶ声が聞こえます
ターミナルにもっと色を！
ターミナルにもっと色を！



そんなわけで..


calを色付けして出力するCalourを作りました
多分Reinventing the Wheelでしょうけれども..


Ruby1.9にのみ対応しています
色付けにはTermColorライブラリを使っています


**使い方
添付ファイルをダウンロードして
そのなかの/bin/cal.rbを実行します

&gt;|ruby|
% ruby cal.rb
||&lt;


引数無しで当月のカレンダーを表示します
今日の日付には反転した色が付きます


[f:id:keyesberry:20101202215308p:image]


月と年でその年月のものを
月のみで本年のその月を
年のみで年間カレンダーを表示します
&gt;|ruby|
% ruby cal.rb 3 2011
% ruby cal.rb 2050 9
% ruby cal.rb 5
% ruby cal.rb 1600
||&lt;


[f:id:keyesberry:20101202215257p:image]

[f:id:keyesberry:20101202215258p:image]


cal.rbの中身は以下のようになっています
&gt;|ruby|
#!/usr/bin/env ruby
#-*-encoding: utf-8-*-
require_relative &quot;../lib/calour&quot;

puts Calour.new.cal *ARGV.map(&amp;:to_i)
||&lt;


Calourクラスのオブジェクトを生成して
唯一のパブリックメソッドcalを呼ぶことで
色付きカレンダーの文字列を出力します


**色の指定
オブジェクトの生成時に引数でカラーを指定できます

&gt;|ruby|
Calour.new( title: [:magenta, :yellow],
            today: :cyan,
            saturday: :blue,
            sunday: :red )
||&lt;


[f:id:keyesberry:20101202215259p:image]


titleの２つの引数はそれぞれ
タイトルにおける月と年のカラーです
デフォルトのカラーは以下の通りです
&gt;|ruby|
  :title =&gt;  [:green,:yellow]
  :today =&gt;  :green
  :saturday =&gt;  :cyan
  :sunday =&gt;  :magenta
  :holiday =&gt;  :red
||&lt;


**祭日の色付け
holiday_optオプションを指定することで
祭日の色付けをすることができます
&gt;|ruby|
Calour.new(holiday_opt: {country: :ja_ja})
||&lt;


[f:id:keyesberry:20101202215301p:image]


祭日データは[http://code.google.com/apis/calendar/:title=Google Calendar Data API]から取得しています


verboseオプションをtrueにすれば祭日名を同時に表示します

&gt;|ruby|
Calour.new(holiday_opt {country: :ja_ja, verbose:true})
||&lt;


[f:id:keyesberry:20101202215302p:image]

[f:id:keyesberry:20101202215303p:image]


countryオプションは現在 ja_ja(日本語表記) ja(英語表記) us
au(australian) cn(china) fr(french) de(german) it(italian)
kr(south_korea) tw(taiwan) gb(uk) に対応しています
holiday_optはデフォルトではoffになっています

[f:id:keyesberry:20101202215304p:image]


**irbやTermtterで使う
irbやTermtterで使う場合は以下の記事の中で紹介した
bosonライブラリを介すると便利です


[http://d.hatena.ne.jp/keyesberry/20101116/p1:title=IRB　それはRubyistの魔法のランプ - hp12c] 


~/.boson/commandsディレクトリに
以下のようなRubyモジュールを作ります
&gt;|ruby|
 vi .boson/commands/mysystem.rb
||&lt;


&gt;|ruby|
autoload :Calour, 'calour'

module MySystem

  # colorized calendar
  def cal(*args)
    puts Calour.new(holiday_opt: {country: :ja_ja, verbose:true}).cal(*args.map(&amp;:to_i))
    puts
  end
end
||&lt;


そうすればirb上でcalコマンドで使えます

[f:id:keyesberry:20101202215305p:image]


shell上ではbosonコマンドを前置します

&gt;|ruby|
% boson cal
||&lt;


Termtterで使う場合はこのaliasを作れば便利です
aliasの作成は~/.termtter/configで以下のようにします
&gt;|ruby|
config.plugins.alias.aliases = {
    :cal =&gt; '! boson cal'
}
||&lt;


[f:id:keyesberry:20101202215307p:image]


**制限
Ruby1.9のみの対応です
内部でシステムのcalコマンドを呼んでいます
それが無いシステムでは動作しません
OSX Tigerでしか動作確認していません
他のシステムで動作するかわかりません
無責任無保証です


使ってくれる人がいたらうれしいです


[https://github.com/melborne/calour:title=melborne's calour at master - GitHub] 

</body>
</day>
<day date="2011-01-20" title="">
<body>
*p1*Rubyの末尾再帰最適化を理解する
RubyではSchemeなどとは異なって
末尾再帰の最適化を勝手にしてはくれません


[http://d.hatena.ne.jp/keyesberry/20090318/p1:title=再帰は再帰なんかじゃない！末尾再帰こそが真の再帰なんだ！][http://d.hatena.ne.jp/keyesberry/20090318/p1:bookmark] 


でもid:athosさんが
Rubyで末尾再帰最適化を実現するコードを書いてくれました


[http://d.hatena.ne.jp/athos/20110119/p1:title][http://d.hatena.ne.jp/athos/20110119/p1:bookmark] 


自分の実力だと一見しただけでは何をしているか理解できなかったので
少し自分用にコードを整理してその処理を追ってみます


&gt;|ruby|
 class Module
   def tco(meth)
     called = false
     tmp = nil
 
     orig_meth = &quot;orig_#{meth}&quot;
     alias_method orig_meth, meth
     private orig_meth
 
     define_method(meth) do |*args|
       unless called
         called = true
         args = tmp until result = send(orig_meth, *args)
         result
       else
         tmp = args
         false
       end
     end
   end
 end

 class Sum
   def sum1(n, acc=0)
     return acc if n == 0
     sum1(n-1, acc+n)
   end
 
   def sum2(n, acc=0)
     return acc if n == 0
     sum2(n-1, acc+n)
   end
   tco :sum2
 end
 
 s = Sum.new
 s.sum2(100000) # =&gt; 5000050000
 s.sum1(100000) # =&gt; 
 # ~&gt; -:25: stack level too deep (SystemStackError)
||&lt;


tcoクラスメソッドに対象のメソッドを渡せばその最適化がなされます
tcoメソッドでは具体的には以下の処理をしています


+元メソッド(sum2)の別名(orig_sum2)を定義する(alias_method)
+元メソッド名を持った新メソッドを定義する(define_method)
+新メソッドにおいて別名定義した元メソッドを反復的に呼び出す


これによってsum2が呼ばれると以下の処理がなされます
+新メソッドが呼ばれ、その中で元メソッドが呼ばれる(unless節)
+元メソッドの呼び出しは、その引数nが0(resultが有意な値)になるまでここで反復的に繰り返される
+元メソッドの再度の呼び出しにより、今度は新メソッドのelse節が実行される(called=true)
+ここでその引数argsが次の元メソッドの反復呼び出しに渡されるよう保持する
+元メソッドの呼び出しにおいて引数nが0になると、accが返りresultに渡される
+これによってuntilループを抜けて、このメソッドの返り値としてresultが得られることとなる


なるほど！

</body>
</day>
<day date="2011-01-24" title="">
<body>
*p1*Rubyを使って「なぜ関数プログラミングは重要か」を解読しよう！
「Why Functional Programming Matters:なぜ関数プログラミングは重要か」(原著者：John Huges 邦訳：山下伸夫)という論文があります


[http://www.sampou.org/haskell/article/whyfp.html:title][http://www.sampou.org/haskell/article/whyfp.html:bookmark] 


これはMirandaという関数型言語を使って
プログラマにとって
関数プログラミングがいかに重要であるかを論証したものです
これが書かれてからの年数((1984年))と被ブクマ数を見れば
極めて有益でmust_readであることは明らかでしょうが
自分にとっては高度な内容で読み解くのにかなり苦労しています


リストを使った関数の貼り合せ(3.の前半)までについて
Rubyでこれに近いことを記述し
自分の解釈でその骨子を説明してみました
関数プログラミングの妙味と
Rubyの記述も簡潔でパワフルであるということを示せればと思います
きっと理解不足による間違いが含まれていると思いますが..


**なぜ関数プログラミングは重要か
モジュール化設計がプログラミングを成功させる鍵である
見過ごされがちだがプログラミング言語において
コードを自由にモジュール化するためには
それらを結合する糊が極めて重要な役割を担う
プログラマの目標は小さく　簡潔で　汎用的なモジュールを
貼り合せてプログラムを構成することにある
関数プログラミングには二種類の強力な糊
つまり関数の貼り合せをする糊(高階関数)と
プログラムの貼り合せをする糊(遅延評価)がある


**関数の貼り合せ
Rubyにおける関数の貼り合せの能力を示すために
最初にリストの処理を見ていく


Rubyにはリスト処理のためのArrayクラスがあるので
ここでは各関数をArrayクラスのメソッドとして定義していく
前処理として関数言語風にhead(リストの先頭要素)と
tail(リストの先頭要素を除いた残り)を定義する
さらにリストに要素を結合するconsを定義する

&gt;|ruby|
class Array
  alias head first
  def tail
    drop 1
  end
  
  def cons(a)
    [a] + self
  end
end

ls = Array[1,2,3,4,5] # =&gt; [1, 2, 3, 4, 5]
ls.head # =&gt; 1
ls.tail # =&gt; [2, 3, 4, 5]
ls.cons(0) # =&gt; [0, 1, 2, 3, 4, 5]
||&lt;


最初にリストの要素を足し合わせるsum0を定義する
これは再帰を使って以下のように書くことができる
&gt;|ruby|
class Array
  def sum0
    return 0 if empty?
    head + tail.sum0
  end
end

ls = Array[1,2,3,4,5]
ls.sum0 # =&gt; 15
||&lt;


つまり空リストに対しては0を返すようにし
それ以外ではリストの最初の要素を
残りの要素の和に足していくことで結果を得る


ここで
この定義における加算に固有の要素
つまり0と+を一般化すると
リスト処理の汎用メソッドreduceができ上がる((同じ目的で既にEnumerable#reduceが存在します))

&gt;|ruby|
class Array
  def reduce(f, a)
    return a if empty?
    f[head, tail.reduce(f, a)]
  end
end
||&lt;


Rubyでは
メソッドはそのままでは引数として渡すことができないので
ここではfとしてProcオブジェクトを受けるようにし
Proc#[]で実行するようにしている((Proc#.callまたはProc#.()という呼びだし方法もあります))


今度はreduceとaddメソッドを使ってsumを再定義しよう

&gt;|ruby|
class Array
  def sum
    reduce add, 0
  end

  private
  def add
    -&gt;a,b{ a + b }　# lambda{ |a,b| a + b } と同じ
  end
end

ls = Array[1,2,3,4,5]
ls.sum # =&gt; 15
||&lt;


addメソッドはa,bを引数に取るProcオブジェクト
つまり手続きを返す高階関数である


同様にしてreduceとmultiplyメソッドを使って
要素を掛け合わせるproductを定義する((Arrayには別の目的のためのproductメソッドがあるので警告がでます))

&gt;|ruby|
class Array
  def product
    reduce multiply, 1
  end

  private
  def multiply
    -&gt;a,b{ a * b }
  end
end

ls = Array[1,2,3,4,5]
ls.product # =&gt; 120
||&lt;


また真理値リストの要素のうち何れかが真かを検査するany_trueと
すべての要素が真であることを検査するall_trueを同様に定義する
&gt;|ruby|
class Array
  def any_true
    reduce method(:or), false
  end

  def all_true
    reduce method(:and), true
  end

  private
  def or(a,b)
    a or b
  end

  def and(a,b)
    a and b
  end
end

tf1 = Array[false, true, false]
tf2 = Array[true, true, true]
tf1.any_true # =&gt; true
tf2.any_true # =&gt; true
tf1.all_true # =&gt; false
tf2.all_true # =&gt; true
||&lt;


Rubyにおいてorとandは予約語なので
そのままの形では引数として渡すことができない
ここではこの問題を回避するため
orとandをMethodオブジェクト化して渡している


さてここでreduce(f, a)をcons(a)との対比で理解してみよう
リスト[1,2,3]はconsを使って以下のように作ることができる

&gt;|ruby|
[].cons(3).cons(2).cons(1) # =&gt; [1, 2, 3]
||&lt;


reduce(f,a)は上の式のconsをすべてfに置き換え
[]をaに置き換えたものとみなすことができる

&gt;|ruby|
a.f(3).f(2).f(1)
||&lt;


その結果先のsumのreduce add, 0と
productのreduce multiply, 1は
それぞれ以下のように理解できる

&gt;|ruby|
0.add(3).add(2).add(1)

1.multiply(3).multiply(2).multiply(1)
||&lt;


そうするとreduce cons, []は
リストを複写するものであることが理解できるだろう
consをreduceに渡せるように
少し改良して複写メソッドdupを定義する

&gt;|ruby|
class Array
  def cons
    -&gt;(a,ls=self){ [a] + ls }
  end

  def reduce(f, a)
    return a if empty?
    f[head, tail.reduce(f, a)]
  end

  def dup
    reduce cons, []
  end
end

[1,2,3].dup # =&gt; [1, 2, 3]
||&lt;
consは他の補助メソッドと同様に２つの引数を取るようにし
かつ[]メソッドで実行されるようProcオブジェクト化する


ここでdupにおけるreduceの第二引数にリストを渡せるようにすれば
リストを結合するappendが定義できる
後にappendは関数合成しやすいように高階関数としよう
&gt;|ruby|
class Array
  def append
    -&gt;(ls,s=self){ ls.reduce cons, s }
  end
end

[4,5,6].append[ls] # =&gt; [1, 2, 3, 4, 5, 6]
||&lt;


続いてリストの要素を２倍するメソッドdouble_allを定義しよう
double_allはreduceとdouble_and_consを
使って次のように書くことができる
&gt;|ruby|
  def double_all
    reduce double_and_cons, []
  end

  private
  def double_and_cons
    -&gt;num,ls{ cons[2*num, ls] }
  end
end

ls = Array[1,2,3,4,5]
ls.double_all # =&gt; [2, 4, 6, 8, 10]
||&lt;


ここでdouble_and_consはさらに
doubleとf_and_consにモジュール化することができる

&gt;|ruby|
class Array
  def double_all
    reduce f_and_cons[double], []
  end
  
  private
  def double
    -&gt;num{ 2 * num }
  end
  
  def f_and_cons
    -&gt;f,el,ls{ cons[f[el], ls] }.curry
  end
end

ls = Array[1,2,3,4,5]
ls.double_all # =&gt; [2, 4, 6, 8, 10]
||&lt;


double_allにおいてreduceはその第1引数として
Procオブジェクトを受け取る必要がある
ここではf_and_consをカリー化することにより
それがdoubleのみを取って
Procオブジェクトを返せるよう工夫している
このような方法を関数の部分適用という


また2つの関数を合成するcomposeメソッドを定義することにより
consとdoubleを合成する方法がある

&gt;|ruby|
class Array
  def double_all
    reduce compose(cons, double), []
  end

  private
  def double
    -&gt;num{ 2 * num }
  end
  
  def compose(f,g)
    -&gt;x,y{ f[g[x],y] }
  end
end

ls = Array[1,2,3,4,5]
ls.double_all # =&gt; [2, 4, 6, 8, 10]
||&lt;


double_allはconsと合成する関数を一般化することによって
更にモジュール化を進めることができる
&gt;|ruby|
class Array
  def double_all
    map double
  end

  def map(f)
    reduce compose(cons, f), []
  end
end

ls = Array[1,2,3,4,5]
ls.double_all # =&gt; [2, 4, 6, 8, 10]
||&lt;


mapは任意のメソッドfをリストのすべての要素に適用する
mapはreduceと並ぶもう一つの汎用的なメソッドである((同じ目的のArray#mapが存在するので警告がでます))

&gt;|ruby|
[1,2,3,4,5].map -&gt;x{ x ** 2 } # =&gt; [1, 4, 9, 16, 25]
%w(ruby haskell scheme).map -&gt;s{ s.upcase } # =&gt; [&quot;RUBY&quot;, &quot;HASKELL&quot;, &quot;SCHEME&quot;]
||&lt;


このようにしてメソッドを高階関数と
いくつかの単純なメソッドの合成としてモジュール化することにより
リストのための多数のメソッドを効果的に定義することができる


(続く？)((この先は難しくて自分にはちょっと厳しいかも..))


(追記：2011-1-29)appendの記述を修正しました。
(追記：2011-2-1)続きを書きました。
[http://d.hatena.ne.jp/keyesberry/20110129/p1:title=]

</body>
</day>
<day date="2011-01-27" title="">
<body>
*p2*Rubyの目次
[http://d.hatena.ne.jp/keyesberry/20110127/p1:title=前の記事]で作ったツールで早々
自分が投稿したRuby関連の記事を取得・整理して目次を作りました
内容が古く役に立たないものもあると思いますが
どなたかの参考になれば幸いです:-)


それにしても自分の中途半端さがよくわかる..


**Ruby言語仕様
+[http://d.hatena.ne.jp/keyesberry/20080319/p1:title=Ruby、君はオブジェクト指向なんかじゃない、謎の生命体試行錯誤だ！(2008-03-19)][http://d.hatena.ne.jp/keyesberry/20080319/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20080321/p1:title=Ruby、君はオブジェクト指向なんかじゃない、謎の生命体試行錯誤だ！(2008-03-21)][http://d.hatena.ne.jp/keyesberry/20080321/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20080323/p1:title=Ruby、君はオブジェクト指向なんかじゃない、謎の生命体試行錯誤だ！(2008-03-23)][http://d.hatena.ne.jp/keyesberry/20080323/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20080802/p1:title=Rubyのシンボルは文字列の皮を被った整数だ！(2008-08-02)][http://d.hatena.ne.jp/keyesberry/20080802/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20080809/p1:title=Rubyのブロックはメソッドに対するメソッドのMix-inだ！(2008-08-09)][http://d.hatena.ne.jp/keyesberry/20080809/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20080812/p1:title=Rubyのyieldは羊の皮を被ったevalだ！(2008-08-12)][http://d.hatena.ne.jp/keyesberry/20080812/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20080816/p1:title=Rubyのクラスはオブジェクトの母、モジュールはベビーシッター(2008-08-16)][http://d.hatena.ne.jp/keyesberry/20080816/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20080827/p1:title=Rubyのクラスはソフトクリームコーン(2008-08-27)][http://d.hatena.ne.jp/keyesberry/20080827/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20080905/p1:title=Rubyのオブジェクトは生物なんかじゃない、TopLevelこそが生物なんだ！(2008-09-05)][http://d.hatena.ne.jp/keyesberry/20080905/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20080917/p1:title=RubyのSymbol#to_procを考えた人になってみる(2008-09-17)][http://d.hatena.ne.jp/keyesberry/20080917/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20080927/p1:title=RubyのObjectクラスは過去を再定義するタイムマシンだ！(2008-09-27)][http://d.hatena.ne.jp/keyesberry/20080927/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20080930/p1:title=RubyのModuleクラスはすべてのモジュールの母であり同時にすべてのクラスの父である！(2008-09-30)][http://d.hatena.ne.jp/keyesberry/20080930/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20081022/p1:title=メソッドが見つからないならRubyに作ってもらえばいいよ！ - If method_missing, define_method by Ruby -(2008-10-22)][http://d.hatena.ne.jp/keyesberry/20081022/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090826/p1:title=Rubyのブロック(クロージャ)はローカル変数をインスタンス変数に変えるマジックだ！(2009-08-26)][http://d.hatena.ne.jp/keyesberry/20090826/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090901/p1:title=RubyのProcオブジェクトはキューティーハニーだ!(2009-09-01)][http://d.hatena.ne.jp/keyesberry/20090901/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101105/p1:title=Rubyのモジュール関数を理解しよう！(2010-11-05)][http://d.hatena.ne.jp/keyesberry/20101105/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101111/p1:title=Rubyのメソッドに別名があってもいいじゃないか(2010-11-11)][http://d.hatena.ne.jp/keyesberry/20101111/p1:bookmark]


**ツールとしてのRuby
+[http://d.hatena.ne.jp/keyesberry/20080708/p1:title=Ruby、同じことの繰り返しは君に任せるよ ～ 再帰でハノイの塔を解こう！～(2008-07-08)][http://d.hatena.ne.jp/keyesberry/20080708/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090111/p1:title=Rubyでフィボナッチ、トリボナッチ、テトラナッチ！そして僕はヒトリボッチ(2009-01-11)][http://d.hatena.ne.jp/keyesberry/20090111/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090326/p1:title=Rubyでスペル修正プログラムを書こう！(2009-03-26)][http://d.hatena.ne.jp/keyesberry/20090326/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100121/p1:title=Rubyで最短経路を探索しよう！(2010-01-21)][http://d.hatena.ne.jp/keyesberry/20100121/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100315/p1:title=ApplescriptとRubyでもう僕は移動しない(2010-03-15)][http://d.hatena.ne.jp/keyesberry/20100315/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101012/p1:title=Rubyでソート・アルゴリズムを表現しよう!(2010-10-12)][http://d.hatena.ne.jp/keyesberry/20101012/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101017/p1:title=Rubyで文字列検索アルゴリズムを表現しよう!(2010-10-17)][http://d.hatena.ne.jp/keyesberry/20101017/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101110/p1:title=((Rubyで) 書く (Lisp) インタプリタ)(2010-11-10)][http://d.hatena.ne.jp/keyesberry/20101110/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101116/p1:title=IRB　それはRubyistの魔法のランプ(2010-11-16)][http://d.hatena.ne.jp/keyesberry/20101116/p1:bookmark]


**Rubyと関数型言語
+[http://d.hatena.ne.jp/keyesberry/20090129/p1:title=SchemeとRubyで高階関数を学ぼう(2009-01-29)][http://d.hatena.ne.jp/keyesberry/20090129/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090131/p1:title=SchemeとRubyで高階関数を学ぼう ~その2~(2009-01-31)][http://d.hatena.ne.jp/keyesberry/20090131/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090201/p1:title=SchemeとRubyでデータ抽象を学ぼう(2009-02-01)][http://d.hatena.ne.jp/keyesberry/20090201/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090205/p1:title=SchemeとRubyでリストの操作を学ぼう(2009-02-05)][http://d.hatena.ne.jp/keyesberry/20090205/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090206/p1:title=SchemeとRubyで接続インタフェースを学ぼう(2009-02-06)][http://d.hatena.ne.jp/keyesberry/20090206/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090208/p1:title=SchemeとRubyで写像の入れ子を学ぼう(2009-02-08)][http://d.hatena.ne.jp/keyesberry/20090208/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090215/p1:title=SchemeとRubyで図形言語を学ぼう(2009-02-15)][http://d.hatena.ne.jp/keyesberry/20090215/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090216/p1:title=高階関数はコードをユーザフレンドリーにする(2009-02-16)][http://d.hatena.ne.jp/keyesberry/20090216/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090313/p1:title=SchemeとRubyで記号微分を学ぼう(2009-03-13)][http://d.hatena.ne.jp/keyesberry/20090313/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090318/p1:title=再帰は再帰なんかじゃない！末尾再帰こそが真の再帰なんだ！(2009-03-18)][http://d.hatena.ne.jp/keyesberry/20090318/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110120/p1:title=Rubyの末尾再帰最適化を理解する(2011-01-20)][http://d.hatena.ne.jp/keyesberry/20110120/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110124/p1:title=Rubyを使って「なぜ関数プログラミングは重要か」を解読しよう！(2011-01-24)][http://d.hatena.ne.jp/keyesberry/20110124/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110129/p1:title=Rubyを使って「なぜ関数プログラミングは重要か」を解読しよう！(その２)(2011-01-29)][http://d.hatena.ne.jp/keyesberry/20110129/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110201/p1:title=Rubyを使って「なぜ関数プログラミングは重要か」を解読しよう！(その３)(2011-02-01)][http://d.hatena.ne.jp/keyesberry/20110201/p1:bookmark]


**Rubyチュートリアル
+[http://d.hatena.ne.jp/keyesberry/20090407/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その1)(2009-04-07)][http://d.hatena.ne.jp/keyesberry/20090407/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090408/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その2)(2009-04-08)][http://d.hatena.ne.jp/keyesberry/20090408/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090409/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その3)(2009-04-09)][http://d.hatena.ne.jp/keyesberry/20090409/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090410/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その4)(2009-04-10)][http://d.hatena.ne.jp/keyesberry/20090410/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090411/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その5)(2009-04-11)][http://d.hatena.ne.jp/keyesberry/20090411/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090412/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その6)(2009-04-12)][http://d.hatena.ne.jp/keyesberry/20090412/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090413/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その7)(2009-04-13)][http://d.hatena.ne.jp/keyesberry/20090413/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090414/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その8)(2009-04-14)][http://d.hatena.ne.jp/keyesberry/20090414/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090415/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その9)(2009-04-15)][http://d.hatena.ne.jp/keyesberry/20090415/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090416/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その10)(2009-04-16)][http://d.hatena.ne.jp/keyesberry/20090416/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090417/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その11)(2009-04-17)][http://d.hatena.ne.jp/keyesberry/20090417/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090418/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その12)(2009-04-18)][http://d.hatena.ne.jp/keyesberry/20090418/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090419/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その13)(2009-04-19)][http://d.hatena.ne.jp/keyesberry/20090419/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090420/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その14)(2009-04-20)][http://d.hatena.ne.jp/keyesberry/20090420/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090421/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その15)(2009-04-21)][http://d.hatena.ne.jp/keyesberry/20090421/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090422/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(その16)(2009-04-22)][http://d.hatena.ne.jp/keyesberry/20090422/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090423/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(最終回)(2009-04-23)][http://d.hatena.ne.jp/keyesberry/20090423/p1:bookmark]


**Rubyスクリプト
+[http://d.hatena.ne.jp/keyesberry/20081002/p1:title=GraphvizでRubyのクラス階層を視覚化しよう！(2008-10-02)][http://d.hatena.ne.jp/keyesberry/20081002/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090425/p1:title=Ruby+Shoesでスキャニメーションを作ろう！(2009-04-25)][http://d.hatena.ne.jp/keyesberry/20090425/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090427/p1:title=Ruby+Shoesでスキャニメーションを作ろう！（その2)(2009-04-27)][http://d.hatena.ne.jp/keyesberry/20090427/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20091001/p1:title=Rubyで写真にタイトルを付けてFlickrにアップしよう!(2009-10-01)][http://d.hatena.ne.jp/keyesberry/20091001/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100203/p1:title=Rubyでアニメーション・グラフを作ろう！(2010-02-03)][http://d.hatena.ne.jp/keyesberry/20100203/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100204/p1:title=Rubyでカラフルにグラフを書こう！ ーGraphViz色見本(2010-02-04)][http://d.hatena.ne.jp/keyesberry/20100204/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100205/p1:title=Rubyでいろんなかたちと矢印のグラフを書こう！ ーGraphViz Shape&amp;Arrow見本(2010-02-05)][http://d.hatena.ne.jp/keyesberry/20100205/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100206/p1:title=Rubyのランダムをグラフ化しよう！(2010-02-06)][http://d.hatena.ne.jp/keyesberry/20100206/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100206/p2:title=Rubyで属性を指定してグラフを書こう！ ーGraphViz属性リスト(2010-02-06)][http://d.hatena.ne.jp/keyesberry/20100206/p2:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100207/p2:title=Rubyで素数とフィボナッチを視覚化しよう！　ーGraphAzサンプル(2010-02-07)][http://d.hatena.ne.jp/keyesberry/20100207/p2:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100302/p1:title=Ruby製ノコギリで株価を切り刻もう!(2010-03-02)][http://d.hatena.ne.jp/keyesberry/20100302/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100527/p1:title=Rubyでマリオを奏でよう！ ～_whyのbloopsaphoneの紹介(2010-05-27)][http://d.hatena.ne.jp/keyesberry/20100527/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100710/p1:title=Rubyでスキャニメーションを作ろう！(2010-07-10)][http://d.hatena.ne.jp/keyesberry/20100710/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101107/p1:title=RubyでANSIカラーシーケンスを学ぼう！(2010-11-07)][http://d.hatena.ne.jp/keyesberry/20101107/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101202/p1:title=Rubyでcalをカラフルに(2010-12-02)][http://d.hatena.ne.jp/keyesberry/20101202/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110127/p1:title=Rubyではてダの記事一覧を取得してまとめ頁を作ろう！(2011-01-27)][http://d.hatena.ne.jp/keyesberry/20110127/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110209/p1:title=Ruby製クレヨンでお絵描きしようよ！(2011-02-09)][http://d.hatena.ne.jp/keyesberry/20110209/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110510/p1:title=ABCでもマリオを奏でたいよ！(2011-05-10)][http://d.hatena.ne.jp/keyesberry/20110510/p1:bookmark]


**RubyとWeb
+[http://d.hatena.ne.jp/keyesberry/20060809/p1:title=RailsでFlickrを遊ぼう! (Putting Flickr on Rails)(2006-08-09)][http://d.hatena.ne.jp/keyesberry/20060809/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20060810/p1:title=Flickr on Railsをいじる(その１)(2006-08-10)][http://d.hatena.ne.jp/keyesberry/20060810/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20060811/p1:title=Flickr on Railsをいじる(その２)(2006-08-11)][http://d.hatena.ne.jp/keyesberry/20060811/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20070614/p1:title=Railsでブログを作ろう！(Creating a Weblog in 15 minutes)(2007-06-14)][http://d.hatena.ne.jp/keyesberry/20070614/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20080913/p1:title=Rubyのクラスとメソッドを全部いっぺんに見たい！(2008-09-13)][http://d.hatena.ne.jp/keyesberry/20080913/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20081001/p1:title=Rubyのクラスとメソッドを全部いっぺんに見たい！ - 改訂版(2008-10-01)][http://d.hatena.ne.jp/keyesberry/20081001/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090430/p1:title=Ruby.Sinatra.Git.Heroku #=&gt; ”Happy Web Development!”(2009-04-30)][http://d.hatena.ne.jp/keyesberry/20090430/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090501/p1:title=Ruby.Sinatra.Git.Heroku #=&gt; ”Happy Web Development!”　(後編)(2009-05-01)][http://d.hatena.ne.jp/keyesberry/20090501/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100714/p1:title=Rubyのクラスとメソッドを全部いっぺんに！ - 再改訂版(2010-07-14)][http://d.hatena.ne.jp/keyesberry/20100714/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110218/p1:title=CanvasアニメーションをHerokuで公開しようよ！(2011-02-18)][http://d.hatena.ne.jp/keyesberry/20110218/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110222/p1:title=jQuery UIでCanvasアニメーションを操作しようよ(2011-02-22)][http://d.hatena.ne.jp/keyesberry/20110222/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110603/p1:title=SinatraはDSLなんかじゃない、Ruby偽装を使ったマインドコントロールだ！(2011-06-03)][http://d.hatena.ne.jp/keyesberry/20110603/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110605/p1:title=Sinatraに別構文があってもいいじゃないか！(2011-06-05)][http://d.hatena.ne.jp/keyesberry/20110605/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110607/p1:title=内部DSLを使って、RubyのWebフレームワークを書こう！(2011-06-07)][http://d.hatena.ne.jp/keyesberry/20110607/p1:bookmark]


**Termtter
+[http://d.hatena.ne.jp/keyesberry/20100123/p1:title=Termtter is a Sandbox for Rubyists!(2010-01-23)][http://d.hatena.ne.jp/keyesberry/20100123/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100125/p1:title=Termtterでuriを開こう！ - uri-openの紹介と改良(2010-01-25)][http://d.hatena.ne.jp/keyesberry/20100125/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100130/p2:title=Termtterで写真を投稿しよう！ - twitpic plugin(2010-01-30)][http://d.hatena.ne.jp/keyesberry/20100130/p2:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100203/p2:title=Termtterで検索しよう!(2010-02-03)][http://d.hatena.ne.jp/keyesberry/20100203/p2:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100207/p1:title=TermtterならGoogle検索だってできる(2010-02-07)][http://d.hatena.ne.jp/keyesberry/20100207/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100208/p1:title=TermtterでコマンドのDefault挙動を変更する(2010-02-08)][http://d.hatena.ne.jp/keyesberry/20100208/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100208/p2:title=Termtterでmoreしようよ(2010-02-08)][http://d.hatena.ne.jp/keyesberry/20100208/p2:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100210/p1:title=Termtterならニュース検索だってできる(2010-02-10)][http://d.hatena.ne.jp/keyesberry/20100210/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100212/p1:title=TermtterならBlogだってVideoだってPatentだって(2010-02-12)][http://d.hatena.ne.jp/keyesberry/20100212/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100216/p1:title=Termtterなら暗号だって回文だって(2010-02-16)][http://d.hatena.ne.jp/keyesberry/20100216/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100219/p1:title=TermtterならGOOGだってAAPLだって(2010-02-19)][http://d.hatena.ne.jp/keyesberry/20100219/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100221/p1:title=TermtterならGmailだって(2010-02-21)][http://d.hatena.ne.jp/keyesberry/20100221/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100222/p1:title=Termtterで#nowplaying(2010-02-22)][http://d.hatena.ne.jp/keyesberry/20100222/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100307/p1:title=Termtterでupdateコマンドを省略する(2010-03-07)][http://d.hatena.ne.jp/keyesberry/20100307/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100610/p1:title=Termtterなら友だちだって見つけられる！(2010-06-10)][http://d.hatena.ne.jp/keyesberry/20100610/p1:bookmark]


**オイラープロジェクト
+[http://d.hatena.ne.jp/keyesberry/20090113/p2:title=Rubyで3と5の倍数を求める ～Rubyでオイラープロジェクトを解こう！Problem1(2009-01-13)][http://d.hatena.ne.jp/keyesberry/20090113/p2:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090113/p3:title=Rubyでフィボナッチ数列を求める ～Rubyでオイラープロジェクトを解こう！Problem2(2009-01-13)][http://d.hatena.ne.jp/keyesberry/20090113/p3:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090113/p4:title=Rubyで素因数を求める ～Rubyでオイラープロジェクトを解こう！Problem3(2009-01-13)][http://d.hatena.ne.jp/keyesberry/20090113/p4:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090114/p1:title=Rubyで回文数を求める ～Rubyでオイラープロジェクトを解こう！Problem4(2009-01-14)][http://d.hatena.ne.jp/keyesberry/20090114/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090115/p1:title=Rubyで最小公倍数を求める ～Rubyでオイラープロジェクトを解こう！Problem5(2009-01-15)][http://d.hatena.ne.jp/keyesberry/20090115/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090116/p1:title=Rubyでエラトステネス ～Rubyでオイラープロジェクトを解こう！Problem7(2009-01-16)][http://d.hatena.ne.jp/keyesberry/20090116/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090116/p2:title=Rubyでサムオブスクエアスクエアオブサム ～Rubyでオイラープロジェクトを解こう！Problem6(2009-01-16)][http://d.hatena.ne.jp/keyesberry/20090116/p2:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090117/p1:title=Rubyで数字をスライスする ～Rubyでオイラープロジェクトを解こう！Problem8(2009-01-17)][http://d.hatena.ne.jp/keyesberry/20090117/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090117/p2:title=Rubyでピタゴラスを求める ～Rubyでオイラープロジェクトを解こう！Problem9(2009-01-17)][http://d.hatena.ne.jp/keyesberry/20090117/p2:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090118/p1:title=Rubyで縦横斜めの積を求める ～Rubyでオイラープロジェクトを解こう！Problem11(2009-01-18)][http://d.hatena.ne.jp/keyesberry/20090118/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090118/p2:title=Rubyでサブプライム問題解決！ ～Rubyでオイラープロジェクトを解こう！Problem10(2009-01-18)][http://d.hatena.ne.jp/keyesberry/20090118/p2:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090119/p1:title=Rubyで三角数の約数を探せ！ ～Rubyでオイラープロジェクトを解こう！Problem12(2009-01-19)][http://d.hatena.ne.jp/keyesberry/20090119/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090119/p2:title=Rubyで100個の数を足す ～Rubyでオイラープロジェクトを解こう！Problem13(2009-01-19)][http://d.hatena.ne.jp/keyesberry/20090119/p2:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090120/p1:title=Rubyで最長の数列を探す ～Rubyでオイラープロジェクトを解こう！Problem14(2009-01-20)][http://d.hatena.ne.jp/keyesberry/20090120/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090122/p1:title=Rubyで最短ルート数を探す ～Rubyでオイラープロジェクトを解こう！Problem15(2009-01-22)][http://d.hatena.ne.jp/keyesberry/20090122/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090122/p2:title=Rubyで桁の合計を求める ～Rubyでオイラープロジェクトを解こう！Problem16(2009-01-22)][http://d.hatena.ne.jp/keyesberry/20090122/p2:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090123/p1:title=Rubyで英数字を作って文字数を数える ～Rubyでオイラープロジェクトを解こう！Problem17(2009-01-23)][http://d.hatena.ne.jp/keyesberry/20090123/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090125/p1:title=Rubyで三角形の最大ルートを求める ～Rubyでオイラープロジェクトを解こう！Problem18(2009-01-25)][http://d.hatena.ne.jp/keyesberry/20090125/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090126/p1:title=Rubyで20世紀の日曜日を求める ～Rubyでオイラープロジェクトを解こう！Problem19(2009-01-26)][http://d.hatena.ne.jp/keyesberry/20090126/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090126/p2:title=Rubyで階乗して桁を合計 ～Rubyでオイラープロジェクトを解こう！Problem20(2009-01-26)][http://d.hatena.ne.jp/keyesberry/20090126/p2:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090127/p1:title=Rubyで友愛数を探す ～Rubyでオイラープロジェクトを解こう！Problem21(2009-01-27)][http://d.hatena.ne.jp/keyesberry/20090127/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20090128/p1:title=Rubyでアルファベット値を数える ～Rubyでオイラープロジェクトを解こう！Problem22(2009-01-28)][http://d.hatena.ne.jp/keyesberry/20090128/p1:bookmark]


**その他
+[http://d.hatena.ne.jp/keyesberry/20080305/p1:title=Cocoaアプリ用Rubyのロードパスを設定しよう(2008-03-05)][http://d.hatena.ne.jp/keyesberry/20080305/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100318/p1:title=Yet Another Ruby FizzBuzz(2010-03-18)][http://d.hatena.ne.jp/keyesberry/20100318/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100324/p1:title=Yet Another Ruby FizzBuzz その3(2010-03-24)][http://d.hatena.ne.jp/keyesberry/20100324/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100324/p2:title=Yet Another Ruby FizzBuzz その2(2010-03-24)][http://d.hatena.ne.jp/keyesberry/20100324/p2:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20100324/p3:title=Yet Another Ruby FizzBuzz その4(2010-03-24)][http://d.hatena.ne.jp/keyesberry/20100324/p3:bookmark]


(追記：2011-1-28)時系列で並べ替えました。
*p1*Rubyではてダの記事一覧を取得してまとめ頁を作ろう！
継続的にブログを続けていると
投稿はそれなりの数になります
そうするとそれをまとめたくなるのが人情です
まとめによって記事の一覧性が高まります
運が良ければ
古い投稿にブクマやスターがもらえるかもしれません


そんなわけで..


はてダのユーザ単位で記事一覧を取得する
HateDa::EntryListというライブラリをRubyで作りました(‥;)
取得したデータには記事のタイトル、日付、URLが含まれているので
それをベースにして簡単にまとめ頁を作ることができますね！


**使い方
次のサイトからファイルをダウンロードします
htmlの解析にNokogiriを使っているので
なければgem install nokogiriしてください


[https://github.com/melborne/HateDa:title=]


以下のように使います
&gt;|ruby|
 require 'hateda'

 hd = HateDa::EntryList.new(:keyesberry)
 list = hd.get(:pages =&gt; 1) do |url, title, date|
   date.between?(&quot;2010-10-1&quot;, &quot;2011-1-25&quot;) and title =~ /ruby/i
 end
 puts hd.print_list(list)
||&lt;


手順は以下の通りです
+HateDa::EntryListクラスにユーザIDを渡しオブジェクトを生成します
+getメソッドで対象頁を取得しHTML解析した結果を得ます
+getメソッドでは頁を指定する引数と条件を指定するブロックを渡します
+print_listメソッドで取得したリストをはてダ投稿用((はてな記法))に整形出力します


getメソッドの返り値は{url=&gt;[title, date]}のようなHashになります
このサンプルの出力は以下のようになります
&gt;|ruby|
+[http://d.hatena.ne.jp/keyesberry/20110124/p1:title=Rubyを使って「なぜ関数プログラミングは重要か」を解読しよう！(2011-01-24)][http://d.hatena.ne.jp/keyesberry/20110124/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110120/p1:title=Rubyの末尾再帰最適化を理解する(2011-01-20)][http://d.hatena.ne.jp/keyesberry/20110120/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101202/p1:title=Rubyでcalをカラフルに(2010-12-02)][http://d.hatena.ne.jp/keyesberry/20101202/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101116/p1:title=IRB　それはRubyistの魔法のランプ(2010-11-16)][http://d.hatena.ne.jp/keyesberry/20101116/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101111/p1:title=Rubyのメソッドに別名があってもいいじゃないか(2010-11-11)][http://d.hatena.ne.jp/keyesberry/20101111/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101110/p1:title=((Rubyで) 書く (Lisp) インタプリタ)(2010-11-10)][http://d.hatena.ne.jp/keyesberry/20101110/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101107/p1:title=RubyでANSIカラーシーケンスを学ぼう！(2010-11-07)][http://d.hatena.ne.jp/keyesberry/20101107/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101105/p1:title=Rubyのモジュール関数を理解しよう！(2010-11-05)][http://d.hatena.ne.jp/keyesberry/20101105/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101017/p1:title=Rubyで文字列検索アルゴリズムを表現しよう!(2010-10-17)][http://d.hatena.ne.jp/keyesberry/20101017/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20101012/p1:title=Rubyでソート・アルゴリズムを表現しよう!(2010-10-12)][http://d.hatena.ne.jp/keyesberry/20101012/p1:bookmark]
||&lt;


getメソッドには対象頁を指定するキーワード引数:pagesを渡せます
:pagesはその値として数字またはRangeを受けます
ここでいう頁は記事一覧の一頁のことで
一頁には50件程度の記事が含まれています

&gt;|ruby|
 hd.get(:pages =&gt; 3)      #記事一覧の3頁目のみを取得
 hd.get(:pages =&gt; 1..3)   #1～3頁目を取得
 hd.get         　　　　　　#1～10頁を取得
 hd.get(:pages =&gt; 5..15)  #1～15頁を取得
||&lt;

引数を省略すると10頁までを取得します
それ以上を取得したい場合は例のように範囲を明示してください


getはまた頁の絞り込みをするためのキーワード引数:wordを取ります
:wordに渡した文字列で記事全文を検索し
その文字列が含まれる記事のみを対象にします


&gt;|ruby|
  #'任天堂'の語を含む記事のみを取得
 hd.get(:word =&gt; '任天堂')
  #'ruby'の語を含む記事群の1頁目のみを取得
 hd.get(:word =&gt; 'ruby', :pages =&gt; 1)
||&lt;


getのブロックには
url, 記事タイトル(title), 日付(date)を対象に
条件を指定して目的の記事を絞り込むことができます
urlとtitleは文字列ですので
正規表現のマッチングを行うのがいいでしょう
dateはDateクラスのオブジェクトですのでそのメソッドが使えます
更にDateクラスを拡張して以下のメソッドが使えます

&gt;|ruby|
  date.before?(&quot;2010/12/31&quot;)   # dateが2010-12-31以前か？

  date.after?(&quot;2009-12-3&quot;)     # dateが2009-12-3以降か？

  date.sameday?(&quot;2010-1-1&quot;)    # dateが2010-1-1か？

  # dateが2009-12-31と2010-2-1の間か？(当日を含む)
  date.between?(&quot;2009-12-31&quot;, &quot;2010-2-1&quot;)
||&lt;


print_listメソッドはキーワード引数として
 :bookmark :day :linenoを取れます
値はすべてBooleanです
 :bookmarkは被ブクマ数表示の有無
 :dayは日付表示の有無
 :linenoは先頭連続番号の有無です
省略した場合は先の例のようにすべて有りになります

&gt;|ruby|
 # bookmarkと日付を省略
 hd.print_list(list, bookmark:false, day:false)
 # linenoのみ省略
 hd.print_list(list, lineno:false)
||&lt;


需要があるかは知りませんが
使ってくれる人がいたらうれしいです


(追記:2011-1-28)HateDa::EntryListの仕様を変更したので、それに合わせて記述を直しました。

</body>
</day>
<day date="2011-01-29" title="">
<body>
*p1*Rubyを使って「なぜ関数プログラミングは重要か」を解読しよう！(その２)
[http://d.hatena.ne.jp/keyesberry/20110124/p1:title=前回]に引き続き「なぜ関数プログラミングは重要か」を
Rubyを使って解釈し自分の理解に基づいて解説してみます


**関数の貼り合せ（ツリー編）
貼り合せの能力はリスト上の関数にとどまらない
ラベル付き順序ツリーの例でこれを示そう


Rubyにはリストに都合の良いArrayクラスが組込みであったが
ツリーに都合の良いものはないので自分でクラスを定義しよう
ツリーはラベルを持ったノードを連結したものとして表現できるので
この連結の機能をもったNodeクラスを定義することで
ツリーを表現しよう

&gt;|ruby|
class Node
  attr_reader :label, :subtrees
  def initialize(label, *subtrees)
    @label = label
    @subtrees = subtrees
  end
end

def node
  -&gt;label,*subtrees{ Node.new(label, *subtrees) }
end
||&lt;


ノードオブジェクトはlabelと
サブノードのリストsubtreesをもつことができる
ここではノードオブジェクトを関数言語風に生成するために
node関数(Objectクラスのメソッド)を用意している


例えば
&gt;||

           1 o
            ／ ＼
          ／     ＼
        ／         ＼
     2 o             o 3
                     |
                     |
                     |
                     o  4

||&lt;
というツリーは
このNodeクラスを使って以下のように表現できる
&gt;|ruby|
tree = node[1, 
            node[2],
            node[3, node[4]]
            ]

# &gt;&gt; #&lt;Node:0x0a431c @label=1, @subtrees=[#&lt;Node:0x0a4420 @label=2, @subtrees=[]&gt;, #&lt;Node:0x0a4358 @label=3, @subtrees=[#&lt;Node:0x0a4394 @label=4, @subtrees=[]&gt;]&gt;]&gt;
||&lt;


つまりノード１は２つのノード２，３をサブノードとしてもち
ノード３はノード４をサブノードとしてもっている
nodeの第２引数は省略できこの場合subtreesの値は[]になる


さてここで
リストで用意したreduceメソッドと同じ目的をツリーで果たす
red_treeメソッドを定義してみよう


リストのところの説明でreduceがリストを生成するconsとの比較で
consと[]をfとaに置き換えたものとみなせると言った
同じ発想でツリーがリストを含むノードで生成される
つまりnodeとconsと[]で生成できることから
red_treeはこれらをfとgとaに置き換えたものとみなせる


ここでツリーとリストは別のクラスなので
それぞれのクラスの上にred_treeを定義する必要がある
&gt;|ruby|
class Node
  def red_tree(f, g, a)
    f[label, subtrees.red_tree(f, g, a)]
  end
end

class Array
  def red_tree(f, g, a)
    return a if empty?
    g[head.red_tree(f, g, a), tail.red_tree(f, g, a)]
  end
end
||&lt;


ここで最初の引数である関数fはノードオブジェクトの要素に適用され
第２の引数である関数gはリストの要素に適用される
red_treeと他の関数を貼り合せることで
興味深い関数がいくつも定義できる


次の段階に進む前にArrayクラスに定義した有用なメソッド群を
Nodeクラスにも定義したい
ここではNodeクラスに同じものを用意するのではなく
Arrayクラスのそれらのメソッドをモジュールに抽出して
Nodeクラスでも使えるようにしよう

&gt;|ruby|
module Functional
  def cons
    -&gt;(x,ls=self){ [x] + ls }
  end

  def append
    -&gt;(ls,se=self){ ls.reduce cons, se }
  end

  def add
    -&gt;x,y{ x + y }
  end

  def double
    -&gt;num{ 2 * num }
  end
  
  def compose(f,g)
    -&gt;x,y{ f[g[x],y] }
  end
end

class Array
  include Functional
end

class Node
  include Functional
end
||&lt;


準備ができたので
まずツリーのラベルの数値をすべて足すsum_treeを定義しよう
&gt;|ruby|
class Node
  def sum_tree
    red_tree add, add, 0
  end
end

tree = node[1,
            node[2],
            node[3, node[4]]
           ]

tree.sum_tree # =&gt; 10
||&lt;


ツリーのlabel全体のリストは以下のように定義できる
&gt;|ruby|
class Node
  def labels
    red_tree cons, append, []
  end
end

tree.labels # =&gt; [1, 2, 3, 4]
||&lt;


最後にリストのmapと類似したメソッド
つまり関数fを
ツリーのすべてのラベルに適用するメソッドmap_treeを定義する
&gt;|ruby|
class Node
  def map_tree(f)
    red_tree compose(node, f), cons, []
  end
end
||&lt;


map_treeを使えば
たとえばラベルの数値を倍にするメソッドを定義できる

&gt;|ruby|
class Node
  def double_all
    map_tree double
  end
end

tree.double_all.labels # =&gt; [2, 4, 6, 8]
||&lt;


以上のように高階関数すなわち関数を引数に取ったり
関数を返したりすることができる関数を使うことにより
プログラムを柔軟に多数の汎用的な部品に分割できるようになる


(続く？)


(追記：2011-2-1)続きを書きました。

[http://d.hatena.ne.jp/keyesberry/20110201/p1:title=]

</body>
</day>
<day date="2011-01-30" title="">
<body>
*p1*fun of Processing!
Processingは楽しいな
キレイな色玉を飛ばして
しばらくじっと眺めてみよう
色玉が静かに底に沈んだら
今度はマウスでクリックね
メッセージを押してもう一度
Processingは楽しいな
&lt;div class=&quot;hatena-widget&quot;&gt;
&lt;script src=&quot;http://gmodules.com/ig/ifr?url=http://dl.dropbox.com/u/58702/gadget2.xml&amp;synd=open&amp;w=320&amp;h=460&amp;title=&amp;border=%23ffffff%7C0px%2C0px+solid+%23ffffff&amp;output=js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;script src=&quot;https://gist.github.com/802419.js?file=bounce.pde&quot;&gt;&lt;/script&gt;


(追記：2011-1-31)メッセージのクリックでリスタートできるようにしました。
</body>
</day>
<day date="2011-01-31" title="">
<body>
*p1*fun of Processing
[http://d.hatena.ne.jp/keyesberry/20110130/p1:title=前の記事]のパラメータを少し変えて
今度はひらがなバージョン
こうして見ると
ひらがなって味があるよね
&lt;div class=&quot;hatena-widget&quot;&gt;
&lt;script src=&quot;http://gmodules.com/ig/ifr?url=http://dl.dropbox.com/u/58702/gadget07.xml&amp;synd=open&amp;w=320&amp;h=460&amp;title=&amp;border=%23ffffff%7C0px%2C0px+solid+%23ffffff&amp;output=js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;script src=&quot;https://gist.github.com/802419.js?file=bounce2.pde&quot;&gt;&lt;/script&gt;
</body>
</day>
<day date="2011-02-01" title="">
<body>
*p1*Rubyを使って「なぜ関数プログラミングは重要か」を解読しよう！(その３)
[http://d.hatena.ne.jp/keyesberry/20110129/p1:title=引き続き]「なぜ関数プログラミングは重要か」を
Rubyを使って解釈し自分の理解に基づいて解説してみます
誤解が有るかも知れません
いやきっとあります
ご指摘いただければ助かります


**プログラムの貼り合せ(遅延評価)
次に関数プログラミングの２つ目の強力な糊
つまりプログラムを貼り合せる糊について説明する


いま２つのプログラムｆとｇがあって
入力inputをこれらに適用する場合を考える
&gt;|ruby|
g (f input)
||&lt;


プログラムｆは入力inputを受け取ってその出力を計算し
その出力はプログラムｇの入力として使われる


一般的なプログラム言語ではｆからの出力を
一時的にメモリーに蓄えることでその実装を可能とするが
ケースによってはメモリー占有量が膨大になり得る


関数プログラミングではプログラムｆとｇは厳密な同期の上で走る
つまりプログラムｆはプログラムｇが必要とする分だけ
実行されて残りは破棄される
このことからプログラムｆは
無限に出力を生成し続けるものであってもよい
これによってプログラムの停止条件は
ループ本体と切り離すことができ
強力なモジュール化が可能になる


このようなプログラムの評価方式は「遅延評価」と呼ばれる


**ニュートンーラプソン法による平方根
遅延評価の力を使って
ニュートンーラプソン法による平方根のアルゴリズムを求めてみよう
この方法でnの平方根を求めるとき任意の近似値xを選び
xとn/xの平均を取っていくことでより良い近似値xを得る
これを繰り返し十分に良い近似値が得られたら処理を終える
良い近似値かの判断は隣接する近似値の差が
許容誤差eps以下であるかにより判断する


Rubyにおける一般的な実装は以下のようになるだろう
&gt;|ruby|
 EPS = 0.0001    # 許容誤差
 A0 = 1.0        # 初期近似値

 def sqrt(n, x=A0, eps = EPS)
   loop do
     y = x
     x = (x + n/x) / 2.0           # 次の近似値
     return x if (x-y).abs &lt; eps
   end
 end

 sqrt 2 # =&gt; 1.4142135623746899
 sqrt 5 # =&gt; 2.236067977499978
 sqrt 8 # =&gt; 2.8284271250498643
||&lt;


この実装ではループの停止条件は
ループに組み込まれてしまって分離できない
遅延評価を使うことによって実装のモジュール化を行い
その部品が他の場面でも使えることを示そう


基本的にRubyの関数(メソッド)は正格評価であり遅延評価されない
しかし関数をProcやEnumeratorオブジェクトとすることによって
その評価のタイミングを遅らせる
つまり遅延評価させることができる


まず次の近似値を計算するnext_valを定義しよう

&gt;|ruby|
 def next_val
   -&gt;n,x{ (x + n/x) / 2.0 }.curry
 end
||&lt;


next_val((nextはRubyの予約語なので使えない))は
求める平方根の数値nと近似値xを取って次の近似値を返すが
これをcurry化されたProcオブジェクトを返すように実装する
これによって
２つの引数を渡すタイミングをコントロールできるようになる
つまり数値nだけを先に渡すことによってnext_valは
１つの引数xを受ける関数に変わる


例を示そう
&gt;|ruby|
 next_for_five = next_val[5]
 nx = next_for_five[1.0] # =&gt; 3.0
 nx = next_for_five[nx] # =&gt; 2.3333333333333335
 nx = next_for_five[nx] # =&gt; 2.238095238095238
 nx = next_for_five[nx] # =&gt; 2.2360688956433634
||&lt;


次に初期値に任意の関数を繰り返し適用して
その結果のリストを返す汎用関数repeatを定義しよう

&gt;|ruby|
 def repeat(f, x)
   Enumerator.new { |y| loop { y &lt;&lt; x; x = f[x] } }
 end
||&lt;


repeat関数は１つの引数を取って１つの結果を返す関数ｆと
ｆの初期値となるxを取りEnumeratorオブジェクトを返す
Enumeratorのブロックの中では
loopによってxを関数ｆに適用した結果が
繰り返しｙつまりEnumerator::Yielderオブジェクトに渡されるが
これはEnumeratorオブジェクトが呼び出されるまで実行されず
そのため無限ループにはならない


このrepeat関数に先のnext_val関数を渡すことによって
平方根nの近似値のリストが得られる
&gt;|ruby|
 approxs = repeat next_val[5], 1.0 # =&gt; #&lt;Enumerator: #&lt;Enumerator::Generator:0x0a4aec&gt;:each&gt;

 ls = []
 5.times { ls &lt;&lt; approxs.next }
 ls # =&gt; [1.0, 3.0, 2.3333333333333335, 2.238095238095238, 2.2360688956433634]
||&lt;


Enumeratorオブジェクトはその呼び出し((ここではnext))の度に
ループを１つ回して結果を１つ返す
repeatはその出力を利用する関数と同期して
それが必要とされる分だけ評価される
つまりrepeatそれ自体は繰り返し回数の制限を持たない


次に関数with_inを定義しよう
with_inは許容誤差と近似値のリスト((正確にはリストではなくEnumeratorオブジェクト))を引数に取り
許容誤差よりも小さい２つの連続する近似値を探す

&gt;|ruby|
 def with_in(eps, enum)
   a, b = enum.next, enum.peek
   return b if (a-b).abs &lt;= eps
   with_in(eps, enum)
 end
||&lt;


最初の行でEnumeratorオブジェクトの返す
最初の２つの値をnextとpeekでa, bに取る
Enumerator#peekはカーソルを進めないで先頭要素を取る
２行目の終了条件が満たされない限り
処理は再帰的に繰り返えされる


最後にこれらの部品を使って
平方根を求める関数sqrtを定義しよう
&gt;|ruby|
 EPS = 0.0001    # 許容誤差
 A0 = 1.0        # 初期近似値

 def sqrt(n, a0=A0, eps=EPS)
   with_in eps, repeat(next_val[n], a0)
 end

 sqrt 2 # =&gt; 1.4142135623746899
 sqrt 3 # =&gt; 1.7320508100147274
 sqrt 5 # =&gt; 2.236067977499978
 sqrt 8 # =&gt; 2.8284271250498643
||&lt;


sqrt関数はこのようにしてモジュール化された３つの汎用部品
next_val repeat with_inを貼り合せて作ることができた


sqrt関数はモジュールを合成して構成されているので
プログラムの基本的な構造を変えることなく変更が容易に行える


今度は
２つの連続する近似値の差がゼロに近づくという条件の代わりに
２つの近似値の比が１に近づくという条件に変えてみよう
これは非常に小さいまたは非常に大きい数に対しては
より適切な結果を出す


この目的を達成するには
関数with_inに代わる関数relativeを定義するだけでよい

&gt;|ruby|
 def relative(eps, enum)
   a, b = enum.next, enum.peek
   return b if (a-b).abs &lt;= eps*b.abs
   relative(eps, enum)
 end

 def sqrt(n, a0=A0, eps=EPS)
   relative eps, repeat(next_approx[n], a0)
 end

 sqrt 2 # =&gt; 1.4142135623746899
 sqrt 3 # =&gt; 1.7320508100147274
 sqrt 5 # =&gt; 2.236067977499978
 sqrt 8 # =&gt; 2.8284271250498643
||&lt;


他の部品を変えることなく新しいsqrt関数ができた


(続く？)

</body>
</day>
<day date="2011-02-04" title="">
<body>
*p1*Processingアプレットをはてダに貼り付けよう！

&lt;div class=&quot;hatena-widget&quot;&gt;
&lt;script src=&quot;http://gmodules.com/ig/ifr?url=http://dl.dropbox.com/u/58702/clock2.xml&amp;synd=open&amp;w=200&amp;h=200&amp;title=&amp;border=%23ffffff%7C0px%2C0px+solid+%23ffffff&amp;output=js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;


[http://processing.org/:title=Processing]はJavaをベースにした
オープンソースのグラフィック専用言語です
マルチプラットフォームの統合開発環境(IDE)が用意されており
それをインストールするだけで誰でも簡単に
グラフィカルなプログラミングを始めることができます


IDEにはエクスポート機能があって
作ったプログラムをアプレット化して
簡単にWebサーバにアップし公開できます


でもWebサーバを用意するのは簡単ではありません
できれば手軽にはてダに貼り付けたい


そんなわけで...


その手順を以下に書いておきます
なおここではDropbox((ファイルサーバとして使います))とGoogleのアカウントが必要です
Dropboxのアカウントをお持ちでない方は
是非とも次のリンクから！


[http://db.tt/KEbzDMO:title=]


上に貼り付けた
clockアプレット(clock.pde)を例に手順を説明します
+clock.pdeをexportしてclock.jarを生成する
+clock.jarを~/Dropbox/public/に移動しそのpublic linkを取得する
+~/Dropbox/public/にiGoogle登録用のclock.xmlを作りそのpublic linkを取得する
+iGoogleにアプレットを登録する
+はてダにclock.xmlへのリンクを貼る


**1. clock.pdeをexportしてclock.jarを生成する
ProcessingのIDEにおいてclock.pdeを作った後
その最右にあるメニューボタンを押すとappletフォルダ内に
clock.jarその他のファイルが自動生成されます

**2. clock.jarを~/Dropbox/public/に移動しそのpublic linkを取得する
生成されたclock.jarをDropbox/publicフォルダに移動します
DropboxのWebサイトに行き
そのファイルのpublic linkを取得します
linkはマウスカーソルをファイルに当てて
右側に現れる矢印から選択できます

**3. ~/Dropbox/public/にiGoogle登録用のclock.xmlを作りそのpublic linkを取得する
以下の内容でDropbox/publicフォルダにxmlファイルを作ります
&gt;|xml|
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; 
&lt;Module&gt;
  &lt;ModulePrefs title=&quot;Clock&quot; height=&quot;200&quot; /&gt; 
  &lt;Content type=&quot;html&quot;&gt;
     &lt;![CDATA[ 
     &lt;applet archive= &quot;http://dl.dropbox.com/u/58702/clock.jar&quot;
             code=&quot;clock.class&quot; width=&quot;200&quot; height=&quot;200&quot; &gt;&lt;/applet&gt;
     ]]&gt;
  &lt;/Content&gt;
&lt;/Module&gt;
||&lt;


appletタグのarchiveに先のpublic linkを指定します
codeをファイル名.classとします
width heightをclock.pdeでのものと一致させます
DropboxのWebサイトに行き
このファイルのpublic linkを取得します


**4. iGoogleにアプレットを登録する
iGoogleのサイトに行き
先のclock.xmlをgadgetとして登録します
右上の「コンテンツを追加」で開いたページ左下の
「フィードやガジェットを追加」を押します
先ほどのpublic linkを貼り付けて「追加」を押します
確認メッセージをOKしてから
iGoogleのホームに戻り
gadgetが登録されたことを確認します


**5. はてダにclock.xmlへのリンクを貼る
はてなダイアリーで記事を投稿する際に
以下のxmlを本文のところに貼り付けます

&gt;|xml|
&lt;div class=&quot;hatena-widget&quot;&gt;
  &lt;script src=&quot;http://gmodules.com/ig/ifr?url=http://dl.dropbox.com/u/58702/clock.xml&amp;synd=open&amp;w=200&amp;h=200&amp;title=&amp;border=%23ffffff%7C0px%2C0px+solid+%23ffffff&amp;output=js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
||&lt;


urlには先ほどのclock.xmlのpublic linkを指定します
w hをclock.pdeのwidth heightに合わせます
以上です!


なお自分の環境ではpdeを編集して再エクスポートした場合
変更がうまく反映できませんでした
内容を別ファイルにコピーして
別名で上記行程を繰り返し対応しました


この記事は以下のサイトを大いに参考にしています
ありがとうございます！

[http://mtl.recruit.co.jp/blog/2007/09/flash.html:title=]
[http://d.hatena.ne.jp/t_yano/20080706/1215370412:title=]


&lt;script src=&quot;https://gist.github.com/802419.js?file=clock.pde&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2011-02-09" title="">
<body>
*p1*Ruby製クレヨンでお絵描きしようよ！
&lt;a href=&quot;http://www.flickr.com/photos/somewhatfrank/3442601259/&quot; title=&quot;Crayolas by Frank Gruber, on Flickr&quot;&gt;&lt;img src=&quot;http://farm4.static.flickr.com/3327/3442601259_11703f3e84_m.jpg&quot; width=&quot;240&quot; height=&quot;180&quot; alt=&quot;Crayolas&quot; /&gt;&lt;/a&gt;


米国にCrayolaというクレヨンの老舗メーカーがあります(([http://www.crayola.com/:title=]))
創業以来その色数を増やしていって
現在ではその標準カラーは133色もあるそうです
さらに12以上のスペシャルセットがあって
それらを合わせると色数は300を超えます


ウィキペディアにCrayola社クレヨンのページがあって
そこにほぼ全色のカラーコードが掲載されていることを
情報サイト((http://www.tommyjp.com/2011/02/html.html))を通して知りました


[http://en.wikipedia.org/wiki/List_of_Crayola_crayon_colors:title=]


ファンタスティック！
Color Loverとしてはこれを無視できません


そんなわけで..


Rubyの勉強を兼ねましてこれらのカラーコードを取得する
crayolaというライブラリをRubyで書きました (‥;)
混色など一部は対象外ですが9セット275色に対応しています


**crayolaの使い方
以下のように使います

&gt;|ruby|
&gt;&gt; Crayola::Crayola.color_names
=&gt; [&quot;Almond&quot;, &quot;Antique Brass&quot;, &quot;Apricot&quot;, &quot;Aquamarine&quot;, &quot;Asparagus&quot;, &quot;Atomic Tangerine&quot;, &quot;Banana Mania&quot;, &quot;Beaver&quot;, &quot;Bittersweet&quot;, &quot;Black&quot;, &quot;Blizzard Blue&quot;, &quot;Blue&quot;, &quot;Blue Bell&quot;, &quot;Blue Gray&quot;, &quot;Blue Green&quot;, &quot;Blue Violet&quot;, &quot;Blush&quot;, &quot;Brick Red&quot;, &quot;Brown&quot;, &quot;Burnt Orange&quot;, &quot;Burnt Sienna&quot;, &quot;Cadet Blue&quot;, &quot;Canary&quot;, &quot;Caribbean Green&quot;, &quot;Carnation Pink&quot; ... &quot;Eerie Black&quot;, &quot;Black Shadows&quot;, &quot;Fiery Rose&quot;, &quot;Sizzling Sunset&quot;, &quot;Heat Wave&quot;, &quot;Lemon Glacier&quot;, &quot;Spring Frost&quot;, &quot;Absolute Zero&quot;, &quot;Winter Sky&quot;, &quot;Frostbite&quot;]
||&lt;


&gt;|ruby|
&gt;&gt; wild_strawberry = Crayola::Crayola.color('Wild Strawberry')
=&gt; #&lt;struct Crayola::Color series=&quot;Standard Colors&quot;, name=&quot;Wild Strawberry&quot;, hex=&quot;#FF43A4&quot;, rgb=[255, 67, 164], issue=1990, retired=nil, notes=nil&gt;
&gt;&gt; wild_strawberry.members #=&gt; [:series, :name, :hex, :rgb, :issue, :retired, :notes]
&gt;&gt; wild_strawberry.series #=&gt; &quot;Standard Colors&quot;
&gt;&gt; wild_strawberry.name #=&gt; &quot;Wild Strawberry&quot;
&gt;&gt; wild_strawberry.hex #=&gt; &quot;#FF43A4&quot;
&gt;&gt; wild_strawberry.rgb #=&gt; [255, 67, 164]
&gt;&gt; wild_strawberry.issue #=&gt; 1990
&gt;&gt; 
||&lt;

&gt;|ruby|
&gt;&gt; Crayola::Crayola.series
=&gt; [&quot;Standard Colors&quot;, &quot;Silver Swirls&quot;, &quot;Magic Scent&quot;, &quot;Gem Tones&quot;, &quot;Pearl Brite&quot;, &quot;Metallic FX&quot;, &quot;Silly Scents&quot;, &quot;Heads 'n Tails&quot;, &quot;Extreme Twistables Colors&quot;]
&gt;&gt; 
||&lt;

&gt;|ruby|
&gt;&gt; Crayola::Crayola.colors_in_series(&quot;Gem Tones&quot;).map(&amp;:name)
=&gt; [&quot;Amethyst&quot;, &quot;Citrine&quot;, &quot;Emerald&quot;, &quot;Jade&quot;, &quot;Jasper&quot;, &quot;Lapis Lazuli&quot;, &quot;Malachite&quot;, &quot;Moonstone&quot;, &quot;Onyx&quot;, &quot;Peridot&quot;, &quot;Pink Pearl&quot;, &quot;Rose Quartz&quot;, &quot;Ruby&quot;, &quot;Sapphire&quot;, &quot;Smokey Topaz&quot;, &quot;Tiger's Eye&quot;]
&gt;&gt; Crayola::Crayola.color(&quot;Ruby&quot;).hex #=&gt; &quot;#DC0646&quot;
&gt;&gt; 
||&lt;


EggplantとかJazzberry JamとかPiggy Pinkとか
Quick SilverとかTulipとかBig Foot Feetとか
Princess PerfumeとかOrange SodaとかDeep Space Sparkleとか
一体どんな色が出てくるのかワクワクしますね


これらたくさんの色を使って
お絵描きができたらさぞ楽しいでしょうね..


そんなわけで..


crayolaカラーを使ったお絵描きデモを作ってみました
どっちかって言うとHTML5のデモのような気もしますが..


[http://crayovas.heroku.com/:title=]


[f:id:keyesberry:20110209105103p:image]


右上の絵はもちろんルビーです
説明するまでもありません


**crayovasの使い方
+キャンバス上でマウスを一度クリックし、クリックを離した状態でマウスを移動して線を描きます
+終了点で再度クリックして描画を終えます
+よくあるマウスドラッグ中に描画する方式ではないので、最初は戸惑うかも知れません
+キャンバス下のカラーパレットで任意の色をクリックして色を選びます
+初期状態でStandard Colorsのカラーパレットが表示されています。他のシリーズを表示するにはそのシリーズ名をクリックします
+線の太さは右上の太さを示す数字をクリックして選択します
+消しゴムは右上のERASEをクリックして、ペンと同じように開始点でクリック、終了点でクリックして使います。RESETですべての絵を消します
+直近に使用したカラーは上に表示されます。表示をクリックしても色を選択できます


遊んでくれたらうれしいです


ソースコードは以下にあります


[https://github.com/melborne/crayola:title=]
[https://github.com/melborne/crayovas:title=]


(追記：2011-2-10) crayovasのupdateに合せて記述を変更しました。

</body>
</day>
<day date="2011-02-12" title="">
<body>
*p1*Crayovasで塗り絵しようよ！
前の投稿でHTML5のCanvasを使った
Crayovasというデモサイト作ったと書きました


[http://d.hatena.ne.jp/keyesberry/20110209/p1:title=]


[http://crayovas.heroku.com/:title=]


Crayovasでは
Crayolaクレヨン275色を使ったお絵描きができます
ほとんど機能といった機能はないのですが
それでもたくさんの色を使って絵を描けるというのは
想像以上に楽しいことです


しかし一方で楽しくない発見もありました


そう
自分の画力の無さを
思い知ることになったのです！


[f:id:keyesberry:20110209105103p:image]


確かにマウスは描画に適したデバイスとは言えません
ペンタブレットを使えばもう少しマシになるのでしょう


それにしても...です


Rubyと横に書いてあるので「あ～ルビーの絵ね」と
やさしい人間は言ってくれるでしょう
しかし機械にはそんなやさしさはありません
Googleにも僕のルビーを認識させたい..


そんなわけで..


数日
絵の特訓を重ねまして..
その努力の結果..



僕の画力は飛躍的に向上したのです！


[f:id:keyesberry:20110212151657p:image]


[f:id:keyesberry:20110212192536p:image]



......



ゴメンナサイ
嘘をつきました..


これはネット上の画像を下絵に
塗り絵したのでした..


そんなわけで..


画像を取り込んで下絵にできるように
Crayovasをバージョンアップしました
これでもう僕やあなたが
画力の無さに消沈する日々は
過去のものとなったのです！


**使い方
+Googleの画像検索で「塗り絵」「picture for coloring」などと入れて画像を探す
+塗り絵したい絵を見つけたら、マウス右クリックなどでその画像のURLをコピーする
+Crayovasサイト右上のテキストフィールドにURLをコピペしてloadボタンを押す
これで次のようにキャンバス上に下絵がセットされます((なお元の絵はキャンバスのサイズに引き伸ばされてしまうので、縦横比の近い絵を選びましょう))



[f:id:keyesberry:20110212151658p:image]


さあ
あなたの好みの色で自由に絵を仕上げて！




ソースコードは以下にあります
[https://github.com/melborne/crayovas:title=]


</body>
</day>
<day date="2011-02-18" title="">
<body>
*p1*CanvasアニメーションをHerokuで公開しようよ！
もしあなたが暇で暇でしようがなくて
一日中時計をぼーっと眺めるのも悪くない
と考えているのなら
次のリンクをクリックしてください
3分くらいならあなたの時間をつぶせるかもしれません


[http://aclock.heroku.com/:title=]


もしあなたがRubyを使っていて
JavaScriptのことはよく知らないけれども
HTML5のCanvasに興味がでてきて
その成果物をネットで簡単に公開できればうれしいかも
と考えているのなら
以下の記事を読む価値があるかもしれません
もちろん何の保証もありませんが..


**Canvasを使ったWebアプリケーションの構築
この記事は先のリンクで示した
接近する時計のWebアプリケーションを構築する手順を書いています
HTMLはhamlとscssを使って
JavaScriptはjQueryを使って記述しています
WebフレームワークSinatraを使ってHerokuにデプロイしています
OSはMac OSX Tiger..です


**ディレクトリ構成
最終的なファイル構成は以下のようになります
&gt;|bash|
.
├── Gemfile
├── Gemfile.lock
├── clock.rb
├── config.ru
├── public
│&amp;#160;&amp;#160; └── javascripts
│&amp;#160;&amp;#160;     └── clock.js
└── views
    ├── index.haml
    ├── layout.haml
    └── style.scss
||&lt;
Sinatraのために
clock.rb layout.haml index.haml style.scssが必要になります
時計を描画するJavaScriptはclock.jsに記述します
Herokuにデプロイするために更にconfig.ru Gemfileが必要になります
Gemfile.lockはbundler installコマンドで自動生成されます


以下では一つずつファイルを用意する必要がありますが
僕のような無精者のために
Sinatra版scaffold ease_sinatra.rbを用意しました


[https://gist.github.com/802707:title=]


カレントディレクトリでWebApp::ease_sinatraすれば
Sinatraのテンプレートファイルが得られます
かなりいい加減な作りであることをご了承下さい..


**clock.rb
まずWebフレームワークのコントローラとなるclock.rbを書きます
&gt;|ruby|
require 'sinatra'
require 'haml'
require 'sass'

configure do
  APP_TITLE = &quot;Approaching Clock&quot;
  CREDIT = ['hp12c', &quot;http://d.hatena.ne.jp/keyesberry&quot;]
end

get '/' do
  haml :index
end

get '/style.css' do
  scss :style
end
||&lt;

configureブロックはアプリ立ち上げ時に一度だけ呼ばれます
get '/'でルートが呼ばれた(GETされた)ときの挙動を記述します
ここでは
hamlで記述されたviews/index.hamlが返されるよう指定しています
get '/style.css'でlink属性でstyle.cssが呼ばれたときに
scssで記述されたvews/style.scssが返されるよう指定しています


**layout.haml
次にlayout.hamlを記述します
Sinatraではlayoutという名のテンプレートが存在する場合
各テンプレートの読み出しに先立ってそれが自動で読み出されます
&gt;|ruby|
!!! 5
%html
  %head
    %meta{:'http-equiv' =&gt; 'Content-type', :content =&gt; 'text/html', :charset =&gt; 'utf-8'}
    %title= APP_TITLE
    %link{:rel =&gt; 'stylesheet', :href =&gt; '/style.css', :type =&gt; 'text/css'}
    %script{:type =&gt; &quot;text/javascript&quot;, :src =&gt; &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.5.0/jquery.min.js&quot;, :charset =&gt; &quot;utf-8&quot; }
    %script{:type =&gt; &quot;text/javascript&quot;, :src =&gt; &quot;/javascripts/clock.js&quot;, :charset =&gt; &quot;utf-8&quot; }
  %body
    = yield
||&lt;

titleタグに先ほどのconfigureで定義したAPP_TITLEを指定します
hamlでは=(イコール)以降をRubyのコードとして評価します
jQueryはGoogleが提供するものを使っています
時計を記述するclock.jsを指定します
bodyタグの中身はyieldで実体ファイル(index.haml)に委ねます


**index.haml
次にindex.hamlを記述します
&gt;|ruby|
%header
#main
  %canvas#clock{:width =&gt; '1000px', :height =&gt; '500px'}Only for HTML5 adapted browsers
%footer
  %a{:href =&gt; CREDIT[1]}= CREDIT[0]
||&lt;
mainのcanvasタグにclockというid名を付けサイズを指定します
HTML5非対応ブラウザのためのメッセージを記述します
footerタグにCREDITのリンクを貼ります


**style.scss
次にstyle.scssを記述します
scssはsassy css(sassライクなcss)を意味するcssの拡張言語です((Sass、そしてSassy CSS (SCSS) http://hail2u.net/documents/sass-and-sassy-css.html))
scssを使用することによりcssの文法に沿って
sassの拡張を取り入れることができます
&gt;|ruby|
$font_color: #D0FFD0;
$bg_color: #325F82;
$canvas_color: #FFFFFF;

@mixin rounded($topl:32px, $topr:32px, $btmr:32px, $btml:32px) {
  border-radius: $topl $topr $btmr $btml;
  -moz-border-radius: $topl $topr $btmr $btml;
}

* {
  margin: 0;
  padding: 0;
  font-family: Trebuchet ms, Verdana, Myriad Web, Syntax, sans-serif
}

body {
  color: $font_color;
  background-color: $bg_color;
  width: 1000px;
  margin: 60px auto;
}

header {
  display:block;
}

#main {
  canvas#clock {
    border: thin solid #444;
    background-color: $canvas_color;
    @include rounded();
  }
}

footer {
  display: block;
  height: 30px;
  text-align: center;
  margin-top: 20px;
  a {
    text-decoration: none;
    color: $font_color;
    &amp;:visited {
      color: $font_color;
    }
  }
}
||&lt;
$varnameでグローバル変数を定義できます
セレクタをネストできます
@mixin-@includeでセレクタブロックを関数ライクに使えます
ここではrounded()で角丸にミックスインを使っています


**clock.js
メインとなるclock.jsを記述します
JavaScript初学者なので書き方に問題があるかもしれません
間違いをご指摘頂けるとうれしいです
少し長いので分けて説明します
&gt;|javascript|
var canvas = {};
$(document).ready(function(){
  canvas.c = $(&quot;canvas#clock&quot;);
  canvas.ctx = canvas.c[0].getContext('2d');
  canvas.width = canvas.c.width();
  canvas.height = canvas.c.height();
  
  canvas.ctx.translate(canvas.width/2, canvas.height/2);
  
  const min = 60;
  var x = min;
  var sp = 2;
  clock(x);
  setInterval(
    function(){
      clock(x);
      x += sp;
      if (x &gt; canvas.width*0.6 || x &lt; min) { sp = -sp };
    },
    500
  );
})
||&lt;
グローバルに参照できるcanvasオブジェクトを定義します
$(document).ready..はHTMLドキュメントの読み込みの完了を待って
その引数の関数が実行されることを保証します
そのなかで最初にcanvasオブジェクトにcanvasの情報を
オブジェクト・プロパティとしてセットします
JavaScriptではオブジェクト・プロパティは先行する宣言が不要です


canvasへの描画はcanvasオブジェクトの2Dコンテキストに対し行います
そのためgetContext('2d')しますが
jQueryではcanvasオブジェクトはArrayを返すので注意が必要です


時計の描画は中心点を基準に行うほうがやり易いので
ctx.translateで座標軸をcanvasの中心に移動します


Canvasにおけるアニメーションの描画にはsetIntervalを使います
setIntervalは第２引数に指定した周期で第１引数に渡した関数を
関数の実行スタックに繰り返し登録します
setIntervalの第１引数にはclock関数を包んだ匿名関数を渡します
時計を描画するclock関数はそのサイズxを引数にとります
サイズxは匿名関数が呼ばれる度にspだけ増分されてclockに渡されるので
呼び出しの度に時計のサイズは大きくなっていきます
サイズxが任意の値を超えると(ここではcanvas.width*0.6)
時計は今度は徐々に小さくなっていきます


続いてclock関数の中身を見ていきます
&gt;|javascript|
function clock (radius) {
  canvas.ctx.clearRect(-canvas.width/2,-canvas.height/2,canvas.width,canvas.height);
  var unit = radius/75;
  drawFrame(radius, '#325FA2');
  canvas.ctx.save();
  canvas.ctx.rotate(-Math.PI/2); //set start angle at twelve o'clock
  drawHand('hr', radius*0.5, unit*3, unit*5, 'black');
  drawHand('min', radius*0.9, unit*2, unit*10, 'black');
  drawHand('sec', radius*0.9, unit, unit*5, 'red');
  canvas.ctx.restore();
}
||&lt;

ctx.clearRectでキャンバスをクリアします
drawFrame関数で時計の文字盤を描画し
drawHand関数で針を描画します
針の描画はctx.rotateでキャンバスの座標系を回転させながら行うので
最初に初期位置を12時の位置に合わせています
ctx.save() ctx.restore()は動かした座標系を元に戻すために使います((save,restoreが保持するのは座標系だけに限らない))
saveでそれ以前の状態を保存し座標系を動かして描画を行った後
restoreで元に戻します
各描画サイズは
clockに渡されるサイズxに対する比で規定することによって
時計のサイズが変わってもそのバランスが崩れないようにします


次にdrawFrame関数の中身をみます
&gt;|javascript|
function drawFrame (radius, color) {
  drawCircle(radius, radius*0.1, color, false);
  drawPitchLines(radius*0.9, 2, 1);
  drawNumbers(radius/5, radius*0.7, color);
}

function drawCircle (distance, width, color, filly) {
  var ctx = canvas.ctx;
  ctx.beginPath();
  ctx.lineWidth = width;
  ctx.strokeStyle = color;
  ctx.arc(0, 0, distance, 0, 2*Math.PI, true);
  filly ? ctx.fill() : ctx.stroke();
}

function drawPitchLines (distance, length, width) {
  var ctx = canvas.ctx;
  ctx.save();
  for (var i=0; i &lt; 60; i++) {
    ctx.beginPath();
    ctx.strokeStyle = &quot;black&quot;;
    ctx.lineWidth = width;
    ctx.lineCap = 'round';
    var len = i%5==0 ? length*3 : length;
    ctx.moveTo(0, -distance);
    ctx.lineTo(0, -(distance-len));
    ctx.stroke();
    ctx.rotate(2*Math.PI/60);
  };
  ctx.restore();
}

function drawNumbers (size, distance, color) {
  var ctx = canvas.ctx;
  ctx.font = size + &quot;px Helvetica&quot;;
  ctx.fillStyle = color;
  
  for (var i=1; i &lt;= 12; i++) {
    ctx.save();
    ctx.translate(distance*Math.sin(Math.PI/6*i), -distance*Math.cos(Math.PI/6*i));
    ctx.fillText(i, -size/3, size/3);
    ctx.restore();
  };
}
||&lt;
drawFrame関数では外円とインデックスバーと数字を描画する
drawCircle drawPitchLines drawNumbersを呼びます
線の描画はbeginPathで開始宣言し
moveToで開始点lineToで終了点を決めて
strokeで実際に描画します
円はarcで描画します
引数には中心座標　半径　描画角始点終点
および描画方向を指定します
数字の描画はfillTextで行います


次に時計の針を描画するdrawHand関数をみます
&gt;|javascript|
function drawHand (unit, length, width, offset, color) {
  var now = new Date();
  var hr = now.getHours(), min = now.getMinutes(), sec = now.getSeconds();
  hr = hr &gt;= 12 ? hr-12 : hr;
  var _360 = 2*Math.PI;

  var angle;
  if (unit=='hr') {
    angle = hr*_360/12 + min*_360/(12*60) + sec*_360/(12*60*60);
  } else if (unit=='min') {
    angle = min*_360/60 // + sec*_360/(60*60);
  } else {
    angle = sec*_360/60;
  };

  var ctx = canvas.ctx;
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(-offset,0);
  ctx.lineTo(length,0);
  ctx.stroke();
  ctx.restore();
}
||&lt;
Dateオブジェクトを使って現在の時・分・秒を取得します
針の種類によって一度に進む量angleが異なるので場合分けします
ここでは時針は時刻の進行で少しずつ移動しますが
分針は60秒ごとに一気に１つ進むようにしています


clock.jsは以上です

**ローカルでの起動
これでローカルで実行する環境が整いました
早々立ち上げてみましょう
&gt;|ruby|
/Users/keyes/aclock% ruby clock.rb
== Sinatra/1.1.2 has taken the stage on 4567 for development with backup from Thin
&gt;&gt; Thin web server (v1.2.7 codename No Hup)
&gt;&gt; Maximum connections set to 1024
&gt;&gt; Listening on 0.0.0.0:4567, CTRL+C to stop
||&lt;

Ruby1.9.2でshotgunを利用する場合
カレントパスをロードする必要があるかもしれません
&gt;|ruby|
/Users/keyes/aclock% shotgun -I. clock.rb 
== Shotgun/WEBrick on http://127.0.0.1:9393/
[2011-02-18 18:28:47] INFO  WEBrick 1.3.1
[2011-02-18 18:28:47] INFO  ruby 1.9.2 (2010-12-25) [i386-darwin8.11.1]
[2011-02-18 18:28:47] INFO  WEBrick::HTTPServer#start: pid=1613 port=9393
||&lt;

**Herokuへのデプロイ
http://localhost:4567で問題なくアプリケーションが起動したら
Herokuにデプロイするためにconfig.ruとGemfileを用意します


config.ru
&gt;|ruby|
require &quot;bundler&quot;
Bundler.require
$LOAD_PATH &lt;&lt; File.expand_path(File.dirname(__FILE__))
require 'clock'
run Sinatra::Application
||&lt;


Gemfile
&gt;|ruby|
source :rubygems
gem &quot;sinatra&quot;
gem &quot;haml&quot;
||&lt;
Herokuに必要なgemsをインストールするために
BundlerというGem管理ツールを使います
Gemfileに必要なgemsを羅列し
config.ruではbundlerをrequireしてこれらを読み込むよう指定します


Bundlerをインストールして
installコマンドを実行します
&gt;|bash|
/Users/keyes/aclock% gem install bundler
/Users/keyes/aclock% bundle install
||&lt;
これでGemfileに記述したgemsが
アプリケーションで使えるようになります
同時にGemfile.lockが生成され
ローカルとHerokuで使われる
gemsのバージョンの一致が保証されます((http://devcenter.heroku.com/articles/bundler))


HerokuへのデプロイはgitとHeroku gemを使います
初回はSSHキーのセットアップなどが必要になりますが
説明は他サイトに譲ります((http://devcenter.heroku.com/articles/quickstart, http://d.hatena.ne.jp/ruedap/20110128/ruby_heroku_sinatra_hello_world))

&gt;|bash|
/Users/keyes/aclock% git init
/Users/keyes/aclock% git add .
/Users/keyes/aclock% git commit -m 'initial'
||&lt;


Heroku側にアプリケーションのレポジトリを用意し
git pushでデプロイします
&gt;|bash|
/Users/keyes/aclock% heroku create myclock
/Users/keyes/aclock% git push heroku master
||&lt;


早々アプリケーションを立ち上げましょう
&gt;|bash|
/Users/keyes/aclock% heroku open
||&lt;

うまくいかない場合はlogを見てみましょう
&gt;|bash|
/Users/keyes/aclock% heroku logs
||&lt;


さあ
あなたもCanvasを使ったサイトを立ち上げましょう！


enjoy your Canvas life!


ソースコードは以下にあります
[https://github.com/melborne/Approaching-Clock:title=]

</body>
</day>
<day date="2011-02-22" title="">
<body>
*p1*jQuery UIでCanvasアニメーションを操作しようよ
HTML5 Canvasがマイブームです
でも慣れないJavaScriptに悪戦苦闘しています
なかなかキレイにコードが書けません...


[http://crayovas.heroku.com/:title=]　[http://aclock.heroku.com/:title=]に続き
デモを作ったので公開します
jQuery UIのスライダーを使って
ボールの速度や色の属性を調整できます


まあ　それだけです..


[f:id:keyesberry:20110222190656p:image]


[http://eqball.heroku.com/:title=]


以下では前回のデモと異なる部分を中心に説明します
その他の箇所は前回の記事を読んでください


**ファイル構成
ファイル構成は次のようになります
&gt;|bash|
 .
 ├── Gemfile
 ├── Gemfile.lock
 ├── config.ru
 ├── eqball.rb
 ├── public
 │&amp;#160;&amp;#160; ├── css
 │&amp;#160;&amp;#160; │&amp;#160;&amp;#160; └── ui-lightness
 │&amp;#160;&amp;#160; │&amp;#160;&amp;#160;     ├── images
 │&amp;#160;&amp;#160; │&amp;#160;&amp;#160;     │&amp;#160;&amp;#160; ├── ui-bg_diagonals.. png
 │&amp;#160;&amp;#160; │&amp;#160;&amp;#160;     │&amp;#160;&amp;#160; ├── ui-bg_diagonals.. png
 │&amp;#160;&amp;#160; │&amp;#160;&amp;#160;     │&amp;#160;&amp;#160; ├──            :
 │&amp;#160;&amp;#160; │&amp;#160;&amp;#160;     │&amp;#160;&amp;#160; └── ui-icons_ffffff_256x240.png
 │&amp;#160;&amp;#160; │&amp;#160;&amp;#160;     └── jquery-ui-1.8.9.custom.css
 │&amp;#160;&amp;#160; └── javascripts
 │&amp;#160;&amp;#160;     └── eqball.js
 └── views
     ├── index.haml
     ├── layout.haml
     └── style.scss
||&lt;

デモではjQuery UIのslider widget((http://jqueryui.com/demos/slider/))を使っています
public/css/以下のファイル群はsliderのテーマファイルです
以下から取得してpublic以下に配置します


[http://jqueryui.com/download:title=]


**layout.haml
&gt;|ruby|
!!! 5
%html
  %head
    %meta{:'http-equiv' =&gt; 'Content-type', :content =&gt; 'text/html', :charset =&gt; 'utf-8'}
    %title= APP_TITLE
    %link{:rel =&gt; 'stylesheet', :href =&gt; '/style.css', :type =&gt; 'text/css'}
    %link{:rel =&gt; &quot;stylesheet&quot;, :href =&gt; &quot;/css/ui-lightness/jquery-ui-1.8.9.custom.css&quot;, :type =&gt; &quot;text/css&quot;}
    %script{:type =&gt; &quot;text/javascript&quot;, :src =&gt; &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.5.0/jquery.min.js&quot;, :charset =&gt; &quot;utf-8&quot; }
    %script{:type =&gt; &quot;text/javascript&quot;, :src =&gt; &quot;https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.9/jquery-ui.min.js&quot;, :charset =&gt; &quot;utf-8&quot; }
    %script{:type =&gt; &quot;text/javascript&quot;, :src =&gt; &quot;/javascripts/eqball.js&quot;, :charset =&gt; &quot;utf-8&quot; }
  %body
    = yield
||&lt;


スライダーのcssファイルにリンクを張ります
jQueryとjQuery UI本体はGoogleが提供するものを使います


**index.haml
&gt;|ruby|
%header
#main
  %h2 HTML5 Canvas &amp; jQuery UI Demo
  %canvas#eqball{:width =&gt; '1000px', :height =&gt; '500px'}Only for html5 adapted browsers
  -%w(size spx spy trail red green blue alpha).each do |id|
    .box
      %label{:for =&gt; id}= &quot;#{id}:&quot;
      %input{:id =&gt; id, :type =&gt; 'text', :style =&gt; &quot;color:#F6931F;font-weight:bold&quot;}
      %span.slider{:id =&gt; id}
%footer
  %a{:href =&gt; CREDIT[1]}=CREDIT[0]
||&lt;


ボールのサイズ　速度　軌跡　色を調整するために
８個のスライダーと対応するラベルを用意します


**eqball.js(1)
&gt;|javascript|
var canvas = {};
var ball = {
  radius : 35,
  x : 50,
  y : 50,
  spx : 10,
  spy : 10,
  color : 'rgba(30,30,30,1)'
};
var _360 = 2*Math.PI
var x = ball.radius, y = ball.radius;
var bg_alpha = 1.0;

$(document).ready(function(){
  
  setInterval(function(){ bounce(ball) }, 40);

  $(&quot;.slider&quot;).slider({ orientation: 'vertical', range: 'min' });
  
  $(&quot;.slider#size&quot;).slider({ min: 5, max: 75, value: ball.radius,
    slide: function(event, ui){
      ball.radius = ui.value;
      label($(this), ui);
    }
  });
})
||&lt;


ballオブジェクトを生成しsetInterval()で
bounce関数に一定周期で渡します
スライダーの初期設定と操作されたときのイベントを
$(&quot;.slider&quot;).sliderの引数として記述します
slideイベントでスライダーの値ui.valueを
ボールの各属性にセットします


後述のlabel関数でラベルの表示も変更します
ここでは
サイズを変更するスライダーのコードのみを示していますが
他のスライダーについても同じように記述します


**eqball.js(2)
&gt;|javascript|
function label (obj, ui) {
  var id = obj.attr('id');
  $(&quot;input#&quot;+id).val(ui.value);
}

function bounce (ball) {
  rad = ball.radius;
  if (ball.x &gt; canvas.width-rad || ball.x &lt; 0+rad) { ball.spx = -ball.spx };
  if (ball.y &gt; canvas.height-rad || ball.y &lt; 0+rad) { ball.spy = -ball.spy };
  ball.x += ball.spx;
  ball.y += ball.spy;

  var ctx = canvas.ctx
  fadeToClear(bg_alpha);
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, rad, 0, _360, true);
  ctx.fillStyle = ball.color;
  ctx.fill();
}

function fadeToClear (alpha) {
  var ctx = canvas.ctx;
  ctx.fillStyle = rgba(255,255,240,alpha);
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}
||&lt;


label関数でスライダーのラベルの表示を変更します
bounce関数でボールを描画します
キャンバスの境界でボールが反転するように
if条件でspx spyの向きを変えます
この反転条件は手抜きでボールが壁に沈んでしまいますが
ここではよしとします


fadeToClear関数でキャンバスをクリアしたのち
ctx.arc ~ ctx.fillでボールを描きます
fadeToClear関数はボールの軌跡を残せるように
clearRectせずに
alpha値を調整したキャンバスの色を再描画します


視覚に訴えるプログラミングも楽しいですね！


Enjoy Your Canvas Life!


ソースコードは以下にあります
[https://github.com/melborne/EQBall:title=]

</body>
</day>
<day date="2011-05-10" title="">
<body>
*p1*ABCでもマリオを奏でたいよ！
一年ほど前に_whyのbloopsaphoneを使って
マリオを再生できるBloopSongというRubyのDSLを書きました
bloopsaphoneでは
RTTTL(Ring Tone Text Transfer Language)という
携帯電話の電子音に使われる記譜法で書かれた音符を再生します


[http://d.hatena.ne.jp/keyesberry/20100527/p1#20100527f3:title=Rubyでマリオを奏でよう！ ～_whyのbloopsaphoneの紹介 - hp12c] 


でも時代はABCのようです


最近　このABC記譜法をレンダリングする
abcjsというjavascriptライブラリが公開されました((http://code.google.com/p/abcjs/))
このライブラリはすごいです
ABC記譜法による音符のテキストをもった
Webページにこのライブラリを読み込むと
瞬時にその楽譜と音源が自動生成されます!


以下のリンクのABC記譜法で書かれた楽譜を確認した上で
Afterのリンクをクリックしてみてください


http://drawthedots.com/abcplugin


その場で楽譜を打ち込めるエディタもあります


http://drawthedots.com/abcjs


こんな環境があれば当然
ここでもマリオを奏でたくなるというのが人情です
でも僕には
あの楽譜をまた打ち込むという気力は残っていません...


そんなわけで...


RTTTL記譜法をABC記譜法に変換する
Rtttl2ABCというライブラリを書きました!
はっきり言って楽譜を打ち込んだほうが早かったです...


[https://github.com/melborne/Rtttl2ABC:title=melborne/Rtttl2ABC - GitHub] 


そんな需要がないのは分かっていますので
使い方の説明はしませんが
久しぶりにマリオやゼルダのテーマを聞いてみたいという方は
サンプルのRubyコードを実行して
先程のエディタページに貼り付けてみてください
やっぱりマリオはいいですね！


enjoy!

</body>
</day>
<day date="2011-05-18" title="">
<body>
*p1*HTML5+CSS3でWebの未来を開こうよ！
GoogleがHTML5+CSS3に本気のようです


[http://b.hatena.ne.jp/articles/201105/3570:title=Chrome ウェブストア日本版スタート！ はてブディレクターがGoogleに聞いてみた - はてなブックマークニュース]


Googleが本気ならWebの未来はそちらにあるのでしょう
ここはひとつ
バスに乗り遅れないようにしたいですね！


HTML5+CSS3は複雑なJavaScriptのコードを書かずに
手軽にインタラクティブなサイトの実現を可能にします
以下のGoogleのサイトがとても参考になります


[http://www.html5rocks.com/:title=HTML5 Rocks - A resource for open web HTML5 developers]


なるほどWebの新しい可能性にわくわくしますね！


というわけで...


上のサイトを参考にして
自分でもCSS3の簡単なデモページを作ってみました
ChromeかSafariで見てください


[http://css3demo.heroku.com/:title=CSS3DEMO]


[f:id:keyesberry:20110518220916p:image]


基本的にやっていることは
ボタンの押下に反応してテキストのCSSを切り替えているだけです


**デモの説明
以下ではデモで使ったCSS3の各機能を簡単に説明します
なおJavaScriptはjQueryとCoffeeScriptを
HTMLはhaml　CSSはscssを使って書いています
これらの簡易言語を使うことによって
極めて少ない記述で効果的なWebページが作成できます


ベースとなるindex.hamlは以下の通りです


index.haml
&gt;|html|
%header
  %h1 CSS3 DEMO
#main
  .navibox
    %input#slider{:type =&gt; 'range', :min =&gt; 1, :max =&gt; 4, :value =&gt; 1}

    -%w(Web\ Font Text\ Stroke Gradient Shadow Transition Transform Navi\ Position).each do |navi|
      .button{:id =&gt; &quot;#{navi.downcase.delete(' ')}&quot;}= navi

  %p.textbox
    %strong Alice
    was beginning to get very tired of sitting by her... the use of a book,' thought
    %a{:href =&gt; &quot;http://alice...&quot;} Alice
    'without pictures or conversation?' So she was considering... when suddenly a White 
    %a{:href =&gt; &quot;http://rabbit...&quot;} Rabbit
    with pink eyes ran close by her. There was nothing so VERY... it-hole under the hedge...
||&lt;

HTML5ではinputタグのtype属性がいろいろ拡張されますが
ここではrangeを使ってスライダーコントロールを実現しています


**Rounded Corners
テキストボックスとボタンに角丸を適用します
角丸はborder-radiusプロパティで指定します


style.scss
&gt;|css|
  p.textbox { border-radius: 18px; }
  .button {
    border-radius: 3px;
    &amp;:hover { border-radius: 16px; }
  }
||&lt;


**Selectors + Data URL
新たなセレクタとData URLを使って
テキスト内のリンクに画像を埋め込みます


style.scss
&gt;|css|
  a { text-decoration: none; }
  a[href^=&quot;http&quot;]:after {
    content: url(data:image/png;base64,R0lGODlhCQAMAMQAAPr7/Cpdi6 ... GMHACSeDwKAQA7);
    padding-left: 2px;
  }
  a + a { color: #fc601b; }
  a + a + a { color: #33c87c; }
||&lt;
属性セレクタを使って
httpで始まるhrefプロパティを持ったaタグを対象にしています
そしてafter擬似要素でイメージを挿入する位置を指定しています
URLスキームにdataを使い
base64でエンコードした画像を埋め込みます
＋連結接合子で色付けするリンクを指定します


**Columns
スライダーコントロールを操作することで
テキストのコラム数を変化させます


app.coffee
&gt;|javascript|
$ -&gt;
  tbox = $(&quot;.textbox&quot;)

  $(&quot;#slider&quot;).change (event)-&gt;
    tbox.css 'webkitColumnCount', event.target.value
||&lt;

javascriptを使って
スライダーのchangeイベントが発生したときに
tboxのwebkitColumnCountプロパティの値に
スライダーの値がセットされるようにします


**Web Fonts
Webフォントを使うことによって
機種依存のないタイプフェイスを実現します
利用するフォントをcssで指定するために
@font-face規則を使います


style.scss
&gt;|css|
  @font-face {
    font-family: 'Droid Sans';
    font-style: normal;
    font-weight: bold;
    src: local('Droid Sans'), url('http://playground.html5rocks.com/samples/html5_misc/Droid_Sans.ttf') format('truetype');
  }
||&lt;


ボタン操作で複数のWebフォントを切り替えています


app.coffee
&gt;|javascript|
  ttexts = $(&quot;.textbox, .textbox&gt;*&quot;)
  fonts = ['Molengo', 'Vollkorn', 'Droid Sans', 'Verdana']

  $(&quot;.button#webfont&quot;).toggle(
    -&gt; ttexts.css('font-family', fonts[0]); $(this).text fonts[0]
    -&gt; ttexts.css('font-family', fonts[1]); $(this).text fonts[1]
    -&gt; ttexts.css('font-family', fonts[2]); $(this).text fonts[2]
    -&gt; ttexts.css('font-family', fonts[3]); $(this).text 'Web Font'
  )
||&lt;


**Text Stroke
Text Strokeを使っていわゆる袋文字を実現します
あらかじめText Strokeを適用したクラスを用意し
javascriptでこのクラスをテキストに適用するようにします


style.scss
&gt;|css|
  p.textstroke {
    -webkit-text-fill-color: orange;
    -webkit-text-stroke-color: red;
    -webkit-text-stroke-width: 1px;
  }
||&lt;


app.coffee
&gt;|javascript|
  $(&quot;.button#textstroke&quot;).toggle(
    -&gt; tbox.addClass('textstroke');    $(this).text 'Stroked'
    -&gt; tbox.removeClass('textstroke'); $(this).text 'Text Stroke'
  )
||&lt;


**Gradients
 -webkit-gradient属性を使って
ボタンとテキストにグラデーションを与えます


style.scss
&gt;|css|
  .button {
    background: -webkit-gradient(linear, left top, left bottom, from(#fff), to(#ddd));
    &amp;:hover {
      background: -webkit-gradient(linear, left top, left bottom, from(#ccc0f6), to(#cfe4fa));
    }
  }
||&lt;


app.coffee
&gt;|javascript|
  $(&quot;.button#gradient&quot;).toggle(
    -&gt;
      tbox.css 'background', '-webkit-gradient(linear, left top, left bottom, from(#49b9e9), to(#cceedd), color-stop(0.5, #ccc0f6))'
      $(this).text '#1'
    -&gt;
      tbox.css 'background', '-webkit-gradient(radial, center center, 0, center center, 800, to(#cceedd), from(#49b9ff), color-stop(0.5, #ccc0f6) )'
      $(this).text '#2'
    -&gt;
      tbox.css 'background', '-webkit-gradient(linear, left center, right center, from(#49b9e9), to(#cceedd), color-stop(0.5, #cceedd), color-stop(0.5, #49b9e9))'
      $(this).text '#3'
    -&gt;
      tbox.css 'background', '#eed'
      $(this).text 'Gradient'
  )
||&lt;
ボタンのtoggleイベントを使って
テキストのグラデーションの色や方向を切り替えています


**Text and Box Shadow
ボタンの押下でテキストとそのボックスに影を付けます


style.scss
&gt;|css|
  .shadow {
    text-shadow: rgba(64, 64, 64, 0.5) 6px 6px 4px;
    -webkit-box-shadow: rgba(0, 0, 128, 0.5) 6px 6px 6px;
  }
||&lt;


app.coffee
&gt;|javascript|
  $(&quot;.button#shadow&quot;).toggle(
    -&gt; elm.addClass(&quot;shadow&quot;) for elm in [tbox, $(this)]
    -&gt; elm.removeClass(&quot;shadow&quot;) for elm in [tbox, $(this)]
  )
||&lt;


**Transitions
 -webkit-transitionを使えば
CSS切り替え時の遷移をなめらかにすることができます


style.scss
&gt;|css|
  p.textbox { -webkit-transition: 1s ease-in-out; }
||&lt;
上の例のように
 -webkit-transitionの第1引数に対象の属性を指定しないと
transitionがすべての属性に対して適用されることになります((コラムの切り替えに遅延があるのはこのためです))
 -webkit-transition-propertyで
属性を指定することもできます((複数の属性指定がうまく動作しませんでした))


app.coffee
&gt;|javascript|
  $(&quot;.button#transition&quot;).toggle(
    -&gt;
      tbox.css 'margin', '0 0 0 100px'
      $(this).text 'left100'
    -&gt;
      tbox.css 'margin', '0 0 0 -200px'
      $(this).text 'left-200'
    -&gt;
      tbox.css 'margin', '0 0 0 0'
      $(this).text 'Transision'
  )
||&lt;


**2d Transforms
 -webkit-transform属性でテキストの形状をコントロールしています
先のtransitionがここでも適用されているため
動作がスムーズになっています


app.coffee
&gt;|javascript|
  $(&quot;.button#transform&quot;).toggle(
    -&gt;
      $(this).text 'rotate'
      tbox.css '-webkit-transform', 'rotate(-45deg)'
    -&gt;
      $(this).text 'rotate2'
      tbox.css '-webkit-transform', 'rotate(210deg)'
    -&gt;
      $(this).text 'scale'
      tbox.css '-webkit-transform', 'scaleX(0.7)'
    -&gt;
      $(this).text 'skew'
      tbox.css '-webkit-transform', 'skewX(30deg)'
    -&gt;
      $(this).text 'Transform'
      tbox.css '-webkit-transform', 'none'
  )
||&lt;


**Flex Box Model
 -webkit-boxを使うことによって
ボタンの横並びを実現します


style.scss
&gt;|css|
  .navibox {
    display: -webkit-box;
    -webkit-box-orient: horizontal;
    -webkit-box-align: center;
    -webkit-box-pack: center;
  }
||&lt;


javascriptで並びの向きと配置を切り替えます
app.coffee
&gt;|javascript|
  navbox = $(&quot;.navibox&quot;)
  $(&quot;#naviposition&quot;).toggle(
    -&gt; navbox.css {'-webkit-box-orient': 'vertical', 'position': 'absolute', 'top': '120px', 'left': '30px'}
    -&gt; navbox.css {'-webkit-box-orient': 'horizontal', 'position': 'relative', 'top': '0px', 'left': '0px'}
  )
||&lt;


以上です
ソースは以下にあります


[https://github.com/melborne/CSS3DEMO:title=melborne/CSS3DEMO - GitHub]

</body>
</day>
<day date="2011-06-03" title="">
<body>
*p1*SinatraはDSLなんかじゃない、Ruby偽装を使ったマインドコントロールだ！
Sinatraのサイトを開くとSinatraはDSLだと書いてある

&gt;&gt;
Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort:
(SinatraはRubyで手早くWebアプリケーションをつくるためのDSLです)
&lt;&lt;


DSLというのはDomain-Specific Language
つまり特定の目的に特化した言語のことだ
確かにSinatraはWebアプリケーションという
特定の目的のために作られたものだけれども
それは言語じゃない


それが言語といえるためにはオブジェクトのように
独立していて閉じてなきゃいけない((http://www.eonet.ne.jp/~human-being/sub2.html))
でもSinatraは独立も閉じてもなくて
Rubyに寄生することで存在している


いやSinatraは言語どころか
Rubyの上の専門用語ですらない


それが用語といえるためにはせりでの手やりのように
その専門の特別のルールで動かなきゃいけない((http://ja.wikipedia.org/wiki/%E5%B0%82%E9%96%80%E7%94%A8%E8%AA%9E))
でもSinatraはそれ専用のルールで動いてなくて
Rubyのルールで動いてる

&gt;|ruby|
  # myapp.rb
  require 'sinatra'
  
  get '/' do
    'Hello world!'
  end
||&lt;


上のコードをRubyで実行すればSinatraが動くけど
コードの中のgetはRubyの関数((Objectクラスに定義されたメソッド))呼び出しに過ぎない


irbで確かめてみよう

&gt;|ruby|
% irb -f
irb(main):001:0&gt; get '/' do
irb(main):002:1*  'Hello world!'
irb(main):003:1&gt; end
NoMethodError: undefined method `get' for main:Object
        from (irb):1
        from /Users/keyes/.rvm/rubies/ruby-1.9.2-p180/bin/irb:16:in `&lt;main&gt;'
||&lt;

Sinatraをrequireせずにgetを呼ぶと
Objectクラスのインスタンスmainにはgetメソッドは未定義とのエラーが出た


今度はSinatraをrequireしてgetを呼んでみよう
&gt;|ruby|
irb(main):004:0&gt; require 'sinatra'
=&gt; true
irb(main):005:0&gt; get '/' do
irb(main):006:1*  'Hello world!'
irb(main):007:1&gt; end
=&gt; [/^\/$/, [], [], #&lt;Proc:0x00000101331218@/Users/keyes/.rvm/gems/ruby-1.9.2-p180/gems/sinatra-1.2.6/lib/sinatra/base.rb:1152&gt;]
||&lt;

今度はgetが呼べた
そしてRegexpオブジェクトやProcオブジェクトを含んだ
Arrayオブジェクトが返された


それじゃカッコを省略せずにRubyの礼儀正しい構文で呼んでみよう
&gt;|ruby|
irb(main):008:0&gt; get('/') { 'Hello world!' }
=&gt; [/^\/$/, [], [], #&lt;Proc:0x0000010133bce0@/Users/keyes/.rvm/gems/ruby-1.9.2-p180/gems/sinatra-1.2.6/lib/sinatra/base.rb:1152&gt;]
irb(main):009:0&gt; 
||&lt;

同じ結果が返ってきた


ここでRubyのトップレベルで呼べる関数は
Objectクラスに定義された
プライベート・インスタンスメソッドであった
このことをputsで確認してみよう
&gt;|ruby|
irb(main):024:0&gt; Object.private_instance_methods.grep /^puts/
=&gt; [:puts]
||&lt;


しかしその定義の実態はObjectクラスにはなくて
それにインクルードされたKernelモジュールにあるのだった
&gt;|ruby|
irb(main):025:0&gt; Object.private_instance_methods(false).grep /^puts/
=&gt; []
irb(main):026:0&gt; Kernel.private_instance_methods(false).grep /^puts/
=&gt; [:puts]
||&lt;


じゃあ同様にgetもsinatraをrequireしたことによって
Objectクラスに定義されているはずだ
&gt;|ruby|
irb(main):027:0&gt; Object.private_instance_methods.grep /^get/
=&gt; [:get, :gets]
||&lt;

あった


さてその実態はやはりKernelにあるのだろうか
&gt;|ruby|
irb(main):028:0&gt; Object.private_instance_methods(false).grep /^get/
=&gt; []
irb(main):031:0&gt; Kernel.private_instance_methods(false).grep /^get/
=&gt; [:gets]
||&lt;

Kernelにはなかった...


そうすると想像できるのは
sinatraのrequireによってObjectクラスに
別のモジュールがインクルードされたということだ
確かめてみよう
&gt;|ruby|
irb(main):032:0&gt; Object.included_modules
=&gt; [Sinatra::Delegator, Kernel]
||&lt;


Sinatra::Delegatorというモジュールがインクルードされていた
じゃあここにgetメソッドが定義されているんだろう
&gt;|ruby|
irb(main):061:0&gt; Sinatra::Delegator.private_instance_methods(false).grep /^get/
=&gt; [:get]
||&lt;

やはりそうだった
Sinatraのソースコードで中身を確認してみよう

&gt;|ruby|
# base.rb
module Sinatra
  module Delegator #:nodoc:
    def self.delegate(*methods)
      methods.each do |method_name|
        eval &lt;&lt;-RUBY, binding, '(__DELEGATE__)', 1
          def #{method_name}(*args, &amp;b)
            ::Sinatra::Application.send(#{method_name.inspect}, *args, &amp;b)
          end
          private #{method_name.inspect}
        RUBY
      end
    end

    delegate :get, :put, :post, :delete, :head, :template, :layout,
             :before, :after, :error, :not_found, :configure, :set, :mime_type,
             :enable, :disable, :use, :development?, :test?, :production?,
             :helpers, :settings
  end
end
||&lt;


ちょっと分かりづらいけど
要はDelegator.delegateでDelegatorモジュールに
getプライベート・インスタンスメソッドを生成している
そしてその中身は受け取った引数とブロックをそのまま
Sinatra::Applicationクラスに定義されたgetクラスメソッドに
移譲するものとなっている


つまりsinatraをrequireしてトップレベルでgetを呼ぶと
Delegatorモジュールを介してSinatra::Applicationクラスの
getクラスメソッドが呼ばれる


irbで直接これを呼んで確かめてみよう
&gt;|ruby|
irb(main):037:0&gt; Sinatra::Application.get('/') { &quot;hello, world&quot; }
=&gt; [/^\/$/, [], [], #&lt;Proc:0x0000010131a9f0@/Users/keyes/.rvm/gems/ruby-1.9.2-p180/gems/sinatra-1.2.6/lib/sinatra/base.rb:1152&gt;]
||&lt;

期待通りの結果が返ってきた
じゃあその定義があるか確認してみよう
&gt;|ruby|
irb(main):051:0&gt; Sinatra::Application.singleton_methods(false).grep /^get/
=&gt; []
||&lt;

無い...
Sinatra::Applicationにはスーパークラスがあるのかな？
&gt;|ruby|
irb(main):053:0&gt; Sinatra::Application.superclass
=&gt; Sinatra::Base
||&lt;

Sinatra::BaseというのがSinatra::Applicationのスーパークラスだった
&gt;|ruby|
irb(main):055:0&gt; Sinatra::Base.singleton_methods(false).grep /^get/
=&gt; [:get]
||&lt;

getの定義はここにあった


一応ソースを確認してみよう
&gt;|ruby|
module Sinatra
  class Base
    class &lt;&lt; self
      def get(path, opts={}, &amp;block)
        conditions = @conditions.dup
        route('GET', path, opts, &amp;block)

        @conditions = conditions
        route('HEAD', path, opts, &amp;block)
      end

      def put(path, opts={}, &amp;bk);    route 'PUT',    path, opts, &amp;bk end
      def post(path, opts={}, &amp;bk);   route 'POST',   path, opts, &amp;bk end
      def delete(path, opts={}, &amp;bk); route 'DELETE', path, opts, &amp;bk end
      def head(path, opts={}, &amp;bk);   route 'HEAD',   path, opts, &amp;bk end

    private
      def route(verb, path, options={}, &amp;block)
        # Because of self.options.host
        host_name(options.delete(:bind)) if options.key?(:host)

        options.each {|option, args| send(option, *args)}

        pattern, keys = compile(path)
        conditions, @conditions = @conditions, []

        define_method &quot;#{verb} #{path}&quot;, &amp;block
        unbound_method = instance_method(&quot;#{verb} #{path}&quot;)
        block =
          if block.arity != 0
            proc { unbound_method.bind(self).call(*@block_params) }
          else
            proc { unbound_method.bind(self).call }
          end

        invoke_hook(:route_added, verb, path, block)

        (@routes[verb] ||= []).
          push([pattern, keys, conditions, block]).last
      end
    end
  end
end
||&lt;


要するにこういうことだ
sinatraをrequireするとトップレベルに書かれたgetは
あたかもSinatra::Baseクラスの中に書かれたように解釈されて
そこに定義されたクラスメソッドが呼ばれるのだ


試しにSinatra::Base.getを再定義してその効果を見てみよう
&gt;|ruby|
irb(main):075:0&gt; class Sinatra::Base
irb(main):076:1&gt;   def self.get(path)
irb(main):077:2&gt;     {path.intern =&gt; yield}
irb(main):078:2&gt;   end
irb(main):079:1&gt; end
=&gt; nil
irb(main):080:0&gt; get '/' do
irb(main):081:1*  &quot;hello , world!&quot;
irb(main):082:1&gt; end
=&gt; {:/=&gt;&quot;hello , world!&quot;}
||&lt;

うまくいった


つまり
SinatraはほんとうはRubyそのものなんだけど
その構文のユルさとメタプログラミングを使って専用言語を装い
ユーザをその独自の世界に引き込むべく
僕らをマインドコントロールしてたんだ！


もう僕はダマされないぞ！


関連記事：
+[http://d.hatena.ne.jp/keyesberry/20110605/p1:title=Sinatraに別構文があってもいいじゃないか！][http://d.hatena.ne.jp/keyesberry/20110605/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110607/p1:title=内部DSLを使って、RubyのWebフレームワークを書こう！][http://d.hatena.ne.jp/keyesberry/20110607/p1:bookmark]

</body>
<comments>
<comment>
<username>Dexter</username>
<body>Try http://github.com/padrino/padrino-framework</body>
<timestamp>1307315106</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;Dexterさん&lt;br&gt;情報どうもです</body>
<timestamp>1307324384</timestamp>
</comment>
</comments>
</day>
<day date="2011-06-05" title="">
<body>
*p1*Sinatraに別構文があってもいいじゃないか！
前の投稿でSinatraはRubyそのものでDSLじゃないと言いました


[http://d.hatena.ne.jp/keyesberry/20110603/p1:title=SinatraはDSLなんかじゃない、Ruby偽装を使ったマインドコントロールだ！][http://d.hatena.ne.jp/keyesberry/20110603/p1:bookmark]


確かに内部DSLというのはそういうものなのかもしれません
でも言語といったら独自の構文くらいはもっていたい
それで
コードをそのままRubyに通したら
Syntaxエラーになってほしい


ちょっと意味不明ですけど...


そんなわけで...


独自構文を持つSinatra
Chinatra を作りました ^^;((支那虎ということで...))
(ネタ注意！)


**使い方

&gt;|ruby|
#myroute.rb
get /
  haml :index

get /hi
  'hi, my friend!'

get /:name
  hello(params[:name])

helpers
  - hello(name)
    &quot;Wow you are #{name}!&quot; -
||&lt;
独自の構文です！
これはそのままRubyには通りません


以下のファイルを用意します
&gt;|ruby|
#app.rb
require_relative 'chinatra'
require 'myroute'
||&lt;
chinatraライブラリをrequireして
さらに先のmyroute.rbをrequireします
そしてこのapp.rbをrubyで実行します


&gt;|sh|
$ ruby app.rb

== Sinatra/1.2.6 has taken the stage on 4567 for development with backup from Thin
&gt;&gt; Thin web server (v1.2.11 codename Bat-Shit Crazy)
&gt;&gt; Maximum connections set to 1024
&gt;&gt; Listening on 0.0.0.0:4567, CTRL+C to stop
||&lt;


[f:id:keyesberry:20110605170347p:image]


独自構文のSinatraができました！


関連記事：[http://d.hatena.ne.jp/keyesberry/20110607/p1:title=内部DSLを使って、RubyのWebフレームワークを書こう！][http://d.hatena.ne.jp/keyesberry/20110607/p1:bookmark]


&lt;script src=&quot;https://gist.github.com/1008708.js?file=chinatra.rb&quot;&gt;&lt;/script&gt;

</body>
<comments>
<comment>
<username>tkawa</username>
<body>.rbさえつけなければとてもいいと思います！</body>
<timestamp>1307355473</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt; tkawaさん&lt;br&gt;ありがとうございます！.rbのところちょっとだけ直しました。</body>
<timestamp>1307365273</timestamp>
</comment>
</comments>
</day>
<day date="2011-06-07" title="">
<body>
*p1*内部DSLを使って、RubyのWebフレームワークを書こう！
Sinatraのようなベース言語の構文を使って実現するDSLを
内部DSLといいます
前回僕が書いた[http://d.hatena.ne.jp/keyesberry/20110605/p1:title=Chinatra]は一見内部DSLにみえるけど
ベース言語とは異なる構文を使った外部DSLです


でも時代の風は内部DSLに向いています


[http://www.rubyist.net/~matz/20091003.html:title=the 0.8 true language]
[http://capsctrl.que.jp/kdmsnr/wiki/bliki/?LanguageWorkbench:title=言語ワークベンチ]


自分もRubyの構文のユルさとメタプログラミングを使って
Sinatraのような内部DSLを書いてみたい


そしてRubyistをマインドコントロールしたい..




そんなわけで...




Sinatraと別の構文を持った
Webフレームワーク「Shynatra」をRubyで書きました:-)


ShynatraはRubyで下記のような最小労力で
手早くウェブアプリケーションを作成するためのDSLです
&gt;|ruby|
# myapp.rb
require &quot;shynatra&quot;

R/:hello./ {
  'Hello world!'
}
||&lt;

R はCRUDのRです
/:hello の部分はパス(/hello)になります
先頭のコロンはパラメータを表しているわけではありません
./ はパスの終端子です
気に入らなくても省略はできません
それでも気に入らない人は.| か ._ を使いましょう


Rubyに慣れていない方のために一言付け加えますが
これはよく使われる由緒正しきRubyの構文です..
解説はこちら((R./(Rクラスのクラスメソッド/)を引数付きで呼んでいる。引数には、:hello#/(シンボル:helloのインスタンスメソッド/)をブロック付きで呼んだ返り値が渡される))


ルートパスの指定にはnilを使います
&gt;|ruby|
R/nil./ {
  @message = message &quot;Shynatra&quot;
  haml :index
}

H/nil./ {
  def message(app)
    &quot;Welcome to #{app}!&quot;
  end
}
||&lt;
SinatraのHelpersに対応するのはHです
Hを使うときも無意味に/nil./ します


ええ
nilするんです


パスの区切りは_(アンダースコア)を使います
つまり/foo/barは以下のように指定します
&gt;|ruby|
R/:foo_bar./ {
  &quot;You are in: '/foo/bar'&quot;
}
||&lt;
当然
パス名にアンダースコアを含めることはできません


名前付きパラメータは@を前置します
&gt;|ruby|
R/:@name./ { 
  &quot;Hello, &quot; + params[:name]
}
||&lt;
この場合もコロンは必須です
忘れてはいけません


名前付きパラメータをルート以外で使いたいこともあるでしょう
そのときは6を使います
&gt;|ruby|
R/:foo_6name./ {
  &quot;You are in: '/foo/:name' with '#{params[:name]}'&quot;
}

R/:foo_6bar_baz_6name./ {
  &quot;You are in '/foo/:bar/baz/:name' with :bar =&gt; #{params[:bar]}, :name =&gt; #{params[:name]}&quot;
}
||&lt;
ええ
数字の6です
冗談じゃなく


解説は以上です
CRUDのC U D も多分動くと思います
詳細はコードを見てくださいね


Rubyの内部DSLであなたも**natraしてみませんか？


関連記事：
+[http://d.hatena.ne.jp/keyesberry/20110603/p1:title=SinatraはDSLなんかじゃない、Ruby偽装を使ったマインドコントロールだ！][http://d.hatena.ne.jp/keyesberry/20110603/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110605/p1:title=Sinatraに別構文があってもいいじゃないか！][http://d.hatena.ne.jp/keyesberry/20110605/p1:bookmark]


&lt;script src=&quot;https://gist.github.com/1008708.js?file=shynatra.rb&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2011-06-22" title="">
<body>
*p1*知って得する21のRubyのトリビアな記法 ~ 21 Trivia Notations you should know in Ruby

ちょっとトリビアだけど
知っていると意外と便利なRubyの記法を
21個拾ってみたよ(Ruby1.9限定)


君なら全部知ってるかもしれないけど..


**1. 動的継承
Rubyのクラス継承では &lt; 記号の右辺に
クラス定数だけでなくクラスを返す式が書けるよ
&gt;|ruby|
 class Male
  def laugh; 'Ha ha ha!' end
 end
 class Female
  def laugh; 'Fu fu fu..' end
 end

 class Me &lt; [Male, Female][rand 2]

 end
 Me.superclass # =&gt; Female
 Me.new.laugh # =&gt; 'Fu fu fu..'
||&lt;

&gt;|ruby|
 def io(env=:development)
   env==:test ? StringIO : IO
 end

 env = :test
 class MyIO &lt; io(env)

 end
 MyIO.superclass #=&gt; StringIO
||&lt;
つまりRubyでは条件に応じて継承するクラスを
動的に変えることができるんだよ

**2. 大文字メソッド
Rubyでは通常メソッド名には英小文字を使うけど
英大文字も許容されてるんだよ
大文字メソッドは一見定数に見えるよね
&gt;|ruby|
 class Google
   def URL
     'www.google.com'
   end
   private :URL
   def search(word)
     get( URL(), word)
   end
 end
||&lt;
定数は継承サブクラスで参照されるけど
これを非公開にしたいこともあるよね
そんなときには大文字メソッドがいいかもね


引数がないときでもカッコを省略できないという欠点があるけど
関連する複数の定数を定義するときなんかも便利に使えるよ
&gt;|ruby|
 class Google
   def search(word, code=:us)
     get( URL(code), word )
   end

   def URL(code)
     { us: 'www.google.com',
       ja: 'www.google.co.jp' }[code]
   end
   private :URL
||&lt;
僕は「定数メソッド」って呼んでるんだけど
どうかな？

**3. メソッド引数のスペース
Rubyで引数付きメソッドを呼ぶとき
そのカッコを省略できるけど
引数がシンボルであればさらに
メソッド名との間のスペースも省略できるよ
&gt;|ruby|
 def name(sym)
   @name = sym
 end

 name:charlie # =&gt; :charlie
||&lt;
こうするとより宣言的に見えるよね


また* &amp;の後ろのスペースは無視されるから
次のような書き方ができるよ
&gt;|ruby|
 def teach_me(question, * args, &amp; block)
   google(question, * args, &amp; block)
 end

 a, b, * c = 1,2,3,4
 c # =&gt; [3,4]
||&lt;
だからどうした
って話だけど...

**4. 関数部分適用
似たようなメソッドを複数書くことはDRY原則に反するよね
Proc#curryを使えばこれを回避できるかもね
四季判定関数の例を示すね
&gt;|ruby|
 require &quot;date&quot;
 
 season = -&gt;range,date{ range.include? Date.parse(date).mon }.curry
 
 is_spring = season[4..6]
 is_summer = season[7..9]
 is_autumn = season[10..12]
 is_winter = season[1..3]
 
 is_autumn['11/23'] # =&gt; true
 is_summer['1/1'] # =&gt; false
||&lt;
こうなると変数名に ? が使えるとうれしいんだけどなあ

**5. Procによるcase判定
Procの実行はcallメソッドを呼ぶことで実現できるけど
Proc#===はその別名になってるんだよ
先の四季判定関数をcase式で使う例で使い方を見るね
&gt;|ruby|
 for date in %w(2/4 11/23 6/14 8/3)
   act = 
     case date
     when is_spring; 'Wake up!'
     when is_summer; 'Cool down!'
     when is_autumn; 'Read!'
     when is_winter; 'Sleep!'
     end
   puts &quot;#{date} =&gt; #{act}&quot;
 end
 # &gt;&gt; 2/4 =&gt; Sleep!
 # &gt;&gt; 11/23 =&gt; Read!
 # &gt;&gt; 6/14 =&gt; Wake up!
 # &gt;&gt; 8/3 =&gt; Cool down!
||&lt;
引数の受け渡しが暗黙的に行われるので
case式が非常にすっきりするよね

**6. Structクラス
属性主体のクラスを生成するときにはStructが便利だよね
&gt;|ruby|
 module Fortune
   class Teller
     require &quot;date&quot;
     def self.ask(name, age, occupation)
       Date.today.next_day(rand 10)
     end
   end
 end
 
 class Person &lt; Struct.new(:name, :age, :occupation)
   def length_of_life(date)
     (Fortune::Teller.ask(name, age, occupation) - Date.parse(date)).to_i
   end
 end
 
 charlie = Person.new('charlie', 13, :programmer)
 charlie.length_of_life('2011/6/22') # =&gt; 3
||&lt;


実はStruct.newはブロックを取れるから
下のような書き方もできるんだよ
&gt;|ruby|
 Person = Struct.new(:name, :age, :occupation) do
   def length_of_life(date)
     (Fortune::Teller.ask(name, age, occupation) - Date.parse(date)).to_i
   end
 end

 charlie = Person.new('charlie', 13, :programmer)
 charlie.length_of_life('2011/6/22') # =&gt; 3
||&lt;

**7. retryと引数デフォルト
rescue節ではretryを使うことによって
そのブロックの処理を再実行させることができるよね
これをメソッド引数のデフォルト値と組み合わせることで
便利に使えるときがあるんだ
&gt;|ruby|
 require &quot;date&quot;
 def last_date(date, last=[28,29,30,31])
   d = Date.parse date
   Date.new(d.year, d.mon, last.pop).day rescue retry
 end
 
 last_date '2010/6/1' # =&gt; 30
 last_date '2010/2/20' # =&gt; 28
 last_date '2008/2' # =&gt; 29
||&lt;
この例では31日からDateオブジェクトの生成を試して
例外が発生するとretryにより次の日付を試していく


まあ上のはこれでいいんだけど...
&gt;|ruby|
 Date.new(2009,2,-1).day # =&gt; 28
||&lt;

**8. 否定
否定に使われる ! あるいは not が好きじゃない人いる？
ならBasicObject#!があるよ！
&gt;|ruby|
 true.! # =&gt; false
 false.! # =&gt; true
 1.! # =&gt; false
 'hello'.!.! # =&gt; true
||&lt;
...


次に行きます..

**9. ％ノーテーション
String#%を使うことで文字列に
指定フォーマットでオブジェクトを埋め込めるけど
%は配列を受け取れるんだ
&gt;|ruby|
 lang = [:ruby, :java]
 &quot;I love %s, not %s&quot; % lang # =&gt; &quot;I love ruby, not java&quot;
||&lt;


それだけじゃなくて実はハッシュも取れるんだよ
&gt;|ruby|
 lang = {a: :java, b: :ruby}
 &quot;I love %{b}, not %{a}&quot; % lang # =&gt; &quot;I love ruby, not java&quot;
||&lt;

**10. 文字列区切り
文字列を各文字に区切るには
String#splitかString#charsが使えるよね
&gt;|ruby|
 alpha = &quot;abcdefghijklmnopqrstuvwxyz&quot;
 alpha.split(//) # =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
 
 alpha.chars.to_a # =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
||&lt;


でも文字列を複数文字単位で区切るには
String#scanが便利だよ
&gt;|ruby|
 alpha.scan(/.../) # =&gt; [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqr&quot;, &quot;stu&quot;, &quot;vwx&quot;]
 alpha.scan(/.{1,3}/) # =&gt; [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqr&quot;, &quot;stu&quot;, &quot;vwx&quot;, &quot;yz&quot;]
 
 number = '12345678'
 def number.comma_value
   reverse.scan(/.{1,3}/).join(',').reverse
 end
 number.comma_value # =&gt; &quot;12,345,678&quot;
||&lt;

**11. Array#*
Array#*に整数を渡すとそれを繰り返した
新たな配列を返すけど
文字列を渡すとそれをセパレータとした
連結文字列を返すjoinの役割を果たすよ
&gt;|ruby|
 [1, 2, 3] * 3 # =&gt; [1, 2, 3, 1, 2, 3, 1, 2, 3]
 
 [2009, 1, 10] * '-' # =&gt; &quot;2009-1-10&quot;
||&lt;

**12. Arrayスタック系メソッド
Array#&lt;&lt;は一つのオブジェクトしか引数に取れないんだけど
Array#pushは複数取れるんだ
またArray#popは一度に複数の値をポップできる
Array#unshift Array#shiftも同じだよ
&gt;|ruby|
 stack = []
 stack.push 1, 2, 3 # =&gt; [1, 2, 3]
 stack.pop 2 # =&gt; [2, 3]
 stack # =&gt; [1]
 stack.unshift 4, 5, 6 # =&gt; [4, 5, 6, 1]
 stack.shift 3 # =&gt; [4, 5, 6]
 stack # =&gt; [1]
||&lt;


また任意位置の複数の値を取り出す場合は
Array#values_atが便利だよ
&gt;|ruby|
 lang = %w(ruby python perl haskell lisp scala)
 lang.values_at 0, 2, 5 # =&gt; [&quot;ruby&quot;, &quot;perl&quot;, &quot;scala&quot;]
||&lt;

**13. Array#uniq
配列から重複した値を取り除くときはArray#uniqを使うけど
uniqはブロックを取れるから
そこで重複の条件を指定できるんだ
&gt;|ruby|
 Designer = Struct.new(:name, :lang)
 data = {'matz' =&gt; :ruby, 'kay' =&gt; :smalltalk, 'gosling' =&gt; :java, 'dhh' =&gt; :ruby}
 designers = data.to_a.map { |name, lang| Designer[name, lang] }
 
 designers.uniq.map(&amp;:name) # =&gt; [&quot;matz&quot;, &quot;kay&quot;, &quot;gosling&quot;, &quot;dhh&quot;]
 designers.uniq{ |d| d.lang }.map(&amp;:name) # =&gt; [&quot;matz&quot;, &quot;kay&quot;, &quot;gosling&quot;]
||&lt;

**14. Kernel#Array
異なる型の引数を統一的に処理するときには
Kernel#Arrayが便利だよ
&gt;|ruby|
 Array 1 # =&gt; [1]
 Array [1,2] # =&gt; [1, 2]
 Array 1..5 # =&gt; [1, 2, 3, 4, 5]
 
 require &quot;date&quot;
 def int2month(nums)
   Array(nums).map { |n| Date.new(2010,n).strftime &quot;%B&quot;  }
 end
 
 int2month(3) # =&gt; [&quot;March&quot;]
 int2month([2,6,9]) # =&gt; [&quot;February&quot;, &quot;June&quot;, &quot;September&quot;]
 int2month(4..8) # =&gt; [&quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;]
||&lt;

**15. 文字列リスト%w
文字列のリストを作るときには%ｗリテラルが便利だけど
文字列が空白文字を含むときは
バックスラッシュでエスケープすればいいよ
&gt;|ruby|
 designers = %w(John\ McCarthy Yukihiro\ Matsumoto Larry\ Wall Alan\ Kay Martin\ Odersky)
 designers # =&gt; [&quot;John McCarthy&quot;, &quot;Yukihiro Matsumoto&quot;, &quot;Larry Wall&quot;, &quot;Alan Kay&quot;, &quot;Martin Odersky&quot;]
||&lt;

**16. 要素区切りコンマ
配列とハッシュの各要素の区切りにはコンマが使われるけど
最後の要素のカンマは無視されるんだよ
&gt;|ruby|
 p designers = [
                 &quot;John McCarthy&quot;,
                 &quot;Yukihiro Matsumoto&quot;,
                 &quot;Larry Wall&quot;,
                 &quot;Alan Kay&quot;,
                 &quot;Martin Odersky&quot;,
               ]
 
 # &gt;&gt; [&quot;John McCarthy&quot;, &quot;Yukihiro Matsumoto&quot;, &quot;Larry Wall&quot;, &quot;Alan Kay&quot;, &quot;Martin Odersky&quot;]
 
 p designers = {
                 :lisp =&gt; &quot;John McCarthy&quot;,
                 :ruby =&gt; &quot;Yukihiro Matsumoto&quot;,
                 :perl =&gt; &quot;Larry Wall&quot;,
                 :smalltalk =&gt; &quot;Alan Kay&quot;,
                 :scala =&gt; &quot;Martin Odersky&quot;,
               }
 
 # &gt;&gt; {:lisp=&gt;&quot;John McCarthy&quot;, :ruby=&gt;&quot;Yukihiro Matsumoto&quot;, :perl=&gt;&quot;Larry Wall&quot;, :smalltalk=&gt;&quot;Alan Kay&quot;, :scala=&gt;&quot;Martin Odersky&quot;}
||&lt;
要素を頻繁に追加・削除したり
ファイルからevalするときなどにいいかもね

**17. ハッシュリテラル
Ruby1.9ではハッシュの新しい記法が導入されたけど
これは古い記法と混在できるんだ
&gt;|ruby|
 designers1 = {
               :lisp =&gt; &quot;John McCarthy&quot;,
               :ruby =&gt; &quot;Yukihiro Matsumoto&quot;,
               :perl =&gt; &quot;Larry Wall&quot;,
               :smalltalk =&gt; &quot;Alan Kay&quot;,
               :'C++' =&gt;  &quot;Bjarne Stroustrup&quot;,
             }
 
 designers2 = {
               java: &quot;James Gosling&quot;,
               python: &quot;Guido van Rossum&quot;,
               javascript: &quot;Brendan Eich&quot;,
               scala: &quot;Martin Odersky&quot;,
             }
 
 designers = designers1.merge designers2
  # =&gt; {:lisp=&gt;&quot;John McCarthy&quot;, :ruby=&gt;&quot;Yukihiro Matsumoto&quot;, :perl=&gt;&quot;Larry Wall&quot;, :smalltalk=&gt;&quot;Alan Kay&quot;, :&quot;C++&quot;=&gt;&quot;Bjarne Stroustrup&quot;, :java=&gt;&quot;James Gosling&quot;, :python=&gt;&quot;Guido van Rossum&quot;, :javascript=&gt;&quot;Brendan Eich&quot;, :scala=&gt;&quot;Martin Odersky&quot;}
||&lt;

**18. Enumerable#each_with_object
Enumerable#injectは便利なメソッドだけど
ブロック内で条件指定をするような場合でも各イテレーションで
畳込みオブジェクトが返されることを保証しなければならないよ
&gt;|ruby|
 designers.inject([]) { |mem, (lang, name)| mem &lt;&lt; [name,lang]*'/' if lang[/l/]; mem }
  # =&gt; [&quot;John McCarthy/lisp&quot;, &quot;Larry Wall/perl&quot;, &quot;Alan Kay/smalltalk&quot;, &quot;Martin Odersky/scala&quot;]
||&lt;
ブロックの最後の「; mem」の部分だよ


Enumerable#each_with_objectならその手間は要らないよ
&gt;|ruby|
 designers.each_with_object([]) { |(lang, name), mem| mem &lt;&lt; [name,lang]*'/' if lang[/l/] }
  # =&gt; [&quot;John McCarthy/lisp&quot;, &quot;Larry Wall/perl&quot;, &quot;Alan Kay/smalltalk&quot;, &quot;Martin Odersky/scala&quot;]
||&lt;
名前が長いからどうしても避けちゃうけどね..
reduceにマッピングしてくれたらうれしいなあ

**19. Kernel#loop
無限の繰り返しはコードのブロックを
Kernel#loopに渡すことで実現できるよね
&gt;|ruby|
 require &quot;mathn&quot;
 prime = Prime.each
 n = 0
 loop do
   printf &quot;%d &quot; % prime.next
   break if n &gt; 10
   n += 1
 end
 # &gt;&gt; 2 3 5 7 11 13 17 19 23 29 31 37 
||&lt;


ここでloopにブロックを渡さないとEnumeratorが返るんだよ
これを利用すればloopのインデックスを作ることができるよ((@no6v1さんに教えていただきました. http://friendfeed.com/no6v1/0d7a24e4/loop-with_index-_-i-break-if-p-3-qt-merborne))
&gt;|ruby|
 loop # =&gt; #&lt;Enumerator: main:loop&gt;
 
 loop.with_index do |_,n|
   printf &quot;%d &quot; % prime.next
   break if n &gt; 10
 end
 # &gt;&gt; 2 3 5 7 11 13 17 19 23 29 31 37 
||&lt;
ブロックの第1引数がnilになっちゃうけど..

**20. splat展開
Rubyでアルファベットの配列を作るときなどは
通常以下のようにするよね
&gt;|ruby|
 (1..20).to_a # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
 ('a'..'z').to_a # =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
 (1..10).to_a + (20..30).to_a # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
||&lt;


これは*(splat)展開を使って
以下のようにも書けるよ
&gt;|ruby|
 [*1..20] # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
 [*'a'..'m'] # =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;]
 [*1..10, *20..30] # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
||&lt;

**21. 前置コロン
文字列をシンボルに変換するときは通常
String#internかString#to_symを使うけど
文字列リテラルにコロンを前置することでも可能だよ
&gt;|ruby|
 'goodbye'.intern # =&gt; :goodbye
 'goodbye'.to_sym # =&gt; :goodbye
 
 :'goodbye' # =&gt; :goodbye
 
 a = 'goodbye'
 :&quot;#{a}&quot; # =&gt; :goodbye
||&lt;

長かったけどこれで説明を終わるよ
知らないものいくつあった？


よかったら僕にも君のトリビア教えてね！


第2弾を書いたよ!
[http://d.hatena.ne.jp/keyesberry/20120208/p1:title=第2弾!知って得する12のRubyのトリビアな記法 ~ 12 Trivia Notations you should know in Ruby - hp12c]


(追記：2011-6-26) 21の「文字列にコロンを」を「文字列リテラルにコロンを」に変更しました。
(追記：2011-6-27) 2の「カッコを省略できないという欠点があるけど」を「引数がないときでもカッコを省略できないという欠点があるけど」に変更しました。

</body>
<comments>
<comment>
<username>ujihisa</username>
<body>&gt; カッコを省略できないという欠点があるけど&lt;br&gt;省略できます</body>
<timestamp>1308789451</timestamp>
</comment>
<comment>
<username>sora_h</username>
<body>:&quot;aaa&quot; は別のリテラル</body>
<timestamp>1308793787</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;ujihisaさん&lt;br&gt;コメントありがとう。でも僕の1.9.2p180環境だとuninitialized constantとなってしまうんです。最新版が必要なのかな&lt;br&gt;&lt;br&gt;&gt;sora_hくん&lt;br&gt;コメントありがとう&lt;br&gt;それは別のシンボルという意味ですか？&lt;br&gt;でも:hello.equal? :&#39;hello&#39; #=&gt; true になるよ</body>
<timestamp>1308804777</timestamp>
</comment>
<comment>
<username>sora_h</username>
<body>&quot;aaa bbb&quot;のシンボルを作りたい時に:&quot;aaa bbb&quot;することができるようになっている． 文字列を作る &quot;&quot; リテラルの手前に : をつけるとsymbolのリテラルにはなるが，文字列のオブジェクトの手前に:をつけてもならないよね?&lt;br&gt;:&quot;&quot;という別のリテラルがある．リテラルは &quot;String&quot; や 1 (数値)や &#39;String&#39; や [Array] などの事ね．</body>
<timestamp>1309063488</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;sora_hくん&lt;br&gt;なるほど確かにそうですね。記述を少し直しました。ありがとう。</body>
<timestamp>1309066233</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;ujihisaさん&lt;br&gt;あーやっとわかりました。係り受けが曖昧でしたね。記述を直しました。</body>
<timestamp>1309129549</timestamp>
</comment>
<comment>
<username>s-:</username>
<body>-&gt; も curry もその存在を知らずに読んでちょっとビックリ。&lt;br&gt;&lt;br&gt;-&gt;range,date{...}.curry より&lt;br&gt;&lt;br&gt;-&gt;range{-&gt;date{...}} がわりやすいかなと思いました</body>
<timestamp>1309229812</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;s-:さん&lt;br&gt;コメントありがとう。あーこの例だとそれでもよいですね。ただcurryは動的に引数の数を変えられるのがいいんですよね- :)</body>
<timestamp>1309238367</timestamp>
</comment>
</comments>
</day>
<day date="2011-06-26" title="">
<body>
*p1*Rubyのpでメソッドチェーンを覗き見よう！
Rubyでメソッドチェーンの途中経過を覗き見るには
Kernel#tapが便利だよね
&gt;|ruby|
 (1..10).tap{ |x| puts x.inspect }
        .to_a.tap{ |x| puts x.inspect }
        .select { |x| x % 2 == 0 }.tap{ |x| puts x.inspect }
        .map { |x| x * x }.tap{ |x| puts x.inspect }
 
 # &gt;&gt; 1..10
 # &gt;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 # &gt;&gt; [2, 4, 6, 8, 10]
 # &gt;&gt; [4, 16, 36, 64, 100]
||&lt;

tapのブロックにはもちろんいろいろな手続が書けるけど
やっぱり出力系メソッドがよく使われると思うんだ


それならいっそのこと
それらのメソッドがselfを返すようにして
しかも引数を取らないときには
selfが引数になるようにしたら
もっと簡単になるんじゃないかと思ったんだ

&gt;|ruby|
 module Kernel
   [:p, :puts].each do |m|
     alias :&quot;__#{m}__&quot; :&quot;#{m}&quot;
     define_method(m) do |obj=self|
       instance_eval &quot;__#{m}__(obj)&quot;
       self
     end
   end
 end
||&lt;


こうしておけば
先の例は次のように書けるんだよ
&gt;|ruby|
 (1..10).p.to_a.p.select { |x| x % 2 == 0 }.p.map { |x| x * x }.p
 
 # &gt;&gt; 1..10
 # &gt;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 # &gt;&gt; [2, 4, 6, 8, 10]
 # &gt;&gt; [4, 16, 36, 64, 100]
||&lt;
どうかな？


他の例も示しておくね
&gt;|ruby|
 %w(google twitter facebook).map(&amp;:capitalize).puts.map(&amp;:upcase) # =&gt; [&quot;GOOGLE&quot;, &quot;TWITTER&quot;, &quot;FACEBOOK&quot;]
 
 # &gt;&gt; Google
 # &gt;&gt; Twitter
 # &gt;&gt; Facebook
 
 
 require &quot;mathn&quot;
 Prime.each(30).map(&amp;:p)
 
 # &gt;&gt; 2
 # &gt;&gt; 3
 # &gt;&gt; 5
 # &gt;&gt; 7
 # &gt;&gt; 11
 # &gt;&gt; 13
 # &gt;&gt; 17
 # &gt;&gt; 19
 # &gt;&gt; 23
 # &gt;&gt; 29
 
 
 class Array
   def to_h
     Hash[self]
   end
 end
 
 [:GOOG,:YHOO,:MSFT].zip(['google','yahoo','microsoft']).p
                    .to_h.p
                    .each_with_object({}) { |(k,v), h| h[k] = &quot;www.#{v}.com&quot; }.p
 
 # &gt;&gt; [[:GOOG, &quot;google&quot;], [:YHOO, &quot;yahoo&quot;], [:MSFT, &quot;microsoft&quot;]]
 # &gt;&gt; {:GOOG=&gt;&quot;google&quot;, :YHOO=&gt;&quot;yahoo&quot;, :MSFT=&gt;&quot;microsoft&quot;}
 # &gt;&gt; {:GOOG=&gt;&quot;www.google.com&quot;, :YHOO=&gt;&quot;www.yahoo.com&quot;, :MSFT=&gt;&quot;www.microsoft.com&quot;}
||&lt;

先の実装だとオリジナルのメソッドに
ちょっと制限が掛かっちゃうけど((複数の引数が取れないなど))
簡単に途中経過を見れるのはよさそうだよね


既出のアイディアだったら許してね


(追記：2011-6-26) やっぱりありました ^^; こちらはpの拡張ではないのですが、まあ発想は同じです。https://github.com/esminc/tapp (https://twitter.com/#!/mori_dev/status/84845033634799616)

</body>
<comments>
<comment>
<username>tuto0621</username>
<body>面白かったです、特にmapメソッドの間に挟むといいですね。&lt;br&gt;&lt;br&gt;似たようなやつで、pの内容と一緒にRubyのクラス階層やメソッドを表示する&#39;rubywho&#39;ってのを作ったことがあります。 &lt;br&gt; http://d.hatena.ne.jp/tuto0621/20110616/1308192321</body>
<timestamp>1310521613</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;tuto0621さん&lt;br&gt;コメントどうも！なるほど、デバッグでオブジェクト情報も全部出しちゃおうってことですね！</body>
<timestamp>1310536681</timestamp>
</comment>
</comments>
</day>
<day date="2011-06-28" title="">
<body>
*p1*sleep sortに対抗してrunning sortだ！（Ruby版｜失敗に終わる編）
少し前にsleep sortという
ソートアルゴリズムが発見されたよね


[http://d.hatena.ne.jp/gfx/20110519/1305810786:title=常識を覆すソートアルゴリズム！その名も&quot;sleep sort&quot;！]


これをRubyのThreadを使って実現すると
だいたい次のようになるんだよ
&gt;|ruby|
class Array
  def sleep_sort
    mem = []
    map do |i|
      Thread.new(i) do |n|
        sleep n
        mem &lt;&lt; n
      end
    end.each(&amp;:join)
    mem
  end
end

a = (1..10).sort_by { rand } # =&gt; [1, 2, 10, 6, 4, 5, 9, 7, 8, 3]
a.sleep_sort # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
||&lt;


美しいよね
これほどシンプルで安定なソートの方法が今さら発見されるなんて
アルゴリズムの世界はほんとうに奥深いね


先のsleep sortの実装では整数のソートしかできないけれど
ちょっと改良すれば文字のソートにも対応できるんだよ
&gt;|ruby|
class Array
  def sleep_sort
    mem = []
    map do |i|
      Thread.new(i) do |n|
        sleep n.ord         # ここを改良
        mem &lt;&lt; n
      end
    end.each(&amp;:join)
    mem
  end
end

a = (1..10).sort_by { rand }
a.sleep_sort

s = ('a'..'g').sort_by { rand }
s.sleep_sort
||&lt;


実行してみるよ...



...




...





...




...




&gt;|ruby|
a.sleep_sort # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

s.sleep_sort # =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]
||&lt;


ね？


...


sleep sortの唯一の小さな欠点は実行時間だね
それはソート対象の最大整数値と線形の関係にあるんだ


でもその問題も以下のようにすれば低減できる
&gt;|ruby|
class Array
  def sleep_sort
    mem = []
    map do |i|
      Thread.new(i) do |n|
        sleep Math.log(n.ord)        # ここを改良
        mem &lt;&lt; n
      end
    end.each(&amp;:join)
    mem
  end
end

t = Time.now
a = (1..10).sort_by { rand } # =&gt; [7, 9, 1, 2, 10, 6, 3, 5, 8, 4]
a.sleep_sort # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Time.now - t # =&gt; 2.304315

t = Time.now
s = ('a'..'g').sort_by { rand } # =&gt; [&quot;a&quot;, &quot;d&quot;, &quot;b&quot;, &quot;f&quot;, &quot;g&quot;, &quot;e&quot;, &quot;c&quot;]
s.sleep_sort # =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]
Time.now - t # =&gt; 4.635888
||&lt;
sleepにそのままの数値を渡すんじゃなくて
その対数を渡すことによって
最大値との関係は指数の逆数になる


つまりこの例では20倍の高速化！
&gt;|ruby|
n = 'g'.ord # =&gt; 103
Math.log(n) #=&gt; 4.634728988229636
||&lt;


もうこれで
来るRuby2.0のEnumerable#sortの実装は決まりだね！


と言いたいところだけれど
Rubyはもっと早くならなきゃいけないんだよ
これじゃまたRubyのボトルネックが増えてしまうよ




そんなわけで...


僕もsleep sortに対抗して
running sortというソートアルゴリズムを考えてみたよ!


running sortは各スレッドを
ソートアイテムの整数値に応じてsleepさせるのではなくて
その整数値に応じてより多く走らせるアルゴリズムだよ
実装の一例を示すね
&gt;|ruby|
class Array
  def running_sort
    ths, mem = [], []
    each_index do |i|
      ths &lt;&lt; Thread.new(i, self.dup) do |n, _self; res|
        (n+1).times { res = _self.delete_min }
        mem &lt;&lt; res
      end
    end
    ths.each(&amp;:join)
    mem
  end

  def delete_min
    min_idx = find_index { |item| item == self.min }
    delete_at(min_idx)
  end
end

a = (1..10).sort_by { rand } # =&gt; [5, 8, 10, 1, 3, 4, 7, 6, 9, 2]
a.running_sort # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

b = [4,2,9,34,8,98,3,2,64]
b.running_sort # =&gt; [2, 2, 3, 4, 8, 9, 34, 64, 98]

s = ('a'..'g').sort_by { rand } # =&gt; [&quot;g&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;a&quot;, &quot;b&quot;, &quot;e&quot;]
s.running_sort # =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]
||&lt;
sleep sortのようなソート対象アイテムの制限もないし
実行時間も早いよ((対sleep sort比))


アルゴリズムを簡単に説明すると次のようになるよ
+各スレッドにidを付けると共にソート対象の配列selfのコピーを渡す
+各スレッドではselfからid番目に小さい値を取り出して、スレッド間での共有メモリmemに入れる((Array#minを使うのはちょっとルール違反だけど大目にね))
+id番目に小さい値の取り出しは最小値をid回取り出す操作を繰り返すことにより行い、これによってid値に応じてスレッドの仕事量が変わる


新しいソートアルゴリズムの発見だよ！
これで僕の名前も歴史に刻まれることになるよ！


と
言いたいところだけれど...


ご想像のとおり
スレッド間の処理時間のバラつきにより
これはうまく機能しないんだよ...
&gt;|ruby|
a = (1..100).sort_by { rand } # =&gt; [86, 34, 23, 12, 25, 87, 80, 7, 77, 73, 51, 15, 3, 100, 24, 69, 33, 66, 44, 94, 58, 31, 26, 82, 81, 42, 18, 74, 19, 32, 17, 59, 75, 29, 46, 62, 41, 68, 91, 36, 98, 49, 97, 9, 95, 37, 79, 1, 61, 10, 78, 27, 65, 30, 6, 90, 48, 22, 55, 60, 93, 83, 8, 54, 40, 4, 47, 70, 56, 14, 45, 21, 20, 67, 63, 64, 76, 13, 52, 2, 16, 96, 50, 84, 89, 92, 39, 35, 85, 88, 28, 99, 38, 71, 72, 5, 11, 53, 57, 43]

r1 = a.running_sort # =&gt; [1, 2, 3, 4, 5, 7, 8, 11, 12, 14, 16, 18, 6, 9, 13, 17, 20, 21, 22, 23, 24, 25, 26, 27, 29, 30, 31, 33, 34, 36, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 70, 72, 76, 77, 81, 85, 89, 94, 10, 15, 19, 32, 35, 38, 40, 42, 46, 48, 52, 56, 60, 64, 68, 69, 73, 74, 79, 80, 83, 84, 87, 88, 91, 92, 93, 96, 97, 28, 44, 50, 54, 62, 71, 78, 82, 86, 90, 98, 99, 100, 58, 75, 95, 66]

s = ('a'..'z').sort_by { rand } # =&gt; [&quot;x&quot;, &quot;p&quot;, &quot;h&quot;, &quot;z&quot;, &quot;d&quot;, &quot;e&quot;, &quot;r&quot;, &quot;u&quot;, &quot;y&quot;, &quot;m&quot;, &quot;a&quot;, &quot;b&quot;, &quot;g&quot;, &quot;v&quot;, &quot;c&quot;, &quot;o&quot;, &quot;w&quot;, &quot;l&quot;, &quot;q&quot;, &quot;i&quot;, &quot;n&quot;, &quot;k&quot;, &quot;s&quot;, &quot;f&quot;, &quot;t&quot;, &quot;j&quot;]

r2 = s.running_sort # =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;o&quot;]

r1 == a.sort # =&gt; false
r2 == s.sort # =&gt; false
||&lt;

いい線いってるんだけどなー...
ファジーソートとかってカテゴリないかな..


関連記事：[http://d.hatena.ne.jp/keyesberry/20101012/p1:title=Rubyでソート・アルゴリズムを表現しよう!]

</body>
</day>
<day date="2011-06-29" title="">
<body>
*p1*Enumerable#thread_withでRubyのスレッドを簡単に使おう！
前回の投稿ではsleep sortと
それに対抗したrunning sortを紹介したよ


[http://d.hatena.ne.jp/keyesberry/20110628/p1:title=sleep sortに対抗してrunning sortだ！（失敗に終わる編）][http://d.hatena.ne.jp/keyesberry/20110628/p1:bookmark]


それらのアルゴリズムではRubyのThreadを使ったけど
Threadってなんか毎回書き方を忘れるよ
引数の受け渡し方とかjoinとか
もっと簡単にスレッディングしたいのにねぇ...


それでEnumerableなオブジェクトに対して
渡したブロックを並列処理してくれる
メソッドがあれば便利かなと考えたんだよ
それならスレッドの実装のことを忘れて
対象の処理のことだけ考えればいいからね


で
Enumerable#thread_withというメソッドを書いてみたよ((まあThreadの使い方そのまんまなんだけど..))
&gt;|ruby|
module Enumerable
  def thread_with
    mem = []
    map do |*item|
      Thread.new(*item) do |*_item|
        mem &lt;&lt; yield(*_item)
      end
    end.each(&amp;:join)
    mem
  end
end
||&lt;

Enumerable#thread_withがあれば
sleep sortは簡単だよ
&gt;|ruby|
a = (1..10).sort_by { rand } # =&gt; [9, 3, 10, 8, 4, 5, 7, 2, 6, 1]

a.thread_with { |i| sleep i } # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
||&lt;


効率を良くしたければ
次のようにすればいいし
&gt;|ruby|
a = (1..10).sort_by { rand } # =&gt; [9, 3, 10, 8, 4, 5, 7, 2, 6, 1]

a.thread_with { |i| sleep Math.log(i); i } # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
||&lt;


もう少し真面目な例を挙げるね


複数のWebサイトに並列的にアクセスして
そこからimgタグを拾ってくる例を示すよ
ここではベンチマークを取って
スレッドを使わない例と比べているよ
&gt;|ruby|
require &quot;benchmark&quot;
require &quot;open-uri&quot;

a = %w(www.nintendo.co.jp www.google.com www.yahoo.co.jp www.nikkei.com www.ruby-lang.org)
blk = -&gt;item { open(&quot;http://#{item}&quot;).read.scan(/&lt;img .*?&gt;/) }

Benchmark.bmbm do |x|
  x.report { a.map(&amp;blk)  }
  x.report { a.thread_with(&amp;blk) }
end

# &gt;&gt; Rehearsal ------------------------------------
# &gt;&gt;    0.110000   0.040000   0.150000 (  1.112704)
# &gt;&gt;    0.020000   0.020000   0.040000 (  0.243304)
# &gt;&gt; --------------------------- total: 0.190000sec
# &gt;&gt; 
# &gt;&gt;        user     system      total        real
# &gt;&gt;    0.040000   0.010000   0.050000 (  0.756259)
# &gt;&gt;    0.020000   0.010000   0.030000 (  0.242218)
||&lt;
なんかThreadが身近になった感じがしない？


ただ先の実装には１つ問題があるよ
それはもとの配列の順位がthread_withの返り値として
保証されないことだよ((まあそれがスレッドなんだけど))
&gt;|ruby|
a = (1..1000).map { |i| i**2 }
b = (1..1000).thread_with { |i| i**2 }
a == b # =&gt; false
||&lt;


でも以下のようにすれば一応もとの順位は保証できるんだ
&gt;|ruby|
module Enumerable
  def thread_with(order=false)
    mem = []
    map.with_index do |*item, i|
      Thread.new(*item) do |*_item|
        mem &lt;&lt; [i, yield(*_item)]
      end
    end.each(&amp;:join)
    (order ? mem.sort : mem).map(&amp;:last)
  end
end


a = (1..1000).map { |i| i**2 }
b = (1..1000).thread_with(true) { |i| i**2 }
a == b # =&gt; true
||&lt;
つまりthread_withが引数を取るようにして
trueを渡せば
最後にもとの配列の順位にソートしてくれる


まあ
たいしたネタじゃなかったね..

</body>
</day>
<day date="2011-07-01" title="">
<body>
*p1*Rubyのrepeat関数でフィボナッチ、トリボナッチ、テトラナッチ！
１または複数の初期値に任意の関数を繰り返し適用して
その結果のリストを返す汎用関数repeatを定義しよう
&gt;|ruby|
def repeat(f, *args)
  Enumerator.new { |y| loop { y &lt;&lt; (*args = f[*args]) } }
end
||&lt;
repeatは関数f((正確には[]メソッドでcallされる手続きオブジェクト))とfの初期値となるargsを引数に取り
Enueratorオブジェクトを返す


Enumeratorのブロックの中では
loopによってargsを関数fに適用した結果が
繰り返しyつまりEnumerable::Yielderオブジェクトに渡される


次にフィボナッチだ
&gt;|ruby|
def fib
  -&gt;a,b{ [b, a+b] }
end
||&lt;
fib関数は数列上の並んだ2つの数a,bを取り
次の並びとしてその上位の数bとa,bの和の組を返す


さあ
今作成した2つの関数repeatとfibを使って
フィボナッチ数列の第20位までを求めよう
&gt;|ruby|
fibonacci = repeat(fib, 0, 1)
fibonacci.take(20).map(&amp;:first) # =&gt; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]
||&lt;


もちろんfib関数は高階関数である必要はない
通常の関数でいい
&gt;|ruby|
def fibm(a, b)
  [b, a+b]
end
||&lt;


ただしこの場合は関数をオブジェクト化して
repeat関数に渡す必要がある
&gt;|ruby|
fibonacci = repeat(method(:fibm), 0, 1)
fibonacci.take(20).map(&amp;:first) # =&gt; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]
||&lt;


次はトリボナッチだ((http://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0))
フィボナッチが前2項の和を取るのに対して
トリボナッチは前3項の和を取る
&gt;|ruby|
def tribo
  -&gt;a,b,c{ [b, c, a+b+c] }
end
||&lt;


これをrepeat関数に渡して結果を得よう
&gt;|ruby|
tribonacci = repeat(tribo, 0, 0, 1)
tribonacci.take(20).map(&amp;:first) # =&gt; [0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890]
||&lt;


そしてテトラナッチだ
テトラナッチは前4項の和を取る
&gt;|ruby|
def tetra
  -&gt;a,b,c,d{ [b, c, d, a+b+c+d] }
end
||&lt;


同じくrepeat関数に渡して結果を得よう
&gt;|ruby|
tetranacci = repeat(tetra, 0, 0, 0, 1)
tetranacci.take(20).map(&amp;:first) # =&gt; [0, 0, 1, 1, 2, 4, 8, 15, 29, 56, 108, 208, 401, 773, 1490, 2872, 5536, 10671, 20569, 39648]
||&lt;


このように１つのrepeat関数を定義することで
フィボナッチ、トリボナッチ、テトラナッチの各数列を
容易に導きだすことができた


もちろん
repeat関数の応用範囲は数列の算出に留まらない
ニュートンラプソン法による平方根の算出は次のようになる
&gt;|ruby|
def sqrt
  -&gt;n,x{ (x + n/x) / 2.0 }.curry
end

sqrt3 = repeat(sqrt[3], 1.0).take(10).last # =&gt; 1.7320508075688772
sqrt5 = repeat(sqrt[5], 1.0).take(10).last # =&gt; 2.23606797749979
sqrt7 = repeat(sqrt[7], 1.0).take(10).last # =&gt; 2.6457513110645907
||&lt;


(追記:2011-7-1)
さらに進んでEnumerable#repeatというのはどうだろうか
&gt;|ruby|
module Enumerable
  def repeat
    x = self
    Enumerator.new { |y| loop { y &lt;&lt; (x = yield x) }}
  end
end
||&lt;

Enumerable#repeatはselfに初期値を与え
ブロックで繰り返し適用する関数を定義する


このメソッドを使った先の演算は以下のようになる
&gt;|ruby|
fibonacci = [0,1].repeat { |a, b|  [b, a+b] }

fibonacci.take(20).map(&amp;:first) # =&gt; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]

tribonacci = [0,0,1].repeat { |a,b,c|  [b, c, a+b+c] }

tribonacci.take(20).map(&amp;:first) # =&gt; [0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890]

tetranacci = [0,0,0,1].repeat { |a, b, c, d|  [b, c, d, a+b+c+d] }

tetranacci.take(20).map(&amp;:first) # =&gt; [0, 0, 1, 1, 2, 4, 8, 15, 29, 56, 108, 208, 401, 773, 1490, 2872, 5536, 10671, 20569, 39648]

sq5 = [5, 1.0].repeat { |n, x|  [n, (x + n/x) / 2.0] }

sq5.take(10).last.last # =&gt; 2.23606797749979
||&lt;


このほうがRubyっぽいかもしれない


関連記事：
+[http://d.hatena.ne.jp/keyesberry/20090111/p1:title=Rubyでフィボナッチ、トリボナッチ、テトラナッチ！そして僕はヒトリボッチ(2009-01-11)][http://d.hatena.ne.jp/keyesberry/20090111/p1:bookmark]
+[http://d.hatena.ne.jp/keyesberry/20110201/p1:title=Rubyを使って「なぜ関数プログラミングは重要か」を解読しよう！(その３)(2011-02-01)][http://d.hatena.ne.jp/keyesberry/20110201/p1:bookmark]

</body>
</day>
<day date="2011-07-07" title="">
<body>
*p1*RubyでHaskellの数列リストを真似てみよう！
HaskellのリストはRubyの配列と同じように
要素をカンマ区切りのカッコで区切って生成できるんだ
&gt;|haskell|
Hugs&gt; [1, 2, 3]
[1,2,3]
Hugs&gt; ['a', 'b', 'c']
&quot;abc&quot;
Hugs&gt; [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
[&quot;one&quot;,&quot;two&quot;,&quot;three&quot;]
||&lt;


だけどHaskellのリストは
Rubyの配列よりもその記法に柔軟性があり
新しい集合を作るための演算式を書けるリスト内包表記や
数列を簡単に生成できる便利な記法があるんだよ


数列を生成する記法は以下のような感じだよ
&gt;|haskell|
Hugs&gt; [1..10]
[1,2,3,4,5,6,7,8,9,10]
Hugs&gt; [21..31]
[21,22,23,24,25,26,27,28,29,30,31]
Hugs&gt; ['a'..'m']
&quot;abcdefghijklm&quot;
||&lt;
Haskellでは文字列は文字のリストなので
最後の結果はaからmの文字列になるんだね


Rubyで上の式をそのまま書くと
１つのRangeオブジェクトをもつ配列と解釈されちゃうんだけど
 *(splat)展開を使うと同じことができるんだよ
&gt;|ruby|
[*1..10] #=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
[*21..31] #=&gt; [21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
[*'a'..'m'] #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;]
||&lt;
これは[http://d.hatena.ne.jp/keyesberry/20110622/p1:title=以前の投稿]でも紹介したよね


でもHaskellの数列展開ではさらに
次のようなこともできちゃうんだよ
&gt;|haskell|
Hugs&gt; [1, 3..10]
[1,3,5,7,9]
Hugs&gt; [0, 5..50]
[0,5,10,15,20,25,30,35,40,45,50]
Hugs&gt; [1.1, 2.3..10]
[1.1,2.3,3.5,4.7,5.9,7.1,8.3,9.5]
Hugs&gt; ['a', 'c'..'m']
&quot;acegikm&quot;
Hugs&gt; ['A', 'I'..'z']
&quot;AIQYaiqy&quot;
||&lt;
すごいよね？
いわゆる等差数列が簡単にできちゃった


それだけじゃないんだ
等差数列の無限リストだってできちゃうんだよ！
&gt;|haskell|
Hugs&gt; take 20 [1, 9..]
[1,9,17,25,33,41,49,57,65,73,81,89,97,105,113,121,129,137,145,153]
Hugs&gt; take 20 ['A', 'D'..]
&quot;ADGJMPSVY\\_behknqtwz&quot;
||&lt;

使うかどうかはわからないけど
なんかかっこいいよねZen-Codingみたいで！



そんなわけで..



Rubyでも
これと似たようなことをできるようにしてみるね


Rubyでは[1, 3..10]も有効な構文なので
これをそのまま展開するのは都合が悪いよね
だからここではArray#to_aを拡張して
数列展開するようにしてみるよ

&gt;|ruby|
class Array
  alias __to_a__ to_a
  def to_a
    if [Numeric, Range] === self
      n, range = self
      dist = range.begin - n
      res = Enumerator.new { |y| loop { y &lt;&lt; n; n += dist } }
      return res.take_while { |i| i &lt;= range.end }
    end
    __to_a__
  end
end
||&lt;
だいたいこんな感じでどうかな？


配列の要素が数字とRangeのセットの場合に特別な扱いをするよ
if節の条件式の実装はあとで見せるね
最初の数字とRangeの先頭との差distを取って
Enumeratorで等差数列を作るよ
そしてEnumerator#take_whileを使って
Rangeの最後までの数列を返すようにする


if節の条件で使ったArray#===の実装は次のような感じだよ
&gt;|ruby|
class Array
  alias __eq__ ===
  def ===(other)
    if self.size == other.size and any? { |item| item.instance_of? Class }
      other = other.to_enum
      return all? { |item| item === other.next }
    end
    __eq__(other)
  end
end
||&lt;


さあ実行してみるよ
&gt;|ruby|
[1,2,3,4].to_a # =&gt; [1, 2, 3, 4]
[1..10].to_a # =&gt; [1..10]
[1, 3..10].to_a # =&gt; [1, 3, 5, 7, 9]
[0, 5..50].to_a # =&gt; [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
||&lt;
いい感じだね


でもFloatを渡すと..
&gt;|ruby|
[1.1, 2.3..10].to_a # =&gt; [1.1, 2.3, 3.4999999999999996, 4.699999999999999, 5.899999999999999, 7.099999999999998, 8.299999999999997, 9.499999999999996]
||&lt;
浮動小数点演算における丸め誤差がでちゃうんだ


bigdecimalというライブラリを使うと
丸め誤差の問題を回避できるようなんだけど
ここではFloat#to_iを改良してごまかしてみるね
&gt;|ruby|
class Float
  alias __to_i__ to_i
  def to_i(n=0)
    n &gt; 0 ? (self*10**n).__to_i__/10.0**n : __to_i__
  end
end

1.23456.to_i # =&gt; 1
1.23456.to_i(1) # =&gt; 1.2
1.23456.to_i(2) # =&gt; 1.23
1.23456.to_i(3) # =&gt; 1.234
||&lt;
Float#to_iが切り捨てする小数点桁数を
引数として取れるようにする


これを使ってArray#to_aを変更しよう
&gt;|ruby|
class Array
  alias __to_a__ to_a
  def to_a(decimal=1)　# 小数点2位以上は引数を渡す
    if [Numeric, Range] === self
      n, range = self
      dist = range.begin - n
      res = Enumerator.new { |y| loop { y &lt;&lt; n; n += dist } }
      return res.take_while { |i| i &lt;= range.end }
                .map { |i| i.to_i(decimal) rescue i }  # ここを追加
    end
    __to_a__
  end
end

[1, 3..10].to_a # =&gt; [1, 3, 5, 7, 9]
[0, 5..50].to_a # =&gt; [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
[1.1, 2.3..10].to_a # =&gt; [1.1, 2.3, 3.4, 4.6, 5.8, 7.0, 8.2, 9.4]
[1.11, 2.32..10].to_a(2) # =&gt; [1.11, 2.31, 3.52, 4.73, 5.94, 7.15, 8.36, 9.57]
||&lt;
いい感じだね！


さあ次は
アルファベットの等差数列だ


ここでもArray#to_aはあまりいじりたくないので
Stringクラスで算術演算できるようにしてみよう
つまりString#+ が数字を受け取ったときは
その文字コード分シフトした文字を返すようにする
またString#- を定義して文字を受け取ったときは
その文字コードの差を返すようにする
&gt;|ruby|
class String
  alias __plus__ +
  def +(other)
    if other.is_a? Integer
      return (self.ord + other).chr
    end
    __plus__(other)
  end

  def -(other)
    case other
    when String
      self.ord - other.ord
    when Integer
      (self.ord - other).chr
    else
      raise ArgumentError
    end
  end
end

'a' + 5 # =&gt; &quot;f&quot;
'f' - 'a' # =&gt; 5
'f' - 5 # =&gt; &quot;a&quot;
||&lt;
なんとなく汎用性がありそうだよね


こうすればArray#to_aは条件判定の
NumericをObjectに代えるだけでいい((手抜きですね^^;))
&gt;|ruby|
class Array
  alias __to_a__ to_a
  def to_a(decimal=1)
    if [Object, Range] === self # NumericをObjectに変更
      n, range = self
      dist = range.begin - n
      res = Enumerator.new { |y| loop { y &lt;&lt; n; n += dist } }
      return res.take_while { |i| i &lt;= range.end }
                .map { |i| i.to_i(decimal) rescue i }
    end
    __to_a__
  end
end

['a', 'c'..'m'].to_a # =&gt; [&quot;a&quot;, &quot;c&quot;, &quot;e&quot;, &quot;g&quot;, &quot;i&quot;, &quot;k&quot;, &quot;m&quot;]
['A', 'I'..'z'].to_a # =&gt; [&quot;A&quot;, &quot;I&quot;, &quot;Q&quot;, &quot;Y&quot;, &quot;a&quot;, &quot;i&quot;, &quot;q&quot;, &quot;y&quot;]
[1, 3..10].to_a # =&gt; [1, 3, 5, 7, 9]
[0, 5..50].to_a # =&gt; [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
[1.1, 2.3..10].to_a # =&gt; [1.1, 2.3, 3.4, 4.6, 5.8, 7.0, 8.2, 9.4]
[1.11, 2.32..10].to_a(2) # =&gt; [1.11, 2.31, 3.52, 4.73, 5.94, 7.15, 8.36, 9.57]
||&lt;
うまくいったね


さあ
最後は無限リストだ
Rubyでは[1, 3..]という記法は構文エラーになるので
Rangeの最後が-1(文字の場合は'-1')なら
無限リストにするのはどうかな


Array#to_aの変更は簡単だよ
&gt;|ruby|
class Array
  alias __to_a__ to_a
  def to_a(decimal=1)
    if [Object, Range] === self
      n, range = self
      dist = range.begin - n
      res = Enumerator.new { |y| loop { y &lt;&lt; n; n += dist } }
      unless range.end.to_s.to_i &lt; 0   # ここを追加
        return res.take_while { |i| i &lt;= range.end }
                  .map { |i| i.to_i(decimal) rescue i }
      else
        return res                     # ここを追加
      end
    end
    __to_a__
  end
end
||&lt;
Array#to_aの内部ではEnumeratorを使っているので
Enumerable#take_whileしなければ
そのまま無限リストが返るよ


さあ実行してみよう
&gt;|ruby|
[1, 9..-1].to_a.take 20 # =&gt; [1, 9, 17, 25, 33, 41, 49, 57, 65, 73, 81, 89, 97, 105, 113, 121, 129, 137, 145, 153]
['A', 'D'..'-1'].to_a.take 20 # =&gt; [&quot;A&quot;, &quot;D&quot;, &quot;G&quot;, &quot;J&quot;, &quot;M&quot;, &quot;P&quot;, &quot;S&quot;, &quot;V&quot;, &quot;Y&quot;, &quot;\\&quot;, &quot;_&quot;, &quot;b&quot;, &quot;e&quot;, &quot;h&quot;, &quot;k&quot;, &quot;n&quot;, &quot;q&quot;, &quot;t&quot;, &quot;w&quot;, &quot;z&quot;]
||&lt;
うまくいったよ！


Haskellには敵わないけど
Rubyも柔軟だってことが
この投稿で伝わったらうれしいよ


(追記：2011-7-9)
ああ　Rubyには偉大なるRange#stepがあったんだね
通りすがりさんありがとう！


だからわざわざ上のようなことをしなくても
大体のことはできるんだよ
&gt;|ruby|
(1..10).to_a #=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
(1..10).step(2).to_a #=&gt; [1, 3, 5, 7, 9]
(1.1..10).step(1.2).to_a #=&gt; [1.1, 2.3, 3.5, 4.699999999999999, 5.9, 7.1, 8.299999999999999, 9.5]
('a'..'m').step(2).to_a #=&gt; [&quot;a&quot;, &quot;c&quot;, &quot;e&quot;, &quot;g&quot;, &quot;i&quot;, &quot;k&quot;, &quot;m&quot;]
('A'..'z').step('I'.ord-'A'.ord).to_a #=&gt; [&quot;A&quot;, &quot;I&quot;, &quot;Q&quot;, &quot;Y&quot;, &quot;a&quot;, &quot;i&quot;, &quot;q&quot;, &quot;y&quot;]
||&lt;


またNumeric#stepもあるから
数字なら以下のように書いてもいいよね
&gt;|ruby|
1.step(10).to_a #=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
1.step(10, 2).to_a #=&gt; [1, 3, 5, 7, 9]
1.1.step(10, 1.2).to_a #=&gt; [1.1, 2.3, 3.5, 4.699999999999999, 5.9, 7.1, 8.299999999999999, 9.5]
||&lt;


こうなるとString#stepもほしいよね
こんな感じかな？
&gt;|ruby|
class String
  def step(last, nxt=self.next)
    x, dist = self.ord, nxt.ord-self.ord
    Enumerator.new { |y|
      until x &gt; last.ord
        y &lt;&lt; x.chr
        x += dist
      end
    }
  end
end

'a'.step('m', 'c').to_a # =&gt; [&quot;a&quot;, &quot;c&quot;, &quot;e&quot;, &quot;g&quot;, &quot;i&quot;, &quot;k&quot;, &quot;m&quot;]
'A'.step('z', 'I').to_a # =&gt; [&quot;A&quot;, &quot;I&quot;, &quot;Q&quot;, &quot;Y&quot;, &quot;a&quot;, &quot;i&quot;, &quot;q&quot;, &quot;y&quot;]
'a'.step('m').to_a # =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;]
||&lt;



&lt;script src=&quot;https://gist.github.com/1069573.js?file=haskell_sequence.rb&quot;&gt;&lt;/script&gt;

</body>
<comments>
<comment>
<username>通りすがり</username>
<body>(1..4).to_a  # =&gt; [1, 2, 3, 4]&lt;br&gt;&lt;br&gt;(1..10).step(2).to_a # =&gt; [1, 3, 5, 7, 9]&lt;br&gt;&lt;br&gt;(0..50).step(5).to_a # =&gt; [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]&lt;br&gt;&lt;br&gt;(1.1 .. 10).step(1.2).to_a # =&gt; [1.1, 2.3, 3.5, 4.7, 5.9, 7.1, 8.3, 9.5]</body>
<timestamp>1310182656</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;通りすがりさん&lt;br&gt;コメントどうもです。あーなんという... そうですRubyにはRange#stepがあったのですよね..</body>
<timestamp>1310193127</timestamp>
</comment>
</comments>
</day>
<day date="2011-07-11" title="">
<body>
*p1*HerokuでSinatraでmemcachedしようよ!
「NoSQL データベースファーストガイド」(著：佐々木達也)
という本を読んでるよ
各種NoSQLのひと通りの説明と
それぞれにRubyを使ったサンプルがあって
僕のようなNoSQL知識ゼロ(NoKnowledge)
の人にとってはとてもためになるよ
特にサンプルは各NoSQLの利用状況を想定して作られているから
実用的でうれしいよね


[asin:4798029599:detail]


その中に音楽視聴ランキングサイトの楽しいサンプルがあるんだよ
それはGyaoの音楽ランキングに基づいて
YouTubeから対応動画を取ってきてリスト表示するというものだよ
一度アクセスしたデータは
memcachedを使ってサイト側で保持することで
サイトのレスポンスを良くすると共に
他サイトへの負荷を下げるという例だよ


早速僕も同じようなサイトを作って
memcachedの使い方を学ぶよ
本の例はRailsをベースにしてるんだけど
僕はRailsをよく知らないのでここではSinatraを使うよ
そして折角だからHerokuにpushもしてみるね


**memcached
環境はOSX Snow Leopardだよ
ローカルでmemcachedを使うには
brew install memcachedすればいいよ
very verboseモードでの起動はこうだよ
&gt;|bash|
 $ memcached -vv
||&lt;


Herokuでmemcachedを使う場合は
add-onするだけでいいみたいなんだ((http://devcenter.heroku.com/articles/memcache))
&gt;|bash|
 $ heroku addons:add memcache
||&lt;
5MBまでは無料だけど((http://addons.heroku.com/memcache))add-onを利用するには
クレジットカード情報などによる登録が必要だよ
登録しないで上のコマンドを実行すると
登録サイトを教えてくれるからそれに従ってね


最初にmemcachedは何かということなんだけれども
僕はこれをリクエスト間の共有メモリ空間と理解したんだ
普通Webサーバはステートレスつまり
ユーザからの各リクエストは別々のメモリ空間で処理されるんだけど
memcachedを使うと多数のリクエストが
一つの共有メモリ空間を利用できるようになる
つまりmemcachedはWebサーバをステートフルにする
こう理解したんだけどあってるかな？


**GyaoRankサイト
さて最終的にでき上がったものは以下にあるよ


http://gyaorank.heroku.com/


まあ見た目がちゃちいけど
サンプルだから許してね..
調べたらGyaoでは
音楽以外のランキングデータも配信していたので((http://www.redcruise.com/search.php?srcstr=GyaO))
ここではそれらにも対応してみたよ
ヒット率がかなり悪いけど..


ファイル構成をまず示すよ
&gt;|bash|
├── Gemfile
├── Gemfile.lock
├── app.rb
├── config.ru
├── system_extensions.rb
└── views
    ├── index.haml
    ├── layout.haml
    └── style.scss
||&lt;


Gemfileの中身は以下のとおりだよ
&gt;|ruby|
source :rubygems
gem 'sinatra'
gem 'haml'
gem 'sass'
gem 'dalli'
gem 'nokogiri'
||&lt;
本の例ではmemcachedのRubyインタフェースに
memcache-clientというのを使ってるんだけど
HerokuではSASL((Simple Authentication and Security Layer))という
セキュリティ上の認証ができるgemしか使えないようなんだ
だからSASLに対応したDalliという
変わった名前のgemを使っているよ
余談だけどdalliとnokogiriを並べて書くと
僕にはdankogaiに見えてしょうがないんだよ!


SinatraでDalliを使うときは例えば以下のようにするよ
&gt;|ruby|
set :cache, Dalli::Client.new(ENV['MEMCACHE_SERVERS'],
                    :username =&gt; ENV['MEMCACHE_USERNAME'],
                    :password =&gt; ENV['MEMCACHE_PASSWORD'],
                    :expires_in =&gt; 1.day)

data = settings.cache.get(key)

settings.cache.set(key,data)
||&lt;
つまりDalli::Clientオブジェクトをcacheという変数にセットして
getでkeyに対応するデータの取得をし
setでkeyにdataを保存する
データの保持期間はオブジェクト生成時のoptionで指定できる
optionを指定しないならmemcache serverの指定を含めて
引数は不要だよ


次にapp.rbだけど
ちょっと長いので分けて要点だけ説明するよ
&gt;|ruby|
get '/:term/:category' do |term, category|
  @term, @category, @date = term, category, Date.today
  @videos = videos(term, category, @date.to_s)
  @urls = %w(daily weekly newly).product %w(music movie drama anime owarai variety all)

  haml :index
end
||&lt;
Gyaoではmusic movie drama anime owarai variety allの
各カテゴリデータにつき
daily weekly newlyという期間データを用意しているんだ
だからgetではそれらをパラメータとして取って
これに応じたビデオのリストを
videosメソッドで取得するようにしている
また@urlsはプルダウンメニューで使っているよ


videosメソッドを見るよ
&gt;|ruby|
helpers do
  def videos(*term_category_date)
    key = term_category_date * '/'
    if vdata = settings.cache.get(key)
      vdata
    else
      vdata = get_videos(*term_category_date)
      settings.cache.set(key, vdata)
      vdata
    end
  rescue
    get_videos(*term_category_date)
  end
end
||&lt;
ここではmemcachedにアクセスするためのkeyとして
渡された引数term, category, dateを
/ で連結したものを使っているよ
最初にmemcachedに同じキーのデータがあるか見て
なければget_videosメソッドで
GyaoとYouTubeにアクセスして
データを取得しmemcachedにセットする
rescueでmemcachedが死んでる場合にも一応対応したよ


次にget_videosメソッドを見るよ
&gt;|ruby|
helpers do
  def get_videos(*term_category_date)
    ranking = rank_data(term_category_date.first 2)
    video_data(ranking)
  end
end
||&lt;
ここではrank_dataメソッドでGyaoにアクセスし
内容を解析してランキングデータを取得し
video_dataメソッドでそのデータに対応する動画を
YouTubeから取得しているよ


で具体的なこれらの処理の内容は次のとおりだよ
Gyaoのデータはrssライブラリを使って
YouTubeのデータは
nokogiriライブラリを使って解析しているよ
やっていることは本の例と基本的には同じだよ
&gt;|ruby|
helpers do
  def rank_data(*term_category)
    rss = open( URL(:rank) + term_category*'/' ) { |f| RSS::Parser.parse f.read }
    rss.items.inject([]) { |mem, item| mem &lt;&lt; item.title.scan(/[^「」]+/) }
  end

  def video_data(ranking)
    ranking.thread_with(true) do |artist, title|
      opts = [&quot;vq=&quot; + URI.encode(&quot;%s %s&quot; % [artist, title]), &quot;format=5&quot;]*'&amp;'
      entry = Nokogiri::XML(open [URL(:video), opts]*'?').search('entry').first
      data = { artist: artist, title:  title }
      if entry
        q = { url:    entry.xpath('media:group/media:content').first['url'],
              type:   entry.xpath('media:group/media:content').first['type'],
              count:  entry.xpath('yt:statistics').first['viewCount'] }
        data.update q
      end
      data
    end
  end

  def URL(code)
    { video: 'http://gdata.youtube.com/feeds/api/videos',
      rank:  'http://gyao.yahoo.co.jp/rss/ranking/c/' }[code]
  end
end
||&lt;
ただここではビデオの取得にスレッドを使っているよ
折角だからここでは[http://d.hatena.ne.jp/keyesberry/20110629/p1:title=この間作った]
Enumerable#thread_withを使ってみたよ
これはsystem_extensions.rbというファイルに置いてあるよ


system_extensions.rbの中身はこうだよ
&gt;|ruby|
# encoding: UTF-8
module Enumerable
  def thread_with(order=false)
    mem = []
    map.with_index do |*item, i|
      Thread.new(*item) do |*_item|
        mem &lt;&lt; [i, yield(*_item)]
      end
    end.each(&amp;:join)
    (order ? mem.sort : mem).map(&amp;:last)
  end
end

class Fixnum
  def day
    self*60*60*24
  end
  alias days day
end

module Kernel
  def requires(*features)
    features.each { |f| require f.to_s }
  end
end
||&lt;
Fixnum#dayとKernel#requiresは
app.rbでつかってるんだけど
まあおまけだよ


layout.hamlとindex.hamlには
特に面白いところはないので説明は省くね


NoSQLってなんかもっと難しいものをイメージしてたけど
全然そんなこと無いんだね


(追記：2011-7-11)Dalli::Client.newの引数を修正しました。((https://github.com/mperham/dalli/wiki/Heroku-Configuration))


&lt;script src=&quot;https://gist.github.com/1075425.js&quot;&gt; &lt;/script&gt;

</body>
</day>
<day date="2011-07-19" title="">
<body>
*p1*Ruby1.9でもEND HELLを解消したい！
RubyKaigi2011において
現行Rubyの構文上の欠点である
END HELLを解消するEnd Rubyが
あんどうやすし氏(id:technohippy)により提唱されました


[http://www.ustream.tv/recorded/16077046:title=parse.yの歩き方]


END HELLとは要するに以下のような
醜いendの連なりのことです
&gt;|ruby|
module MyModule
  class MyClass
    def my_method
      10.times do
        if rand &lt; 0.5
          p :small
        else
          p :large
        end
      end 
    end      &lt;- ここ
  end
end
||&lt;


氏はLispのcddddrに倣って
Rubyへのennnnndキーワードの導入を提唱します
ennnnndを使えば先のコードは次のように書けます
&gt;|ruby|
module MyModule
  class MyClass
    def my_method
      10.times do
        if rand &lt; 0.5
          p :small
        else
          p :large
        ennnnnd
||&lt;
変態ですね！


Rubyコミッターらによる実装も完了したようなので
Ruby2.0で正式採用となるのも間違いなさそうです..


http://d.hatena.ne.jp/ku-ma-me/20110718/p1


そこで気がはやい人のために
Ruby1.9でもennnnndを可能とする
ennndライブラリを作りました:)


以下のように使います
まずはあなたのコードを用意します
&gt;|ruby|
# mycode.rb
module MyModule
  class MyClass
    def my_method
      10.times do
        if rand &lt; 0.5
          p :small
        else
          p :large
        ennnnnd
||&lt;


ennndライブラリとあなたのコードをrequireして
実行する実行コードを用意します
&gt;|ruby|
#req.rb 
require './ennnd'
require 'mycode'

MyModule::MyClass.new.my_method
||&lt;
つまりennndキーワードを含むあなたのコードを
ライブラリとして読み込みます


これを現行Rubyで実行します
&gt;|sh|
% ruby req.rb 
:small
:small
:large
:small
:small
:large
:small
:large
:small
:small
||&lt;


やっぱりRubyは楽しいですね！


関連記事：[http://d.hatena.ne.jp/keyesberry/20110605/p1:title=Sinatraに別構文があってもいいじゃないか！]


&lt;script src=&quot;https://gist.github.com/1091353.js?file=ennnd.rb&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2011-07-25" title="">
<body>
*p1*RubyのメタプログラミングでInterpreterパターンを実装しよう！
「Rubyによるデザインパターン」(著：ラス・オルセン)は
GoFの23あるデザインパターンのうちの14個について
Rubyによる実装とその解説を試みた書籍です


[asin:4894712857:detail]


**Interpreterパターン
その中にInterpreterパターンを取り扱った章(15)があります
Interpreterパターンでは言語上に
問題解決に特化した専用言語を構築します
専用言語で書かれたプログラムはパーサで抽象構文木(AST)
というオブジェクトのツリー構造に変換され
評価(interpret)されます
ASTはオブジェクトノードの集まりですが
これはその言語のプリミティブなノードである終端(terminal)と
終端への参照を含む高階の非終端(nonterminal)で構成されます


本書ではRubyによるInterpreterパターンの実装例として
ファイル検索用インタープリタが紹介されています
このインタープリタでは最終的に以下のような書き方で
ファイル検索が行えます
&gt;|ruby|
  (bigger(1024) &amp; writable) | file_name('*.mp3')
||&lt;


説明は不要と思いますが
この記述で1KB以上の書き込み可能ファイルと
mp3ファイルの集合が表現されています
Rubyをよく知っている人なら
このプログラムを構文解析するのに
パーサは不要であることに気づくでしょう


そう
Rubyでは演算子のように使える &amp; や | メソッドを活用することで
パーサ無しで利用者にやさしい専用言語を構築できるのです！
つまりこれは内部DSLですね


そして特定のディレクトリでこの集合を評価することで
該当ディレクトリに含まれるファイルリストが得られます
&gt;|ruby|
  file_exp = (bigger(1024) &amp; writable) | file_name('*.mp3')
  puts file_exp.evaluate('~/target_directory')
||&lt;


この専用言語を構築する具体的な手順は
本書を参照してくださいね
もっとも実装コードだけなら
以下のサイトから取得することもできます((該当ファイルはchap15/ex1_files.rbとex3_operators.rbです))


[http://designpatternsinruby.com/index.html:title=Design Patterns In Ruby: Home]


**InterpreterBuilder
デザインパターン初学者の自分にとって
Interpreterパターンはとても新鮮に感じられました
しかしその一方でそれを構築するには
それなりの量のコードが必要であることを知りました
例えば上記ファイル検索用インタープリタを実現するのに
著者はおよそ120行のコードを書いています


でも中を見ると似たようなコードの繰り返しなんですよねー


そんなわけで..


Rubyのメタプログラミングを使って
Interpreterパターンを簡単に実現する
InterpreterBuilderというライブラリを書いてみました:)


早速先のファイル検索用インタープリタを
InterpreterBuilderライブラリを使って書き直してみます((一部実装が異なります))
&gt;|ruby|
require &quot;find&quot;
require &quot;interpreter_builder&quot;

module FileSelect
  extend InterpreterBuilder    # (1)
  class Expression      # (2)
    def |(other)
      Or.new(self, other)
    end
    
    def &amp;(other)
      And.new(self, other)
    end

    def evaluate(dir)
      files(dir).select { |f| yield f }
    end

    def files(dir)
      dir = File.expand_path(dir)
      Find.find(dir).select { |f| File.file? f }
    end
  end

  terminals = {
    all: -&gt;f { true },
    file_name: -&gt;f, pattern{ File.fnmatch pattern, File.basename(f) },
    bigger: -&gt;f, size{ File.size(f) &gt; size },
    writable: -&gt;f { File.writable? f }
  }
  
  terminals.each do |name, blk|
    converter =-&gt;dir{ Expression.new.files(dir) }
    define_terminal(name, Expression, :evaluate, converter, &amp;blk)  # (3)
  end
  
  nonterminals = {
    except: :-,
    or: :|,
    and: :&amp;
  }
  
  nonterminals.each do |name, op|
    define_nonterminal(name, Expression, :evaluate, op, false)   # (4)
  end

  def except(exp)
    Except.new(All.new, exp)
  end
end
||&lt;
InterpreterBuilderを使うことで
ファイル検索用インタプリタの実装は
僅か50行になりました！


使い方の手順は以下のとおりです
+InterpreterBuilderモジュールをextendする(1)
+ASTノードのベースクラスExpressionを定義する(2)
+define_terminalメソッドを使って終端オブジェクト(Expressionのサブクラス)を定義する(3)
+define_nonterminalメソッドを使って非終端オブジェクト(Expressionのサブクラス)を定義する(4)


define_terminalではAll FileName Bigger Writableという名の
Expressionサブクラスを作ります
同時に同名の関数的メソッド
all file_name bigger writableも生成されます((関数メソッドが不要の場合は第5引数にfalseを渡します))
第3引数にはサブクラスでオーバーライドするメソッド名を
第4引数にはその引数を被評価集合に変換するconverterを
更に被評価集合に対する適合条件をブロックで渡します


define_nonterminalではExcept Or Andという名の
Expressionサブクラスを作ります
第4引数にはその非終端で参照される
非終端オブジェクトに適用する演算子を指定します


説明が不十分で言ってることがよくわからないと思いますが
先のコードを見て理解して頂けると助かります^^;


InterpreterBuilderの内部実装は以下のとおりです
&gt;|ruby|
# encoding: UTF-8
class String
  alias _capitalize capitalize
  def capitalize
    self.split('_').map(&amp;:_capitalize).join
  end
end

module InterpreterBuilder
  def define_terminal(name, superclass, target_meth, converter=-&gt;p{p}, function=true)
    define_node(name, superclass, target_meth, function) do |*dir|
      converter[*dir].select { |item| yield item, *@attrs }
    end
  end

  def define_nonterminal(name, superclass, target_meth, op, function=true)
    define_node(name, superclass, target_meth, function) do |*dir|
      f1, *f2 = @attrs.map { |attr| attr.send(target_meth, *dir) }
      f1.send(op, *f2)
    end
  end

  def define_node(name, superclass, target_meth, function, &amp;blk)
    klass = Class.new(superclass) do
      def initialize(*attrs)
        *@attrs = attrs
      end
      define_method(target_meth, &amp;blk)
    end
    const_set(name.to_s.capitalize, klass)
    define_function(name) if function
  end

  def define_function(name)
    self.class_eval {
      define_method(name) do |*args|
        Module.const_get(name.to_s.capitalize).new(*args)
      end
    }
  end
end
||&lt;


**ユーザ検索用インタープリタ
別の例を示します
今度はInterpreterBuilderを使って
ユーザの属性集合を求める
ユーザ検索用のクエリー言語を構築してみます


今ここに
カンマ区切りのユーザ属性情報があります
&gt;|bash|
Joe, 25, M, US, Programmer
Armstrong, 28, M, US, Teacher
Karen, 43, F, US, Programmer
Ken, 38, M, JP, Doctor
Yui, 18, F, JP, Student
Paku, 33, M, KO, RestaurantOwner
Soh, 51, M, KO, Teacher
Ralf, 29, M, DE, Programmer
Naomi, 16, F, FR, Student
||&lt;


ユーザ調査用インタープリタはこのユーザ情報を読み取り
以下のような簡単なクエリー言語を使って
対象ユーザの抽出を行えるようにします
&gt;|ruby|
 except(nationality(:JP))  # 日本人以外のユーザ

 age(30, :&gt;) &amp; sex(:M)   # 30歳以上の男性ユーザ

 age(30, :&lt;) &amp; job('Programmer') &amp; (nationality(:US) | nationality(:DE))
 # 30歳未満の米国またはドイツのプログラマー
||&lt;


最初にInterpreterBuilderを使わずに
このクエリー言語を構築するコードを示します
&gt;|ruby|
# encoding: UTF-8
module Census
  Person = Struct.new(:name, :age, :sex, :nationality, :job)  
  
  class Expression
    def |(other)
      Or.new(self, other)
    end

    def &amp;(other)
      And.new(self, other)
    end
    
    def evaluate(people)
      people.select { |f| yield f }
    end
  end

  module Interface
    def all
      All.new
    end

    def sex(sex)
      Sex.new(sex)
    end
    
    def age(age, op)
      Age.new(age, op)
    end
    
    def nationality(n)
      Nationality.new(n)
    end
    
    def job(job)
      Job.new(job)
    end
    
    def except(exp)
      Except.new(All.new, exp)
    end
  end

  include Interface

  class All &lt; Expression
    def evaluate(people)
      super { true }
    end
  end

  class Sex &lt; Expression
    def initialize(sex)
      @sex = sex
    end
  
    def evaluate(people)
      super { |p| p.sex == @sex }
    end
  end

  class Age &lt; Expression
    def initialize(age, op)
      @age, @op = age, op
    end
  
    def evaluate(people)
      super { |p| p.age.send(@op, @age) }
    end
  end

  class Nationality &lt; Expression
    def initialize(nationality)
      @nationality = nationality
    end
  
    def evaluate(people)
      super { |p| p.nationality == @nationality }
    end
  end

  class Job &lt; Expression
    def initialize(job)
      @job = job
    end
  
    def evaluate(people)
      super { |p| p.job == @job }
    end
  end

  class Except &lt; Expression
    def initialize(expression1, expression2)
      @expression1 = expression1
      @expression2 = expression2
    end
  
    def evaluate(people)
      @expression1.evaluate(people) - @expression2.evaluate(people)
    end
  end
  
  class Or &lt; Expression
    def initialize(expression1, expression2)
      @expression1, @expression2 = expression1, expression2
    end
  
    def evaluate(people)
      @expression1.evaluate(people) | @expression2.evaluate(people)
    end
  end
  
  class And &lt; Expression
    def initialize(expression1, expression2)
      @expression1, @expression2 = expression1, expression2
    end
  
    def evaluate(people)
      @expression1.evaluate(people) &amp; @expression2.evaluate(people)
    end
  end
end
||&lt;
およそ120行のコードが必要になります


次にこれと等価なコードを
InterpreterBuilderを使って構築してみます
&gt;|ruby|
# encoding: UTF-8
require &quot;../lib/interpreter_builder&quot;

module Census
  extend InterpreterBuilder
    
  Person = Struct.new(:name, :age, :sex, :nationality, :job)  

  class Expression
    def |(other)
      Or.new(self, other)
    end

    def &amp;(other)
      And.new(self, other)
    end
    
    def evaluate(people)
      raise &quot;override this method in the subclass&quot;
    end
  end

  terminals = {
    all: -&gt;person { true },
    sex: -&gt;person,sex { person.sex == sex },
    age: -&gt;person,age,op { person.age.send(op, age) },
    nationality: -&gt;person, nation { person.nationality == nation },
    job: -&gt;person,job { person.job == job }
  }
  
  terminals.each do |name, blk|
    define_terminal(name, Expression, :evaluate, &amp;blk)
  end

  nonterminals = {
    except: :-,
    or: :|,
    and: :&amp;
  }
  
  nonterminals.each do |name, op|
    define_nonterminal(name, Expression, :evaluate, op, false)
  end

  def except(exp)
    Except.new(All.new, exp)
  end
end
||&lt;
48行で構築できました


では先のユーザ情報を読み取って
クエリーを実行してみましょう
&gt;|ruby|
require &quot;./sample/census&quot;
include Census

people = DATA.lines.map do |line|
  name, age, sex, nationality, job = line.scan(/\w+/)
  Person[name, age.to_i, sex.intern, nationality.intern, job]
end

none_japanese = except(nationality(:JP))
puts none_japanese.evaluate(people)

over30men = age(30, :&gt;) &amp; sex(:M)
puts over30men.evaluate(people)

under30_us_or_de_programmer = age(30, :&lt;) &amp; job('Programmer') &amp; (nationality(:US) | nationality(:DE))
puts under30_us_or_de_programmer.evaluate(people)

__END__
Joe, 25, M, US, Programmer
Armstrong, 28, M, US, Teacher
Karen, 43, F, US, Programmer
Ken, 38, M, JP, Doctor
Yui, 18, F, JP, Student
Paku, 33, M, KO, RestaurantOwner
Soh, 51, M, KO, Teacher
Ralf, 29, M, DE, Programmer
Naomi, 16, F, FR, Student
||&lt;


ここでは__END__以下のデータを読み取って
各ユーザ毎に
Personオブジェクトを生成してpeople変数に格納し
これを先のクエリー言語で評価しています
結果は以下のとおりです
&gt;|ruby|
puts none_japanese.evaluate(people)

#&lt;struct Census::Person name=&quot;Joe&quot;, age=25, sex=:M, nationality=:US, job=&quot;Programmer&quot;&gt;
#&lt;struct Census::Person name=&quot;Armstrong&quot;, age=28, sex=:M, nationality=:US, job=&quot;Teacher&quot;&gt;
#&lt;struct Census::Person name=&quot;Karen&quot;, age=43, sex=:F, nationality=:US, job=&quot;Programmer&quot;&gt;
#&lt;struct Census::Person name=&quot;Paku&quot;, age=33, sex=:M, nationality=:KO, job=&quot;RestaurantOwner&quot;&gt;
#&lt;struct Census::Person name=&quot;Soh&quot;, age=51, sex=:M, nationality=:KO, job=&quot;Teacher&quot;&gt;
#&lt;struct Census::Person name=&quot;Ralf&quot;, age=29, sex=:M, nationality=:DE, job=&quot;Programmer&quot;&gt;
#&lt;struct Census::Person name=&quot;Naomi&quot;, age=16, sex=:F, nationality=:FR, job=&quot;Student&quot;&gt;

puts over30men.evaluate(people)

#&lt;struct Census::Person name=&quot;Ken&quot;, age=38, sex=:M, nationality=:JP, job=&quot;Doctor&quot;&gt;
#&lt;struct Census::Person name=&quot;Paku&quot;, age=33, sex=:M, nationality=:KO, job=&quot;RestaurantOwner&quot;&gt;
#&lt;struct Census::Person name=&quot;Soh&quot;, age=51, sex=:M, nationality=:KO, job=&quot;Teacher&quot;&gt;

puts under30_us_or_de_programmer.evaluate(people)

#&lt;struct Census::Person name=&quot;Joe&quot;, age=25, sex=:M, nationality=:US, job=&quot;Programmer&quot;&gt;
#&lt;struct Census::Person name=&quot;Ralf&quot;, age=29, sex=:M, nationality=:DE, job=&quot;Programmer&quot;&gt;
||&lt;
うまくいっているようですね！


**算術演算インタープリタ
あまり意味が無いのですが
InterpreterBuilderの活用例として
以下のような構文を実現する
算術演算インタープリタを実装してみます
&gt;|ruby|
 exp = divide( plus(2, multiple(3,4)), 3 )
 exp.to_i # =&gt; 4
||&lt;


算術演算では終端は数字になるので
selfを返すFixnum#to_iをiterpretメソッドとして使います
&gt;|ruby|
# encoding: UTF-8
require_relative &quot;../lib/interpreter_builder&quot;

module Calc
  extend InterpreterBuilder
  
  class Expression
  end
  
  nonterminals = {
    plus: :+,
    minus: :-,
    multiple: :*,
    divide: :/
  }
  
  nonterminals.each do |name, op|
    define_nonterminal(name, Expression, :to_i, op)
  end
end
||&lt;
非終端である演算子の定義を追加することで
他の算術演算も可能になります


Interpreterパターンに対する根本的な理解が間違っていて
意味不明なことをやっている可能性がありますが
誰かの何かの参考になればうれしいです


(追記：2011-7-26)算術演算の例を一部修正しました。


https://github.com/melborne/InterpreterBuilder

</body>
</day>
<day date="2011-07-27" title="">
<body>
*p1*1から始めるRuby
数学の世界で1は数である
3歳の子供でもそれを知っている
そして私やあなたが老いて死にゆくまで
1は数であり
そこに疑念の入る余地はない


プログラミングの世界でもふつう
1は数である
CでもJavaでもHaskellでも
1は数であり
それ以上でもそれ以下でもない


ところが驚くべきことに
Rubyの世界では
1は数ではないのである


嘘だと思うなら
irbを立ち上げて
次のようにしてみるといい
&gt;|ruby|
$ irb
&gt;&gt; 1.next
=&gt; 2
||&lt;


あなたは今
1にnextというメッセージを送った
そうしたら1は
2という答えを返したのだ
つまりRubyの世界で
1は数以上のものであり
メッセージに返答する「何か」である


Rubyの世界でそれは「オブジェクト」と呼ばれている


1はメッセージに反応するオブジェクトである


しかしここで一つの疑問が湧いてくる
それならば今
1が返した2というのは何なのか
数なのかそれともオブジェクトなのか


この疑問にもirbが答えてくれる
&gt;|ruby|
&gt;&gt; 1.next.next
=&gt; 3
||&lt;


1からの返答に
さらにnextというメッセージを送ってみる
つまり1.nextで返される2にメッセージを送ってみると
果たして3が返ってきた
そう　1から返答された2も
やはりオブジェクトだったのだ


疑い深いあなたは
これだけでは納得しないかも知れない
そしてirbで
きっと次のように入力するのだろう
&gt;|ruby|
&gt;&gt; 1.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next
=&gt; 100
||&lt;


納得した？


そうRubyの世界では入り口も出口も
そのすべてがオブジェクトなのである


さて
1がオブジェクトならnext以外の
どんなメッセージに反応するのかが気になるところだ
Rubyではその答えも1に聞けばいい
methodsというメッセージを1に送ってみよう
&gt;|ruby|
&gt;&gt; 1.methods
=&gt; [:to_s, :-@, :+, :-, :*, :/, :div, :%, :modulo, :divmod, :fdiv, :**, :abs, :magnitude, :==, :===, :&lt;=&gt;, :&gt;, :&gt;=, :&lt;, :&lt;=, :~, :&amp;, :|, :^, :[], :&lt;&lt;, :&gt;&gt;, :to_f, :size, :zero?, :odd?, :even?, :succ, :integer?, :upto, :downto, :times, :next, :pred, :chr, :ord, :to_i, :to_int, :floor, :ceil, :truncate, :round, :gcd, :lcm, :gcdlcm, :numerator, :denominator, :to_r, :rationalize, :singleton_method_added, :coerce, :i, :+@, :eql?, :quo, :remainder, :real?, :nonzero?, :step, :to_c, :real, :imaginary, :imag, :abs2, :arg, :angle, :phase, :rectangular, :rect, :polar, :conjugate, :conj, :between?, :nil?, :=~, :!~, :hash, :class, :singleton_class, :clone, :dup, :initialize_dup, :initialize_clone, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :inspect, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :respond_to_missing?, :extend, :display, :method, :public_method, :define_singleton_method, :__id__, :object_id, :to_enum, :enum_for, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__]
||&lt;


これらは1が応答できるメッセージの集合で
Rubyでは「メソッド」と呼ばれている
つまり1はあなたからの問い合わせに対し
これら130個ものメソッドで応答する


**クラス
上の説明を聞いてあなたは
「Rubyの1って天才、スゲー」とつぶやいたに違いない


しかし事実はそうではない
実は1の中身は私やあなたのあたまの中同様
ほとんど空っぽなのである
空っぽなのに
1はこれらのメッセージに反応できるのである


このカラクリは難しいものではない
Rubyにおいて1は
先のメソッドの集合を実際に持っている
Fixnumというクラスにリンクされている
そして1があなたからのメッセージを受け取ると
それをFixnumに渡してその返答が得られたら
1はそれをあなたに返しているだけなのだ


つまり1は
「ググって」ばかりの私やあなたと同じで
問い合わせのたびにただ「クラスってる」だけで
FixnumこそがGoogle同様のスゲー存在なのである
そして私やあなたはWebの世界では
Rubyの1みたいな存在なのである..


Ruby設計者がこのような仕組みを採用した理由は
容易に想像がつくだろう
そう　Rubyでは2も3も109も17320508も
Fixnumというクラスにリンクしていて
これらの数に対する問い合わせがあったときには
すべてFixnumが答えを用意しているのだ
そうすればこれらの数がそれぞれ個別に
130個のメソッドを持つ必要はなくなる


**メソッド定義
Rubyで「プログラミングをする」というのは
「オブジェクトにメッセージを送る」とほぼ同義である
自由で柔軟なプログラミングを実現するため
Rubyの設計者は大量のメソッドを用意した
しかしもちろんそれだけでは
真に自由なプログラミングができるわけではない
独自メソッドが定義できてこそ
本当のプログラミングが実現できる
そしてRubyはそれをあなたに許す


今あなたが1に挨拶したら
返事がほしいとしよう
1の中身は空っぽで
Fixnumクラスがメソッドを持っていることを思い出そう
そう　あなたのメソッドもFixnumクラスに追加すればいい
&gt;|ruby|
&gt;&gt; class Fixnum
&gt;&gt;  def hello
&gt;&gt;    &quot;Yo!&quot;
&gt;&gt;  end
&gt;&gt; end
||&lt;


さあ　あなたから1に挨拶を!
&gt;|ruby|
&gt;&gt; 1.hello
=&gt; &quot;Yo!&quot;
||&lt;


もう少し気の利いた返事がほしいなら
メッセージが別のオブジェクトを
受け取れるようにすればいい
&gt;|ruby|
&gt;&gt; class Fixnum
&gt;&gt;   def hello(name)
&gt;&gt;     &quot;Yo! #{name}&quot;
&gt;&gt;   end
&gt;&gt; end
||&lt;


そしてあなたの名前を渡す
&gt;|ruby|
&gt;&gt; 1.hello(&quot;Charlie&quot;)
=&gt; &quot;Yo! Charlie&quot;
||&lt;


ここまでの説明が理解できたなら
挨拶に答えられるようになったのが
1だけではないということが分かるだろう
&gt;|ruby|
&gt;&gt; 2.hello(&quot;Ken&quot;)
=&gt; &quot;Yo! Ken&quot;
&gt;&gt; 24.hello(&quot;ジャック・バウアー&quot;)
=&gt; &quot;Yo! ジャック・バウアー&quot;
&gt;&gt; 365.hello(365)
=&gt; &quot;Yo! 365&quot;
||&lt;


そう今やFixnumクラスに属する
すべての数字が
あなたが作ったhelloに答えられる


[f:id:keyesberry:20110803144422p:image:w360]


上のコードの最後の答えを見て
ドキリとする人もいるかもしれない
メソッドに渡すオブジェクトを「引数」と呼ぶけれども
渡されるものがオブジェクトである限り
Rubyはそれを引数として受け入れる
上の２つは文字列のオブジェクトを引数として渡し
最後のものは今まで見てきた数のオブジェクトを渡している
すでにオブジェクトからの応答がオブジェクトであることを
理解したあなたなら次のコードも理解できるだろう
&gt;|ruby|
&gt;&gt; 1.hello(2.hello(&quot;Ma&quot;))
=&gt; &quot;Yo! Yo! Ma&quot;
||&lt;


（[http://d.hatena.ne.jp/keyesberry/20110801/p1:title=続き]）

</body>
</day>
<day date="2011-08-01" title="">
<body>
*p1*1から始めるRuby(その２)
[http://d.hatena.ne.jp/keyesberry/20110727/p1:title=1から始めるRuby]の続きです


**クラス再び
「Rubyの1はFixnumというクラスに属している」
前回私はそう言った
疑い深いあなたは
うさぎ本(([asin:4274068099:title]))やキリン本(([asin:4873113679:title]))を紐解いて
その事実を確かめたかもしれない


でもそれは回り道だ
それも1に聞くのが確実で早い
&gt;|ruby|
&gt;&gt; 1.class
=&gt; Fixnum
||&lt;


しかもこの方法は確実で早いだけではない
実は1の返答には
Rubyにおける別の重大な真実が隠されているのだ


あなたが1にclassと送ったら
彼はFixnumと返してきた
Rubyでは入口も出口もオブジェクトであった
賢明なあなたはもう気が付いたかもしれない


そう
RubyではFixnumというクラスもまた
オブジェクトなのである!


あなたは誰かに
クラスというのはオブジェクトのひな形
つまり設計図であると教えられただろう
Rubyにおいてもそれは真実だ
Fixnumクラスは1オブジェクトのひな形になっている
でもFixnumは
それと同時にRubyの世界に実体として存在し
1と同じようにオブジェクトとして振る舞うのだ


試しに前回1に覚えさせた挨拶に
Fixnumを投げてみよう
&gt;|ruby|
&gt;&gt; class Fixnum
&gt;&gt;   def hello(name)
&gt;&gt;    &quot;Yo! #{name}&quot;
&gt;&gt;   end
&gt;&gt; end
=&gt; nil
&gt;&gt; 1.hello(Fixnum)
=&gt; &quot;Yo! Fixnum&quot;
||&lt;


helloメソッドは
Fixnumをオブジェクトとして受け入れた


では
1のときと同様に
Fixnumがどんなメッセージに反応するか見てみよう
&gt;|ruby|
&gt;&gt; Fixnum.methods
=&gt; [:allocate, :superclass, :freeze, :===, :==, :&lt;=&gt;, :&lt;, :&lt;=, :&gt;, :&gt;=, :to_s, :included_modules, :include?, :name, :ancestors, :instance_methods, :public_instance_methods, :protected_instance_methods, :private_instance_methods, :constants, :const_get, :const_set, :const_defined?, :const_missing, :class_variables, :remove_class_variable, :class_variable_get, :class_variable_set, :class_variable_defined?, :module_exec, :class_exec, :module_eval, :class_eval, :method_defined?, :public_method_defined?, :private_method_defined?, :protected_method_defined?, :public_class_method, :private_class_method, :autoload, :autoload?, :instance_method, :public_instance_method, :nil?, :=~, :!~, :eql?, :hash, :class, :singleton_class, :clone, :dup, :initialize_dup, :initialize_clone, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :frozen?, :inspect, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :respond_to_missing?, :extend, :display, :method, :public_method, :define_singleton_method, :__id__, :object_id, :to_enum, :enum_for, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__]
||&lt;


Fixnumはこれら95個のメッセージに反応する


ちなみに
1のためにFixnumが持っているメソッドを見るには
次のようにすればいい
&gt;|ruby|
&gt;&gt; Fixnum.instance_methods
=&gt; [:to_s, :-@, :+, :-, :*, :/, :div, :%, :modulo, :divmod, :fdiv, :**, :abs, :magnitude, :==, :===, :&lt;=&gt;, :&gt;, :&gt;=, :&lt;, :&lt;=, :~, :&amp;, :|, :^, :[], :&lt;&lt;, :&gt;&gt;, :to_f, :size, :zero?, :odd?, :even?, :succ, :integer?, :upto, :downto, :times, :next, :pred, :chr, :ord, :to_i, :to_int, :floor, :ceil, :truncate, :round, :gcd, :lcm, :gcdlcm, :numerator, :denominator, :to_r, :rationalize, :singleton_method_added, :coerce, :i, :+@, :eql?, :quo, :remainder, :real?, :nonzero?, :step, :to_c, :real, :imaginary, :imag, :abs2, :arg, :angle, :phase, :rectangular, :rect, :polar, :conjugate, :conj, :between?, :nil?, :=~, :!~, :hash, :class, :singleton_class, :clone, :dup, :initialize_dup, :initialize_clone, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :inspect, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :respond_to_missing?, :extend, :display, :method, :public_method, :define_singleton_method, :__id__, :object_id, :to_enum, :enum_for, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__]

&gt;&gt; Fixnum.instance_methods == 1.methods
=&gt; true
||&lt;


**メタクラス(クラスのクラス)
さてFixnumがオブジェクトだとすると
また一つの疑問が湧いてくる
Fixnumにメッセージを送ったとき
その答えを用意しているのは一体誰なのかと


もうあなたも答えの探し方が分かっただろう
irbを開いて..
&gt;|ruby|
&gt;&gt; Fixnum.class
=&gt; Class
||&lt;


FixnumはClassという名のクラスを返してきた
つまりFixnumにメッセージを送ったとき
それに答える実体は
Classクラスであったのだ


そしてあなたの疑問は尽きることはない
先の答えからClassもまたオブジェクトであり
したがってClassもメッセージに反応する
だとしたらその答えを用意しているのは一体誰なのかと


さあもう一度やってみて!
&gt;|ruby|
&gt;&gt; Class.class
=&gt; Class
||&lt;


自分の目を疑っているなら
これで目が覚めるだろう
&gt;|ruby|
&gt;&gt; Class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class.class
=&gt; Class
||&lt;


Rubyの世界の家族構成が見えてきた
1オブジェクトにはFixnumクラスという母がいて
1に代わって答えを用意し
Fixnumクラス(オブジェクト)にはClassクラスという母がいて
Fixnumに代わって答えを用意する
そして
Classクラス(オブジェクト)は自分自身が母でもあって
自分で答えを用意する


[f:id:keyesberry:20110805084256p:image:w360]


そうつまりClassクラスは
Rubyの世界におけるアダムとイヴだったのだ!
世界(オブジェクト)はここからはじまった


前回私は
「FixnumこそがGoogle同様のスゲー存在なのである」
と言ったが今ここでそれを撤回する
そして言う
「ClassクラスこそがGoogle同様のスンゲー存在なのである」


**クラスメソッド定義
さて
ここまでの仕組みが理解できたなら
Fixnumにも挨拶をさせてみよう
やり方はもうわかるよね？
&gt;|ruby|
&gt;&gt; class Class
&gt;&gt;   def bonjour
&gt;&gt;     &quot;Bonjour from Fixnum with love!&quot;
&gt;&gt;   end
&gt;&gt; end
=&gt; nil
&gt;&gt; Fixnum.bonjour
=&gt; &quot;Bonjour from Fixnum with love!&quot;
||&lt;


一見うまくいっているこのコードを見て
何も感じないのであれば
あなたはRubyのことを
まだよく知らないのかもしれない
このまま先を読み進めてほしい
違和感を感じたのなら
「[http://i.loveruby.net/ja/rhg/book/:title=1から始めるRuby（その３２６）]」に飛んで！
ここはあなたのためのページじゃない


問題を明らかにしよう
下のコードを見てほしい
&gt;|ruby|
&gt;&gt; String.bonjour
=&gt; &quot;Bonjour from Fixnum with love!&quot;
&gt;&gt; Array.bonjour
=&gt; &quot;Bonjour from Fixnum with love!&quot;
&gt;&gt; Hash.bonjour
=&gt; &quot;Bonjour from Fixnum with love!&quot;
&gt;&gt; Symbol.bonjour
=&gt; &quot;Bonjour from Fixnum with love!&quot;
&gt;&gt; Regexp.bonjour
=&gt; &quot;Bonjour from Fixnum with love!&quot;
&gt;&gt; Range.bonjour
=&gt; &quot;Bonjour from Fixnum with love!&quot;
||&lt;


RubyにはFixnum以外にも多数のクラスが用意されている
上に並べたものはそれらの代表選手だけれども
これらのクラスもbonjourメソッドに反応してしまった
しかもfrom Fixnumなんて!


実は
ClassクラスはFixnumの母というだけではなく
すべてのクラスの母なのだ
&gt;|ruby|
&gt;&gt; String.class
=&gt; Class
&gt;&gt; Array.class
=&gt; Class
&gt;&gt; Hash.class
=&gt; Class
&gt;&gt; Symbol.class
=&gt; Class
&gt;&gt; Regexp.class
=&gt; Class
&gt;&gt; Range.class
=&gt; Class
||&lt;


仮にあなたが独自のメソッドに飽きたらなくなって
後から独自のクラスを作ったときにも
この問題のあるbonjourメソッドに反応してしまう
&gt;|ruby|
&gt;&gt; class Loner
&gt;&gt;
&gt;&gt; end
=&gt; nil
&gt;&gt; Loner.bonjour
=&gt; &quot;Bonjour from Fixnum with love!&quot;
||&lt;


[f:id:keyesberry:20110803150309p:image:w360]


解決策は２つある
１つ目はFixnumという文字列の代わりに
selfを渡すのだ
&gt;|ruby|
&gt;&gt; class Class
&gt;&gt;   def bonjour
&gt;&gt;     &quot;Bonjour from #{self} with love!&quot;
&gt;&gt;   end
&gt;&gt; end
||&lt;


selfというのはそれを包むオブジェクトを返す
Rubyのキーワードだ
bonjourメソッドが
Fixnumクラスオブジェクトに送られたなら
Fixnumがselfになる
Arrayクラスオブジェクトに送られたなら
Arrayがselfになる
あなたのLonerクラスオブジェクトに送られたなら
Lonerがselfになる
&gt;|ruby|
&gt;&gt; Fixnum.bonjour
=&gt; &quot;Bonjour from Fixnum with love!&quot;
&gt;&gt; String.bonjour
=&gt; &quot;Bonjour from String with love!&quot;
&gt;&gt; Array.bonjour
=&gt; &quot;Bonjour from Array with love!&quot;
&gt;&gt; Hash.bonjour
=&gt; &quot;Bonjour from Hash with love!&quot;
&gt;&gt; Symbol.bonjour
=&gt; &quot;Bonjour from Symbol with love!&quot;
&gt;&gt; Regexp.bonjour
=&gt; &quot;Bonjour from Regexp with love!&quot;
&gt;&gt; Range.bonjour
=&gt; &quot;Bonjour from Range with love!&quot;
&gt;&gt; Class.bonjour
=&gt; &quot;Bonjour from Class with love!&quot;
&gt;&gt; Loner.bonjour
=&gt; &quot;Bonjour from Loner with love!&quot;
||&lt;


（[http://d.hatena.ne.jp/keyesberry/20110805/p1:title=続き]）

</body>
</day>
<day date="2011-08-05" title="">
<body>
*p1*1から始めるRuby(その３)
[http://d.hatena.ne.jp/keyesberry/20110801/p1:title=1から始めるRuby(その２)]の続きです

**クラスメソッド定義(続き)
bonjourメソッド内でselfを使うことで
このメソッドがそれぞれのクラスでの呼び出しに対し
適切に応答するようになった


しかしできればbonjourメソッドは
Fixnum専用のものにして
他のクラスでは呼び出せないようにしたい
Classクラスはすべてのクラスのクラスだったから
そこに定義したbonjourメソッドはすべてのクラスで
呼び出せるようになってしまった
仮にFixnumのためだけのクラスがあれば
そこにbonjourメソッドを定義して問題は解決しそうである


期待通りRubyにはそのようなクラスが存在する
しかしなぜかひっそりと..


早速このクラスを使って目的を果たそう
&gt;|ruby|
&gt;&gt; class &lt;&lt; Fixnum
&gt;&gt;   def bonjour
&gt;&gt;     &quot;Bonjour from Fixnum with love!&quot;
&gt;&gt;   end
&gt;&gt; end
=&gt; nil
&gt;&gt; Fixnum.bonjour
=&gt; &quot;Bonjour from Fixnum with love!&quot;
&gt;&gt; String.bonjour
NoMethodError: undefined method `bonjour' for String:Class
&gt;&gt; Array.bonjour
NoMethodError: undefined method `bonjour' for Array:Class
&gt;&gt; Class.bonjour
NoMethodError: undefined method `bonjour' for Class:Class
||&lt;


class &lt;&lt; Fixnum という構文は
Fixnumオブジェクト専用の名無しのクラスを定義する
この構文を見慣れないRuby使いもきっといるだろう
Rubyにひっそりと存在するものだから
その呼び方すら確定していない
ある人はSingletonクラスといい
ある人はEigenクラスといい
またある人は特異クラスという((ruby1.9ではsingletonを使っているようです. class&lt;&lt;1;end))
私は是非ともステルスクラスと呼びたいが


[f:id:keyesberry:20110805221956g:image:w360]


実はこの構文には別の書き方が３種ある
そしてこちらの書き方のほうが広く知られている

&gt;|ruby|
 class Fixnum
   class &lt;&lt; self     # Fixnumクラス定義の中でselfを使って
     def bonjour
       &quot;Bonjour from Fixnum with love!&quot;
     end
   end
 end

 def Fixnum.bonjour   # メソッド定義でFixnumを前置して
   &quot;Bonjour from Fixnum with love!&quot;
 end

 class Fixnum
   def self.bonjour   # Fixnumクラス内のメソッド定義でselfを前置して
     &quot;Bonjour from Fixnum with love!&quot;
   end
 end
||&lt;


最初の構文は元の構文を
Fixnumクラス定義内に配置したものだ
Fixnumクラス内でselfはFixnumを返す
次の構文はメソッド定義をするときに
その適用対象オブジェクト(ここではFixnum)
を限定するやり方だ
最後の構文はこのメソッド式構文を
クラス定義内に配置したものだ


なぜ同じ事をやるのに
４種もの書き方があるのかというと
RubyはPerlの流れを汲むTMTOWTDIの言語だからだ


TMTOWTDIを最初見たとき私は
「TiMe TO WheTher Die or Ill」の略だと思ったのだが
正しくは
「There's More Than One Way To Do It」の略だそうである
（やり方はいくらあってもええじゃないか）
長い割には面白くない答えだったので
別の答えを用意した

&gt;|ruby|
 /Today's (Mon|Tue) Or (Wed|Thu) Day/I
||&lt;


(続く？)

</body>
</day>
<day date="2011-08-10" title="">
<body>
*p1* + (足す)から始めるRuby
数学の世界で + は演算子である
5歳の子供でもそれを知っている
そして私やあなたが老いて死にゆくまで
 + は演算子であり
そこに疑念の入る余地はない


プログラミングの世界でもふつう
 + は演算子である
CでもJavaでもPerlでも
 + は演算子であり
それ以上でもそれ以下でもない


ところが驚くべきことに
Rubyの世界では
 + は演算子ではないのである


嘘だと思うなら
エディタを立ち上げて((irbではうまくいきません))
次のようにしてみるといい
&gt;|ruby|
class Fixnum
  def +(other)
    Integer(&quot;#{self}&quot;+&quot;#{other}&quot;)
  end
end

1 + 2 # =&gt; 12
123 + 456 # =&gt; 123456
||&lt;


あなたは今
Fixnum#+ メソッドを再定義した
そうしたら1 + 2は12という答えを返した
そうRubyの世界で + は演算子ではなく
ユーザが再定義可能な
ひとつのメソッドに過ぎないのだ


つまり 1 + 2 や 123 + 456 の構文は
以下のシンタックスシュガーである
&gt;|ruby|
1.+(2) # =&gt; 12
123.+(456) # =&gt; 123456
||&lt;


疑い深いあなたは
これだけでは納得しないかも知れない
そしてきっと
他の演算子についても試してみるのだろう
&gt;|ruby|
class Fixnum
  def +(other)
    Integer(&quot;#{self}&quot;+&quot;#{other}&quot;)
  end

  alias :minus :-
  def -(other)
    res = self.minus(other)
    res &gt; 0 ? res : &quot;unknown world for me.&quot;
  end

  def *(other)
    &quot;#{self}&quot;.center(other, &quot;*&quot;)
  end

  def /(other)
    &quot;#{self}&quot;.count(&quot;#{other}&quot;)
  end

  def **(other)
    self * other * other
  end
end

1 + 2 # =&gt; 12
123 + 456 # =&gt; 123456

9 - 4 # =&gt; 5
21 - 34 # =&gt; &quot;unknown world for me.&quot;

12345 * 20 # =&gt; &quot;*******12345********&quot;

3333456456 / 3 # =&gt; 4
3333456456 / 5 # =&gt; 2

12345 ** 7 # =&gt; &quot;*12345**12345**12345**12345**12345**12345**12345*&quot;
||&lt;


納得した？


そうRubyの世界では + だけでなく
演算子のほとんどがメソッド呼び出しなのである


演算子をメソッドにする利点は２つある
１つは今見たようにそれが再定義可能であることだ
しかしより大きな利点は２つ目にある


上で再定義したFixnum#+の中身を
注意深く見てほしい
 + の定義の中で + が使われているのが分かるだろう
通常このような定義は
定義が定義を呼び出すことになってうまく働かない
しかしここでは問題なく動いている


もうあなたは気付いているに違いない
そうFixnum#+の定義の中の + は
Fixnumの+を呼び出しているのではなく
Stringの+を呼び出しているのだ
そしてString#+は文字列を結合するべく定義されている
再定義されたFixnum#**の結果が理解できるなら
あなたはこれを正しく理解している


これで演算子をメソッドにする
２つ目の利点が分かっただろう
つまりRubyでは異なる種類のオブジェクトごとに
同じ演算子を持てるのだ
そして各オブジェクトの演算子は
その属するクラスにおいてそれぞれ適切に定義される


Rubyにおいて + 演算子は数と文字列だけでなく
配列と時間のオブジェクトでも標準で使える
&gt;|ruby|
[1,2,3] + [4,5,6] # =&gt; [1, 2, 3, 4, 5, 6]

now = Time.now # =&gt; 2011-08-10 17:36:10 +0900
now + 60*60 # =&gt; 2011-08-10 18:36:10 +0900
||&lt;


もちろん標準クラスのメソッドを
改変することのリスクをあなたは理解するだろう
それはすべてに影響する
しかしその影響を最小限に抑えて
機能を拡張するような改変は許容できるだろう


文字に整数を足したり引いたりして
文字コードにおける並びの文字を返すよう
拡張した例を示そう
&gt;|ruby|
class String
  alias __plus__ +
  def +(other)
    if other.is_a? Integer
      return (self.ord + other).chr
    end
    __plus__(other)
  end

  def -(other)
    case other
    when String
      self.ord - other.ord
    when Integer
      (self.ord - other).chr
    else
      raise ArgumentError
    end
  end
end

'a' + 'b' # =&gt; &quot;ab&quot;
'a' + 5 # =&gt; &quot;f&quot;
'f' - 'a' # =&gt; 5
'f' - 5 # =&gt; &quot;a&quot;
||&lt;
String#+はその引数に文字列が渡されたときは
標準の動作に従って文字列を結合する
数字が渡されたときには
文字コードにおいてその分シフトした文字列を返す


もちろんあなたのオブジェクトにも
 + 演算子を自由に定義できる
早速やってみよう
&gt;|ruby|
class City
  attr_reader :name
  def initialize(name)
    @name = name
  end
  def +(other)
    City.new(name+other.name)
  end
end

c1 = City.new('buda') # =&gt; #&lt;City:0x00000100869e20 @name=&quot;buda&quot;&gt;
c2 = City.new('pest') # =&gt; #&lt;City:0x000001008699c0 @name=&quot;pest&quot;&gt;
c3 = c1 + c2 # =&gt; #&lt;City:0x00000100869600 @name=&quot;budapest&quot;&gt;
c3.name # =&gt; &quot;budapest&quot;
||&lt;


２つのCityオブジェクトを合わせると
新しい都市が生まれた!


このようにしてRubyでは
通常の算術演算子を
その対象のオブジェクトに応じて
それに則した用途として定義できる
これはプログラミングを
極めて直感的なものにするのである



姉妹シリーズ「[http://d.hatena.ne.jp/keyesberry/20110727/p1:title=1から始めるRuby][http://d.hatena.ne.jp/keyesberry/20110727/p1:bookmark]」もよろしくね:)

</body>
</day>
<day date="2011-08-15" title="">
<body>
*p1*RubyでもErlangの[H|T]したいよ!
「プログラミングErlang」(Joe Armstrong著/榊原一矢訳)
という本でちょっとErlangの世界を覗いているよ


[asin:4274067149:detail]


Erlangのような関数型言語はリスト処理に優れていて
便利な構文がいろいろとあるんだね
例えばリストの先頭に別の要素を結合したものを
 | を使って簡単に作れるんだ

&gt;|erl|
1&gt; Langs = [haskell, erlang, lisp].
[haskell,erlang,lisp]
2&gt; NewLangs = [ruby | Langs].
[ruby,haskell,erlang,lisp]
||&lt;
[ruby | Langs] のところが
リストへの要素の追加になってるよ
ちなみにErlangでは変数は大文字で始まって
アトム((Rubyのシンボルのようなもの))は引用符なしで書けるんだ
また式の終りには英語のようにピリオドを付けるよ


一方でリストから先頭要素を分離したものを作るには
次のようにするよ
&gt;|erl|
3&gt; [H|T] = Newlangs. 
[ruby,haskell,erlang,lisp]
4&gt; H.
ruby
5&gt; T.
[haskell,erlang,lisp]
6&gt; 
||&lt;
変数Hにリストの先頭要素がバインドされて
変数Tにリストの残りがバインドされる


この何がうれしいかって言うと
これでリストの再帰的な処理が
すごく簡単に書けるんだよ
試しにリストの要素を足し合わせる
sum関数を定義してみるね
&gt;|erl|
sum([], N) -&gt; N;
sum([H|T], N) -&gt; sum(T, H+N).

sum([1,2,3,4,5], 0).
=&gt; 15
||&lt;
リストが空のときは第２引数Nを返す
そうでないときは先頭要素HをNに足して
残りのリストTでsum関数を再帰する
簡潔でカッコイイよねー


リストの要素に関数を適用する
map関数も書いてみるよ
&gt;|erl|
map([], _) -&gt; [];
map([H|T], F) -&gt; [F(H)|map(T,F)].

map([1,2,3,4,5], fun(X)-&gt;X*X end).
=&gt; [1,4,9,16,25]
||&lt;
リストが空のときは空リストを返す
そうでないときは先頭要素Hに関数Fを適用し
一方で残りのリストTでmap関数を再帰し
これらを結合してできるリストを返す
つまりここでは[H|T]を使って
リストの分離と結合をしてる
素敵だねー
ちなみにfun(X)-&gt;X*X end は
Rubyのlambdaにそっくりだよね


**Rubyでやってみる
で
これを見てRubyでも | で
リストの結合や分離ができたら
カッコイイと思ったんだ


じゃあ少しやってみるね
Object#| を定義するといろいろと問題がありそうなので
ここではFixnum String Symbolに対象を絞って実装するよ
&gt;|ruby|
[String, Symbol].each do |klass|
  klass.module_eval do
    def |(other)
      [self] + other
    end
  end
end

class Fixnum
  alias :__OR__ :|
  def |(other)
    case other
    when Array; [self] + other
    else __OR__(other)
    end
  end
end

list = [2,3,4]
'a' | list # =&gt; [&quot;a&quot;, 2, 3, 4]
:a | list # =&gt; [:a, 2, 3, 4]
1 | list # =&gt; [1, 2, 3, 4]
1 | 3 # =&gt; 3
||&lt;

これでリストの結合ができた
どうかな？


次にリストの分離だけれど
Array#| を再定義して引数にIntegerが渡されたら
先頭要素を分離するというのを考えたんだけど
なんかスマートじゃないんだ


で
ここでハタと気が付いたんだけど
Rubyには既にカッコイイ分離方法があったんだよ
&gt;|ruby|
list = [1, 2, 3, 4, 5]
a, *b = list
a # =&gt; 1
b # =&gt; [2, 3, 4, 5]
||&lt;
Rubyの多重代入はリストの分離に使えるんだ


さて
Rubyでも再帰を使ってsumとmapを定義してみよう
Rubyはオブジェクト指向だから
Arrayのメソッドとしてこれらを定義するよ
まずは先の定義を使わない例を示すよ

&gt;|ruby|
class Array
  alias :head :first
  def tail
    drop 1
  end

  def sum(acc=0)
    return acc if empty?
    tail.sum(head+acc)
  end

  def mappy(&amp;blk)
    return [] if empty?
    [blk[head]] + tail.mappy(&amp;blk)
  end
end

[*1..10].sum # =&gt; 55
[*1..5].mappy { |i| i * i } # =&gt; [1, 4, 9, 16, 25]
%w(ruby erlang haskell lisp).mappy { |n| n.capitalize } # =&gt; [&quot;Ruby&quot;, &quot;Erlang&quot;, &quot;Haskell&quot;, &quot;Lisp&quot;]
||&lt;
ここではリストの先頭を返すheadメソッドと
残りを返すtailメソッドを別途定義しているよ


次に
先に定義した | と多重代入を使った
ヴァージョンを示すよ

&gt;|ruby|
class Array
  def sum(acc=0)
    return acc if empty?
    head, *tail = self
    tail.sum(head+acc)
  end

  def mappy(&amp;blk)
    return [] if empty?
    head, *tail = self
    blk[head] | tail.mappy(&amp;blk)
  end
end

[*1..10].sum # =&gt; 55
[*1..5].mappy { |i| i * i } # =&gt; [1, 4, 9, 16, 25]
%w(ruby erlang haskell lisp).mappy { |n| n.capitalize } # =&gt; [&quot;Ruby&quot;, &quot;Erlang&quot;, &quot;Haskell&quot;, &quot;Lisp&quot;]
||&lt;

できたよ!


って
変数名にheadとtailを使ったからか
なんか見た目に違いがなくて
あんまり面白くなかったね..


でもRubyの多重代入が
リストのheadとtailの分離に使えることに
気づけたから僕自身は良しとするよ


(追記:2010-8-16)RubyのArray#sumをErlangのsumに合わせて末尾再帰版に修正しました

</body>
</day>
<day date="2011-08-23" title="">
<body>
*p1*RubyのようなCoffeeScriptを使ってJavaのようなProcessingを書いてJavascriptで実行してWebでビジュアライジング・データを実現しようよ!
「ビジュアライジング・データ ―Processingによる情報視覚化手法」(Ben Fry著) という
情報視覚化の実践的テクニックを解説する素晴らしい本があります


[asin:4873113784:detail]


この本では情報の視覚化にProcessingという
Javaをベースにしたグラフィック専用言語を使っています
Processingはマルチプラットフォームの統合開発環境に
その実行環境を備えていますが
エクスポート機能でJAVAアプレットを生成することで
成果物をWeb上に公開することもできます


http://processing.org/


しかしJAVAアプレットによる情報の視覚化に
不満を持っている人がいました
できればプラグインを介さずに
直接ブラウザのCanvas上で情報視覚化を実現したい
jQuery作者のJohn Resig氏はProcessingをJavaScriptにポートして
ブラウザ上でProcessingのコードを直接実行できるようにしました


[http://processingjs.org/:title=Processing.js]の登場です


一方で
Rubyしか知らない素人プログラマがいました
彼もWeb上での情報の視覚化をしてみたかったので
サイ本を入手してJavaScriptをマスターしようと考えました
Processing.jsの登場によりJavaScriptが書ければ
Processingによる情報の視覚化ができますからね
でもその異質感((Rubyしか知らない個人の感想です))に簡単に跳ね返されて
ビジュアライジング・データの夢は儚く消えました
そして彼はつぶやきました


「世界が全部Rubyで記述できたらいいのに..」


でも
そんな日はなかなか来そうにありません



ところがそんな彼に一条の光明が差しました
まるでRubyと見間違うような
JavaScript用のコンパイラが登場したらしいのです!


その名もCoffeeScript


「プログラミング言語にジャワまでなら許せるけど、
コーヒーはねーよ」と内心思いつつも
その[http://jashkenas.github.com/coffee-script/:title=サイト]を覗いていみると..



「パパ　僕にも読めるよ!」



そんなわけで...


CoffeeScriptとProcessing.jsを使って
ビジュアライジング・データをしてみました :)


つまりRubyのようなCoffeeScriptを使って
JavaのようなProcessingのコードを書いて
Javascriptで実行して
WebのCanvas上でビジュアライジング・データを実現します
僕の言ってることわかりますか？


以下では
先の書籍にあった時系列グラフのサンプルをCoffeeScriptに移植し
Webブラウザで実行できるようにしたデモを紹介します
WebフレームワークはSinatra
開発環境はMac OSX Snow Leopardです
CoffeeScriptの書き方がたぶんイマイチなのはご容赦ください^^;
デモをHerokuにアップしたので
まずは見てやってください


[http://processing-demo.heroku.com/:title=Visualizing-Data with Processing Demo]


タブを切り替えると
グラフがぐにゅっとなるのが気持ちいいですよね
グラフは書籍にあったサンプルの他
2009年の国内人口推計((http://www.stat.go.jp/data/jinsui/2009np/index.htm))を使っています


**ディレクトリ構成
最終的なファイル構成は以下のようになります
&gt;|ssh|
.
├── Gemfile
├── Gemfile.lock
├── app.rb
├── config.ru
├── public
│&amp;#160;&amp;#160; ├── census.ssv
│&amp;#160;&amp;#160; ├── js
│&amp;#160;&amp;#160; │&amp;#160;&amp;#160; ├── graph.coffee
│&amp;#160;&amp;#160; │&amp;#160;&amp;#160; └── processing-1.2.3.min.js
│&amp;#160;&amp;#160; └── milk-tea-coffee.tsv
└── views
    ├── index.haml
    ├── layout.haml
    └── style.scss
||&lt;


**設計方針
以下のような方針でビジュアライジング・データを実現します
+データを格納したcensus.ssv((スペース区切りのテキストファイル))とmilk-tea-coffee.tsv((タブ区切りのテキストファイル))をrubyで読みだして解析する
+解析したデータをJSON APIとして特定のURLで提供できるようにする
+graph.coffeeにProcessingによるグラフ描画コードを記述する
+graph.coffee側で解析データを非同期で取得しグラフに描画する


**app.rb
Webフレームワークのコントローラとなる
app.rbの要点だけを書きます
&gt;|ruby|
get &quot;/milk&quot; do
  haml :index
end

get &quot;/milk.json&quot; do
  redirect '/milk' unless request.xhr?
  content_type :json
  parse_data('public/milk-tea-coffee.tsv', '\t', [5, 2.5, 10]).to_json
end

helpers do
  def parse_data(path, sep, intervals)
    q = {}
    File.open(path) do |file|
      q['label'] = retrieve_label(file.lines.first, sep) 
      q['data'] = retrieve_data(file.lines, sep)
      all_data = q['data'].map { |d| d[0..-2] }.flatten
      q['dataMin'], q['dataMax'] = all_data.min.floor, all_data.max.ceil
      q['intervals'] = intervals
    end
    q
  end
end
||&lt;
ここではグラフを描画するURLを'/milk'としています
JavaScriptから'/milk.json'がgetされると
データファイルをparse_dataメソッドで解析して
結果をJSONで返します
parse_dataでは
label data dataMin dataMax intervalsに値をセットします
labelとdataの取得はretrieve_label retrieve_dataに委ねますが
ここではその説明は省略します


**Processingオブジェクト(graph.coffee)
graph.coffeeは長いので分けて要点だけ説明します
&gt;|javascript|
$ -&gt;
  $.getJSON &quot;/milk.json&quot;, (json) -&gt;
    label = json.label
    data = json.data
    dataMax = Math.ceil(json.dataMax/10.0)*10
    dataMin = if json.dataMin &gt; 0 then 0 else json.dataMin
    [yInterval, yIntervalMinor, xInterval] = json.intervals

    canvas = $(&quot;canvas#processing&quot;)[0]
    processing = new Processing(canvas, graph)
||&lt;
まずHTMLの読み込み完了を待って
jQueryの$.getJSONを使って非同期で
先のURLからJSON化されたデータを取得し
それぞれの値をグローバル変数にセットします


そしてnew Processing(canvas graph)で
グラフ描画の実体である
graphオブジェクトをcanvas要素に結びつけた
Processingオブジェクトを生成します
これによってgraphオブジェクト内のdrawメソッドが
指定のフレームレートで繰り返し実行され
Canvas上にグラフが描かれることになります


**graphオブジェクト(graph.coffee)
次にgraphオブジェクトを示します
&gt;|javascript|
graph = (p) -&gt;
  p.setup = -&gt;
    [rowCount, columnCount] = [data.length-1, label.length-1]
    [dateMin, dateMax] = [data[0][columnCount], data[rowCount][columnCount]]
    [xMin, yMin] = [dateMin[0], dateMax[0]]
    p.size(can_w, can_h)
    p.frameRate(20)
    p.smooth()
    setTabPositions(p)
    for row in [0..rowCount]
      interpolators[row] = new Integrator(0)
      interpolators[row].set_target(data[row][0])

  p.draw = -&gt;
    drawMainFrame(p)
    
    for row in [0..rowCount]
      interpolators[row].update()
      
    drawDataArea(p, areaColor)
    drawXLabels(p)
    drawYLabels(p)
    drawDataHighlight(p, [255, 63, 0])
    drawTabs(p)
||&lt;
graphオブジェクトは
setupメソッドとdrawメソッドを持っています
setupメソッドはgraphオブジェクトの生成時に実行されるので
ここでグラフのサイズやフレームレートなどを設定します
そしてdrawメソッドは指定フレームレートで
そこに書かれた処理を繰り返し実行します
グラフの枠組みをdrawMainFrame drawXLabels
drawYLabels drawTabsで描画し
グラフの描画は
drawDataArea drawDataHighlightで行っています


**drawDataArea(graph.coffee)
次にdrawDataAreaについて説明します
&gt;|javascript|
graph = (p) -&gt;
  drawDataArea = (p, color)-&gt;
    [r,g,b] = color
    p.fill(r,g,b)
    p.noStroke()
    p.beginShape()
    p.vertex(borderLeft, borderBottom)
    for row in [0..rowCount]
      year = data[row][columnCount][0]
      val = interpolators[row].value
      x = p.map(year, xMin, yMin, borderLeft, borderRight)
      y = p.map(val, dataMin, dataMax, borderBottom, borderTop)
      p.curveVertex(x, y)
      if row is 0 or row is rowCount
        p.curveVertex(x, y)
    p.vertex(borderRight, borderBottom)
    p.vertex(borderRight, borderBottom)
    p.endShape(p.CLOSE)
||&lt;
curveVertex関数を使ってデータエリアを描画します
色やストロークを決定した後
beginShape関数で描画を開始し
各点をcurveVertexでプロットして
endShape関数で終了します
他の描画関数も同じようなことをしているので
説明は省略します


**Integrator(graph.coffee)
ここで各点をプロットするときに
データ値を直接渡さずにinterpolatorを介します
interpolatorはBenFryによるIntegratorオブジェクトで
これを介すると描画点をターゲット値に向けて
徐々に増分して描画できるようになります
Integratorの実装を以下に示します
&gt;|javascript|
class Integrator
  # Ben Fry's Integrator
  constructor: (@value, @damping=0.5, @attraction=0.2) -&gt;
    @mass = 1
    @targeting = false
    @vel = 0
    @force = 0.1

  update: -&gt;
    if @targeting
      @force += @attraction * (@target - @value)
    accel = @force / @mass
    @vel = (@vel + accel) * @damping
    @value += @vel
    @force = 0

  set_target: (t) -&gt;
    @targeting = true
    @target = t
||&lt;


**layout.haml
&gt;|html|
!!! 5
%html
  %head
    %meta{:charset =&gt; 'utf-8'}
    %title= APP_TITLE
    %link{:rel =&gt; 'stylesheet', :href =&gt; '/style.css'}
    %script{:src =&gt; &quot;http://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js&quot;}
    %script{:src =&gt; '/js/processing-1.2.3.min.js'}
    %script{:src =&gt; &quot;http://jashkenas.github.com/coffee-script/extras/coffee-script.js&quot;}
    %script{:type =&gt; 'text/coffeescript', :src =&gt; '/js/graph.coffee'}
  %body
    = yield
||&lt;
layout.hamlではscriptとしてjquery.js 
processing.js coffee-script.js graph.coffee を読み込みます
coffee-script.jsはclientサイドで
coffeeファイルをjavascriptに変換します


**config.ru
&gt;|ruby|
require 'bundler'
Bundler.require
$LOAD_PATH &lt;&lt; File.expand_path(File.dirname(__FILE__))
require 'app'

mime_type :coffee, &quot;text/coffeescript&quot;

run Sinatra::Application
||&lt;
coffeeファイルを'text/coffeescript' mime_typeで扱えるよう
config.ruでその指定をします


説明が大雑把で詳細が掴めないと思いますが
ソースコードを添付しますので
そちらを参照頂ければ助かります^^;


https://github.com/melborne/ProcessingDemo


参考サイト:
[http://dry.ly/2011/02/21/coffeescript--processingjs--crazy-delicious/:title=CoffeeScript + Processing.js == Crazy Delicious]



関連記事:
[http://d.hatena.ne.jp/keyesberry/20110204/p1:title=Processingアプレットをはてダに貼り付けよう！ - hp12c]

[http://d.hatena.ne.jp/keyesberry/20110131/p1:title=fun of Processing - hp12c]

[http://d.hatena.ne.jp/keyesberry/20110130/p1:title=fun of Processing! - hp12c]

</body>
</day>
<day date="2011-08-31" title="">
<body>
*p1*Rubyで論理プログラミングしようよ!
人生は選択の連続だよ
１つの選択が君の未来を変えるよ
そして残念なことに
後からその失敗に気がついても
選択をやり直すことは人生ではできないんだよ..


コンピュータプログラムにも似たようなところがあるよ
プログラムは一度走り出したら止まらないから
途中の分岐で選ばれた選択を
後から変えるのは得意じゃないんだ


**問題１
例えば次のような問題を考えてみるよ
&gt;&gt;
 xが1,2,3の何れかで yが4,5,6の何れかであるとき
 x + y = 7
 となるx, yの組みを求めよ
&lt;&lt;
x, yには複数の選択肢があって
xの決定はyの決定に影響を与えるから
その組み合わせを決めるためには
人間がするのと同様の試行錯誤が必要になりそうだよね
どうやってプログラムしたらいいか
ちょっと戸惑うよね


こういったはっきりと決まっていない事実に基づいて
答えを求めることを非決定性の問題と言うらしいよ
なるほどそうすると人生は差し詰め
非決定性の連立方程式を解くようなものなんだろうね


さて君ならこの問題どうコーディングするのかな


確かにコンピュータプログラムは人間と似ているけど
大きく違うところが２つあるよ
それはその計算量と記憶力だよ
コンピュータは短時間で膨大な量の計算をこなして
その結果を忘れずにしっかりと記憶することができる
そのパワーを活用すれば
未来を決定づけるすべての選択肢を用意して
成功の道だけを選ぶようにすることができる


ここでもしこの問題の解法に
ループを考えたとしたら君は負け組だよ


なぜならRubyにはすべての選択肢を生成する
Array#productがあるんだから
&gt;|ruby|
xl = [1, 2, 3]
yl = [4, 5, 6]

xl.product(yl).tap{|t| p t}.select { |x, y| x + y == 7 } # =&gt; [[1, 6], [2, 5], [3, 4]]

# &gt;&gt; [[1, 4], [1, 5], [1, 6], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6]]
||&lt;
ほらできた!


tapの出力を見れば
Array#productがx yの
すべての組み合わせを生成しているのが分かるよね
そしてArray#selectで
x + y = 7の条件を満たすものだけを選択してる


**問題２
じゃあ次はピタゴラスをやってみようよ
説明するまでもないけどピタゴラス数は
[tex:A^2 + B^2 = C^2]
を満たす整数A B Cの組のことだよ
A B Cをすべての整数とすると答えは無限にあるだろうから
ここでは辺の総和(A+B+C)がN以下であるものを求めてみるよ

&gt;|ruby|
def pythag(n)
  al, bl, cl = [*1..n], [*1..n], [*1..n]
  al.product(bl, cl).select do |a, b, c|
    a + b + c &lt;= n &amp;&amp; a**2 + b**2 == c**2
  end
end

pythag(30) # =&gt; [[3, 4, 5], [4, 3, 5], [5, 12, 13], [6, 8, 10], [8, 6, 10], [12, 5, 13]]
||&lt;
あっという間に答えが出た
辺の総和が30以下のピタゴラス数は6組あるんだね


上の条件で各辺の範囲は1～Nで同じだから
Array#repeated_permutationを使ってもいいよね
&gt;|ruby|
def pythag(n)
  [*1..n].repeated_permutation(3).select { |a,b,c| a + b + c &lt;= n &amp;&amp; a**2 + b**2 == c**2 }
end

pythag(30) # =&gt; [[3, 4, 5], [4, 3, 5], [5, 12, 13], [6, 8, 10], [8, 6, 10], [12, 5, 13]]
||&lt;


**問題３
次はもう少し論理問題っぽいものをやってみるよ
&gt;&gt;
baker(パン屋)、cooper(桶屋)、fletcher(矢屋)、miller(粉屋)、smith(鍛冶屋)が５階建てのアパートの別々の階に住んでいる。bakerは最上階には住んでない。cooperは地上階には住んでない。fletcherは最上階にも地上階にも住んでない。millerはcooperよりも上の階に住んでいる。smithはfletcherに接する階には住んでない。fletcherはcooperに接する階には住んでない。誰がどこに住んでいるか？

[計算機プログラムの構造と解釈/４章/３より(一部改変しました)((http://www.mokehehe.com/assari/index.php?%B7%D7%BB%BB%B5%A1%A5%D7%A5%ED%A5%B0%A5%E9%A5%E0%A4%CE%B9%BD%C2%A4%A4%C8%B2%F2%BC%E1%2F%A3%B4%BE%CF%2F%A3%B3))
&lt;&lt;

有名な問題だから知ってる人もいると思うけど
知らなかったらちょっと考えてみてね


Array#productを使えば造作無いよね

&gt;|ruby|
baker_, cooper_, fletcher_, miller_, smith_ = [[*1..5]] * 5

ans = baker_.product(cooper_, fletcher_, miller_, smith_).detect do |baker, cooper, fletcher, miller, smith|
  [baker,cooper,fletcher,miller,smith].uniq.size == 5 &amp;&amp;
  baker != 5 &amp;&amp;
  cooper != 1 &amp;&amp;
  fletcher != 1 &amp;&amp;
  fletcher != 5 &amp;&amp;
  miller &gt; cooper &amp;&amp;
  (smith - fletcher).abs != 1 &amp;&amp;
  (fletcher - cooper).abs != 1 
end

&quot;baker =&gt; %i, cooper =&gt; %i, fletcher =&gt; %i, miller =&gt; %i, smith =&gt; %i&quot; % ans # =&gt; &quot;baker =&gt; 3, cooper =&gt; 2, fletcher =&gt; 4, miller =&gt; 5, smith =&gt; 1&quot;
||&lt;

detect内の条件が増えると
見た目が綺麗じゃないよね
補助関数を作ってもう少し良くしてみるよ


&gt;|ruby|
def rule(*rules)
  rules.all?
end

ans = [*1..5].permutation(5).tap{|t| p t}.detect do |baker, cooper, fletcher, miller, smith|
  rule baker != 5,
        cooper != 1,
        fletcher != 1,
        fletcher != 5,
        miller &gt; cooper,
        (smith - fletcher).abs != 1,
        (fletcher - cooper).abs != 1 
end

&quot;baker =&gt; %i, cooper =&gt; %i, fletcher =&gt; %i, miller =&gt; %i, smith =&gt; %i&quot; % ans # =&gt; &quot;baker =&gt; 3, cooper =&gt; 2, fletcher =&gt; 4, miller =&gt; 5, smith =&gt; 1&quot;

# &gt;&gt; #&lt;Enumerator: [1, 2, 3, 4, 5]:permutation(5)&gt;
||&lt;
rule関数はEnumerable#all?を使って
各条件の&amp;&amp;を取るよ
これでいくらかすっきりしたね
ちなみにこういうのもDSLって呼んでいいのかな？


さらにここではArray#permutationを使ったよ
５人の選択範囲が同じだからね((各値が異なることが保証されるので、最初の条件も不要になる))
productとpermutationは似たメソッドだけど
実はその返り値に大きな違いがあるんだよ
productはそのすべての組み合わせを生成して返すけど
permutationはEnumeratorを返すつまり
この段階では組み合わせを生成しないんだ
そしてselectが呼ばれたときその条件に従って
はじめて内容を評価つまり遅延評価するんだ
これは効率上きっと有利だろうね


**継続
さてArray#productを使った先の解法は
コンピュータパワーを使った
富豪的プログラミングと言えるかも知れないね
例えば先のピタゴラスにおける
productで生成される組の数を見てみよう
&gt;|ruby|
def pythag(n)
  al, bl, cl = [*1..n], [*1..n], [*1..n]
  al.product(bl, cl).tap{ |t| p t.size }.select do |a, b, c|
    a + b + c &lt;= n &amp;&amp; a**2 + b**2 == c**2
  end
end

pythag(30) # =&gt; [[3, 4, 5], [4, 3, 5], [5, 12, 13], [6, 8, 10], [8, 6, 10], [12, 5, 13]]

pythag(100) # =&gt; [[3, 4, 5], [4, 3, 5], [5, 12, 13], [6, 8, 10], [7, 24, 25], [8, 6, 10], [8, 15, 17], [9, 12, 15], [9, 40, 41], [10, 24, 26], [12, 5, 13], [12, 9, 15], [12, 16, 20], [12, 35, 37], [15, 8, 17], [15, 20, 25], [15, 36, 39], [16, 12, 20], [16, 30, 34], [18, 24, 30], [20, 15, 25], [20, 21, 29], [21, 20, 29], [21, 28, 35], [24, 7, 25], [24, 10, 26], [24, 18, 30], [24, 32, 40], [28, 21, 35], [30, 16, 34], [32, 24, 40], [35, 12, 37], [36, 15, 39], [40, 9, 41]]

# &gt;&gt; 27000
# &gt;&gt; 1000000
||&lt;
N=30とした場合
その組み合わせの数は27000組になる
そしてN=100とするとその数は100万組!
ちょっと気になる数字だよね


この例では各辺の選択範囲は同じだから
Array#permutationを使えば問題は解決するけど
選択範囲が異なる場合はpermutationが使えない
それにコンピュータはもっと人間の思考を
シミュレートしたものであるべきだって意見もあるだろうね
つまり一つ試しては戻り一つ試しては戻るという
動作を繰り返しながら一つづつ答えを見つける
そんな試行錯誤型の解法があってもいいよね


Rubyでは継続(Continuation)を使ったプログラミングにより
それが実現できるんだ
Rubyにおける継続はKernel#callccの呼び出しで
「今」を持ち運び可能なオブジェクトにして
未来のどこかでそれを再度呼び出す(callする)
つまり「過去」に戻ることを実現可能にする


ちょっと例を示すよ
&gt;|ruby|
require &quot;continuation&quot;

time_machine = nil
my_vocabularies = 
  [:be_my_wife?, :i_love_you, :i_need_you, :present_for_you, :i_always_love_you]

print &quot;I met her...\n\n&quot;
sleep 1

propose = callcc { |t| time_machine = t; my_vocabularies.shift }

print &quot;I said.. #{propose}.\n&quot;
sleep 1

print &quot;and she said..\n&quot;
sleep 2

puts answer =
    case propose
    when :i_always_love_you
      &quot;yes!&quot;
    when :i_love_you, :i_need_you
      &quot;hmm...&quot;
    else
      &quot;goodbye&quot;
    end

sleep 2
puts
unless answer == &quot;yes!&quot;
  print &quot;Back to the past\n\n&quot;
  time_machine.call(my_vocabularies.shift)
else
  print &quot;Y.E.S!\n&quot;
  exit
end

# &gt;&gt; I met her...
# &gt;&gt; 
# &gt;&gt; I said.. be_my_wife?.
# &gt;&gt; and she said..
# &gt;&gt; goodbye
# &gt;&gt; 
# &gt;&gt; Back to the past
# &gt;&gt; 
# &gt;&gt; I said.. i_love_you.
# &gt;&gt; and she said..
# &gt;&gt; hmm...
# &gt;&gt; 
# &gt;&gt; Back to the past
# &gt;&gt; 
# &gt;&gt; I said.. i_need_you.
# &gt;&gt; and she said..
# &gt;&gt; hmm...
# &gt;&gt; 
# &gt;&gt; Back to the past
# &gt;&gt; 
# &gt;&gt; I said.. present_for_you.
# &gt;&gt; and she said..
# &gt;&gt; goodbye
# &gt;&gt; 
# &gt;&gt; Back to the past
# &gt;&gt; 
# &gt;&gt; I said.. i_always_love_you.
# &gt;&gt; and she said..
# &gt;&gt; yes!
# &gt;&gt; 
# &gt;&gt; Y.E.S!
||&lt;
暇なら手元にコピーして実行してみてくれる？


さて自分でRubyの継続を使って
先の問題を解きたいところなんだけど
どうにも僕の頭がついていかなくて
継続を使いこなすにはまだ時間が掛かりそうなんだよ


そこで継続を使ったRubyの拡張ライブラリAmbの
助けを借りることにするよ
Ambを使うとより宣言的に論理問題の条件を記述できるんだ


gem install ambでインストールして次のように使うよ((loaderroが出た場合lib/amb.rb内のパスを修正してください))
まずはピタゴラスから
&gt;|ruby|
require 'amb'

def pythag(n)
  q = []
  amb = Class.new{include Amb}.new
  a = amb.choose *(1..n)
  b = amb.choose *(1..n)
  c = amb.choose *(1..n)
  
  amb.assert a + b + c &lt;= n
  amb.assert a**2 + b**2 == c**2
  q &lt;&lt; [a, b, c]
  amb.failure
rescue
  q
end
pythag(30) # =&gt; [[3, 4, 5], [4, 3, 5], [5, 12, 13], [6, 8, 10], [8, 6, 10], [12, 5, 13]]
||&lt;
Ambはモジュールだからクラスにincludeして使うよ
Amb#chooseで選択肢をセットするんだけど
このとき裏ではcalccが呼ばれているよ
Amb#assertで条件を定義して
a b cを呼び出せば答えが得られる
Amb#failureはすべての答えが得られるまで
継続をcallして答えがなくなるとエラーを送出するんだ
failureを呼ばなければ最初の答えだけが得られる


同じことはAMB.solve_allクラスメソッドでも実現できるよ
&gt;|ruby|
n = 30
AMB = Class.new{include Amb}
AMB.solve_all do |amb|
  a = amb.choose *(1..n)
  b = amb.choose *(1..n)
  c = amb.choose *(1..n)

  amb.assert a + b + c &lt;= n
  amb.assert a**2 + b**2 == c**2
  p [a, b, c]
end

# &gt;&gt; [3, 4, 5]
# &gt;&gt; [4, 3, 5]
# &gt;&gt; [5, 12, 13]
# &gt;&gt; [6, 8, 10]
# &gt;&gt; [8, 6, 10]
# &gt;&gt; [12, 5, 13]
# &gt;&gt; No More Solutions
||&lt;


じゃあアパート住人の問題もAmbで解いてみるよ
&gt;|ruby|
AMB = Class.new{include Amb}
AMB.solve do |amb|
  baker = amb.choose(1, 2, 3, 4, 5)
  cooper = amb.choose(1, 2, 3, 4, 5)
  fletcher = amb.choose(1, 2, 3, 4, 5)
  miller = amb.choose(1, 2, 3, 4, 5)
  smith = amb.choose(1, 2, 3, 4, 5)

  amb.assert [baker, cooper, fletcher, miller, smith].uniq.size == 5
  amb.assert baker != 5
  amb.assert cooper != 1
  amb.assert fletcher != 1 &amp;&amp; fletcher != 5
  amb.assert miller &gt; cooper
  amb.assert (smith - fletcher).abs != 1
  amb.assert (fletcher - cooper).abs != 1

  puts &quot;baker =&gt; %i, cooper =&gt; %i, fletcher =&gt; %i, miller =&gt; %i, smith =&gt; %i&quot; % [baker, cooper, fletcher, miller, smith]
end

# &gt;&gt; baker =&gt; 3, cooper =&gt; 2, fletcher =&gt; 4, miller =&gt; 5, smith =&gt; 1
||&lt;
なんか宣言的でいいよね!


最後にベンチマークを取ってみるよ
N=100でビタゴラスを求めたときの結果だよ
&gt;|ruby|
require &quot;benchmark&quot;
require &quot;amb&quot;

def pythag(n)
  al, bl, cl = [*1..n], [*1..n], [*1..n]
  al.product(bl, cl).select do |a, b, c|
    a + b + c &lt;= n &amp;&amp; a**2 + b**2 == c**2
  end
end

def pythag_with_permutation(n)
  [*1..n].repeated_permutation(3).select { |a,b,c| a + b + c &lt;= n &amp;&amp; a**2 + b**2 == c**2 }
end

def pythag_with_amb(n)
  q = []
  amb = Class.new{include Amb}.new
  a = amb.choose *(1..n)
  b = amb.choose *(1..n)
  c = amb.choose *(1..n)
  
  amb.assert a + b + c &lt;= n
  amb.assert a**2 + b**2 == c**2
  q &lt;&lt; [a, b, c]
  amb.failure
rescue
  q
end

Benchmark.bmbm do |bm|
  n = 100
  bm.report { pythag(n) }
  bm.report { pythag_with_permutation(n) }
  bm.report { pythag_with_amb(n) }
end
# &gt;&gt; Rehearsal ------------------------------------
# &gt;&gt;    0.510000   0.050000   0.560000 (  0.594200)
# &gt;&gt;    0.360000   0.000000   0.360000 (  0.361962)
# &gt;&gt;   12.240000   0.600000  12.840000 ( 12.879879)
# &gt;&gt; -------------------------- total: 13.760000sec
# &gt;&gt; 
# &gt;&gt;        user     system      total        real
# &gt;&gt;    0.540000   0.010000   0.550000 (  0.549009)
# &gt;&gt;    0.340000   0.000000   0.340000 (  0.349040)
# &gt;&gt;   12.210000   0.530000  12.740000 ( 12.763450)
||&lt;

うわっAmb遅っ!


参考サイト:
[http://www.geocities.jp/m_hiroi/light/abcruby17.html:title=お気楽 Ruby プログラミング入門]
[http://jp.rubyist.net/?KansaiWorkshop16#l12:title=日本Rubyの会 公式Wiki - KansaiWorkshop16]
[http://shugo.net/jit/20051029.html:title=関西オープンソース2005発表 , 非決定性計算 , KOF宴会 - Journal InTime(2005-10-29)]
[http://rubyist.g.hatena.ne.jp/muscovyduck/20070601/p1:title=Rubyの「継続(Continuation)」(1) - バリケンのRuby日記 - Rubyist]
[http://d.hatena.ne.jp/tociyuki/20070320/1174403351:title=継続でバックトラックを Ruby で - Tociyuki::Diary]
[http://practical-scheme.net/docs/cont-j.html:title=なんでも継続]


(追記:2011-9-1) 参考サイトのリンクを追記しました。一部コードを修正しました。
(追記:2011-11-27) 一部Array#permutationをArray#repeated_permutationに変更しました。

</body>
<comments>
<comment>
<username>kumonopanya</username>
<body>ans = [*1..5].permutation(5)tap{|t| p t}.select do |baker, cooper, fletcher, miller, smith|&lt;br&gt;&lt;br&gt;tapの前の.が抜け落ちている。&lt;br&gt;&lt;br&gt;ans = [*1..5].permutation(5).tap{|t| p t}.select do |baker, cooper, fletcher, miller, smith|</body>
<timestamp>1314865703</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;kumonopanyaさん&lt;br&gt;ありがとう！訂正しました</body>
<timestamp>1314866451</timestamp>
</comment>
</comments>
</day>
<day date="2011-09-02" title="">
<body>
*p1*Rubyでもリスト内包表記したい？

PythonやHaskellやErlangにはリスト内包表記と呼ばれる
リストの中で新たなリストを生成する構文があるよ

例えばRubyでリストの要素の値を倍にしたい場合は
Array#mapを使うよね
&gt;|ruby|
 l = [*1..10]
 l.map { |i| i*2 } # =&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
||&lt;


これをErlangのリスト内包表記では以下のように書けるんだ
&gt;|erlang|
 L = lists:seq(1,10).
 [X*2 || X &lt;- L].  % =&gt; [2,4,6,8,10,12,14,16,18,20]
||&lt;
リストLからXを選び出しそれに2を掛けたものを返す
つまり || の左辺には出力となる式を
右辺には限定子を書く
X &lt;- LはErlangではGeneratorと呼ぶらしいよ


次にリストから偶数だけを選んで
それらを倍にしたい場合を考えるよ
Rubyなら次のように書くよね
&gt;|ruby|
 l.select(&amp;:even?).map { |i| i*2 } # =&gt; [4, 8, 12, 16, 20]
||&lt;

またはこう書くよ
&gt;|ruby|
 l.map { |i| i*2 if i.even? }.compact # =&gt; [4, 8, 12, 16, 20]
||&lt;


これがErlangではこう書けるんだよ
&gt;|erlang|
 [X*2 || X &lt;- L, X rem 2 =:= 0].  % =&gt; [4,8,12,16,20]
||&lt;
リストの最後の項がfilterになって
選び出されるXを限定する
Rubyもいい線いってるけど
リスト内包のほうが宣言的でわかりやすいかな


さらに
リストから偶数かつ5より大きい数だけを選んで
倍にする場合をやってみるよ
まずはRuby
&gt;|ruby|
 l.select { |i| i.even? &amp;&amp; i &gt; 5 }.map { |i| i*2 } # =&gt; [12, 16, 20]
||&lt;
または
&gt;|ruby|
 l.map { |i| i*2 if i.even? &amp;&amp; i &gt; 5 }.compact # =&gt; [12, 16, 20]
||&lt;


Erlangだと次のようになるよ
&gt;|erlang|
 [X*2 || X &lt;- L, X rem 2 =:= 0, X &gt; 5]. # =&gt; [12,16,20]
||&lt;
複数のfilterをカンマ区切りで指定できる
簡潔だよね


さらにもう一歩進んでみよう
3つの異なる範囲のリスト(l1=1～5, l2=3～7, l3=5～9)があって
それらから一つずつ選択された数の合計が11になるものを求めるよ
[http://d.hatena.ne.jp/keyesberry/20110831/p1:title=前の記事]で紹介したように
RubyではArray#productを使えば簡単にできるよね
&gt;|ruby|
l1 = [1,2,3,4,5]
l2 = [3,4,5,6,7]
l3 = [5,6,7,8,9]
l1.product(l2, l3).select { |a,b,c| a + b + c == 11  }

# =&gt; [[1, 3, 7], [1, 4, 6], [1, 5, 5], [2, 3, 6], [2, 4, 5], [3, 3, 5]]
||&lt;


これをErlangのリスト内包表記では次のように書けるんだ
&gt;|erlang|
 L1 = [1,2,3,4,5].
 L2 = [3,4,5,6,7].
 L3 = [5,6,7,8,9].
 [{A,B,C} || A &lt;- L1, B &lt;- L2, C &lt;- L3, A + B + C =:= 11].

 % =&gt; [{1,3,7},{1,4,6},{1,5,5},{2,3,6},{2,4,5},{3,3,5}]
||&lt;
わかりやすいね
つまりリスト内包では複数のgeneratorを指定できて
それらから要素が良しなに取り出されて
filterの条件にマッチする組だけが生成される


Rubyのproductも簡潔ではあるけれども
あらかじめすべての組み合わせが生成されてしまう
という点がイマイチかな

**Rubyで実装を試みる
そんなわけで
Rubyでなんとかリスト内包表記っぽいことが
できないか考えてみたよ(ネタとして)


最初に考えた構文は次のとおりだよ
&gt;|ruby|
class Array
  def %(ary)
    map(&amp;ary[0]).compact
  end
end

list = [*1..10]
list % [-&gt;x{x*2 if x.even?}] # =&gt; [4, 8, 12, 16, 20]
||&lt;
Array#%を定義してその引数として
Procオブジェクトを一つ含む配列を取る
そして渡すProcの中でgeneratorとfilterを指定するよ


ary[0]とするのがダサいよね


ということで
次のようなものも考えてみたよ
&gt;|ruby|
list = [*1..10]
list. &lt;=[-&gt;x{x*2 if x.even?}] # =&gt; [4, 8, 12, 16, 20]
||&lt;


一瞬でこの実装がわかる人はいる？
ちょっと凝ってみたんだけど..



実装は次のとおりだよ
&gt;|ruby|
class Array
  def &lt;=
    -&gt;x { map { |e| x[e] }.compact }
  end
end
||&lt;
つまりArray#&lt;=を引数なしで呼んで
それが返したProcオブジェクトを
Proc#[]でcallしてる
-&gt;x{x*2 if x.even?}はその引数となるProcオブジェクトだよ
&lt;=[]とするとProcの呼び出しに全く見えないよね


でもまだ-&gt;x{x*2 if x.even?}がイケテない
せめてgeneratorとfilterに分けたい
それで次のようにしてみたよ
&gt;|ruby|
class Array
  def &lt;=
    -&gt;gen,*preds {
      select { |e| preds.all? { |pred| pred[e] } }
      .map { |e| gen[e] }
    }
  end
end

list = [*1..10]
list. &lt;=[-&gt;x{x*2}, -&gt;x{x.even?}, -&gt;x{x&gt;5}] # =&gt; [12, 16, 20]
||&lt;
こうすれば
filterをカンマ区切りでいくつでも追加できる


でも正直-&gt;x{ }がいくつも連続するのはヒドすぎるねー
&gt;|ruby|
list. &lt;=[x*2, x.even?, x&gt;5] # =&gt; [12, 16, 20]
||&lt;
のように出来ればいいんだけど
xは未定義だから構文エラーになっちゃう
それに複数のgeneratorを渡すこともできないから
先の3つのリストの合計を取るような問題にも対応できない..



**RBridge
で諦めかけたそのとき..


全く別のアプローチに気が付いたんだよ!


次のコードは先の３つのリストの合計を取る例を
関数sum_toとして実装してるんだ
&gt;|ruby|
def sum_to(n, a, b, c, x=&lt;&lt;-ERL)
  [ {A, B, C} ||
      A &lt;- #{a},
      B &lt;- #{b},
      C &lt;- #{c},
      A + B + C =:= #{n}
  ]
  ERL
  x.evarl
end

a = [1,2,3,4,5]
b = [3,4,5,6,7]
c = [5,6,7,8,9]

sum_to(11, a, b, c)

# =&gt; [[1, 3, 7], [1, 4, 6], [1, 5, 5], [2, 3, 6], [2, 4, 5], [3, 3, 5]]
||&lt;

関数sum_toの中身はErlangのコードそのままだよ
ヒアドキュメントによりErlangのコードを文字列化し
これにevarlメソッドを送ってる


もう気が付いた人もいると思うけど..


そう　裏でErlangサーバーを起動して
Rubyから呼んでいるのでした!
String#evarlの実装は次のとおりだよ
&gt;|ruby|
require &quot;rbridge&quot;

class String
  def evarl
    @@erl ||= RBridge.new(nil, &quot;localhost&quot;, 9900)
    @@erl.erl self
  end
end
||&lt;
RBridgeというRubyからErlangサーバに接続できる
拡張ライブラリが実はあるんだよ!


gem install rbridgeでインストールして
シェルでrulangコマンドを実行してサーバを起動する
デフォルトの待ち受けポートは9900になるよ((サーバの停止はps aux | grep rulangなどとしてPIDを見つけてkill PIDしてください))


そして先のコードのように指定ポートで
RBridgeのインスタンスを生成し
RBridge#erlにErlangのコードを含む文字列を渡す
するとbeamというErlangのエミュレータでこれを解析し
結果をRubyの形式で返すよ


便利なものを作ってくれる人が
世の中にはいるもんだね!


**id:ku-ma-meさんによるRubyの内包表記
で世の中には他にもすごい人がいるんだよ((改めて言うまでもありませんが..))
Rubyで実用レベルのリスト内包表記
類似の構文ができてるんだ


[http://d.hatena.ne.jp/ku-ma-me/20070623/p2:title=Ruby で内包表記 - まめめも]
&gt;|ruby|
# [ x^2 | x &lt;- [0..10] ] みたいなもの
p list{ x ** 2 }.where{ x.in(0..10) }
  #=&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# [ [x, y] | x &lt;- [0..2], y &lt;- [0..2], x &lt;= y ] みたいなもの
p list{ [ x, y ] }.where{ x.in(0..2); y.in(0..2); x &lt;= y }
  #=&gt; [[0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2]]

# sieve (x:xs) = x:sieve [ y | y &lt;- xs, y `mod` x /= 0 ] みたいなもの
def sieve(x, *xs)
	ys = list{ y }.where{ y.in(xs); y % x != 0 }
	[x] + (ys.empty? ? [] : sieve(*ys))
end
p sieve(*(2..50))
  #=&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
||&lt;


すごいよね
で　この構文を見て実装がどうなっているか
想像できる人はどれくらいいるのかな
もう僕にはまったく歯が立たなかったよ
変数x yは一体..


そしてその実装を見ても..


まだまだ僕は精進が必要だよ


ちなみにRuby1.9だと
continuationをrequireする必要があるよ


参考サイト:
[http://d.hatena.ne.jp/unageanu/20071120/1195562775:title=Rulang BridgeでRubyからErlangを呼び出してみた - うなの日記](現在の実装はこの記述とは少し異なっています)

</body>
</day>
<day date="2011-09-08" title="">
<body>
*p1*Ruby脳でCoffeeScriptのクラスを理解する
Rubyは最高の言語だから
もっと普及していいと思うけれども
その障害となっているのはたぶん
「Rubyがビジュアルに訴えない言語」となっているからだよ
たしかにRubyにはRuby/TkとかShoesとかがあるけど
現代のプログラミングで「ビジュアル」と言ったら
暗黙的に「Web上の」という修飾が付くよね


一方でJavaScriptは
jQueryやCoffeeScriptの人気を見る限り
最高とは言えない言語だけれども
「ビジュアルに訴える言語」となっている点が
普及の大きな要因になっていると思うよ
つまりブラウザ上で実行できる唯一の言語たる地位が
JavaScriptの大きなアドバンテージなんだね


だから今のところ
「最高の言語でビジュアルなプログラミング」
をすることはできないけれども僕らにはCoffeeScriptがあるよ
CoffeeScriptはRubyの影響を大きく受けてるから
この言語を使って「ビジュアル」なプログラミングをすることが
現時点での最良の選択だと僕は思うんだよ


そんなわけで..


JavaScriptのことをよく知らないRuby脳の僕が
Coffeescriptのクラスのことを少し学んだので
ここでRubyのクラスと対比しつつ説明してみるよ
きっと誤解があると思うけど間違っていたら教えてね
なお以下ではCoffeeScriptのことを単にCoffeeと呼ぶよ


さっそくCoffeeを使って
簡単なクラスを定義してみるよ
&gt;|javascript|
class Duck
  constructor: (@name, @age) -&gt;

  say: -&gt;
    &quot;Quack Quack #{@name}!&quot;

mofi = new Duck('Mofi', 12)
pipi = new Duck('Pipi', 9)
tete  = new Duck('Tete', 5)

mofi.say() # =&gt; &quot;Quack Quack Mofi!&quot;
pipi.say() # =&gt; &quot;Quack Quack Pipi!&quot;
tete.say() # =&gt; &quot;Quack Quack Tete!&quot;
||&lt;
Rubyを知っているならこのコードはすぐ読めるよね
new関数でDuckオブジェクトを生成して
sayメソッドを呼んでいるよ


対応するRubyコードはこんな感じかな
&gt;|ruby|
class Duck
  def initialize(name, age)
    @name, @age, = name, age
  end
  
  def say
    &quot;Quack Quack #{@name}&quot;
  end
end

mofi = Duck.new('Mofi', 12)
pipi = Duck.new('Pipi', 9)
tete = Duck.new('Tete', 5)

mofi.say # =&gt; &quot;Quack Quack Mofi&quot;
pipi.say # =&gt; &quot;Quack Quack Pipi&quot;
tete.say # =&gt; &quot;Quack Quack Tete&quot;
||&lt;
インスタンス変数への初期値の代入構文は
Rubyにもほしい機能だよね


一見これらのコードは同じに見えるけど
異なる挙動が２つほどあるよ


１つ目はCoffeeでは先のコードで
既にインスタンス変数への外部からのアクセスが
可能になっている点だよ
確かめてみよう
&gt;|ruby|
mofi.name = &quot;mofy&quot;
mofi.name # =&gt; mofy
mofi.say() # =&gt; Quack Quack Mofy!
||&lt;
読み出しも書き込みもできる
Rubyではメソッドを介してじゃないと
インスタンス変数にアクセスすることはできないので
Coffeeと等価にするには
アクセッサメソッドを定義する必要があるよ


２つ目は
sayの呼び出しには常にカッコが必要な点だよ
CoffeeでRubyのようにカッコを省略すると
次のような結果が返るよ
&gt;|javascript|
mofi.say

# =&gt; function () {                                
         return &quot;Quack Quack &quot; + this.name + &quot;!&quot;;
       }                                         
||&lt;
これはJavaScriptに変換された
sayのコードそのものだよ
そしてCoffeeではsayの後のカッコが
そのメソッドを実行させるんだね


つまりこういうことだよ
Coffee(JavaScript)では
オブジェクトの後に続く.nameや.sayは
オブジェクトの内部変数nameや
sayにセットされた値にアクセスする方法なんだよ
そしてJavaScriptでは
関数はファーストクラスのオブジェクトだから
他のデータと同じように
内部変数にそのままセットできるんだ
JavaScriptでは
このような内部変数をプロパティと呼ぶそうだよ


さてこれらの点を考慮して
Rubyのコードを修正すると次のようになるよ
&gt;|ruby|
class Duck
  attr_accessor :name, :age
  def initialize(name, age)
    @name, @age, = name, age
  end
  
  def say
    -&gt;{ &quot;Quack Quack #{@name}&quot; }
  end
end

mofi = Duck.new('Mofi', 12)
pipi = Duck.new('Pipi', 9)
tete = Duck.new('Tete', 5)

mofi.say.call # =&gt; &quot;Quack Quack Mofi&quot;
pipi.say.() # =&gt; &quot;Quack Quack Pipi&quot;
tete.say[] # =&gt; &quot;Quack Quack Tete&quot;
tete.say # =&gt; #&lt;Proc:0x00000100866680@-:8 (lambda)&gt;
||&lt;
attr_accessorの説明は不要だよね
sayメソッドはProcオブジェクトを返すようにして
呼び出し側でProc#callすれば
Coffeeと同様の結果が得られるよ
Proc#callの別名() []もここで示したよ


さて一応先のCoffeeコードを
JavaScriptにコンパイルしたものにも目を通してみるよ
CoffeeScriptの[http://jashkenas.github.com/coffee-script/#top:title=公式サイト]でTRY COFFSCRIPTすると
次のJavaScriptのコードが得られるんだ
&gt;|javascript|
var Duck, mofi, pipi, tete;
Duck = (function() {
  function Duck(name, age) {
    this.name = name;
    this.age = age;
  }
  Duck.prototype.say = function() {
    return &quot;Quack Quack &quot; + this.name + &quot;!&quot;;
  };
  return Duck;
})();

mofi = new Duck('Mofi', 12);
pipi = new Duck('Pipi', 9);
tete = new Duck('Tete', 5);

mofi.say();
pipi.say();
tete.say();
||&lt;


JavaScriptのことはよくわからないから
ここからの説明は僕の推測を大いに含んでいるよ
まずCoffeeにおけるconstructor: () -&gt; というのが
function Duck(){} に変換されているから
constructorは関数定義になることがわかるよ
このDuck関数を実行してnewに渡すと
nameとageのプロパティを持った
オブジェクトが生成されるんだね
JavaScriptはRubyのような
クラスベースのオブジェクト指向ではなくて
コピーベースのオブジェクト指向だから
ここで生成された３つのオブジェクトmofi pipi teteは
Duckオブジェクトのコピーと考えればいいのかな


次にCoffeeにおける say: -&gt; が
Duck.prototype.say = function(){} と変換されているよ
つまり
Duckオブジェクトのprototypeという名のプロパティに
sayプロパティが生成されてここに関数がセットされている
なるほど
コピーベースのオブジェクト指向においては
Duck.say = function(){} とすると関数の実体が
すべてのオブジェクトにコピーされてしまって
効率上問題がある
だからprototypeという共通の器を作って
そこに関数を置けるようにしたんだね


**メソッドの追加
さて次にオブジェクトに別のメソッドを追加してみよう
Rubyでインスタンスメソッドを追加するには
クラスを再オープンすればいいよね
&gt;|ruby|
class Duck
  def how_old
    -&gt;{ &quot;I'm #{@age} years old.&quot; }
  end
end

mofi.how_old.call # =&gt; &quot;I'm 12 years old.&quot;
pipi.how_old.call # =&gt; &quot;I'm 9 years old.&quot;
||&lt;


Coffeeで同じことをするには
上で学んだようにDuckのprototypeプロパティに
関数をセットすればいいはずだよ
これはCoffeeでは次のようにするよ
&gt;|javascript|
Duck::howOld = -&gt;
  &quot;I'm #{@age} years old.&quot;

mofi.howOld() # =&gt; &quot;I'm 12 years old.&quot;
pipi.howOld() # =&gt; &quot;I'm 9 years old.&quot;
||&lt;
Rubyで::は定数のスコープ演算子を表すから
これはちょっと間違えそうだね


JavaScriptにコンパイルするよ
&gt;|javascript|
Duck.prototype.howOld = function() {
  return &quot;I'm &quot; + this.age + &quot; years old.&quot;;
};

mofi.howOld(); # =&gt; &quot;I'm 12 years old.&quot; 
pipi.howOld(); # =&gt; &quot;I'm 9 years old.&quot;  
||&lt;
いいみたいだね
ちなみにJavaScriptでは
クラスを再オープンすることはできなさそうだね
Duckを再定義すると
別のDuckオブジェクトが定義されてしまうよ


**プロパティの追加
Coffeeでは個々のオブジェクトに
簡単にプロパティを設定できるよ
&gt;|javascript|
pipi.color = 'brown'
pipi.swim = -&gt;
  &quot;swim #{@age} days!&quot;

pipi.color # =&gt; 'brown'
pipi.swim() # =&gt; 'swim 9 days!'
||&lt;


もちろんこれらは
他のオブジェクトからは参照できないよ
&gt;|javascript|
tete.color # =&gt; undefined
tete.swim() # =&gt; TypeError: Object #&lt;Duck&gt; has no method 'swim'
||&lt;


JavaScriptの対応コードは次のようになるよ
&gt;|ruby|
pipi.color = 'brown';
pipi.swim = function() {
  return &quot;swim &quot; + this.age + &quot; days&quot;;
};

pipi.color;
pipi.swim();
||&lt;


Coffeeのオブジェクトにおけるこの軽量さは
Ruby脳にはちょっと驚きだよ
まるでRubyのHashのようだね


さてRubyでもオブジェクト固有のメソッドを定義できるので
等価コードを書いてみるよ
&gt;|ruby|
class &lt;&lt; pipi
  attr_accessor :color
  def swim
    &quot;swim #{@age} days!&quot;
  end
end
pipi.color = 'brown'

pipi.color # =&gt; &quot;brown&quot;
pipi.swim # =&gt; &quot;swim 9 days!&quot;

tete.color # =&gt; undefined method `color'
tete.swim # =&gt; undefined method `swim'
||&lt;


Rubyではpipiオブジェクトについて
シングルトンクラスを開いて
各メソッドを定義する必要があるよ


ちなみにprototypeプロパティに定義された関数と
同名の関数をプロパティにセットすると
どうなるかは想像がつくよね
そのオブジェクトに関しては
それが優先して呼び出されるんだ

&gt;|javascript|
class Duck
  constructor: (@name, @age) -&gt;

  say: -&gt;
    &quot;Quack Quack #{@name}!&quot;

mofi = new Duck('Mofi', 12)
pipi = new Duck('Pipi', 9)
tete  = new Duck('Tete', 5)

mofi.say = -&gt;
  &quot;Gaa Gaa #{@name}!&quot;

mofi.say() # =&gt; &quot;Gaa Gaa Mofi!&quot;
pipi.say() # =&gt; &quot;Quack Quack Pipi!&quot;
tete.say() # =&gt; &quot;Quack Quack Tete!&quot;
||&lt;
この挙動はRubyでも同じだね


**クラスメソッド
さて次にDuckクラスに
クラスメソッドを定義することを考えてみるよ
まずはRubyにDuckの総数をカウントする
countクラスメソッドを定義してみるよ
&gt;|ruby|
class Duck
  @@count = 0
  def self.count
    @@count
  end
  def initialize(name, age)
    @name, @age, = name, age
    @@count += 1
  end
end

mofi = Duck.new('Mofi', 12)
pipi = Duck.new('Pipi', 9)
tete = Duck.new('Tete', 5)

Duck.count # =&gt; 3
||&lt;
クラス変数@@countを初期化し
Duck.countメソッドを定義して
@@countにアクセスできるようにする
そしてinitializeでカウントアップするよ


CoffeeにおいてDuckクラスの外で
Duckのプロパティをセットするのは
Duck.count = 0でできるけど
クラス定義の中では次のように書くみたいだね
&gt;|ruby|
class Duck
  @count: 0  または @count = 0
  constructor: (@name, @age) -&gt;
    Duck.count += 1

mofi = new Duck('Mofi', 12)
pipi = new Duck('Pipi', 9)
tete  = new Duck('Tete', 5)

Duck.count # =&gt; 3
||&lt;
インスタンス変数と同じ @ を使うよ
ちょっと紛らわしいけどプロパティの中と外で
@の意味が変わることを覚えとけばいいね


**プライベート・メソッド
さて次にDuckにプライベートメソッドを定義してみるよ
Rubyではprivateキーワードで簡単にできるよね
eatメソッドで呼ばれるfoodメソッドを定義するね
&gt;|ruby|
class Duck
  def eat
    -&gt;{ &quot;eat &quot; + food }
  end

  private
  def food
    &quot;meat!&quot;
  end
end

mofi = Duck.new('Mofi', 12)

mofi.eat.call # =&gt; &quot;eat meat!&quot;
mofi.food # =&gt; private method `food' called
||&lt;


それでプライベートメソッドで
インスタンス変数を呼ぶことももちろんできるよ

&gt;|ruby|
class Duck
  def eat
    -&gt;{ &quot;eat &quot; + food }
  end

  private
  def food
    &quot;#{@age} meat!&quot;
  end
end

mofi = Duck.new('Mofi', 12)

mofi.eat.call # =&gt; &quot;eat 12 meat!&quot;
||&lt;


Coffeeでプライベートメソッドを定義するには
ちょっとわからないけど次のようにするのかな

&gt;|javascript|
class Duck
  eat: -&gt;
    &quot;eat &quot; + food()

  food = -&gt;
    &quot;beans&quot;
 
mofi = new Duck('Mofi', 12)

mofi.eat() # =&gt; 'eat beans'
mofi.food() # =&gt; TypeError: Object #&lt;Duck&gt; has no method 'food'
||&lt;
オブジェクト内のfood変数に&quot;beans&quot;を返す
無名関数をセットするよ


次にfoodでインスタンス変数を呼ぶよ
&gt;|javascript|
class Duck
  eat: -&gt;
    &quot;eat &quot; + food()

  food = -&gt;
    &quot;#{@age} beans&quot;
 
mofi = new Duck('Mofi', 12)

mofi.eat() # =&gt; 'eat undefined beans'
||&lt;


残念ながらこれがうまくいかないんだよ
ちょっと僕には理由がわからないんだけど..


ここでは引数でオブジェクトを指し示すthisを受け渡して
目的を達成するよ

&gt;|javascript|
class Duck
  eat: -&gt;
    &quot;eat &quot; + food(this)

  food = (obj)-&gt;
    &quot;#{obj.age} beans&quot;
 
mofi = new Duck('Mofi', 12)

mofi.eat() # =&gt; 'eat 12 beans'
||&lt;


僕が勉強したのはここまでだよ
Coffeeではクラスの継承もできるみたいなんだけど
それはまた別機会にするよ


(追記:2011-09-09) 記述を一部加筆・修正しました。

</body>
</day>
<day date="2011-09-14" title="">
<body>
*p1*僕はブログを書く ~ HateDa::Bookmarks の紹介
僕はブログを書く
名前も知らない誰かが
そのテーマに惹かれて
きっと読んでくれるから


僕はブログを書く
年齢も性別も知らない誰かが
僕と同じ関心を持って
ブクマをしてくれるから


僕はブログを書く
きっと生涯会うことのない誰かが
その内容に共感して
スターやコメントをくれるから


僕はブログを書く
ブクマやスターを通して
同じ関心を持っている人たちを
見つけることができるから


僕はブログを書く


でもどうやったら
僕のブログに良くブクマしてくれる人を
簡単に見つけることができるの？
どうやったら..




というわけで..


はてダのブックマーク情報を取得して
ブックマーカー別 記事別などの
統計を得るための簡単なツール
HateDa::BookmarksをRubyで作りました;)


**HateDa::Bookmarksの使い方
次のサイトからファイルをダウンロードします
htmlの解析にNokogiriを使っているので
なければgem install nokogiriしてください


https://github.com/melborne/HateDa


以下のように使います
&gt;|ruby|
&gt;&gt; require 'hateda'
&gt;&gt; bm = HateDa::Bookmarks.new(:keyesberry) # =&gt; #&lt;HateDa::Bookmarks:0x00000100d22570 @username=:keyesberry, @total=nil, @dataset=nil&gt;
&gt;&gt; bm.dataset
&gt;&gt; bm.dataset.first # =&gt; {:url=&gt;&quot;http://d.hatena.ne.jp/keyesberry/20110908/p1&quot;, :title=&gt;&quot;Ruby脳でCoffeeScriptのクラスを理解する - hp12c&quot;, :marker=&gt;&quot;nabetama&quot;, :tags=&gt;[&quot;ruby&quot;, &quot; coffeescript&quot;, &quot; javascript&quot;, &quot; js&quot;], :note=&gt;&quot;&quot;, :time=&gt;2011-09-13 00:00:00 +0900}

&gt;&gt; bm.total #=&gt; 1647
||&lt;


Bookmarks#datasetメソッドではてなから
ブックマーク情報を取得し解析します
つまりそこからurl title marker tags note timeの
情報を含んだハッシュのリストを生成します
一度取得したデータセットは@datasetにキャッシュされます
Bookmarks#totalメソッドで総ブックマーク数が得られます


そしてBookmarks#group_by_topメソッドを使って
ブックマーカー別　エントリー別などの
集計情報を生成できます
&gt;|ruby|
&gt;&gt; top10_markers = bm.group_by_top(:marker, 10).map{|name, list| [name, list.size]}
  # =&gt; [[&quot;yuiseki&quot;, 37], [&quot;Watson&quot;, 26], [&quot;tomisima&quot;, 23], [&quot;kitokitoki&quot;, 16], [&quot;taka222&quot;, 14], [&quot;ohnishiakira&quot;, 12], [&quot;ku-kai27&quot;, 10], [&quot;Naruhodius&quot;, 10], [&quot;aka5ping&quot;, 10], [&quot;Layzie&quot;, 9]]

&gt;&gt; top10_entries = bm.group_by_top(:title, 10).map{|t, list| [t, list.size]}
  # =&gt; [[&quot;知って得する21のRubyのトリビアな記法 ~ 21 Trivia Notations you should know in Ruby - hp12c&quot;, 160], [&quot;QuickSilver、君はランチャーなんかじゃない、実行統合環境だ！ - hp12c&quot;, 107], [&quot;IRB　それはRubyistの魔法のランプ - hp12c&quot;, 96], [&quot;1から始めるRuby - hp12c&quot;, 70], [&quot;Rubyなら動くグラフも作れるよ！ - hp12c&quot;, 58], [&quot;SinatraはDSLなんかじゃない、Ruby偽装を使ったマインドコントロールだ！ - hp12c&quot;, 53], [&quot;Rubyのシンボルは文字列の皮を被った整数だ！ - hp12c&quot;, 45], [&quot;Rubyで論理プログラミングしようよ! - hp12c&quot;, 41], [&quot;RubyでANSIカラ - hp12c&quot;, 37], [&quot;Ruby製ノコギリで株価を切り刻もう! - hp12c&quot;, 29]]

&gt;&gt; Layzie_bookmarks = bm.dataset.select{|h| h[:marker] == 'Layzie'}.map{|h|h[:title]}
  # =&gt; [&quot;Rubyのクラスとメソッドを全部いっぺんに！ - 再改訂版 - hp12c&quot;, &quot;オープンソース・プログラマも知っておきたい商標のこと（その４） - hp12c&quot;, &quot;オープンソース・プログラマも知っておきたい商標のこと（その３） - hp12c&quot;, &quot;オープンソース・プログラマも知っておきたい商標のこと（その２） - hp12c&quot;, &quot;オープンソース・プログラマも知っておきたい商標のこと（その１） - hp12c&quot;, &quot;SchemeとRubyでリストの操作を学ぼう - hp12c&quot;, &quot;Ruby.Sinatra.Git.Heroku  #=&gt; \&quot;Happy Web Development!\&quot; - hp12c&quot;, &quot;Ruby.Sinatra.Git.Heroku #=&gt; \&quot;Happy Web Development!\&quot;　(後編) - hp12c&quot;, &quot;QuickSilver、君はランチャーなんかじゃない、実行統合環境だ！ - hp12c&quot;]
||&lt;
なおブクマ数が4000を超える場合は
最新4000のブックマークのみを対象にしています((MAX_PAGESを200に設定))
どれくらいの同時アクセスが許容されるのかよくわからないので..((このあたりの常識をご存じの方教えて下さい!))


なおこのツールには以前紹介した
はてダの記事一覧を取得するツールも含まれています


[http://d.hatena.ne.jp/keyesberry/20110127/p1:title=Rubyではてダの記事一覧を取得してまとめ頁を作ろう！ - hp12c]


**Hatena Bookmarkers in Visual
折角なのでこのツールで取得した情報を
ビジュアライズするDemoサイトを
Processing.jsを使って作ってみました:)
あなたのはてダのTOP20ブックマーカーを
グラフ表示するだけの簡単なサイトです


[f:id:keyesberry:20110914151214p:image]
[http://hdbmkrs.heroku.com/:title=Hatena Bookmarkers]


トップページではてなIDを入れるとグラフが表示されます
最初のアクセスではデータ取得に数秒掛かります
グラフの各バーは各ユーザのサイトにリンクしていて
クリックするとオープンできます
これであなたのブログにブクマしてくれてる人の
発信している情報に簡単にアクセスできますね!
作りこみが甘い点はDemoということでご勘弁を..


なお現状でブクマ数が4000を超えるサイトの
データ取得がうまくいっていません
ローカルでは問題ないのですがHeroku上では
Threadがうまく生成されていないようです..
どなたか解決策が分かりましたら教えて下さい^^;


一応サイトのコードも置いておきます
[https://github.com/melborne/hdbmkrs:title=melborne/hdbmkrs - GitHub]

</body>
<comments>
<comment>
<username>Dissertation Writing</username>
<body>nice blog..</body>
<timestamp>1317124739</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;Dissertation Writing&lt;br&gt;thanks!</body>
<timestamp>1317168503</timestamp>
</comment>
</comments>
</day>
<day date="2011-09-29" title="">
<body>
*p1*irbから学ぶRubyの並列処理 ~ forkからWebSocketまで
世の中は並列化花ざかりだよ
人間はシングルタスクのままなのに
プログラミングするときは
マルチタスクが要求されるなんて
世知辛い世の中になったものだね


でも情報革命は始まったばかりだから
愚痴ってばかりもいられないよ
自分がその波にうまく乗れないとしても
うまく乗ってる人の様を
間近で見てみたいと思うんだ



そんなわけで..


Rubyのfork Thread Reactor EventMachine
WebSocketなどの並列化について少し学んだので
自分の理解をここにまとめておくよ


**REPL
irbはRubyにおける対話型の実行環境だよ
これは一般にはREPLと呼ばれてるんだ
REPLはユーザの入力を
読み取り(Read)
評価し(Eval)
出力する(Print) 処理を
繰り返すよ(Loop)


irbのコードは5000行にものぼるらしいけど
その核心は次のように1行で書けるよ
&gt;|ruby|
 loop{ puts eval gets }
||&lt;
getsでユーザ入力を読み取り
evalで評価し
putsで出力する処理を
loopで繰り返す
これじゃGEPLだけどね:)


このコードを保存して(gepl.rb)
実行してみよう
&gt;|sh|
$ ruby gepl.rb
%w(ruby lisp haskell).map(&amp;:upcase)
RUBY
LISP
HASKELL       

&quot;hello, repl!&quot;.gsub('r','g')
hello, gepl!  
||&lt;
ちゃんと動いてるね
Ctrl+Cで終了するよ


通常loopは無限ループを生成するけど
先のコードではgetsのところで処理が止まり
ユーザからの入力を待ち受ける
ここがポイントだよ


ちなみにこのコードは
その入出力を明示的にして
次のようにも書けるね
&gt;|ruby|
loop do
  input = $stdin.gets
  output = eval(input)
  $stdout.puts output
end
||&lt;
デフォルトでグローバル変数$stdinと$stdoutには
標準入力　標準出力がセットされてるから
キーボードからの入力が読み取られ
ディスプレイに出力がなされるんだ


**マルチユーザーREPL
REPLは１ユーザに対する対話環境だよ
でも複数ユーザで使えたらもっとうれしいよね
どうすればいい？


そうだよ
入出力と評価(eval)を切り離せばいいんだよ
いわゆるクライアント・サーバー方式だね
クライアントからの入力をサーバーに渡して評価し
結果をクライアントに出力する


じゃあ早速REPLサーバーを書いてみるよ
&gt;|ruby|
#repl_server.rb
require &quot;socket&quot;

server = TCPServer.new(60000)
loop do
  client = server.accept   # clientからの接続を待つ
  
  begin
    loop { client.puts eval client.gets }
  rescue
  ensure
    client.close
  end
end
||&lt;
Rubyならこんなに簡単に書けちゃうんだ
TCPServer.newでサーバーインスタンスを生成し
acceptメソッドでクライアントからの接続を待ち受けるよ
クライアントが接続したら
getsでユーザからの入力を評価し結果をユーザに返す
接続したクライアント(これをソケットと呼ぶよ)からgetsし
ソケットにputsしてるところがポイントだよ


$stdin $stdoutの参照先を
クライアントのソケットに切り替えるやり方にすると
最初のコードとの違いがはっきりするかもね
&gt;|ruby|
#repl_server.rb
require &quot;socket&quot;

server = TCPServer.new(60000)
loop do
  client = server.accept
  begin
    $stdin, $stdout = client, client
    loop { puts eval gets }
  rescue
  ensure
    client.close
    $stdin = STDIN
    $stdout = STDOUT
  end
end
||&lt;
ensure節ではこれらの後処理をしているよ


サーバーを立ち上げて
クライアントから接続してみようよ
telnetを使うね
&gt;|sh|
$ telnet localhost 60000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
3.times { puts &quot;Hello, friend&quot; }
Hello, friend
Hello, friend
Hello, friend
3
||&lt;
いい感じだね
Ctrl+]に続きquitでtelnetの接続を切るよ


**並列化REPL
でも先のサーバーには大きな問題があるよ
誰か一人が接続していると
他の人が接続できないつまり
複数の人が同時に使えないんだよ
先のコードで１つの接続がacceptされると
loop内のgetsは
その接続先ユーザからの入力を待ち続けることになる
でそのユーザの接続が切れてはじめて
処理はループされacceptで
別の接続を待ち受けられるようになるんだ
これは大問題だね
複数のターミナルから接続して試してみればわかるよ


さあここで並列化の出番だよ


Rubyで並列化を実現するにはいくつかの方法があるよ
ちょっとどんなやり方があるか考えてみてくれる？


**個別接続による並列化
もっとも単純な方法は処理が終わるたびに
ユーザからの接続を毎回切る方法だよ
前のユーザの接続が切れれば
サーバーは別の接続を待てるからね
まあ
これを並列化と呼ぶのはどうかとも思うけど..


コードは次のような感じになるかな
&gt;|ruby|
require &quot;socket&quot;

server = TCPServer.new(60000)
loop do
  client = server.accept
  client.puts eval client.gets
  client.close
end
||&lt;
evalしたものをクライアントに返したら
そのソケットを閉じる
これによってそのクライアントの接続は切れるから
別のクライアントからの接続を待ち受けられるようになる


構成がシンプルでいいんだけど
ユーザにとってはちょっと面倒だよね
使うたびに接続し直さなきゃならないからね
なんかWebサーバーみたいだよね..


**forkによる並列化
２つ目は複数のプロセスを起動する方法だよ
Rubyでプロセスを並列化するにはKernel#forkを使うよ


forkのブロックで囲まれたコードは別プロセスで起動されるから
loop{}のところをforkのブロックに投げればよさそうだね
やってみるよ
&gt;|ruby|
require &quot;socket&quot;

server = TCPServer.new(60000)
loop do
  client = server.accept
  fork do    # 別プロセスで起動
    begin
      loop { client.puts eval client.gets }
    rescue
    ensure
      client.close
    end
  end
end
||&lt;
acceptでクライアントが接続すると
forkで別プロセスが起動されて
その中でgetsの待ち受けがされるけど
メインプロセスは外側のループで先頭に戻り
これでacceptで別のクライアントの接続を待てるね


じゃあ複数のtelnetから接続して試してみよう
&gt;|sh|
$ telnet localhost 60000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
1 + 2
3
---------------------------------------
$ telnet localhost 60000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
[2011,10,1].join '-'
2011-10-1
||&lt;
うまくいったね


念のためこの状況で
複数のプロセスが立ってるか確認してみるよ
&gt;|sh|
$ ps aux | grep repl_server
keyes     1335   0.3  0.1  2448356   1176 s001  R+    3:01PM   0:00.90 ruby repl_server.rb
keyes     1303   0.3  0.0  2448356   1040 s001  S+    2:59PM   0:01.30 ruby repl_server.rb
keyes     1301   0.3  0.2  2448356   3756 s001  R+    2:59PM   0:01.34 ruby repl_server.rb
||&lt;
３つのプロセスが立ってるのがわかるね


ただプロセスは個々に独立したメモリ空間を専有するから
接続ユーザ数が多くなるとちょっと心配だよね
またチャットサーバーのように
ユーザ間での情報のやり取りが必要な場合
プロセス間で通信させなきゃならないから
そんなときはちょっと厄介そうだよね


**Threadによる並列化
３つ目はスレッドを使う方法だよ
スレッドは１つのプロセス内で処理を並走させる仕組みだよ
並走する処理は同じプロセス内にあるから
その間でのデータ共有が容易という利点があるんだ


じゃあThreadクラスを使ったサーバーを書いてみるよ
&gt;|ruby|
require &quot;socket&quot;

server = TCPServer.new(60000)
loop do
  client = server.accept
  
  Thread.new(client) do |cl|
    begin
      loop { cl.puts eval cl.gets }
    rescue
    ensure
      cl.close
    end
  end
end
||&lt;
forkをThread.newに変えればいいだけだから簡単だね
ただスレッドは同じプロセス内で並走するから
acceptしたclientをブロック引数を通して
ちゃんと渡さないと問題が生じるよ


同じように複数のtelnetから接続してみるよ
&gt;|sh|
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
[*1..10].select{|i| i.even? }
2
4
6
8
10
-------------------------------
Connected to localhost.
Escape character is '^]'.
Array.ancestors
Array
Enumerable
Object
Kernel
BasicObject
-------------------------------
$ ps aux |grep repl_server
keyes     1712   0.3  0.2  2451964   3808 s001  S+    7:03PM   0:00.24 ruby repl_server.rb
||&lt;
プロセスは１つのままだってこと確認できるよね


前でスレッドがマルチプロセスよりも
データ共有が容易って書いたから
そのサンプルも書いてみるよ
サーバーからの出力を
接続しているすべてのクライアントに出力する例だよ
&gt;|ruby|
require &quot;socket&quot;

server = TCPServer.new(60000)
clients = []   # 接続クライアントの管理用配列
loop do
  client = server.accept
  clients &lt;&lt; client  # 接続クライアントを登録
  
  Thread.new(client) do |cl|
    begin
      loop do
        output = eval cl.gets
        clients.each { |c| c.puts output }  # 結果を全クライアントに配信
      end
    rescue
    ensure
      cl.close
      clients.delete(cl) # 切断したクライアントを管理対象外に
    end
  end
end
||&lt;
接続クライアント管理用の配列を用意して
結果を全員にブロードキャストすればいいね
簡単だね


ただスレッドモデルはスレッド間で共有するデータを
書き換えるような場合の取り扱いがちょっと厄介だよ
それとやっぱり各スレッドごとに
いつ来るかわからないデータを待っている
というのが無駄といえば無駄だよね



**Reactorパターンによる並列化
４つ目はReactorパターンを使って並列化する方法だよ
Reactorパターンというのは簡単に言うと
一箇所でいろいろなイベントを待ち受けて
イベントが来たらこれに反応(リアクト)して
その種類に応じた処理を実行するモデルのことだよ
RubyでReactorパターンを実現するには
IO.selectメソッド(またはKernel#select)を使うよ


早速Reactor版REPLサーバーを書いてみるよ
REPLサーバーにおけるイベントには
サーバーに対するものつまりクライアントの接続と
クライアントに対するものつまりソケットへのデータ入力があるよ
これらをsocketsという配列で管理しよう
&gt;|ruby|
require &quot;socket&quot;

server = TCPServer.new(60000)
sockets = [server]
loop do
  r_sockets = IO.select(sockets)[0] # すべてのイベントを待ち受ける
  r_sockets.each do |socket|
    case socket
    when TCPServer     # サーバーに対するクライアントの接続があったとき
      client = socket.accept
      sockets &lt;&lt; client
    when TCPSocket     # クライアントに対するデータ入力があったとき
      unless socket.eof?
        socket.puts eval socket.gets
      else
        socket.close
        sockets.delete(socket)
      end
    end
  end
end
||&lt;

IO.selectは登録したソケットに対する
入力／出力／例外のイベントを待ち受け
そのイベントが発生したソケットを返すけど
返り値はイベント別のソケットの配列になっているよ
ここでは入力イベントだけに関心があるから
配列の第一要素のみ取り出してるよ


そしてcase式でイベントのあった
ソケットの種類に応じて処理を切り分けてるよ
つまりサーバーがクライアントからの接続を受けたときは
TCPServerの節に入って
sockets配列に接続のあったクライアントが登録され
ループでselectに戻って次のイベントを待つよ
最初のクライアントの接続時にはsockets配列には
serverしか登録されていないから
処理は必ずここに来ることになるよ


一方クライアントにデータの入力があったときは
TCPSocketの節に入って入力データの処理をするよ
入力データがあるときはそれを評価し結果を返し
無いときはソケットを閉じてその接続を解放するよ
そしてループでまたselectに戻って次のイベントを待つよ


Reactorパターンでは
すべてのクライアントの接続は維持されたままなのに
処理が並走しないつまり単一プロセス単一スレッドで
複数クライアントからの要求に応じることができる
という点がユニークだよ
このモデルなら処理が並走することはないので
共有データを書き換えるようなことも簡単にできるよね


**EventMachineによる並列化
ただwhen式でのソケットの切り分け処理が
面倒といえば面倒だよね
でも安心していいよ
EventMachineというライブラリを使えば
これが驚異的に簡単にできちゃうんだよ
&gt;|ruby|
require &quot;eventmachine&quot;

EM.run do
  EM.start_server('localhost', 60000) do |c|
    def c.receive_data(data)
      send_data eval(data)
    end
  end
end
||&lt;
EventMachineはRreactorパターンによる
イベント駆動型のI/Oインタフェースを提供するライブラリだよ
JavaScriptのNode.jsみたいなものなんだろうね


もうコードを見れば分かると思うけど
EM.runでイベントループが開始されて
クライアントからのデータ入力があると
receive_dataメソッドが呼び出されるので
ここでsend_dataを呼んでevalした入力を返せばいいんだ


EventMachineを使えば
チャットサーバーだって簡単に書けちゃうんだ
&gt;|ruby|
require &quot;eventmachine&quot;

module Chat
  @@channel = EM::Channel.new
  def post_init
    puts &quot;-- someone connected&quot;
    @sid = @@channel.subscribe { |data| send_data &quot;&gt;&gt; #{data}&quot; }
  end

  def receive_data(data)
    @@channel.push data
  end

  def unbind
    puts &quot;-- someone disconnected from the server&quot;
    @@channel.unsubscribe(@sid)
  end
end

EM.run do
  EM.start_server('localhost', 60000, Chat)
end
||&lt;
EMサーバーはクライアントの接続があるたびに
その引数でセットしたChatモジュールをインスタンス化して
その監視対象として登録するよ((モジュールをインスタンス化って変だよね..))
各インスタンスのpost_initメソッドはその接続時に
unbindメソッドはその切断時に呼び出され
receive_dataは先の例と同様にデータ受信時に呼び出されるよ


データをブロードキャストするにはEM::Channelを使うよ
subscribeでそのクライアントに対する処理を登録して
pushで呼び出せばいいんだ


gem install eventmachineして
telnetから試してみてね

**WebSocket
ここまでくるとWebサーバー上でも
この並列化技術を使いたいと考えるのが人情だよね
そう
これこそがWebSocketなんだよ


そしてうれしいことにEventMachineには
そのためのプラグインem-websocketがあるんだ
gem install em-websocketして使うよ
サーバー側のコードは次のような感じだよ
&gt;|ruby|
require 'em-websocket'

EM.run {
  @channel = EM::Channel.new

  EM::WebSocket.start(:host =&gt; &quot;localhost&quot;, :port =&gt; 60000) do |ws|
    sid = nil
    ws.onopen { sid = @channel.subscribe { |msg| ws.send msg } }
    ws.onmessage { |msg| @channel.push &quot;#{sid}: #{msg}&quot; }
    ws.onclose { @channel.unsubscribe(sid) }
  end
}
||&lt;
EM::WebSocket.startでサーバーインスタンスを立ち上げて
クライアントからの接続を待ち受けるよ
クライアントからの接続があるとonopenが呼ばれるから
ここでchannelに
メッセージをブロードキャストする処理を登録するよ
クライアントがテキストを送信するとonmessageが呼ばれるから
それをchannelにpushして登録した処理を呼ぶよ


次にクライアントサイドのコードだよ
&gt;|html|
&lt;html&gt;
  &lt;head&gt;
    &lt;script src='http://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js'&gt;&lt;/script&gt;
    &lt;script&gt;
      $(document).ready(function(){
        function debug (str) { $(&quot;#debug&quot;).append(&quot;&lt;p&gt;&quot;+str+&quot;&lt;/p&gt;&quot;) };
        
        ws = new WebSocket(&quot;ws://localhost:60000/&quot;);
        ws.onopen = function() { debug(&quot;Welcome to Chattata!&quot;) };
        ws.onmessage = function(evt) { $(&quot;#msglist&quot;).append(&quot;&lt;p&gt;&quot;+evt.data+&quot;&lt;/p&gt;&quot;) };
        ws.onclose = function() { debug(&quot;socket closed&quot;) };

        $(&quot;form&quot;).submit(function(){
          var msg = $(&quot;input#msg&quot;);
          ws.send(msg.val());
          msg.val('');
          return false;
        });
      });
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;debug&quot;&gt;&lt;/div&gt;
    &lt;form&gt;
      &lt;input id=&quot;msg&quot; type=&quot;text&quot;&gt;&lt;/input&gt;
    &lt;/form&gt;
    &lt;div id=&quot;msglist&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
||&lt;
クライアント側では
サーバーに接続するソケットをインスタンス化するよ
ユーザがテキストを送信すると$(&quot;form&quot;).submitが呼ばれ
その内容はws.sendでソケットに送り出されるよ
これによってサーバー側のchannelに登録された処理が呼ばれ
接続されているクライアントに
テキストがブロードキャストされるよ
クライアント側ではこれをonmessageで受けて
テキストをwindow上に表示するよ


じゃあ試してみるよ

[f:id:keyesberry:20110929223805p:image]


良い感じだね！
WebSocketはHTML5の新しい規格だから
対応ブラウザか確認してね


ちょっと長い投稿になっちゃったけど
最後まで付き合ってくれてありがとう

</body>
</day>
<day date="2011-10-09" title="">
<body>
*p1*RubyでFizzBuzz問題を解いて上司に対抗しよう!
FizzBuzz問題は有名だから
少しプログラムをかじったことがあれば
名前くらいは知ってるよね
それを会社の10人のプログラマにテストしてみたら
あまりできがよくなかったという話があるよ


[http://d.hatena.ne.jp/JunichiIto/20111007/1317976730#20111007f1:title=FizzBuzz問題を使って社内プログラミングコンテストを開催してみた - ITは芸術だ]


確かにFizzBuzz問題は一見単純だから
誰でも簡単に解けると思われがちだけど
時間制限付きの抜き打ちテストというかたちでだされたら
頭が混乱して僕もどんな結果になるか心配だよ


だから上司の嫌がらせで恥をかかされないように
いまからしっかりと予習しておくよ:)


**問題の分割
通常1つの問題は複数の小さな問題でできているんだ
だから与えられた問題を読んだとき最初にすべきことは
それを複数の小さな問題に切り分けることだよ


早速FizzBuzz問題を小さな問題に切り分けてみよう


僕はFizzBuzz問題は次のような
3つの小さな問題に切り分けられると思うんだ


+1つの数を取ってFizzBuzzの結果を返す関数を作る問題
+1からxまでの数をその関数に適用する関数を作る問題
+スクリプト引数xを2の関数に与えて結果をターミナルに出力する関数を作る問題


**小さな問題1
じゃあこれらの問題を順に解いていくよ
まずは最初の小さな関数(fizzbuzzとする)を作ろう
これは1を取ったら1
2を取ったら2
3を取ったら'Fizz'
5を取ったら'Buzz'
を返すような関数を作ればいいから簡単だよね


あ いい忘れたけど僕はRubyしか書けないからRubyで書くよ
例えばこんなのどうかな？
&gt;|ruby|
def fizzbuzz(n)
  case
  when n%5==0 &amp;&amp; n%3==0; 'FizzBuzz'
  when n%5==0; 'Buzz'
  when n%3==0; 'Fizz'
  else n
  end
end

fizzbuzz(1) # =&gt; 1
fizzbuzz(3) # =&gt; &quot;Fizz&quot;
fizzbuzz(4) # =&gt; 4
fizzbuzz(5) # =&gt; &quot;Buzz&quot;
fizzbuzz(10) # =&gt; &quot;Buzz&quot;
fizzbuzz(15) # =&gt; &quot;FizzBuzz&quot;
||&lt;


オーソドックスだけど個人的には
Fixnum#%が何回も出てくるのはイケてないと感じるよ
こうすればもう少し良くなるかな
&gt;|ruby|
def fizzbuzz(n)
  mod_zero = -&gt;base{ n%base == 0 }
  case
  when mod_zero[3] &amp;&amp; mod_zero[5]; 'FizzBuzz'
  when mod_zero[3]; 'Fizz'
  when mod_zero[5]; 'Buzz'
  else n
  end
end

fizzbuzz(1) # =&gt; 1
fizzbuzz(3) # =&gt; &quot;Fizz&quot;
fizzbuzz(4) # =&gt; 4
fizzbuzz(5) # =&gt; &quot;Buzz&quot;
fizzbuzz(10) # =&gt; &quot;Buzz&quot;
fizzbuzz(15) # =&gt; &quot;FizzBuzz&quot;
||&lt;


少し良くなったと思うけど
個人的にはwhenの順位を考慮しなきゃ
いけないってのが好きじゃないんだ
これはどうかな？
&gt;|ruby|
def fizzbuzz(n)
  x = &quot;&quot;
  x &lt;&lt; &quot;Fizz&quot; if n%3 == 0
  x &lt;&lt; &quot;Buzz&quot; if n%5 == 0
  x.empty? ? n : x
end

fizzbuzz(1) # =&gt; 1
fizzbuzz(3) # =&gt; &quot;Fizz&quot;
fizzbuzz(4) # =&gt; 4
fizzbuzz(5) # =&gt; &quot;Buzz&quot;
fizzbuzz(10) # =&gt; &quot;Buzz&quot;
fizzbuzz(15) # =&gt; &quot;FizzBuzz&quot;
||&lt;

まあこれは趣味の問題かもね..


**小さな問題2
さて2つ目の小さな問題を解くよ
2つ目は
「1からxまでの数をその関数に適用する関数を作る」
だったね
RubyにはEnumeratorがあるから
これはばかみたいに簡単だよね
関数名をmap_uptoにしよう
&gt;|ruby|
def map_upto(max, f)
  (1..max).map { |n| f[n] }
end

map_upto(15, method(:fizzbuzz)) # =&gt; [1, 2, &quot;Fizz&quot;, 4, &quot;Buzz&quot;, &quot;Fizz&quot;, 7, 8, &quot;Fizz&quot;, &quot;Buzz&quot;, 11, &quot;Fizz&quot;, 13, 14, &quot;FizzBuzz&quot;]
||&lt;


**小さな問題3
次に3つ目の小さな問題を解くよ
3つ目は
「スクリプト引数xを2の関数に与えて
結果をターミナルに出力する関数を作る」
だったね
Rubyスクリプトに与えられた引数は
ARGVという配列に格納されるよね
またターミナルへの改行出力はputsだよね
だから次のようになるよ
関数名をconsoleとするよ
&gt;|ruby|
def console(f)
  raise &quot;need an argument of integer&quot; if ARGV[0].nil?
  max = ARGV[0].to_i
  f[max].each { |e| puts e }
end
||&lt;
ここでは引数がない場合のチェックしかしてないけど
厳密なチェックが必要ならここで書くことになるよ


さあこれで完成だよ
コードをまとめて再掲するよ
&gt;|ruby|
def fizzbuzz(n)
  x = &quot;&quot;
  x &lt;&lt; &quot;Fizz&quot; if n%3 == 0
  x &lt;&lt; &quot;Buzz&quot; if n%5 == 0
  x.empty? ? n : x
end

def map_upto(max, f)
  (1..max).map { |n| f[n] }
end

def console(f)
  raise &quot;need an argument of integer&quot; if ARGV[0].nil?
  max = ARGV[0].to_i
  f[max].each { |e| puts e }
end

if __FILE__ == $0
  fizzbuzz_upto = -&gt;max{ map_upto(max, method(:fizzbuzz)) }
  console fizzbuzz_upto
end
||&lt;

さあ実行してみよう
&gt;|sh|
$ ruby fizzbuzz.rb 15
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
||&lt;
うまくいったね!


問題を切り分けて
一つづつ解いていけば簡単だね


経験あるプログラマは
これらを瞬時に頭の中でやってしまうから
ぼくらの気持ちがわからないんだね
次のようなコードをよく見るけど
個人的には問題の切り分けができてないから
良いコードとは思えないんだよ
&gt;|ruby|
max = ARGV[0].to_i
(1..max).each do |n|
  res =
    case 
    when n%3 == 0 &amp;&amp; n%5 == 0; 'FizzBuzz'
    when n%3 == 0; 'Fizz'
    when n%5 == 0; 'Buzz'
    else n
    end
  puts res
end
||&lt;
テストしづらいし改変にも弱いからね


先のコードならテストしやすいし改変にも強そうだよね

&gt;|ruby|
require &quot;test/unit&quot;
require &quot;stringio&quot;
require &quot;./fizzbuzz&quot;

class TestFizzBuzz &lt; Test::Unit::TestCase
  def setup
    @ans = [1,2,'Fizz',4,'Buzz','Fizz',7,8,'Fizz','Buzz',11,'Fizz',13,14,'FizzBuzz']
  end

  def test_fizzbuzz
    (1..15).each { |n| assert_equal(@ans[n-1], fizzbuzz(n)) }
  end

  def test_map_upto
    assert_equal(@ans, map_upto(15, method(:fizzbuzz)))
  end

  def test_console
    begin
      $stdout = op = StringIO.new(&quot;&quot;, 'w')
      fizzbuzz_upto = -&gt;max{ map_upto(max, method(:fizzbuzz)) }
      console(fizzbuzz_upto)
      out = str2fizzbuzz_list(op.string)
      assert_equal(@ans, out)
    ensure
      $stdout = STDOUT
    end
  end

  def str2fizzbuzz_list(str)
    str.split.map { |n| n =~ /(Fi|Bu)zz/ ? n : n.to_i }
  end
end
||&lt;


(追記:2011-10-15)関数の機能分離が不十分だったので修正しました。


関連記事:
[http://d.hatena.ne.jp/keyesberry/20100318/p1:title=Yet Another Ruby FizzBuzz - hp12c]
[http://d.hatena.ne.jp/keyesberry/20100324/p2:title=Yet Another Ruby FizzBuzz その2 - hp12c]
[http://d.hatena.ne.jp/keyesberry/20100324/p1:title=Yet Another Ruby FizzBuzz その3 - hp12c]
[http://d.hatena.ne.jp/keyesberry/20100324/p3:title=Yet Another Ruby FizzBuzz その4 - hp12c]

</body>
</day>
<day date="2011-10-11" title="">
<body>
*p1*プログラミング言語が好き？ ~WebSocketのデモ
少し前にRubyでWebSocketする記事を書いたよ


[http://d.hatena.ne.jp/keyesberry/20110929/p1:title=irbから学ぶRubyの並列処理 ~ forkからWebSocketまで - hp12c]


折角WebSocketの概要を理解したんだから
簡単なデモを作ってみんなに見てもらいたいと思ったんだよ


それで次のようなものが出来上がったよ


[http://lovelang.heroku.com/:title=Love Languages?]


[f:id:keyesberry:20111011180850p:image]


僕の独断で選んだ12の言語から
自分の好きな言語を選んで投票するデモだよ
円グラフはWebSocketによりリアルタイムで更新されるから
君が見ているときに誰かが投票していれば
その様子がわかるようになっているよ
誰もそこにいなければiPhoneからでも投票して
PCの画面を見てみれば変化がわかると思うよ


デモでは好きな言語に好きなだけ投票できるから
言語の人気度は測れないけど
その言語に対する熱愛度が測れるかもしれないよ
このブログに辿り着く人はRuby好きが多いだろうから
結果が相当偏りそうだけどね..


適当に遊んでもらえるとうれしいよ


WebSocketの実装には[http://pusher.com/:title=Pusher]というサービスを使ってるんだけど
その使い方は別の記事にできればと思うよ
とりあえずコードは[https://github.com/melborne/LoveLang:title=github]に置いておくね


(追記:2011-10-14) 諸般の事情((scriptクリックが絶えないので..))によりコードは一旦非公開とします。すいません
(追記:2011-10-12) 諸般の事情((熱愛度が激しすぎて..))によりデモは停止中です。ごめんなさい。
(追記:2011-10-19) デモは再開しています。またいつメンテに入るかわかりませんが...
(追記:2011-10-24) サンプルコードを再掲しました。


</body>
</day>
<day date="2011-10-26" title="">
<body>
*p1*LoveLangの熱き戦い
２週ほど前に私は[http://lovelang.heroku.com:title=LoveLang]という
小さなサイトをHeroku上に公開しました
ちょうどWebSocketを学んだばかりだったので
ちょっとデモを作ってその動作を試してみたかったのです
いつものようにそのことを
このブログとTwitterで告知しました


何人かの人が来て
自分の好きな言語のボタンを数回クリックして
去って行きました
中にはそこに留まる人もいました
LoveLangはリアルタイムで見ている人の人数がわかるのです


暫くは大した動きはなかったので
あらためてTwitterで投票を呼びかけてみました
これにfollower1800の@jugyoさんが答えてくれました((https://twitter.com/#!/jugyo/status/123773761534177280))
するとTwitter上にLoveLangのリンクを貼ったTweetが
増殖していきました
10前後だったUserCounterの値が30 40と増えていきました
円グラフ上の数値はすごい勢いでインクリメントしていきました
これを機に様相は一変したのです


遂にはその声は
follower15000のRubyのパパにも届きました((https://twitter.com/#!/yukihiro_matz/status/123790343064924160))
UserCounterは100を超えました
TwitterでもLoveLangを話題にしたつぶやきが多数見られました
LoveLangはプログラマの何かに火をつけたのです


だんだんサイトが重くなって
新たなコネクションを張れなくなりました
そしてfollower45000の@dankogai氏が訪れたとき((https://twitter.com/#!/dankogai/status/123794000854515712, https://plus.google.com/103748274114027132441/posts/1wj37XUnHB6))には
コネクションは300を超えて
さらに接続は困難なものになりました


私は興奮しました


円グラフの数値はすごい勢いで増えていき
各言語の値があっという間に
10万クリックを超えました
Twitter上で特定の言語に対するクリック支援
を要請する動きすらありました
そのような口コミの広がりが新たな参加者を呼び込み
グラフ上の数値は加速度的に増加していったのです


[http://ceron.jp/site/lovelang.heroku.com:title=サイト情報：lovelang.heroku.com - Ceron.jp]
[http://topsy.com/lovelang.heroku.com/:title=Twitter Trackbacks for Love Languages?]


しかしその中には明らかに人間の手に拠らないすなわち
スクリプトによる値の増加が見受けられました
Twitter上でもこれに言及する発言が増えていきました
LoveLangを「公認DoSサイト」とか
「自動クリックゲー」と呼ぶ人も現れました
考えてみれば
怠慢・短気・傲慢を美徳とするプログラマに
「マウスをクリックして言語愛を示せ」とは
無理な相談だったのかも知れません


ここに至って私はやっと
自分が一部のプログラマに
挑戦状を叩きつけていたことを知るのです...


深夜になっても
Clicked by Scriptは止まりませんでした
サイトはWebSocket実現のために
Pusher((http://pusher.com/))の無料プランを利用しています
しかしどういうわけかその制約を超えてコネクションは維持され
無数のClicked by Scriptをさばいたのです


やむなく公開から8時間後一旦サイトを閉鎖し
データをリセットしました
腱鞘炎を顧みずコーディングも放り投げて
ひたすらクリックで言語愛を表明してくれた人たちには
申し訳ない気持ちで一杯でした..


その日のメッセージ総数は
信じられないことに1億に達していました
軽い気持ちで公開したデモサイトが
自分に未曾有の経験をもたらしました
私にはまともなサイトを公開した経験も
サイトセキュリティに関する知識も
頼れるプログラマの知人もいなかったので
ほんとうに戸惑いました


[http://togetter.com/li/199744:title=深夜の連打祭り ～ lovelang.heroku.com ～ - Togetter]



しかし有難いことに
Twitter上で対策の糸口となるつぶやきを見つけました
&gt;&gt;
みなさんもChromeのコンソールで for(i=0;i&lt;10000;i++){document.getElementById('5').click();} しましょう
&lt;&lt;


そう犯人は現場に戻る習性があるのです!


[http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1014833445:title=なぜ犯人は現場に戻るんでしょうか？ - Yahoo!知恵袋]


早々私は対策に乗り出し
$(&quot;button&quot;).click を
$(&quot;button&quot;).mouseup に変更して
再公開に踏み切ったのです
公開するやいなやコネクションは数十に達しました
暫くは対策の効果が効いて
Clicked by Scriptは静かになりました


ところが１時間もしないうちに
連続する高速のカウントアップが始まり
あっという間に値は10万に達しました
私は数時間でまたサイトの閉鎖を余儀なくされました


私はまたヒントを探して
Twitter上のつぶやきを見守りました
そして「Ajaxのpostコールがidだけで行われている」
旨の発言を見つけました
サイトでは言語ボタンをクリックすると
そのボタンのidと共に
Ajaxのpostリクエストが発動してサーバ側に渡ります
サーバはそのidから
対応言語のカウンタをインクリメントしてPusherに渡します
PusherはそれをWebSocketを介して
各Browserにブロードキャストするのです


Clicked by Scriptが行われているときに
postリクエストのend pointを変更してみると
果たしてカウンタはストップしました
マウスクリックをシミュレートする
スクリプトではこうなりませんから
これで犯行の手口がはっきりしました


私は早々対策に乗り出しました
WebSocketではBrowserのタブ毎に
固有のソケットIDを割り当てるので
postリクエストにこのIDを共に渡すようにしました
またend point側でunless request.xhr?の記述を追加して
postリクエストをAjax限定にしました


サイトを再開すると
すぐに数十のコネクションが張られましたが
Clicked by Scriptは止みました
私はこれでLoveLangに平和が訪れることを期待しました


しかしその期待はすぐに裏切られることになりました
暫くするとpostリクエストに
ソケットIDを渡すscriptが書かれ
私の防潮堤は簡単に破られました
またしても私の認識は
全然甘かったことを思い知るのでした


私はサイトを閉鎖し再度対策を検討しました
そしてpostリクエストにsessionデータを含む
いくつかの固有データを共に渡すようにしました
sessionデータはAES 256で暗号化し
改ざんされた場合はリクエストを拒否するようにしました


またリクエストのend point名を
「clickbyyourfingertipplease.json」に変え
サイトには「run is not love, but click is.」と表示し
更にはTwitterで「少し愛して、長く愛して」とつぶやいて
その良心に訴えるように努めました.. ^^;


そしてそのどれかは一定の効果を奏しました :)
postリクエストを偽装した侵入は激減しました((完全になくなったかは定かではありません))


しかしその一方で別の言語に対する
別の手口による犯行が始まりました
今度はpostリクエストのend pointを変えても
カウンタはストップしません


マウスクリックのシミュレートに対しては
clickイベントをmouseupイベントに変えた
だけの対策しかできていませんでした
そこでカーソルがあるべき場所にあるときだけ
mouseupイベントが発動されるようにしました


この対策も一定の効果はありましたが
それが効かないスクリプトもありました
java.awt.Robotのような
カーソル自体を制御するライブラリを使えば
人間のマウス操作をシミュレートできるからです


ここに来て私は
自分の実力とサイトセキュリティの限界を見ました


「どんなに高い壁を作ってもそこを乗り越えてくるやつはいる」
3.11の教訓が私には全く生かされていませんでした..




そこで視点を変えてみることにしました
Clicked by Scriptを受け入れることにしたのです
一方で
一定時間内のクリック数を制約するルールを入れたのです
この制約はもちろん
真面目にクリック(?)している人にも働きますが
人間はこれに対応できますし
彼の腱鞘炎を防止するためにも適切な措置なのです





２週間が過ぎて
LoveLangにはかつての熱狂はなくなりました
それでもLoveLangをちょっと覗いて
自分の愛する言語にクリックしていく人がいます
この１週間は平穏な運営が続いています((この投稿が新たな火種にならぬことを祈ります))


今となっては
私が施した幾つかの対策が功を奏しているのか
それとも
「自動クリックゲー」に彼らが飽きたのかはわかりません((まあ後者の理由でしょうね))
「lovelangとは何だったのか」などと
あの熱狂を振り返って哲学的なTweetをする人もいました


昨日こんなうれしいTweetを見ました
&gt;&gt;
今宵はマッカーシー教授を偲んで#lovelangでもするか．((https://twitter.com/#!/mkamotsu/status/128777158691786753))
&lt;&lt;


LoveLangは今も生きています


昨日  言語関連Tweetを表示するリニューアルを施しました
これからも
LoveLangをどうぞよろしくお願いしますm(__)m


[http://lovelang.heroku.com/:title=Love Languages?]


[https://github.com/melborne/LoveLang:title=melborne/LoveLang - GitHub]
</body>
</day>
<day date="2011-10-27" title="">
<body>
*p1*LoveLang再び
LoveLangの熱狂を通して
僕はWebサイトのセキュリティの限界を見ました
つまり人の手によるクリックと
スクリプトによるクリック(Clicked by Script)を
確実に判別することが
極めて困難であることを知ったのです


[http://d.hatena.ne.jp/keyesberry/20111026/p1:title=LoveLangの熱き戦い - hp12c]


LoveLangでは最終的にClicked by Scriptを
完全に排除することは諦め
同一ユーザからのクリック数を
制限することでこれに対応しました


しかし僕は後に
より完全なClicked by Script対策を見いだしたのです..


その方法は..


LoveLangからボタンおよびその投票の機構を
完全に取り除くのです!


ボタンも投票の機構もなければ
たとえスクリプトと言えども
為す術がないはずです...


賢明な読者の皆さんは
DoS対策で疲弊して
遂に僕が狂ったとお思いでしょう
ボタンがなければどうやって投票するのかと


いえ僕は狂っていません
実は解決策があるのです..


クリックでなくTweetで投票させるのです!



そんな発想に基づいて
新たにLoveLangTweetを作りました


[f:id:keyesberry:20111027184146p:image]


[http://lovelangtweet.heroku.com/:title=Love Languages? with Tweet]


あなたの愛する言語をTwitterでつぶやけば
LoveLangTweetはそれをカウントして
円グラフに反映します
LoveLangのときのようにあなたの言語を
トップにしたいのならそれをつぶやき続ければいいのです!
JavaやPHPに打ち勝つには相当な努力が必要ですが..
まあそれよりも
流れてくる言語関係のTweetを眺めているほうが
楽しめると思います


フィルタの作りがいい加減で
カウントミスしたりゴミがカウントされたりしますが
そこは大目にみてください :)



</body>
</day>
<day date="2011-10-31" title="">
<body>
*p1*Tweetでドット絵を描こう!
パリでポストイットアートが流行っているそうです


[http://doope.jp/2011/1020312.html:title=パリのUbisoftオフィスから始まったポストイット戦争のドキュメンタリー映像が登場、日本語字幕入り &amp;#171; doope! 国内外のゲーム情報総合サイト]


窓に自由に絵を描くのではなく
ポストイットという制約をベースに
ドット絵を作るということが
却って
人の創造性や競争心を刺激するのですね


面白い


ちょうどTwitterを使った
リアルタイムアプリケーションを作ったばかりだったので(([http://lovelangtweet.heroku.com/:title=Love Languages? with Tweet]))
この記事を読んで一つの好奇心が湧いてきました


Tweetという制約をベースに
ドット絵を描かせたら
創造性や競争心が刺激されて
面白いことが起こるかもしれないと..


そんなわけで..


Tweetでドット絵を描く実験的サイト
「Tweette Dotte」を作りました :)



[http://tweetdot.heroku.com/:title=Tweette Dotte]


[f:id:keyesberry:20111101095127p:image]



**遊び方
いつものようにTwitterでつぶやきます
そのとき2つの特別なhashtagを付加してもらいます
&gt;&gt;
 こんにちは! #twdot #5:7:red
&lt;&lt;


最初の #twdot で
あなたのTweetがTweette Dotteの対象になります
次の #5:7:red は
マス目のx-y座標とその色を指定していて
これによってサイト上のそのマス目の色が赤くなります


Tweette Dotteには共通の1つのキャンバスしかないので
果たしてまともな絵ができるのかわかりません
しかし個人的には何か予想もしない
面白いことが起こることを期待しているのです..


暇つぶしに遊んでくれたらうれしいです



</body>
</day>
<day date="2011-11-02" title="">
<body>
*p1*Tweette Dotteの遊び方
先の記事でTweetでドット絵を描く
実験的サイト「[http://tweetdot.heroku.com/:title=Tweette Dotte]」を紹介しました


[http://d.hatena.ne.jp/keyesberry/20111031/p1:title=Tweetでドット絵を描こう! - hp12c]


自分の告知力が弱くて
なかなか人が集まってはくれませんが
昨夜は突如としてその中心に
ブラックインベーダが出現して
場を盛り上げてくれました


[http://tweetdot.heroku.com/:title=Tweette Dotte]

[f:id:keyesberry:20111102191921p:image]


Tweette Dotteの遊び方は前回説明したように
ごく簡単なのですが
少し分かりづらい点もあるので
ここでQ&amp;A形式にまとめておきます


**Q: どうやって遊ぶんですか。
&gt;&gt;
A: ご使用のTwitterクライアントからいつものようにつぶやきます。そのとき2つの特別なハッシュタグを付加します。例えば次のようにします。
&gt;|
  こんにちは! #twdot #5:7:red
|&lt;
最初の #twdot で、あなたのTweetがTweette Dotteの対象になります。次の #5:7:red は、マス目のx-y座標とその色を指定していて(x:y:color)、これによってサイト上のそのマス目の色が赤くなります。つぶやきは右側のタイムラインに表示されます。ハッシュタグだけで本文がなくてもいいです。
&lt;&lt;

**Q: 16色しか使えないんですか。
&gt;&gt;
A: 次のページに載っているX11の色名称のすべてが使えます。

[http://ja.wikipedia.org/wiki/%E3%82%A6%E3%82%A7%E3%83%96%E3%82%AB%E3%83%A9%E3%83%BC:title=ウェブカラー - Wikipedia]

これは全部で141色ありますが、そのほか16進トリプレットでの指定もできます。そのときは先頭の#を忘れないで下さい(ex. 5:7:#FFCC00)。
&lt;&lt;

**Q: 取り消しはできないんですか。
&gt;&gt;
A: whiteを同じマス目に再Tweetすることで取り消します。例えば#4:4:redを取り消したいときは#4:4:whiteとします。なお右側のタイムラインの表示は、元のツイートを削除しても取り消すことができません((データベースには最新の20ツイートのみが一時的に保存されます))。
&lt;&lt;

**Q: １ツイートで１マスってのがダルいんですが。
&gt;&gt;
A: １回のTweetに複数のドット指定ができるようになりました。((本日対応しました.))次のように指定します。
&gt;|
 こんにちは！ #twdot #3:4:red #5:7:green #9:3:blue
|&lt;
最大で10カ所の同時指定ができますが、その前にTwitterの140文字制限が掛かるかもしれません。
&lt;&lt;

**Q: ハッシュタグの指定がダルいんですが。
&gt;&gt;
A: 二種類あるハッシュタグ#twdot #x:y:colorの省略はできません。ただドット指定のハッシュタグには、いくつかのバリエーションがあります。
xとyとcolorの間の : は / (slash) または _ (underscore)に代えることができます。さらにyとcolorの間の : は省略できます。またアルファベットの大文字小文字は区別しません。つまり以下のような指定が可能です。
&gt;|
   #3:5:red       #3/5/red     #3_5_red      #3:5red
   #3/5/#FFCC00     #3/5#ffcc00      #3:5Red

|&lt;
&lt;&lt;

**Q: 色の付いたマス目に別の色を付けることはできるんですか。
&gt;&gt;
A: 同じマス目に別の色を指定してTweetすることで、その色を上書きできます。自分が色付けしたマス目でも、他の人が色付けしたマス目でも上書きできます。
&lt;&lt;

**Q: 要するに他の人が書いた絵を壊しちゃっていいんですか。
&gt;&gt;
A: 多数の人が1つのキャンバスを共有するツールなので、そこに書かれたものは最初から上書きされる運命にあります。自由にしてください。
&lt;&lt;

**Q: 何を書けばいいんですか。
&gt;&gt;
A: 公共の場に描いて問題ないものなら、何を書いても構いません。意味のあるものでも意味のないものでも、あなたの自由な発想に従って書いてください。
&lt;&lt;

**Q: ツイートだけしたいんですが。
&gt;&gt;
A: #twdotのハッシュタグだけ付けてツイートしてください。右側のタイムラインに表示されます。
&lt;&lt;

**Q: キャンバスの下の「creators」というのは何ですか。
&gt;&gt;
A: 現在のドット絵を構成する色を付けた人の情報です。その人のTwitterアカウント名と付けた色の数を、先頭10人につき表示します。
&lt;&lt;

**Q: 右上の数字は何ですか。
&gt;&gt;
A: 現在このサイトを閲覧しているユーザー数です。
&lt;&lt;

**Q: イマイチ盛り上がってないんですが。
&gt;&gt;
A: 友達を誘ったり、あなたのFollowerにこのサイトの存在を教えてあげてください!
&lt;&lt;

**Q: サイトの名前が変なんですけど。
&gt;&gt;
A: 「ツイートでドット絵」 =&gt; 「ツイートデドットエ」 =&gt; 「Tweette Dotte」となりました;)
&lt;&lt;

**Q: このサイト何でできてるんですか。
&gt;&gt;
A: Ruby製WebフレームワークのSinatraでできています。リアルタイム表示を実現するため、Pusherというサービスを通してWebSocketを使っています。
&lt;&lt;

**Q: ソースコードは公開しないんですか。
&gt;&gt;
A: すべてのソースを公開する予定はありませんが、Pusherの使い方、Twitter APIとWebSocketの連携の仕方については、このブログで公開する予定です。
&lt;&lt;
</body>
</day>
<day date="2011-11-04" title="">
<body>
*p1*Rubyのendは美の観点から必要だ。END HELLは要リファクタへの警告である。メソッド分離、{ }、Guard、三項、ポリモーフィズムで回避せよ！

Rubyのendは構文上の欠点だとされ
一部のRubyistから
END HELLと忌み嫌われている


その一方でRubyのendを愛し
endを綴り続けることで
悟りの境地に達したRubyistもいる
&gt;&gt;
  Rubyistは一日に何度もendと書くことで、
  何事にも終わりがあることを日々確認しているのである
  by @nalsh((https://twitter.com/#!/nalsh/statuses/105432772570656768))
&lt;&lt;


そしてこの私はというと
見習うべきRubyistの姿がそこにあるのに
defと打つと私のエディタが勝手にendと補完するので
物事の終わりも確認できず
醜いendの連なりだけを毎日目にする
という虚しい日々を送っている


結局未熟な私はendの悟りを開くことができず
かつて誤った道に足を踏み入れた


[http://d.hatena.ne.jp/keyesberry/20110719/p1:title=Ruby1.9でもEND HELLを解消したい！ - hp12c]


**endの必要性
しかし私は対称性という様式美の観点から
Rubyのendは重要な役割を果たしていることを知っている


開いたら閉じなければいけない
左足を下ろしたら右足も下ろさなければいけない
おもちゃを出したら片付けなければいけない


つまり対称性とは礼儀の作法である
つまりRubyのendはニッポンの心であり
私はRubyistがその文化の継承者であることを知っている((まったく訳がわからない))


このように美の観点から論じると
endはその構造的文化的背景により
プログラミングには欠かせない
必須のエレメントであることが理解できるだろう


**問題の所在

しかしそうは言っても次のようなendの連なりには
若干の問題を感じざるを得ない

&gt;|ruby|
module MyModule
  class MyClass
    def my_method
      10.times do
        if rand &lt; 0.5
          p :small
        else
          p :large
        end
      end 
    end      &lt;- ここ
  end
end

MyModule::MyClass.new.my_method # =&gt; 10

# &gt;&gt; :large
# &gt;&gt; :large
# &gt;&gt; :large
# &gt;&gt; :large
# &gt;&gt; :small
# &gt;&gt; :small
# &gt;&gt; :large
# &gt;&gt; :small
# &gt;&gt; :large
# &gt;&gt; :large
||&lt;


このようなendの連なりは
むしろその形式美を破壊し
その可読性を著しく阻害する


しかしこの問題の責務は
言語としてのRubyにあるのではなく
実のところあなたにあるのである
そう　あなたの書いたコードに問題があるのである
先のコードはリファクタリングが必要なのである


実はこれはRubyには意図されたことである
つまりRubyはあなたがEND HELLを量産すると
コードの美が破壊されるように設計されており
これによってあなたに
要リファクタリングの警告を発していたのである!


**許容end個数
さて先のコードに
リファクタリングが必要なことはわかった
リファクタリングに際しまずは
許容end個数すなわち美を破壊しないendの連なり個数
がいくつであるのかを知ることが重要である


一般に許容end個数は
end対語平均語長未満とされるから
以下のように求められるだろう
&gt;|ruby|
heads = %w(class module def if unless case while until for begin do)
heads.map(&amp;:size).inject(:+)/heads.size.to_f # =&gt; 4.181818181818182
||&lt;
つまりendの連なりは４つ
理想的には３つ以下である
詳細はJIS X 3017(8.7.2: キーワード)を参照されたい((http://www.webstore.jsa.or.jp/webstore/Com/FlowControl.jsp?lang=jp&amp;bunsyoId=JIS+X+3017%3A2011&amp;dantaiCd=JIS&amp;status=1))


**END HELLの回避方法
具体的なコードによってEND HELLの回避方法は変わるが
ここでは先のコードにおける
END HELLの回避方法をいくつか示すに留める

**その１: 三項条件演算子
if else end式に代えて?:三項条件演算子を使う

&gt;|ruby|
module MyModule
  class MyClass
    def my_method
      10.times do
        p rand &lt; 0.5 ? :small : :large
      end 
    end
  end
end
||&lt;

**その２: { }(curly braces:波括弧)
do endに代えて{ }を使う
&gt;|ruby|
module MyModule
  class MyClass
    def my_method
      10.times { p rand &lt; 0.5 ? :small : :large }
    end
  end
end
||&lt;

**その３:メソッド呼び出し
if else end式に代えてメソッド呼び出しを使う
&gt;|ruby|
module MyModule
  class MyClass
    def my_method
      10.times { p [:small, :large][rand.round] }
    end
  end
end
||&lt;

**その４:メソッド分割
メソッドを分割する
&gt;|ruby|
module MyModule
  class MyClass
    def my_method
      10.times { p small_or_large(0.5) }
    end
    
    private
    def small_or_large(weight)
      rand &lt; weight ? :small : :large
    end
  end
end
||&lt;

**その５:ガード文
if else end式に代えてガード文を使う(ここではnext)
&gt;|ruby|
module MyModule
  class MyClass
    def my_method
      10.times do
        next p :small if rand &lt; 0.5
        p :large
      end 
    end
  end
end
||&lt;

**その６:ポリモーフィズム
if else end式に代えてポリモーフィズムを使う
&gt;|ruby|
class Float
  def size
    [:small, :large][self.round]
  end
end

module MyModule
  class MyClass
    def my_method
      10.times {
        p rand.size
      } 
    end
  end
end
||&lt;

**その７:定数スコープ演算子
定数のスコープ演算子::を使う
&gt;|ruby|
module MyModule; end

class MyModule::MyClass
  def my_method
    10.times {
      p rand.size
    } 
  end
end
||&lt;


以上まとめると
END HELLはRubyのせいではなく
あなたのせいであり
したがってあなたのコードをリファクタして
直ちにEND HELLを回避せよ！

</body>
</day>
<day date="2011-11-14" title="">
<body>
*p1*秋だ!Rubyを学ぼう! ～Rubyを知るための２６ポスト
このブログはプログラミング言語Ruby関連
のポストが大半を占めていて
それらは僕自身がRubyについて
学んだことをベースに書かれています


その一部には
これからRubyを学ぶ人や学び始めたばかりの人が
Rubyを知るための助けになる内容が含まれてると思います
またブログを書く上で自分は
他にないユニークな視点でといつも心掛けているので
ここで
他では得られなかった気づきを得られるかもしれません
手前味噌ですけど.. :)


そんなわけで..


このブログから
Ruby初学者～中級者向けの投稿２６本を選んで
簡単な説明を付けて一覧できるようにしてみました
少し古い投稿も含まれていますが
Rubyを学ぶ上で
これらの記事があなたの参考になったとしたら
そんなにうれしいことはありません


**Rubyの言語仕様に関するもの

１．[http://d.hatena.ne.jp/keyesberry/20110727/p1:title=1から始めるRuby(2011-07-27)][http://d.hatena.ne.jp/keyesberry/20110727/p1:bookmark]
&gt;&gt;
Rubyは純粋なオブジェクト指向プログラミング言語です
「純粋な」というのがRubyのミソで
オブジェクト指向機構を持った他のプログラミング言語とは
この純粋性で一線を画しています
この記事はこの点に焦点を当てて
Rubyのオブジェクト指向機構について説明しています
ただシリーズ物として書き始めたのですが
第３回で止まったままです..
&lt;&lt;


２．[http://d.hatena.ne.jp/keyesberry/20110810/p1:title= + (足す)から始めるRuby(2011-08-10)][http://d.hatena.ne.jp/keyesberry/20110810/p1:bookmark]
&gt;&gt;
Rubyの演算子のほとんどは
オブジェクトに対するメソッド呼び出しです
つまりRubyではオブジェクト指向の純粋性を守りながら
多くの演算子を実装しています
この記事はこのことを通してRubyの特徴を
「1から始めるRuby」に倣って解説しています
&lt;&lt;


３．[http://d.hatena.ne.jp/keyesberry/20090407/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(全17回)(2009-04-07)][http://d.hatena.ne.jp/keyesberry/20090407/p1:bookmark]
&gt;&gt;
この記事は英文小説から
最頻出ワードを抽出するプログラムの作成を通して
Rubyを学ぶチュートリアル・シリーズになっています
小説風の仮想設定から始まって
最初にRubyの特徴を解説し
続いてプログラムの改良を
延々と続けていくチュートリアルです
いつも途中で投げ出してる僕が
全17回最後まで書き上げられためずらしい記事です ^^;
&lt;&lt;


４．[http://d.hatena.ne.jp/keyesberry/20080816/p1:title=Rubyのクラスはオブジェクトの母、モジュールはベビーシッター(2008-08-16)][http://d.hatena.ne.jp/keyesberry/20080816/p1:bookmark]
&gt;&gt;
Rubyの世界の三大要素といったら
クラス　モジュール　オブジェクトを差します
これらを理解せずにRubyを理解することはできません
この記事はこの三大要素の関係性についてまとめています
&lt;&lt;


５．[http://d.hatena.ne.jp/keyesberry/20080927/p1:title=RubyのObjectクラスは過去を再定義するタイムマシンだ！(2008-09-27)][http://d.hatena.ne.jp/keyesberry/20080927/p1:bookmark]
&gt;&gt;
RubyのクラスツリーのルートはObjectクラスです((1.9以降正確にはBasicObject))
この記事はObjectクラスとそこにインクルードされる
Kernelモジュールについて説明しています
&lt;&lt;


６．[http://d.hatena.ne.jp/keyesberry/20080930/p1:title=RubyのModuleクラスはすべてのモジュールの母であり同時にすべてのクラスの父である！(2008-09-30)][http://d.hatena.ne.jp/keyesberry/20080930/p1:bookmark]
&gt;&gt;
ModuleクラスはRubyにおける最重要クラスの１つで
これはモジュールの生成クラスであると共に
Classクラスのスーパークラスでもあります
この記事はそのModuleクラスについて説明しています
&lt;&lt;


７．[http://d.hatena.ne.jp/keyesberry/20080809/p1:title=Rubyのブロックはメソッドに対するメソッドのMix-inだ！(2008-08-09)][http://d.hatena.ne.jp/keyesberry/20080809/p1:bookmark]
&gt;&gt;
Rubyのブロックはメソッドに
コードの塊を渡すことができる仕組みです
この記事はブロックおよび
そのパワーについて解説しています
&lt;&lt;


８．[http://d.hatena.ne.jp/keyesberry/20090826/p1:title=Rubyのブロック(クロージャ)はローカル変数をインスタンス変数に変えるマジックだ！(2009-08-26)][http://d.hatena.ne.jp/keyesberry/20090826/p1:bookmark]
&gt;&gt;
Rubyのブロックはクロージャつまり
それが作られた環境を
そこに閉じ込めることができます
この記事はそのような
ブロックのスコープについて説明しています
&lt;&lt;


９．[http://d.hatena.ne.jp/keyesberry/20080812/p1:title=Rubyのyieldは羊の皮を被ったevalだ！(2008-08-12)][http://d.hatena.ne.jp/keyesberry/20080812/p1:bookmark]
&gt;&gt;
Rubyのブロックはパワフルですが
この記事はevalとの対比でそのパワーを説明しています
&lt;&lt;


１０．[http://d.hatena.ne.jp/keyesberry/20080905/p1:title=Rubyのオブジェクトは生物なんかじゃない、トップレベルこそが生物なんだ！(2008-09-05)][http://d.hatena.ne.jp/keyesberry/20080905/p1:bookmark]
&gt;&gt;
Rubyのトップレベルでは
オブジェクト指向のルールに従わない
手続き指向のプログラミングが実現できます
この記事はその環境を構築している
トップレベルの不思議について書いています
&lt;&lt;


１１．[http://d.hatena.ne.jp/keyesberry/20081022/p1:title=メソッドが見つからないならRubyに作ってもらえばいいよ！ - If method_missing, define_method by Ruby -(2008-10-22)][http://d.hatena.ne.jp/keyesberry/20081022/p1:bookmark]
&gt;&gt;
Rubyではメタプログラミングというのが１つの
重要なプログラミングの手法です
この記事では通常のメソッド定義の方法に始まって
define_method method_missingを使った
動的なメソッド定義の方法までを解説しています
&lt;&lt;


１２．[http://d.hatena.ne.jp/keyesberry/20080802/p1:title=Rubyのシンボルは文字列の皮を被った整数だ！(2008-08-02)][http://d.hatena.ne.jp/keyesberry/20080802/p1:bookmark]
&gt;&gt;
Rubyにはあまり他の言語には見られない
シンボルというオブジェクトがあります
この記事は文字列と数字との比較から
シンボルが何であるかを解説しています
&lt;&lt;


１３．[http://d.hatena.ne.jp/keyesberry/20080917/p1:title=RubyのSymbol#to_procを考えた人になってみる(2008-09-17)][http://d.hatena.ne.jp/keyesberry/20080917/p1:bookmark]
&gt;&gt;
Rubyでは例えば配列の合計値を求めるのに
[1,2,3,4,5].inject { |m,i| m + i } #=&gt; 15
とする代わりに
[1,2,3,4,5].inject(&amp;:+) #=&gt; 15
と書けますが((1.9では[1,2,3,4,5].inject(:+)とも書ける))
それはSymbol#to_procのお陰です
この記事ではその仕組を解説しています
&lt;&lt;


１４．[http://d.hatena.ne.jp/keyesberry/20101105/p1:title=Rubyのモジュール関数を理解しよう！(2010-11-05)][http://d.hatena.ne.jp/keyesberry/20101105/p1:bookmark]
&gt;&gt;
RubyにはMath.sqrtのような
モジュール・メソッドとしても
また関数的にも呼び出される
モジュール関数というものがあります
この記事はその実装に挑戦しています
&lt;&lt;


１５．[http://d.hatena.ne.jp/keyesberry/20090901/p1:title=RubyのProcオブジェクトはキューティーハニーだ!(2009-09-01)][http://d.hatena.ne.jp/keyesberry/20090901/p1:bookmark]
&gt;&gt;
Rubyでは手続きをProcという
オブジェクトに封入できます
この記事はProcオブジェクトの
多様性について解説しています
&lt;&lt;


１６．[http://d.hatena.ne.jp/keyesberry/20090216/p1:title=高階関数はコードをユーザフレンドリーにする(2009-02-16)][http://d.hatena.ne.jp/keyesberry/20090216/p1:bookmark]
&gt;&gt;
関数を引数に取ったり
関数を返したりする関数のことを高階関数と呼びます
この記事はRubyでブロックを使わずに
高階関数を実現する方法を解説しています
&lt;&lt;


１７．[http://d.hatena.ne.jp/keyesberry/20110124/p1:title=Rubyを使って「なぜ関数プログラミングは重要か」を解読しよう！(2011-01-24)][http://d.hatena.ne.jp/keyesberry/20110124/p1:bookmark]
&gt;&gt;
Rubyはオブジェクト指向プログラミング言語ですが
関数プログラミングを実現できる構造を備えています
この記事は「なぜ関数プログラミングは重要か」という
有名な論文をベースにRubyで関数プログラミングを実現する
手法について解説しています
残念ながらこのシリーズも3回で力尽きてます..
&lt;&lt;


１８．[http://d.hatena.ne.jp/keyesberry/20110622/p1:title=知って得する21のRubyのトリビアな記法 ~ 21 Trivia Notations you should know in Ruby(2011-06-22)][http://d.hatena.ne.jp/keyesberry/20110622/p1:bookmark]
&gt;&gt;
Rubyには他の言語に劣らず
ちょっとトリビアだけど知ってると便利な記法
というのが結構あります
この記事はそれを21個ピックアップして解説しています
&lt;&lt;


１９．[http://d.hatena.ne.jp/keyesberry/20101116/p1:title=IRB　それはRubyistの魔法のランプ(2010-11-16)][http://d.hatena.ne.jp/keyesberry/20101116/p1:bookmark]
&gt;&gt;
Rubyにおける対話的実行環境はirbといいます
irbがなければRubyの魅力が半減するほど
重要なツールです
この記事はirbの使い方とそのカスタマイズ
および拡張方法について解説しています
&lt;&lt;


**Rubyを使った問題解決に関するもの
以下はRubyの言語仕様に関する記事ではなく
Rubyを使って問題を解く手法に関する記事です


２０．[http://d.hatena.ne.jp/keyesberry/20080708/p1:title=Ruby、同じことの繰り返しは君に任せるよ ～ 再帰でハノイの塔を解こう！～(2008-07-08)][http://d.hatena.ne.jp/keyesberry/20080708/p1:bookmark]
&gt;&gt;
この記事は再帰およびRubyで
再帰を使ってハノイの塔を解く方法を解説しています
&lt;&lt;


２１．[http://d.hatena.ne.jp/keyesberry/20101017/p1:title=Rubyで文字列検索アルゴリズムを表現しよう!(2010-10-17)][http://d.hatena.ne.jp/keyesberry/20101017/p1:bookmark]
&gt;&gt;
文字列検索の代表的なアルゴリズムには
力まかせ検索　ボイヤー-ムーア検索
クヌース-モリス-プラット検索　N-gramインデックス検索
ラビン-カープ検索などがあります
この記事はこれらのアルゴリズムをRubyで実装して
比較解説しています
&lt;&lt;


２２．[http://d.hatena.ne.jp/keyesberry/20101012/p1:title=Rubyでソート・アルゴリズムを表現しよう!(2010-10-12)][http://d.hatena.ne.jp/keyesberry/20101012/p1:bookmark]
&gt;&gt;
ソートの代表的なアルゴリズムには
挿入ソート　選択ソート　バブルソート
クイックソート　マージソートなどがあります
この記事はこれらのアルゴリズムをRubyで実装して
比較解説しています
この記事ではRubyの簡潔さがよく現れていると思います
&lt;&lt;


２３．[http://d.hatena.ne.jp/keyesberry/20110831/p1:title=Rubyで論理プログラミングしようよ!(2011-08-31)][http://d.hatena.ne.jp/keyesberry/20110831/p1:bookmark]
&gt;&gt;
この記事では
複数の選択的な条件から回答を導き出すような
論理問題をRubyで解く方法を解説しています
&lt;&lt;


２４．[http://d.hatena.ne.jp/keyesberry/20101110/p1:title=((Rubyで) 書く (Lisp) インタプリタ)(2010-11-10)][http://d.hatena.ne.jp/keyesberry/20101110/p1:bookmark]
&gt;&gt;
100行ほどのPythonコードで
Schemeインタプリタを実装したPeter Norvigさんの
「((Pythonで) 書く (Lisp) インタプリタ)」
という記事があります
この記事ではこれをRubyで実装して
Python版と比較解説しています
&lt;&lt;


２５．[http://d.hatena.ne.jp/keyesberry/20090326/p1:title=Rubyでスペル修正プログラムを書こう！(2009-03-26)][http://d.hatena.ne.jp/keyesberry/20090326/p1:bookmark]
&gt;&gt;
Pythonを使ったPeter Norvigさんの
「スペル修正プログラムはどう書くか」という記事があります
この記事はこれをRubyで実装したものを解説しています
&lt;&lt;


２６．[http://d.hatena.ne.jp/keyesberry/20110929/p1:title=irbから学ぶRubyの並列処理 ~ forkからWebSocketまで(2011-09-29)][http://d.hatena.ne.jp/keyesberry/20110929/p1:bookmark]
&gt;&gt;
Rubyで並列処理をするには幾つかの方法があります
この記事ではそれらを順次解説しています
&lt;&lt;


これで26本の解説は終わりです
これらの他にもこのブログには
Rubyに関する記事が多数ありますから
興味を持ったら読んでもらえたらうれしいです
</body>
</day>
<day date="2011-11-20" title="">
<body>
*p1*Rubyで日本の色でお絵かきしようよ!
日本の色の名前がクールだって
いま巷で話題になっているよ


[http://umashika-news.jp/archives/51967828.html:title=日本の色名カッコよすぎワロタｗｗｗｗｗｗｗｗｗ | うましかニュース]

[http://www.colordic.org/w/:title=日本の伝統色 和色大辞典 - Traditional Japanese Color Names]


臙脂(えんじ) 
黄丹(おうに) 
麹塵(きくじん)
黄櫨染(こうろぜん) 
猩々緋(しょうじょうひ) 
雄黄(ゆうおう) 
紛紅(まがいべに) 
枡花色(ますはないろ) 
鶸萌黄(ひわもえぎ) 
唐棣色(はねずいろ) 
榛色(はしばみいろ) 
木賊色(とくさいろ) 
蘇芳色(すおういろ) 
     ...


確かにカッコよすぎで笑っちゃうね!


でもColor Loverとしては
これを笑ってるだけで見過ごす
というわけにはいかないんだよ



そんなわけで..


先の和色大辞典のデータをベースにして
和色465色のカラーコードを取得する
wairoというライブラリをRubyで書いたよ ^^;


**wairoの使い方
以下のサイトからライブラリを取得して
次のように使うよ


https://github.com/melborne/wairo


&gt;|ruby|
require &quot;wairo&quot;

Wairo::Wairo.color_names(true) # =&gt; [&quot;桜色(さくらいろ)&quot;, &quot;薄桜(うすざくら)&quot;, &quot;桜鼠(さくらねず)&quot;, &quot;鴇鼠(ときねず)&quot;, &quot;虹色(にじいろ)&quot;, &quot;珊瑚色(さんごいろ)&quot;, &quot;一斤染(いっこんぞめ)&quot;, &quot;宍色(ししいろ)&quot;, &quot;紅梅色(こうばいいろ)&quot;, &quot;薄紅(うすべに)&quot;, &quot;甚三紅(じんざもみ)&quot;, &quot;桃色(ももいろ)&quot;, &quot;鴇色(ときいろ)&quot;, &quot;撫子色(なでしこいろ)&quot;, &quot;灰梅(はいうめ)&quot;, &quot;灰桜(はいざくら)&quot;, &quot;淡紅藤(あわべにふじ)&quot; ... &quot;素鼠(すねずみ)&quot;, &quot;鼠色(ねずみいろ)&quot;, &quot;源氏鼠(げんじねず)&quot;, &quot;灰色(はいいろ)&quot;, &quot;鉛色(なまりいろ)&quot;, &quot;鈍色(にびいろ)&quot;, &quot;墨(すみ)&quot;, &quot;丼鼠(どぶねずみ)&quot;, &quot;消炭色(けしずみいろ)&quot;, &quot;藍墨茶(あいすみちゃ)&quot;, &quot;羊羹色(ようかんいろ)&quot;, &quot;蝋色(ろういろ)&quot;, &quot;黒(くろ)&quot;, &quot;烏羽色(からすばいろ)&quot;, &quot;鉄黒(てつぐろ)&quot;, &quot;濡羽色(ぬればいろ)&quot;, &quot;黒檀(こくたん)&quot;, &quot;憲法黒茶(けんぽうくろちゃ)&quot;, &quot;暗黒色(あんこくしょく)&quot;]
||&lt;

&gt;|ruby|
ouni = Wairo::Wairo.color(&quot;黄丹&quot;) # =&gt; #&lt;struct Wairo::Color series=:wairo, name=&quot;黄丹&quot;, hex=&quot;#ee7948&quot;, rgb=nil, subname=&quot;おうに&quot;, url=&quot;http://www.colordic.org/colorsample/2248.html&quot;, notes=nil&gt;
ouni.members # =&gt; [:series, :name, :hex, :rgb, :subname, :url, :notes]
ouni.name # =&gt; &quot;黄丹&quot;
ouni.subname # =&gt; &quot;おうに&quot;
ouni.hex # =&gt; &quot;#ee7948&quot;
ouni.url # =&gt; &quot;http://www.colordic.org/colorsample/2248.html&quot;
||&lt;

&gt;|ruby|
Wairo::Wairo.colors.select { |c| c.subname.match(/みどり/) }.map { |c| &quot;#{c.name}(#{c.subname}):#{c.hex}&quot; } # =&gt; [&quot;黒緑(くろみどり):#333631&quot;, &quot;黄緑(きみどり):#b8d200&quot;, &quot;若緑(わかみどり):#98d98e&quot;, &quot;浅緑(あさみどり):#88cb7f&quot;, &quot;薄緑(うすみどり):#69b076&quot;, &quot;千歳緑(ちとせみどり):#316745&quot;, &quot;緑(みどり):#3eb370&quot;, &quot;常磐緑(ときわみどり):#028760&quot;, &quot;深緑(ふかみどり):#00552e&quot;, &quot;青緑(あおみどり):#00a497&quot;, &quot;紅碧(べにみどり):#8491c3&quot;, &quot;灰黄緑(はいきみどり):#e6eae3&quot;]
||&lt;


で
このライブラリを使って
以前作ったCrayovasというお絵かきツール
に和色(wairo)を追加してみたよ :)


[http://crayovas.heroku.com/:title=Crayovas]

[f:id:keyesberry:20111120222334p:image]

絵心のある人がこれらの和色を使って
日本画でも描いてくれたらうれしいよ


Crayovasの使い方については以下を読んでね


[http://d.hatena.ne.jp/keyesberry/20110209/p1:title=Ruby製クレヨンでお絵描きしようよ！ - hp12c]
[http://d.hatena.ne.jp/keyesberry/20110212/p1:title=Crayovasで塗り絵しようよ！ - hp12c]


https://github.com/melborne/crayovas

</body>
</day>
<day date="2011-12-05" title="">
<body>
*p1*Rubyでビックリ階乗を解こう! ～人間の実働時間を最適化する
「ビックリ階乗(Exclamatory Factorial)」って知ってますか？
ええ　知るわけないです
なぜならいま僕が
次のツイートの解に命名したばかりの言葉だからです((https://twitter.com/#!/Chigami/status/96606063931047936))


[f:id:keyesberry:20111205222834p:image]


なかなか意味深なツイートですが
自分が先生だったらこの解答に
◯を付けざるを得ないでしょう
答えにビックリマークを付ける人はいませんからね!


さて
プログラムする身としては
文系理系両者の反応よりも
このような「ビックリ階乗」が
どれくらい奇跡的なものなのかが気になります
つまりa - (b / c) の解(先の例では24)と
(a - b) / c の解の階乗(4!)とが
一致する組み合わせは
果たしてどれくらいあるのでしょうか


数学的に書くとこういうことです
&gt;&gt;
[tex:f1 = a - (b \div c)]
[tex:f2 = (a - b) \div c]


[tex:f1 == f2!]
&lt;&lt;


そんな思いは当然僕だけではありませんでした((ホントのことを言えば、このブログから先のツイートを知ったのでした^^;))


[http://d.hatena.ne.jp/E_Mattsan/20111124/1322145039:title=「40 - 32 / 2 = 4!」 - エンジニアのソフトウェア的愛情]


このブログより1000以下の数字で
15組のビックリ階乗があることがわかっています
ここで1000までの数を考えたときa b c の組み合わせ数は
10億通り([tex:1000^3])にもなりますからその確率は..

&gt;&gt;

[tex:15 \div 10{,}0000{,}0000=0.000000015]

&lt;&lt;
ビックリ階乗は奇跡的な組み合わせなんですね!


しかしそれにしても10億通りの組み合わせとなると
まじめにそのすべてを試してみると当然に
その実行時間が問題になります
先のブログでは試行錯誤して最初のプログラムから
1800倍の高速化を実現して0.1秒以下で答えがでます
手元でRuby版も試して見ましたが0.037秒でした
ステキすぎます!


でこれ以上僕のできることは何も無いのですが
コードの実行時間というものを完全に無視して
コードの読み易さつまり
人間の実働時間の最適化という一点に焦点を合わせて
Rubyでコードを書いてみようと思います^^;


さて
ビックリ階乗の数式をもう一度確認します
&gt;&gt;
[tex:f1 = a - (b \div c)]
[tex:f2 = (a - b) \div c]


[tex:f1 == f2!]
&lt;&lt;


これをRubyの式に置き換えます
&gt;|ruby|
f1 = -&gt;a,b,c{  a - b  / c }
f2 = -&gt;a,b,c{ (a - b) / c }

a, b, c = 40, 32, 2

f1[a,b,c] == factorial(f2[a,b,c]) # =&gt; true
||&lt;
メソッドでもいいですが
ここでは一行で済むProcを使います


このコードは一見よさそうですが
一部に問題があります
&gt;|ruby|
10 / 3 # =&gt; 3
||&lt;
そうですRubyでは整数同士の除算は
余りを無視してしまいます


しかしこの問題はrequire 'mathn'
することで解決します
&gt;|ruby|
require 'mathn'

10 / 3 # =&gt; (10/3)
||&lt;


次にfactorialメソッドってのがダサいですね
こうしましょう
&gt;|ruby|
class Integer
  def !
    (1..self).inject(:*)
  end
end

4.! # =&gt; 24
||&lt;

&gt;|ruby|
require 'mathn'

f1 = -&gt;a,b,c{  a - b  / c }
f2 = -&gt;a,b,c{ (a - b) / c }

a, b, c = 40, 32, 2

f1[a,b,c] == f2[a,b,c].! # =&gt; true
||&lt;
良くなりましたね!


次にa b c についての
10億の組み合わせを作ります
&gt;|ruby|
set = [*2..1000].repeated_permutation(3) # =&gt; #&lt;Enumerator: [2, 3, 4..]:repeated_permutation(3)&gt;
||&lt;


そこから先の条件に見合うものだけ
セレクトします
&gt;|ruby|
selected = set.select { |abc| f1[*abc] == f2[*abc].! }
||&lt;


結果をプリントします
&gt;|ruby|
pp = -&gt;abc{
  print &quot;(%i - %i) / %i = %i\n&quot;         % [*abc, f2[*abc]]
  print &quot; %i - %i  / %i = %i! = %i\n\n&quot; % [*abc, f2[*abc], f1[*abc]]
}

selected.each { |abc| pp[abc] }
||&lt;


さあこれらを組み合わせて!
&gt;|ruby|
require &quot;mathn&quot;
class Integer
  def !
    (1..self).inject(:*)
  end
end

f1 = -&gt;a,b,c{  a - b  / c }
f2 = -&gt;a,b,c{ (a - b) / c }

pp = -&gt;abc{
  print &quot;(%i - %i) / %i = %i\n&quot;         % [*abc, f2[*abc]]
  print &quot; %i - %i  / %i = %i! = %i\n\n&quot; % [*abc, f2[*abc], f1[*abc]]
}

[*2..1000].repeated_permutation(3)
          .select { |abc| f1[*abc] == f2[*abc].! }
          .each { |abc| pp[abc] }
||&lt;


完成です! exclamation.rbで保存して
実行してみましょう!
いきなり1000もなんですから
まずは[*2..100]から..
&gt;|bash|
% time ruby exclamation.rb
(25 - 5) / 5 = 4
 25 - 5  / 5 = 4! = 24

(30 - 18) / 3 = 4
 30 - 18  / 3 = 4! = 24

(40 - 32) / 2 = 4
 40 - 32  / 2 = 4! = 24

ruby exclamation.rb  3.25s user 0.03s system 99% cpu 3.287 total
||&lt;
おおっ
良い感じじゃないですか!


では1000で..
&gt;|ruby|
% time ruby exclamation.rb


  ...



  ...



  ...


||&lt;
全く反応ありません^^;


仕方が無いので require 'mathn' はやめて
a &lt;= b, (b % c) != 0, ((a - b) % c) != 0
の条件だけ入れて足切りします
&gt;|ruby|
[*2..1000].repeated_permutation(3)
          .select { |a,b,c|
            next if a &lt;= b || (b % c) != 0 || ((a - b) % c) != 0
            f1[a,b,c] == f2[a,b,c].!
           }
          .each { |abc| pp[abc] }
||&lt;


いざ!
&gt;|bash|
% time ruby exclamation.rb


  ...


  ...


||&lt;


ちょっとトイレ行ってきます..


&gt;|bash|
% time ruby exclamation.rb


  ...


  ...


||&lt;


お茶飲んできます..


でましたよ!
&gt;|ruby|
(25 - 5) / 5 = 4
 25 - 5  / 5 = 4! = 24

(30 - 18) / 3 = 4
 30 - 18  / 3 = 4! = 24

(40 - 32) / 2 = 4
 40 - 32  / 2 = 4! = 24

(138 - 108) / 6 = 5
 138 - 108  / 6 = 5! = 120

(230 - 220) / 2 = 5
 230 - 220  / 2 = 5! = 120

(721 - 103) / 103 = 6
 721 - 103  / 103 = 6! = 720

(728 - 416) / 52 = 6
 728 - 416  / 52 = 6! = 720

(731 - 473) / 43 = 6
 731 - 473  / 43 = 6! = 720

(735 - 525) / 35 = 6
 735 - 525  / 35 = 6! = 720

(748 - 616) / 22 = 6
 748 - 616  / 22 = 6! = 720

(756 - 648) / 18 = 6
 756 - 648  / 18 = 6! = 720

(765 - 675) / 15 = 6
 765 - 675  / 15 = 6! = 720

(816 - 768) / 8 = 6
 816 - 768  / 8 = 6! = 720

(833 - 791) / 7 = 6
 833 - 791  / 7 = 6! = 720

(952 - 928) / 4 = 6
 952 - 928  / 4 = 6! = 720

ruby exclamation.rb  349.56s user 0.72s system 99% cpu 5:51.87 total
||&lt;


6分!!!


使い捨てプログラムとしては許容できる範囲...
判断は各人にお任せします..

*p2*Rubyでアナグラムしようよ
アナグラム(anagram)をご存知ですか？
アナグラムは単語や文の文字を入れ替えて
別の意味を持った単語や文を作る遊びです
例えば&quot;note&quot;には&quot;tone&quot;
&quot;master&quot;には&quot;stream&quot;というアナグラムがあります


もちろん日本語アナグラムもあります
&quot;タモリ&quot;は&quot;モリタ&quot;のアナグラムです
&quot;いきるいみなんて&quot;と&quot;みんないきている&quot;は
一見哲学的問答に見えますが
これもアナグラムなんです:)


少しやって頂ければ分かりますが
アナグラムを見つけるのは意外と難しいです
試しに&quot;friend&quot; と&quot;setter&quot;と&quot;resort&quot;のアナグラムを
それぞれちょっと考えてみてください
(答え)((&quot;friend&quot;には[&quot;finder&quot;, &quot;redfin&quot;, &quot;refind&quot;], &quot;setter&quot;には[&quot;retest&quot; &quot;street&quot; &quot;tester&quot;], &quot;resort&quot;には[&quot;roster&quot;, &quot;sorter&quot;, &quot;storer&quot;]があります))



そんなわけで..


Rubyにアナグラムを見つけてもらいましょう


**RubyでAnagramを作る
指定の英単語に対する
複数のアナグラムを見つけるプログラムを考えます
こんな感じです
&gt;|ruby|
 find_anagrams('name') # =&gt; ['mean', 'amen']
||&lt;

これを実現するには少なくとも次のステップが必要そうです
+英単語リストを用意する
+指定単語のアナグラムを英単語リストから見つけ出す

**指定単語のアナグラムを英単語リストから見つけ出す
単語リストはどこかにきっとあるでしょうから
後回しにして..
アナグラムを見つける方法を先に考えます


先に示した&quot;name&quot;と&quot;mean&quot;と&quot;amen&quot;はアナグラムですが
どうやってRubyにそれを判断させればいいでしょうか


いい方法を思いつきました
単語を文字で区切って配列化し引き算するんです
&gt;|ruby|
w1 = 'name'
w2 = 'mean'
w3 = 'amen'
w4 = 'man'
ws1 = w1.split(//) # =&gt; [&quot;n&quot;, &quot;a&quot;, &quot;m&quot;, &quot;e&quot;]
ws2 = w2.split(//) # =&gt; [&quot;m&quot;, &quot;e&quot;, &quot;a&quot;, &quot;n&quot;]
ws3 = w3.split(//) # =&gt; [&quot;a&quot;, &quot;m&quot;, &quot;e&quot;, &quot;n&quot;]
ws4 = w4.split(//) # =&gt; [&quot;m&quot;, &quot;a&quot;, &quot;n&quot;]

ws1 - ws2 # =&gt; []
ws1 - ws3 # =&gt; []
ws1 - ws4 # =&gt; [&quot;e&quot;]
||&lt;
空配列になったらアナグラムです!


と言いたいのですがこれはダメです
&gt;|ruby|
w1 = 'name'
w5 = 'amenman'
w1.split(//) - w5.split(//) # =&gt; []

w1 = 'aaabbbccc'
w2 = 'abc'
w1.split(//) - w2.split(//) # =&gt; []
||&lt;
引く配列要素が多かったり
重複要素がある場合は
期待する結果になりません


実はいい方法があります
各単語のシグネチャーを作って
これを比較するのです
でこのシグネチャーは何かというと
単語の文字をソートしたものです
&gt;|ruby|
w1 = 'name'
w1.chars.sort.join.intern # =&gt; :aemn
||&lt;
アナグラムな単語は
このシグネチャーがおなじになるはずです


やってみましょう
&gt;|ruby|
w1 = 'name'
w2 = 'mean'
w3 = 'amen'
w4 = 'amenman'
sig1 = w1.chars.sort.join.intern # =&gt; :aemn
sig2 = w2.chars.sort.join.intern # =&gt; :aemn
sig3 = w3.chars.sort.join.intern # =&gt; :aemn
sig4 = w4.chars.sort.join.intern # =&gt; :aaemmnn
sig1 == sig2 # =&gt; true
sig1 == sig3 # =&gt; true
sig1 == sig4 # =&gt; false
||&lt;
いいですね!((この方法は「珠玉のプログラミング」に載っていました。))


ではこれをメソッド化しておきましょう
&gt;|ruby|
def signature(word)
  word.downcase.chars.sort.join.intern
end

%w(name mean amen man).map { |word| signature word } # =&gt; [:aemn, :aemn, :aemn, :amn]
||&lt;


**単語リスト
さて次に単語リストを用意します
ネットから拾う手もありますが
都合の良いことにMacの /usr/share/dict/
には最初から単語リストwordsが入ってるんです


覗いてみます
&gt;|bash|
% head /usr/share/dict/words
A
a
aa
aal
aalii
aam
Aani
aardvark
aardwolf
Aaron

% tail /usr/share/dict/words 
zymotoxic
zymurgy
Zyrenian
Zyrian
Zyryan
zythem
Zythia
zythum
Zyzomys
Zyzzogeton
||&lt;


語数を調べましょう
&gt;|bash|
% wc -l /usr/share/dict/words
  234936 /usr/share/dict/words
||&lt;
十分ですね


**アナグラム辞書
さて先の方針で
単語同士を直接比較するのではなくて
そのシグネチャーを比較することとしました
ですから単語リストの各単語をそのシグネチャーで
引ける辞書(アナグラム辞書)を作る必要があります
毎回単語リストのシグネチャーを計算するのは
効率的ではありませんからね


データ構造は次のようなものがよさそうです
&gt;|ruby|
{:aemn =&gt; ['name', 'mean', 'amen'], :amn =&gt; ['man']}
||&lt;
シグネチャーをkeyとして
それを持った単語のリストをvalueとするハッシュです


それでは単語リストからアナグラム辞書を作る
build_anagramsメソッドを定義しましょう
入力は単語の配列です
&gt;|ruby|
def build_anagrams(words)
  words.map { |word| [signature(word), word] }
       .inject({}) { |h, (sign, word)| h[sign] ||= []; h[sign] &lt;&lt; word; h }
       .select { |sign, words| words.size &gt; 1 }
end
||&lt;


まずmapでシグネチャーと単語の組みを作って
injectで共通のシグネチャーの指す配列に単語を追加していきます
injectの使い方では注意点が２つあります
１つは h[sign] ||= [] での初期化が必要なこと
１つは各イテレートでハッシュhを返すことです
ちなみに次のような書き方もできます
&gt;|ruby|
def build_anagrams(words)
  mem = Hash.new{|h, k| h[k] = []}
  words.map { |word| [signature(word), word] }
       .each_with_object(mem) { |(sign, word), h| h[sign] &lt;&lt; word }
       .select { |sign, words| words.size &gt; 1 }
end
||&lt;


さてこのメソッドを試してみましょう
&gt;|ruby|
word_list = %w(name mean amen man)
Anagrams = build_anagrams(word_list) # =&gt; {:aemn=&gt;[&quot;name&quot;, &quot;mean&quot;, &quot;amen&quot;], :amn=&gt;[&quot;man&quot;]}
||&lt;
いいですね!


これでもう最初に示した
find_anagramsメソッドが書けますね
&gt;|ruby|
def find_anagrams(word)
  sign = signature(word)
  res = Anagrams[sign]
  res ? res - [word] : []
end

find_anagrams(&quot;name&quot;) # =&gt; [&quot;mean&quot;, &quot;amen&quot;]
find_anagrams(&quot;age&quot;) # =&gt; []
||&lt;


**単語リストの読み込み
ここまで来ればあと一歩です
単語リストのファイルをオープンして
メモリー上に読み出し
そこから単語の配列を作ります
最初は小さな単語ファイル(sample)を用意して
試してみるのがいいですね

&gt;|txt|
name
mean
amen
man
man
MAN
street
sweet
Tester
retest
word
world

tower
rowet
WROTE
X
a
monopersulphuric
b
||&lt;


コードは次のようになります
&gt;|ruby|
def build_wordlist(path)
  File.open(path) do |f|
    f.map { |line| line.chomp.downcase }.uniq.reject { |word| word.size &lt; 2 }
  end
end

WORDS = build_wordlist('./sample') # =&gt; [&quot;name&quot;, &quot;mean&quot;, &quot;amen&quot;, &quot;man&quot;, &quot;street&quot;, &quot;sweet&quot;, &quot;tester&quot;, &quot;retest&quot;, &quot;word&quot;, &quot;world&quot;, &quot;tower&quot;, &quot;rowet&quot;, &quot;wrote&quot;, &quot;monopersulphuric&quot;]
||&lt;
改行を除去して全て小文字化し
重複と空行と一文字単語を除去します


さあ完成です!
コードをまとめてみましょう
&lt;script src=&quot;https://gist.github.com/1429196.js?file=anagram.rb&quot;&gt;&lt;/script&gt;


Rubyならアナグラムも簡単ですね!


**Anagramライブラリ
で　ここまでやったので
Anagramライブラリを書いて見ました
Rspecの練習を兼ねまして..^^;


[https://github.com/melborne/anagram:title=melborne/anagram - GitHub]



**anagramコマンド
後述するAnagram辞書を作ると
Terminalでanagramコマンドが使えます
&gt;|bash|
% ./anagram dream team ruby
dream =&gt; [&quot;armed&quot;, &quot;derma&quot;, &quot;ramed&quot;]
team =&gt; [&quot;mate&quot;, &quot;meat&quot;, &quot;meta&quot;, &quot;tame&quot;, &quot;tema&quot;]
ruby =&gt; [&quot;bury&quot;]
||&lt;
アナグラムを見つけたい１または複数の単語を
コマンドの引数として渡します


**Anagram辞書の作成
Anagram.buildクラスメソッドで
Anagram辞書を作ります
&gt;|ruby|
% irb
&gt;&gt; require 'anagram'
&gt;&gt; 
&gt;&gt; File.open('/usr/share/dict/words') do |f|
&gt;&gt;   Angram.build(f)
&gt;&gt; end
||&lt;
辞書はカレントディレクトリに
YAMLファイル(anagram.yml)で保存されます


**Anagram.findクラスメソッド
Anagram辞書ができれば
findクラスメソッドが使えます
&gt;|ruby|
&gt;&gt; Anagram.find 'time' #=&gt; [&quot;emit&quot;, &quot;item&quot;, &quot;mite&quot;]
&gt;&gt; Anagram.find 'beer' #=&gt; [&quot;bere&quot;, &quot;bree&quot;]
||&lt;


**Anagram.anagrams?クラスメソッド
このメソッドは引数に渡した単語同士が
アナグラムか検査します
&gt;|ruby|
&gt;&gt; Anagram.anagrams? 'beer', 'bair' #=&gt; false
&gt;&gt; Anagram.anagrams? 'time', 'emit', 'item' #=&gt; true
||&lt;


anagrams?メソッドは日本語でも文章でも使えます
&gt;|ruby|
&gt;&gt; Anagram.anagrams? 'いきるいみなんて', 'みんないきている' #=&gt; true
&gt;&gt; sentence1 = &quot;To be or not to be: that is the question; whether 'tis nobler in the mind to suffer the slings and arrows of outrageous fortune...&quot;
&gt;&gt; sentence2 = &quot;In one of the Bard's best-thought-of tragedies our insistent hero, Hamlet, queries on two fronts about how life turns rotten.&quot;
&gt;&gt; Anagram.anagrams?(sentence1, sentence2) #=&gt; true
||&lt;
こんな長いアナグラムを考える人がいるんですね..


**Anagramオブジェクト
Anagram.newでAnagramオブジェクトを生成することで
Anagram#find #longest #most および#all
の各メソッドが使えるようになります
Anagram#findはAnagram.findと同じです
&gt;|ruby|
&gt;&gt; an = Anagram.new
&gt;&gt; an.find 'visit' #=&gt; [&quot;vitis&quot;]
&gt;&gt; an.find 'master' #=&gt; [&quot;martes&quot;, &quot;remast&quot;, &quot;stream&quot;]
&gt;&gt; an.find 'version' #=&gt; []
&gt;&gt; an.find 'bridge' #=&gt; [&quot;begird&quot;]
&gt;&gt; an.find 'paper' #=&gt; [&quot;rappe&quot;]
&gt;&gt; an.find 'speech' #=&gt; []
&gt;&gt; an.find 'take' #=&gt; [&quot;kate&quot;, &quot;keta&quot;, &quot;teak&quot;]
&gt;&gt; an.find 'language' #=&gt; [&quot;ganguela&quot;]
&gt;&gt; 
||&lt;


Anagram#longest は辞書における
長い単語のアナグラムを上位から表示します
Anagram#most は最も組数の多い
アナグラムを上位から表示します
&gt;|ruby|
&gt;&gt; an.longest(size:10).each {|l| p l}
[&quot;hydropneumopericardium&quot;, &quot;pneumohydropericardium&quot;]
[&quot;cholecystoduodenostomy&quot;, &quot;duodenocholecystostomy&quot;]
[&quot;glossolabiopharyngeal&quot;, &quot;labioglossopharyngeal&quot;]
[&quot;chromophotolithograph&quot;, &quot;photochromolithograph&quot;]
[&quot;duodenopancreatectomy&quot;, &quot;pancreatoduodenectomy&quot;]
[&quot;anatomicopathological&quot;, &quot;pathologicoanatomical&quot;]
[&quot;encephalomeningocele&quot;, &quot;meningoencephalocele&quot;]
[&quot;glossolabiolaryngeal&quot;, &quot;labioglossolaryngeal&quot;]
[&quot;anatomicophysiologic&quot;, &quot;physiologicoanatomic&quot;]
[&quot;pericardiacophrenic&quot;, &quot;phrenicopericardiac&quot;]

&gt;&gt; an.most(size:10).each {|m| p m}
[&quot;angor&quot;, &quot;argon&quot;, &quot;goran&quot;, &quot;grano&quot;, &quot;groan&quot;, &quot;nagor&quot;, &quot;orang&quot;, &quot;organ&quot;, &quot;rogan&quot;, &quot;ronga&quot;]
[&quot;elaps&quot;, &quot;lapse&quot;, &quot;lepas&quot;, &quot;pales&quot;, &quot;salep&quot;, &quot;saple&quot;, &quot;sepal&quot;, &quot;slape&quot;, &quot;spale&quot;, &quot;speal&quot;]
[&quot;caret&quot;, &quot;carte&quot;, &quot;cater&quot;, &quot;crate&quot;, &quot;creat&quot;, &quot;creta&quot;, &quot;react&quot;, &quot;recta&quot;, &quot;trace&quot;]
[&quot;ester&quot;, &quot;estre&quot;, &quot;reest&quot;, &quot;reset&quot;, &quot;steer&quot;, &quot;stere&quot;, &quot;stree&quot;, &quot;terse&quot;, &quot;tsere&quot;]
[&quot;leapt&quot;, &quot;palet&quot;, &quot;patel&quot;, &quot;pelta&quot;, &quot;petal&quot;, &quot;plate&quot;, &quot;pleat&quot;, &quot;tepal&quot;]
[&quot;armet&quot;, &quot;mater&quot;, &quot;metra&quot;, &quot;ramet&quot;, &quot;tamer&quot;, &quot;terma&quot;, &quot;trame&quot;, &quot;trema&quot;]
[&quot;asteer&quot;, &quot;easter&quot;, &quot;eastre&quot;, &quot;reseat&quot;, &quot;saeter&quot;, &quot;seater&quot;, &quot;staree&quot;, &quot;teaser&quot;]
[&quot;arist&quot;, &quot;astir&quot;, &quot;sitar&quot;, &quot;stair&quot;, &quot;stria&quot;, &quot;tarsi&quot;, &quot;tisar&quot;, &quot;trias&quot;]
[&quot;laster&quot;, &quot;lastre&quot;, &quot;rastle&quot;, &quot;relast&quot;, &quot;resalt&quot;, &quot;salter&quot;, &quot;slater&quot;, &quot;stelar&quot;]
[&quot;dater&quot;, &quot;derat&quot;, &quot;detar&quot;, &quot;drate&quot;, &quot;rated&quot;, &quot;trade&quot;, &quot;tread&quot;]
||&lt;


Anagram#all は辞書における
すべてのアナグラムの組みを表示します
&gt;|ruby|
&gt;&gt; an.all.size #=&gt; 14212
&gt;&gt; an.all.take 5 #=&gt; [[&quot;aal&quot;, &quot;ala&quot;], [&quot;aam&quot;, &quot;ama&quot;], [&quot;aaronic&quot;, &quot;nicarao&quot;, &quot;ocarina&quot;], [&quot;aaronite&quot;, &quot;aeration&quot;], [&quot;aaru&quot;, &quot;aura&quot;]]
&gt;&gt; an.all.select {|set| set.size &gt; 3 &amp;&amp; set.first =~ /^ru/}
=&gt; [[&quot;ruinate&quot;, &quot;taurine&quot;, &quot;uranite&quot;, &quot;urinate&quot;], [&quot;runite&quot;, &quot;triune&quot;, &quot;uniter&quot;, &quot;untire&quot;], [&quot;rusa&quot;, &quot;saur&quot;, &quot;sura&quot;, &quot;ursa&quot;, &quot;usar&quot;], [&quot;ruse&quot;, &quot;suer&quot;, &quot;sure&quot;, &quot;user&quot;]]
||&lt;

なおAnagram.newは単語リストファイルを
引数に取ることができます
&gt;|ruby|
&gt;&gt; an = Anagram.new(open 'sample_dic')
||&lt;
こうするとAnagram辞書を作らずに
各インスタンスメソッドが使えるようになります


暇なときに遊んでやってください :-)


(追記:2011-12-07) コードを一部修正しました。

</body>
</day>
<day date="2011-12-11" title="">
<body>
*p1*GraphAzでアナグラムをビジュアライズしたよ
この前Rubyで単語のアナグラムを見つける
Anagramライブラリを書いたよ


[http://d.hatena.ne.jp/keyesberry/20111205/p2:title=Rubyでアナグラムしようよ - hp12c]


でもやっぱりアナグラムを単に
ターミナルに出力するだけじゃつまらないよね


で以前に作った
ruby-graphvizをラップするGraphAzを思い出したよ


[http://d.hatena.ne.jp/keyesberry/20100203/p1:title=Rubyでアニメーション・グラフを作ろう！ - hp12c]


それで最も組数の多いアナグラム上位5組を
GraphAzでビジュアライズしてみたら
なんかきれいだったので
コードと共にここに貼っておくよ
円の中心がアナグラムのシグネチャで
周囲がそのシグネチャを持った単語だよ


[f:id:keyesberry:20111211192807p:image]


上位100組だとお花畑になるよ
[f:id:keyesberry:20111212000354p:image]


&lt;script src=&quot;https://gist.github.com/1459802.js?file=graph_anagram.rb&quot;&gt;&lt;/script&gt;


(追記:2011-12-12) 100組のイメージを追加を追加しました．
</body>
</day>
<day date="2011-12-12" title="">
<body>
*p1*Rubyで英文小説をWordleしようよ
Wordleって知ってる？
Wordleはテキスト中の単語をグラフィカルに配置して
表示するツール／サービスだよ


[http://www.wordle.net/:title=Wordle - Beautiful Word Clouds]



例えばProject Gutenbergから
「[http://www.gutenberg.org/cache/epub/11/pg11.txt:title=Alice's Adventures In Wonderland]」を取ってきて
Createページのテキストボックスに
これを貼りつければこんなものができるんだよ


[f:id:keyesberry:20111212175942p:image]


すばらしいよね！
Wordleではテキスト中の単語の出現頻度に応じて
文字の大きさを調整してるよ
加えてRandomizeボタンを押したり
FontやLayoutやColorを変えたりすることで
全く違ったイメージのWordleが作れるよ


Wordleのアルゴリズムについては
「Beautiful Visualization」という
データビジュアライゼーションの本に解説があるよ


[asin:4873115043:detail]


Wordleはすばらしいんだけど一点だけ不満があるよ
それはその単語の大きさがそのテキストの特徴を
必ずしもうまく表していないことだよ
つまりWordleではストップワードの除去が
あまりうまくいっていないんだよ
ちなみにストップワードはその言語で一般的に使われる語
例えばthe a forとかの非特徴的な単語のことだよ
先の結果を見ると
余り特徴的でない単語が並んでることがわかるよね


で以前にこのブログのチュートリアルで作った
WordDictionaryクラスを思い出したんだよ


[http://d.hatena.ne.jp/keyesberry/20090423/p1:title=Rubyチュートリアル ～英文小説の最頻出ワードを見つけよう!(最終回) - hp12c]


WordDictionaryクラスでは
他のテキストからなるベース辞書との比較で
対象テキストの特徴語を抽出できるんだったよ
試しにちょっと固めの小説をベースとして
アリスの特徴語を抽出してみるよ

&gt;|ruby|
require_relative &quot;word_dictionary&quot;

alice = &quot;alices_adventures_in_wonderland.txt&quot;
bases = %w(english_literature.txt analyze_people_on_sight.txt)

alice_wd = WordDictionary.new(alice)
base_wd = bases.map { |base| WordDictionary.new(base, base) }.inject(:+)

p alice_wd.uniq_words(40, base_wd)

# &gt;&gt; [[&quot;alice&quot;, 403], [&quot;turtle&quot;, 59], [&quot;hatter&quot;, 56], [&quot;mock&quot;, 56], [&quot;gryphon&quot;, 55], [&quot;rabbit&quot;, 51], [&quot;mouse&quot;, 44], [&quot;ve&quot;, 44], [&quot;duchess&quot;, 42], [&quot;tone&quot;, 40], [&quot;dormouse&quot;, 40], [&quot;cat&quot;, 37], [&quot;march&quot;, 35], [&quot;hare&quot;, 31], [&quot;white&quot;, 30], [&quot;replied&quot;, 29], [&quot;caterpillar&quot;, 28], [&quot;jury&quot;, 22], [&quot;cried&quot;, 20], [&quot;sort&quot;, 20], [&quot;tea&quot;, 19], [&quot;soup&quot;, 18], [&quot;spoke&quot;, 17], [&quot;sat&quot;, 17], [&quot;talking&quot;, 17], [&quot;garden&quot;, 16], [&quot;hastily&quot;, 16], [&quot;arm&quot;, 15], [&quot;mad&quot;, 15], [&quot;suppose&quot;, 14], [&quot;didn&quot;, 14], [&quot;anxiously&quot;, 14], [&quot;dinah&quot;, 14], [&quot;baby&quot;, 14], [&quot;footman&quot;, 14], [&quot;yes&quot;, 13], [&quot;dodo&quot;, 13], [&quot;cats&quot;, 13], [&quot;wouldn&quot;, 13], [&quot;dance&quot;, 13]]
||&lt;
なんかそれっぽい単語が抽出されたね


うれしいことにWordleのサイトでは
単語とその重み付けのリストを渡して
Wordleを作ることもできるんだよ(Advancedページ)
早々WordDictinaryで抽出したAliceの特徴語を使って
Wordleを作ってみたよ


Alices Adventures In Wonderland (40 words)
[f:id:keyesberry:20111212175943p:image]


Alices Adventures In Wonderland (100 words)
[f:id:keyesberry:20111212175949p:image]


なんかいい感じだよね！
他の小説でも試してみるよ


Pride And Prejudice
[f:id:keyesberry:20111212175944p:image]


The Adventures Of Sherlock Holmes
[f:id:keyesberry:20111212175945p:image]


Frankenstein
[f:id:keyesberry:20111212175946p:image]


Hamlet
[f:id:keyesberry:20111212175947p:image]


Peter Pan
[f:id:keyesberry:20111212175948p:image]


Wordleは楽しいから是非とも試してみて！
僕が作ったWordleは次のURLで見れるよ


[http://www.wordle.net/gallery?username=merborne:title=Wordle - Gallery: merborne]


&lt;script src=&quot;https://gist.github.com/1454681.js&quot;&gt; &lt;/script&gt;

</body>
</day>
<day date="2011-12-15" title="">
<body>
*p2*Rubyのtapはメソッドチェーンだけのものじゃない!
あるインスタンス変数にオブジェクトがセットされているときに
その参照を外しつつ
そのオブジェクトを返すというメソッドが必要になったんだよ
次のような感じだよ
&gt;|ruby|
 @name = nil #at initialize

 def set_name(name)
   @name = name
 end

 def reset_name

 end

 set_name('Charlie') # =&gt; &quot;Charlie&quot;
 reset_name # =&gt; &quot;Charlie&quot;
||&lt;


ここでreset_nameしたときに
インスタンス変数にセットされてた
オブジェクトを返したいんだ
なんかよくありそうだよね


こんなときは普通reset_nameを
次のように書くと思うんだ
&gt;|ruby|
 def reset_name
   name = @name
   @name = nil
   name
 end

 set_name('Charlie') # =&gt; &quot;Charlie&quot;
 reset_name # =&gt; &quot;Charlie&quot;
||&lt;


でもなんかスマートじゃないよね


で少し考えたんだけど
多重代入を使うともう少しマシになるんだ
&gt;|ruby|
 def reset_name
   name, @name = @name, nil
   name
 end

 set_name('Charlie') # =&gt; &quot;Charlie&quot;
 reset_name # =&gt; &quot;Charlie&quot;
||&lt;


でもやっぱり返り値を確保するためだけに
ローカル変数を用意しなきゃならないなんて
なんかイケてないよね..


そこでObject#tapの出番ですよ奥さん..
&gt;|ruby|
 def reset_name
   @name.tap { @name = nil }
 end

 set_name('Charlie') # =&gt; &quot;Charlie&quot;
 reset_name # =&gt; &quot;Charlie&quot;
 @name # =&gt; nil
||&lt;


tapはそのブロックを評価するけれども
その結果を捨ててしまうという
謙虚な変わり者のメソッドだよ


なかなかイケてると思うんだけど
どうかな？
周知のTipsだったらごめんね


*p1*Rubyのエニュメレータ内での破壊行為は止めてください!

RubyのArrayにはrotate!という便利なメソッドがあるよ
このメソッドは文字通り配列の要素をローテートするんだ
&gt;|ruby|
 a = [1,2,3]
 a.rotate! # =&gt; [2, 3, 1]
 a.rotate! # =&gt; [3, 1, 2]
 a # =&gt; [3, 1, 2]
||&lt;

メソッド名の最後に!(ビックリマーク)があるから
これは元のオブジェクト自身を変えるよ


昨日僕はこのrotate!メソッドにおける
ローテートの過程を取りたいと思ったんだよ
で次のようなコードを書いてみたんだ
&gt;|ruby|
 a = [1,2,3]
 3.times.map { a.rotate! }
||&lt;


そうしたら期待したものとは違う
次のような結果が返ってきたんだ
&gt;|ruby|
 # =&gt; [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
||&lt;


あれ？
mapがいけないのかな..
&gt;|ruby|
 q = []
 3.times { q &lt;&lt; a.rotate! }
 q # =&gt; [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
||&lt;


ローテートしてないのかと思って
ブロック内でpしてみたらちゃんとしてるんだよ
&gt;|ruby|
 a = [1,2,3]
 3.times.map { p a.rotate! } # =&gt; [[1, 2, 3], [1, 2, 3], [1, 2, 3]]

 # &gt;&gt; [2, 3, 1]
 # &gt;&gt; [3, 1, 2]
 # &gt;&gt; [1, 2, 3]
||&lt;
なんか変だな..


で少し考えたら理由がわかったんだ
Array#rotate!はselfを返すんだったよ
&gt;|ruby|
 a = [1,2,3]
 a.object_id # =&gt; 2151892940
 3.times.map { a.rotate!.object_id } # =&gt; [2151892940, 2151892940, 2151892940]
||&lt;


つまりmapの返り値はa.rotate!の
スナップショットの配列を返すんじゃなくて
元オブジェクトの参照の配列を返すんだよ
でmapの返り値はすべての要素に対する
イテレートが終わってから返されるから(当然だよね)
その時点つまり最後のa.rotate!の後における
元オブジェクトの状態がすべての配列の要素として
返されることになるんだ


つまりこれは次のコードと同じようなことなんだよ
&gt;|ruby|
 a = [1,2,3]
 b = a.rotate!
 c = a.rotate!
 d = a.rotate!
 [b, c, d] # =&gt; [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
||&lt;


だからスナップショットつまり途中経過がほしい場合は
さっきみたいにpしたり
to_sしたりdupしたりする必要があるんだね
&gt;|ruby|
 a = [1,2,3]
 3.times.map { a.rotate!.to_s } # =&gt; [&quot;[2, 3, 1]&quot;, &quot;[3, 1, 2]&quot;, &quot;[1, 2, 3]&quot;]

 a = [1,2,3]
 3.times.map { a.rotate!.dup } # =&gt; [[2, 3, 1], [3, 1, 2], [1, 2, 3]]
||&lt;


同じことはほかのRubyの破壊的メソッドでも起きるよ
&gt;|ruby|
 s = &quot;hello, world!&quot;
 s.size.times.map { p s.chop! } # =&gt; [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]
 # &gt;&gt; &quot;hello, world&quot;
 # &gt;&gt; &quot;hello, worl&quot;
 # &gt;&gt; &quot;hello, wor&quot;
 # &gt;&gt; &quot;hello, wo&quot;
 # &gt;&gt; &quot;hello, w&quot;
 # &gt;&gt; &quot;hello, &quot;
 # &gt;&gt; &quot;hello,&quot;
 # &gt;&gt; &quot;hello&quot;
 # &gt;&gt; &quot;hell&quot;
 # &gt;&gt; &quot;hel&quot;
 # &gt;&gt; &quot;he&quot;
 # &gt;&gt; &quot;h&quot;
 # &gt;&gt; &quot;&quot;
||&lt;


うっかりしてるとまたミスしそうだよ
分かってる人には当たり前のことなんだろうけど
僕はちょっと嵌っちゃったから書いてみたよ :)


&lt;del datetime=&quot;2011-12-15T07:17:25+09:00&quot;&gt;だからビルのエレベーター内での危険行為はもう止めようよ!&lt;/del&gt;
だからRubyのエニュメレータ内での破壊行為はもう止めようよ!

</body>
</day>
<day date="2011-12-18" title="">
<body>
*p2*Wordleでビジネスカードを作ろう!

少し前の投稿で
テキスト中の単語をグラフィカルに配置して
表示するWordleというツールを紹介したよ


[http://d.hatena.ne.jp/keyesberry/20111212/p1:title=Rubyで英文小説をWordleしようよ - hp12c]
[http://www.wordle.net/:title=Wordle - Beautiful Word Clouds]


Wordleでは単語の出現頻度に応じて
そのサイズを異ならせて表示するよ


でサイズの異なる単語が並んだもの
って言えばビジネスカードだから
Wordleでビジネスカードが作れるんじゃね？
って思ったんだよ


そんなわけで..


コンピュータ界の巨人たちのビジネスカードを
Wordleで作ってみたよ
なんかそれっぽくない？


[f:id:keyesberry:20111218145910p:image]
Google


[f:id:keyesberry:20111218145911p:image]
Microsoft


[f:id:keyesberry:20111218145913p:image]
facebook


[f:id:keyesberry:20111218145912p:image]
Apple


[http://www.wordle.net/gallery?username=merborne:title=Wordle - Gallery: merborne]

**作り方
+WordleサイトのAdvancedページに行く
+ビジネスカードを構成する単語とその重み付け情報を入力する(以下を参照)
+Rondomize, Font, Layout, Colorなどの設定を気に入るまでいじる

&gt;&gt;
(入力情報)
Google:1000
Larry Page:500
Chief Executive:100
1600 Amphitheatre Parway:100
Mountain View:100
CA 94043:100
USA:100
Tel 650 253-0000:100
Fax 650 253-0001:100
larry@gmail.com:100
&lt;&lt;

残念ながら日本語には対応してないんだけど
結構遊べるよねWordleって


*p1*RubyのRSpecでリボルバーを作ってロシアンルーレットしようよ!
今までコードを書くとき
正直あまりまじめにテストをしてこなかったよ
でもいつまでもそういう訳にはいかないだろうから
以下の記事を参考にしてRSpecをやってみたんだ


[http://d.hatena.ne.jp/t-wada/20100228/p1:title=RSpec の入門とその一歩先へ - t-wadaの日記]
[http://jp.rubyist.net/magazine/?0021-Rspec:title=Rubyist Magazine - スはスペックのス 【第 1 回】 RSpec の概要と、RSpec on Rails (モデル編)]


そうしたら次のようなことが分かったんだよ
+RSpecは設計図
+RSpecはなんかたのしい


でこの感覚をみんなと共有できればと思ったので
RSpec入門者の僕がRSpecを使って
ここで何か作ってみるよ


さて　何を作ろうか..


何か実用的で楽しいものがいいよね
そうだ折角だからなかなか手に入らないものがいいね
なかなか手に入らないものといったら..


もちろん輸入禁制品だよね!


そんなわけで..


RubyのRSpecを使ってけん銃を作るよ
で最高にイカしてるけん銃と言ったらリボルバーだから
リボルバーを作ることにするよ
銃が完成したら
君とロシアンルーレットを楽しみたいと思うんだ


最初に断っておくと
このポストは君がエディタとターミナルを開いて
僕と同じことをすることを期待したもの
つまりチュートリアルの形式になっているよ
だから相当長いポストになることを覚悟してほしいよ


結果だけみたい人は以下にコードを張ったから
それにざっと目を通してそれから
「ロシアンルーレットで遊ぶ」の項に飛んでくれるとうれしいよ


[https://gist.github.com/1490370:title=Revolver for Russian Roulette ― Gist]


**リボルバーの作り方

うれしいことにRubyには
ロシアンルーレットのための部品が既に用意されてるよ
Array#rotate! #shuffle #cycle は
まさにその目的のために作られたんだよ
これらのメソッドがあれば作業がかなり捗るよね


さて　簡単な方針だけ決めてRSpecを書いていくよ
けん銃にもいろいろあるからここでは
いきなりRevolverクラスを作るんじゃなくて
ベースとなるGunクラスを作って
Revolverクラスはそれを継承するようにしよう

&gt;|ruby|
 #gun_spec.rb
 require &quot;rspec&quot;
 require_relative &quot;gun&quot;
 
 describe Gun do
   
 end
 
 describe Revolver do
   
 end
||&lt;


**Gunクラス

けん銃は少なくとも弾を込めて
発砲できなくちゃいけないから
これをGunクラスの機能として持たせるよ
薬室(弾を込める場所)　装弾　発砲をそれぞれ
chamber set_cartridge triggerとするよ
弾はカートリッジ(cartridge)と言うよ


ちなみに銃に詳しくない人はここに目を通すといいよ


[http://s-c-c.info/tec/revo.html:title=SCC-Gun]


&gt;|ruby|
 describe Gun do
   context &quot;chamber&quot; do
     
   end
 
   context &quot;set_cartridge&quot; do
     
   end
 
   context &quot;trigger&quot; do
     
   end
 end
||&lt;


ここで一度rspecを走らせてみるよ
&gt;|bash|
 % rspec -fs -c gun_spec.rb
 % gun_spec.rb:4:in `&lt;top (required)&gt;': uninitialized constant Object::Gun (NameError)
||&lt;


Gunクラスがないって文句を言われたからこれを作ろう
Revolverもね

&gt;|ruby|
 #gun.rb
 class Gun
   
 end
 
 class Revolver &lt; Gun
   
 end
||&lt;


さあもう一度テストするよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb
 No examples found.
 
 Finished in 0.00005 seconds
 0 examples, 0 failures
||&lt;


でchamberは最初は空でset_cartridgeすると
弾がそこに入って撃てるようになる
そういう設計に沿ってexampleを書くよ
&gt;|ruby|
 require &quot;rspec&quot;
 require_relative &quot;gun&quot;
 
 describe Gun do
   before do
     @gun = Gun.new
   end
 
   context &quot;chamber&quot; do
     it &quot;should be empty at default&quot; do
       @gun.chamber.should be_empty
     end
     
   end
 
   context &quot;set_cartridge&quot; do
     it &quot;should set a cartridge to the chamber&quot; do
       @gun.set_cartridge
       @gun.chamber.should == [Cartridge.new]
     end
   end
 
   context &quot;trigger&quot; do
     
   end
 end
 
 describe Revolver do
   
 end
||&lt;


そしてテストするよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 Gun
   chamber
     should be empty at default (FAILED - 1)
   set_cartridge
     should set a cartridge to the chamber (FAILED - 2)
 Failures:
 
   1) Gun chamber should be empty at default
      Failure/Error: @gun.chamber.should be_empty
      NoMethodError:
        undefined method `chamber' for #&lt;Gun:0x00000100a1e248&gt;
      # ./gun_spec.rb:11:in `block (3 levels) in &lt;top (required)&gt;'
 
   2) Gun set_cartridge should set a cartridge to the chamber
      Failure/Error: @gun.set_cartridge
      NoMethodError:
        undefined method `set_cartridge' for #&lt;Gun:0x00000100a1cda8&gt;
      # ./gun_spec.rb:18:in `block (3 levels) in &lt;top (required)&gt;'
 
 Finished in 0.00092 seconds
 2 examples, 2 failures
 Failed examples:
 
 rspec ./gun_spec.rb:10 # Gun chamber should be empty at default
 rspec ./gun_spec.rb:17 # Gun set_cartridge should set a cartridge to the chamber
||&lt;


chamberメソッドもset_cartridgeメソッドも
無いって言われたから作るよ
&gt;|ruby|
 class Gun
   attr_reader :chamber
   def initialize
     @chamber = []
   end
 
   def set_cartridge
     @chamber &lt;&lt; Cartridge.new
   end
 end
||&lt;


もう一度テストするよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 Gun
   chamber
     should be empty at default
   set_cartridge
     should set a cartridge to the chamber (FAILED - 1)
 Failures:
 
   1) Gun set_cartridge should set a cartridge to the chamber
      Failure/Error: @gun.set_cartridge
      NameError:
        uninitialized constant Gun::Cartridge
      # ./gun.rb:8:in `set_cartridge'
      # ./gun_spec.rb:18:in `block (3 levels) in &lt;top (required)&gt;'
 
 Finished in 0.00328 seconds
 2 examples, 1 failure
||&lt;

1つ目はパスしたけど
2つ目はまだ弾を作ってなかったからフェイルしたよ
弾を作るよ
&gt;|ruby|
 class Cartridge
   
 end
||&lt;


テストね
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 Gun
   chamber
     should be empty at default
   set_cartridge
     should set a cartridge to the chamber (FAILED - 1)
 Failures:
 
   1) Gun set_cartridge should set a cartridge to the chamber
      Failure/Error: @gun.chamber.should == [Cartridge.new]
        expected: [#&lt;Cartridge:0x00000100a992b8&gt;]
             got: [#&lt;Cartridge:0x00000100a99420&gt;] (using ==)
        Diff:
        @@ -1,2 +1,2 @@
        -[#&lt;Cartridge:0x00000100a992b8&gt;]
        +[#&lt;Cartridge:0x00000100a99420&gt;]
      # ./gun_spec.rb:19:in `block (3 levels) in &lt;top (required)&gt;'
 Finished in 0.00145 seconds
 2 examples, 1 failure
||&lt;


今度は弾が違うって言われたよ
弾の同値性をオブジェクトで判断するからだね
じゃあ同値性をクラスで判断して弾の個性を消すよ
&gt;|ruby|
 class Cartridge
   include Comparable
   def &lt;=&gt;(other)
     self.class &lt;=&gt; other.class
   end
 end
||&lt;


さあもう一度
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 Gun
   chamber
     should be empty at default
   set_cartridge
     should set a cartridge to the chamber
 Finished in 0.00088 seconds
 2 examples, 0 failures
||&lt;
うまくいったよ!


さて次にchamberに弾が入ってたらもう詰められないから
そのときはエラーがでるようにしないと
exampleを書くよ
&gt;|ruby|
  context &quot;set_cartridge&quot; do
    it &quot;should set a cartridge to the chamber&quot; do
      @gun.set_cartridge
      @gun.chamber.should == [Cartridge.new]
    end

    it &quot;should be error when the chamber has a cartridge&quot; do
      -&gt;{ 2.times { @gun.set_cartridge } }.should raise_error
    end
  end
||&lt;
raise_errorを捕捉するにはset_cartridgeのリターンを
Procオブジェクト化しないといけないよ
ちょっとイケてないけどねー


テストするよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 Gun
   chamber
     should be empty at default
   set_cartridge
     should set a cartridge to the chamber
     should be error when the chamber has a cartridge (FAILED - 1)
 
 Failures:
 
   1) Gun set_cartridge should be error when the chamber has a cartridge
      Failure/Error: -&gt;{ 2.times { @gun.set_cartridge } }.should raise_error
        expected Exception but nothing was raised
      # ./gun_spec.rb:23:in `block (3 levels) in &lt;top (required)&gt;'
 
 Finished in 0.00122 seconds
 3 examples, 1 failure
||&lt;


エラーを期待したのに
エラーにならないって言われたので対応するよ
ErrorクラスはChamberErrorにしようか
&gt;|ruby|
 class Gun
   class ChamberError &lt; StandardError; end
   
   attr_reader :chamber
   def initialize
     @chamber = []
   end
 
   def set_cartridge
     raise ChamberError, 'The chamber is full' unless @chamber.empty?
     @chamber &lt;&lt; Cartridge.new
   end
 end
||&lt;


テストするよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 Gun
   chamber
     should be empty at default
   set_cartridge
     should set a cartridge to the chamber
     should be error when the chamber has a cartridge
 
 Finished in 0.00137 seconds
 3 examples, 0 failures
||&lt;
パスしたよ


さて次はtrigger周りを作ろう
もちろん発砲したら'Bang!'ってならなきゃ
&gt;|ruby|
  context &quot;trigger&quot; do
    it &quot;should return 'Bang!'&quot; do
      @gun.trigger.should == 'Bang!'
    end
  end
||&lt;


実装もしちゃうよ
&gt;|ruby|
 class Gun
 
   def trigger
     'Bang!'
   end
 end
||&lt;


テストするよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 Gun
   chamber
     should be empty at default
   set_cartridge
     should set a cartridge to the chamber
     should be error when the chamber has a cartridge
   trigger
     should return 'Bang!'
 
 Finished in 0.00148 seconds
 4 examples, 0 failures
||&lt;
いいね!


さて今度は弾がないときの対応も取らないと
&gt;|ruby|
  context &quot;trigger&quot; do
    it &quot;should return 'Bang!'&quot; do
      @gun.trigger.should == 'Bang!'
    end

    it &quot;should be nil when the chamber is empty&quot; do
      @gun.chamber.should be_empty
      @gun.trigger.should be_nil 
    end
  end
||&lt;


テストするよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 Gun
   chamber
     should be empty at default
   set_cartridge
     should set a cartridge to the chamber
     should be error when the chamber has a cartridge
   trigger
     should return 'Bang!'
     should be nil when the chamber is empty (FAILED - 1)
 Failures:
 
   1) Gun trigger should be nil when the chamber is empty
      Failure/Error: @gun.trigger.should be_nil
        expected: nil
             got: &quot;Bang!&quot;
      # ./gun_spec.rb:34:in `block (3 levels) in &lt;top (required)&gt;'
 Finished in 0.00234 seconds
 5 examples, 1 failure
||&lt;


弾がなくても発砲しちゃうって..
対応するよ
&gt;|ruby|
  def trigger
    return nil if @chamber.empty?
    'Bang!'
  end
||&lt;


テストするよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 Gun
   chamber
     should be empty at default
   set_cartridge
     should set a cartridge to the chamber
     should be error when the chamber has a cartridge
   trigger
     should return 'Bang!' (FAILED - 1)
     should be nil when the chamber is empty
 Failures:
 
   1) Gun trigger should return 'Bang!'
      Failure/Error: @gun.trigger.should == 'Bang!'
        expected: &quot;Bang!&quot;
             got: nil (using ==)
      # ./gun_spec.rb:29:in `block (3 levels) in &lt;top (required)&gt;'
 Finished in 0.00218 seconds
 5 examples, 1 failure
||&lt;


今度はさっきパスしたexampleがフェイルしてる
そうだよ弾をセットしてないからね
テストが間違ってたんだ
テストを直してもう一度
&gt;|ruby|
  context &quot;trigger&quot; do
    it &quot;should return 'Bang!'&quot; do
      @gun.set_cartridge
      @gun.trigger.should == 'Bang!'
    end

    it &quot;should be nil when the chamber is empty&quot; do
      @gun.chamber.should be_empty
      @gun.trigger.should be_nil 
    end
  end
||&lt;


テストする
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 Gun
   chamber
     should be empty at default
   set_cartridge
     should set a cartridge to the chamber
     should be error when the chamber has a cartridge
   trigger
     should return 'Bang!'
     should be nil when the chamber is empty
 Finished in 0.0023 seconds
 5 examples, 0 failures
||&lt;
いいね!


さてそれから弾を撃ったら
chamberは空にならなきゃいけないね
追加しよう
&gt;|ruby|
  context &quot;chamber&quot; do
    it &quot;should be empty at default&quot; do
      @gun.chamber.should be_empty
    end

    it &quot;should be empty after triggering&quot; do
      @gun.set_cartridge
      @gun.trigger
      @gun.chamber.should be_empty
    end
  end
||&lt;


テストするよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 
 Gun
   chamber
     should be empty at default
     should be empty after triggering (FAILED - 1)
   set_cartridge
     should set a cartridge to the chamber
     should be error when the chamber has a cartridge
   trigger
     should return 'Bang!'
     should be nil when the chamber is empty
 
 Failures:
 
   1) Gun chamber should be empty after triggering
      Failure/Error: @gun.chamber.should be_empty
        expected empty? to return true, got false
      # ./gun_spec.rb:17:in `block (3 levels) in &lt;top (required)&gt;'
 Finished in 0.00227 seconds
 6 examples, 1 failure
||&lt;


フェイルするから実装するよ
&gt;|ruby|
  def trigger
    return nil if @chamber.empty?
    @chamber.clear
    'Bang!'
  end
||&lt;


もう一度テスト
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 
 Gun
   chamber
     should be empty at default
     should be empty after triggering
   set_cartridge
     should set a cartridge to the chamber
     should be error when the chamber has a cartridge
   trigger
     should return 'Bang!'
     should be nil when the chamber is empty
 
 Finished in 0.00215 seconds
 6 examples, 0 failures
||&lt;
いいね!


さてGunクラスは一応これで完成として
今度はRevolverクラスを作っていくよ


**Revolverクラス
リボルバーは6弾程の弾を保持する
回転式シリンダーという独特の機構を持っていて
一発撃つ毎にシリンダーが一つ回転して
次の弾がチャンバーにアラインされて
発砲の準備が整うよ


早速Revolverクラスを設計しよう
Gunクラスでは弾を直接chamberにセットしたけど
Revolverではcylinderにセットすることになるよね
だからset_cartridgeとchamberの再設計が必要だよ
ここではcylinderの0位置に弾がセットされたら
chamberにも弾があることにするよ
&gt;|ruby|
 describe Revolver do
   before do
     @rev = Revolver.new
   end
 
   context &quot;set_cartridge&quot; do
     it &quot;should set a cartridge to the cylinder pos 0&quot; do
       @rev.set_cartridge
       @rev.cylinder[0].should == Cartridge.new
     end
   end
 end
||&lt;


テストしてみるよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 
 Revolver
   set_cartridge
     should set a cartridge to the cylinder pos 0 (FAILED - 1)
 
 Failures:
 
   1) Revolver set_cartridge should set a cartridge to the cylinder pos 0
     Failure/Error: @rev.cylinder[0].should == Cartridge.new
      NoMethodError:
       undefined method `cylinder' for #&lt;Revolver:0x00000100a5af90&gt;
      # ./gun_spec.rb:53:in `block (3 levels) in &lt;top (required)&gt;'
 
 Finished in 0.00296 seconds
 7 examples, 1 failure
||&lt;


cylinderがないって言われたので作るよ
&gt;|ruby|
 class Revolver &lt; Gun
   CYLINDER_SIZE = 6
   attr_reader :cylinder
   def initialize
     @cylinder = Array.new(CYLINDER_SIZE)
     super
   end
 end
||&lt;


再テストするよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 
 Revolver
   set_cartridge
     should set a cartridge to the cylinder pos 0 (FAILED - 1)
 
 Failures:
 
   1) Revolver set_cartridge should set a cartridge to the cylinder pos 0
     Failure/Error: @rev.cylinder[0].should == Cartridge.new
        expected: #&lt;Cartridge:0x00000100a6a3a0&gt;
        got: nil (using ==)
      # ./gun_spec.rb:53:in `block (3 levels) in &lt;top (required)&gt;'
 Finished in 0.00281 seconds
 7 examples, 1 failure
||&lt;


今度は設計と違う結果(nil)が返ってきたよ
Revolver用のset_cartridgeを実装しないとね
最初は0ポジション空いてなければ隣に装弾する方式にしよう
先を急ぐから例外処理もここに書いちゃうよ
&gt;|ruby|
 class Revolver &lt; Gun
   class CylinderError &lt; StandardError; end
   
   CYLINDER_SIZE = 6
   attr_reader :cylinder
   def initialize
     @cylinder = Array.new(CYLINDER_SIZE)
     super
   end
 
   def set_cartridge
     pos = @cylinder.index(nil)
     raise CylinderError, 'Cylinder is full' unless pos
     @cylinder[pos] = Cartridge.new
   end
 end
||&lt;


もう2つほどexampleを追加してからテストしてみよう
&gt;|ruby|
  context &quot;set_cartridge&quot; do
    it &quot;should set a cartridge to the cylinder pos 0&quot; do
      @rev.set_cartridge
      @rev.cylinder[0].should == Cartridge.new
    end

    it &quot;should set 3 cartridges to the cylinder pos 0-3&quot; do
      3.times { @rev.set_cartridge }
      @rev.cylinder.should == [Cartridge.new, Cartridge.new, Cartridge.new, nil, nil, nil]
    end

    it &quot;should be error when it called more than the cylinder rooms&quot; do
      Revolver::CYLINDER_SIZE.times { @rev.set_cartridge }
      -&gt;{ @rev.set_cartridge }.should raise_error(Revolver::CylinderError)
    end
  end
||&lt;


テストだよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 
 Revolver
   set_cartridge
     should set a cartridge to the cylinder pos 0
     should set 3 cartridges to the cylinder pos 0-3
     should be error when it called more than the cylinder rooms
 
 Finished in 0.00315 seconds
 9 examples, 0 failures
||&lt;
OKだね!
ほんとうはcylinderの自由な位置に
カートリッジを装填できるべきだけど
ここでは割愛するよ


さてtriggerにいこう
まずはちゃんとBangするように
&gt;|ruby|
  context &quot;trigger&quot; do
    it &quot;should return 'Bang!'&quot; do
      @rev.set_cartridge
      @rev.trigger.should == 'Bang!'
    end
  end
||&lt;


&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 
 Revolver
   set_cartridge
     should set a cartridge to the cylinder pos 0
     should set 3 cartridges to the cylinder pos 0-3
     should be error when it called more than the cylinder rooms
   trigger
     should return 'Bang!' (FAILED - 1)
 Failures:
   1) Revolver trigger should return 'Bang!'
      Failure/Error: @rev.trigger.should == 'Bang!'
        expected: &quot;Bang!&quot;
             got: nil (using ==)
      # ./gun_spec.rb:70:in `block (3 levels) in &lt;top (required)&gt;'
 
 Finished in 0.00469 seconds
 10 examples, 1 failure
||&lt;


フェイルしちゃったよ
あーchamberに弾が無いからね
cylinder[0]に弾があれば
chamberにも弾があるって設計だったよね
&gt;|ruby|
  def chamber
    [ @cylinder[0] ].compact
  end
||&lt;


&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 
 Revolver
   set_cartridge
     should set a cartridge to the cylinder pos 0
     should set 3 cartridges to the cylinder pos 0-3
     should be error when it called more than the cylinder rooms
   trigger
     should return 'Bang!' (FAILED - 1)
 Failures:
   1) Revolver trigger should return 'Bang!'
      Failure/Error: @rev.trigger.should == 'Bang!'
        expected: &quot;Bang!&quot;
             got: nil (using ==)
      # ./gun_spec.rb:70:in `block (3 levels) in &lt;top (required)&gt;'
 
 Finished in 0.00338 seconds
 10 examples, 1 failure
||&lt;


まだフェイルする..
そうかこれはGun#triggerで
直接@chamberを参照してるから起きてるんだ
ここを直そう
&gt;|ruby|
 class Gun
 
    def trigger
 -    return nil if @chamber.empty?
 +    return nil if chamber.empty?
 -    @chamber.clear
 +    reset_chamber
     'Bang!'
    end
 
 +  private
 +  def reset_chamber
 +    @chamber.clear
 +  end
 end
 
 
 class Revolver
 
 + def reset_chamber
 +   @cylinder[0] = nil
 + end
 + private :reset_chamber
 end
||&lt;


テストだよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 
 Gun
   chamber
     should be empty at default
     should be empty after triggering
   set_cartridge
     should set a cartridge to the chamber
     should be error when the chamber has a cartridge  trigger
     should return 'Bang!'
     should be nil when the chamber is empty
 Revolver
   set_cartridge
     should set a cartridge to the cylinder pos 0
     should set 3 cartridges to the cylinder pos 0-3
     should be error when it called more than the cylinder rooms
   trigger
     should return 'Bang!'
 Finished in 0.00373 seconds
 10 examples, 0 failures
||&lt;
OKだね


考えてみたらロシアンルーレットってみんな
毎回ハンマー(撃鉄)を手で起こしてるよね
このタイプのリボルバーはシングルアクションというそうだよ
是非ともこの機構(cocking)を実装したいよ
cockingしないと発砲できないようにしよう
それから発砲した後はhammerが戻るようにしよう
&gt;|ruby|
  context &quot;trigger&quot; do
    it &quot;should return 'Bang!'&quot; do
      @rev.set_cartridge
      @rev.cocking
      @rev.trigger.should == 'Bang!'
    end

    it &quot;should be nil without cocking&quot; do
      @rev.set_cartridge
      @rev.trigger.should be_nil
    end
  end

  context &quot;hammer&quot; do
    it &quot;should be false after triggering&quot; do
      @rev.set_cartridge
      @rev.cocking
      @rev.trigger
      @rev.hammer.should be_false
    end
  end
||&lt;


当然hammerやcockingが無いって怒られるから
それを確認した上で実装しよう
&gt;|ruby|
 class Revolver &lt; Gun
   attr_reader :cylinder, :hammer
   def initialize
     @cylinder = Array.new(CYLINDER_SIZE)
     @hammer = false
     super
   end
 
   def cocking
     @hammer = true
   end
 
   def trigger
     return nil unless @hammer
     @hammer = false
     super
   end
 end
||&lt;


テストするよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 
 Revolver
   set_cartridge
     should set a cartridge to the cylinder pos 0
     should set 3 cartridges to the cylinder pos 0-3
     should be error when it called more than the cylinder rooms
   trigger
     should return 'Bang!'
     should be nil without cocking
   hammer
     should be false after triggering
 Finished in 0.0042 seconds
 12 examples, 0 failures
||&lt;
いいみたいだね


あ　それとcockingしたら
cylinderが一つ回転するようにしないといけなかったよ
回転しないと連続発砲ができないからね
&gt;|ruby|
  context &quot;cylinder&quot; do
    it &quot;should rotate for next when cocking&quot; do
      @rev.set_cartridge
      @rev.cocking
      @rev.cylinder.should == [nil, nil, nil, nil, nil, Cartridge.new]
    end
  end
||&lt;


テストするよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 Revolver
   set_cartridge
     should set a cartridge to the cylinder pos 0
     should set 3 cartridges to the cylinder pos 0-3
     should be error when it called more than the cylinder rooms
   cylinder
     should rotate for next when cocking (FAILED - 1)
   trigger
     should return 'Bang!'
     should be nil without cocking
   hammer
     should be false after triggering
 
 Failures:
 
   1) Revolver cylinder should rotate for next when cocking
      Failure/Error: @rev.cylinder.should == [nil, Cartridge.new, nil, nil, nil, nil]
        expected: [nil, #&lt;Cartridge:0x000001009cc1c8&gt;, nil, nil, nil, nil]
             got: [#&lt;Cartridge:0x000001009cc330&gt;, nil, nil, nil, nil, nil] (using ==)
        Diff:
        @@ -1,2 +1,2 @@
        -[nil, #&lt;Cartridge:0x000001009cc1c8&gt;, nil, nil, nil, nil]
        +[#&lt;Cartridge:0x000001009cc330&gt;, nil, nil, nil, nil, nil]
      # ./gun_spec.rb:71:in `block (3 levels) in &lt;top (required)&gt;'
 
 Finished in 0.00549 seconds
 13 examples, 1 failure
||&lt;


フェイルするから直すよ
&gt;|ruby|
  def cocking
    @cylinder.rotate!
    @hammer = true
  end
||&lt;


テストだよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 
 Revolver
   set_cartridge
     should set a cartridge to the cylinder pos 0
     should set 3 cartridges to the cylinder pos 0-3
     should be error when it called more than the cylinder rooms
   cylinder
     should rotate for next when cocking
   trigger
     should return 'Bang!' (FAILED - 1)
     should be nil without cocking
   hammer
     should be false after triggering
 
 Failures:
 
   1) Revolver trigger should return 'Bang!'
      Failure/Error: @rev.trigger.should == 'Bang!'
        expected: &quot;Bang!&quot;
             got: nil (using ==)
      # ./gun_spec.rb:79:in `block (3 levels) in &lt;top (required)&gt;'
 
 Finished in 0.00466 seconds
 13 examples, 1 failure
||&lt;


今度はtriggerのexampleでエラーが出たよ
cockingで弾がpos 0にいなくなったからだね
じゃあset_cartridgeでpos 0じゃなくpos 1に
弾をセットするように変えて対応するよ
&gt;|ruby|
   context &quot;set_cartridge&quot; do
 -    it &quot;should set a cartridge to the cylinder pos 0&quot; do
 +    it &quot;should set a cartridge to the cylinder pos 1&quot; do
       @rev.set_cartridge
 -      @rev.cylinder[0].should == Cartridge.new
 +      @rev.cylinder[1].should == Cartridge.new
     end
 
 -    it &quot;should set 3 cartridges to the cylinder pos 0-3&quot; do
 +    it &quot;should set 3 cartridges to the cylinder pos 1-4&quot; do
       3.times { @rev.set_cartridge }
 -      @rev.cylinder.should == [Cartridge.new, Cartridge.new, Cartridge.new, nil, nil, nil]
 +      @rev.cylinder.should == [nil, Cartridge.new, Cartridge.new, Cartridge.new, nil, nil]
     end
 
     it &quot;should be error when it called more than the cylinder rooms&quot; do
       Revolver::CYLINDER_SIZE.times { @rev.set_cartridge }
       -&gt;{ @rev.set_cartridge }.should raise_error(Revolver::CylinderError)
     end
   end
 
   context &quot;cylinder&quot; do
     it &quot;should rotate for next when cocking&quot; do
       @rev.set_cartridge
       @rev.cocking
 -      @rev.cylinder.should == [nil, nil, nil, nil, nil, Cartridge.new]
 +      @rev.cylinder.should == [Cartridge.new, nil, nil, nil, nil, nil]
     end
   end  
||&lt;


フェイルするから実装するよ
&gt;|ruby|
  def set_cartridge
    pos = @cylinder.rotate.index(nil)
    raise CylinderError, 'Cylinder is full' unless pos
    pos = (pos + 1) % CYLINDER_SIZE
    @cylinder[pos] = Cartridge.new
  end
||&lt;


テストだよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 
 Revolver
   set_cartridge
     should set a cartridge to the cylinder pos 1
     should set 3 cartridges to the cylinder pos 1-4
     should be error when it called more than the cylinder rooms
   cylinder
     should rotate for next when cocking
   trigger
     should return 'Bang!'
     should be nil without cocking
   hammer
     should be false after triggering
 
 Finished in 0.00461 seconds
 13 examples, 0 failures
||&lt;
うまくいったよ


じゃあ連続発砲ができるか試すよ
&gt;|ruby|
  context &quot;trigger&quot; do
    it &quot;should work sequentially&quot; do
      6.times { @rev.set_cartridge }
      @rev.cocking
      8.times.map { @rev.trigger.tap{ @rev.cocking } }.should == [&quot;Bang!&quot;, &quot;Bang!&quot;, &quot;Bang!&quot;, &quot;Bang!&quot;, &quot;Bang!&quot;, &quot;Bang!&quot;, nil, nil]
    end
  end
||&lt;


テストするよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 
 Revolver
   set_cartridge
     should set a cartridge to the cylinder pos 1
     should set 3 cartridges to the cylinder pos 1-4
     should be error when it called more than the cylinder rooms
   cylinder    should rotate for next when cocking
   trigger
     should return 'Bang!'
     should be nil without cocking
     should work sequentially
   hammer
     should be false after triggering
 
 Finished in 0.00705 seconds
 14 examples, 0 failures
||&lt;
うまくいってるようだね


さて最後に
ロシアンルーレットに必須の機能とも言うべき
spin_cylinderを実装しよう
&gt;|ruby|
  context &quot;spin_cylinder&quot; do
    it &quot;should rotate the cylinder line randomly(fail sometimes)&quot; do
      @rev.set_cartridge
      before_spin = @rev.cylinder.dup
      @rev.spin_cylinder
      @rev.cylinder.should_not == before_spin
    end
  end
||&lt;
あまり良いテストじゃないよね..
こういうランダムな結果をテストするのは
どうすればいいんだろうね
わからないから今回はこれでよしとして先に進むよ


さてもちろんテストに通らないので
spin_cylinderを実装するよ

&gt;|ruby|
  def spin_cylinder
    @cylinder.rotate!(rand CYLINDER_SIZE)
  end
||&lt;


さあテストだよ
&gt;|ruby|
 % rspec -fs -c gun_spec.rb 
 
 Gun
   chamber
     should be empty at default
     should be empty after triggering
  set_cartridge
     should set a cartridge to the chamber
     should be error when the chamber has a cartridge
   trigger
     should return 'Bang!'
     should be nil when the chamber is empty
 Revolver
   set_cartridge
     should set a cartridge to the cylinder pos 1
     should set 3 cartridges to the cylinder pos 1-4
     should be error when it called more than the cylinder rooms
   cylinder
     should rotate for next when cocking
   trigger
     should return 'Bang!'
     should be nil without cocking
     should work sequentially
   hammer
     should be false after triggering
   spin_cylinder
     should rotate the cylinder line randomly(fail sometimes)
 
 Finished in 0.00705 seconds
 15 examples, 0 failures
||&lt;
いいね!


さあこれでようやくRevolverが完成したよ!


**ロシアンルーレットで遊ぶ
さあ銃が用意できたから
早速ロシアンルーレットできるか試してみるよ
まずは舞台(russian_roulette.rb)を作ろう

&gt;|ruby|
 require &quot;term/ansicolor&quot;
 require_relative &quot;gun&quot;
 
 String.send(:include, Term::ANSIColor)
 
 def russian_roulette(fighters)
   print &quot;--- Welcome to Russian Roulette ---\n&quot;.green
   print &quot;Today's fighters are: &quot;
   print fighters.map { |f| f.magenta.underline }.join(&quot;, &quot;)
   print &quot;\nLet's go!\n\n&quot;
 
   rev = Revolver.new
   rev.set_cartridge
   sleep 2
 
   fighters.shuffle.cycle do |fighter|
     print &quot;#{fighter}'s turn:\n&quot;.cyan
     rev.cocking
     rev.spin_cylinder
     sleep 2
     unless result = rev.trigger
       print &quot;  Nothing happened..\n\n&quot;.yellow
       sleep 1
     else
       print &quot;  #{result}  &quot;.yellow.on_red.blink
       print &quot;  #{fighter} is dead.\n&quot;.blue
       print &quot;\n--- Game is over ---\n&quot;.green
       exit
     end
   end
 end
 
 russian_roulette(ARGV)
||&lt;
term-ansicolorで色を付けたから
gem install term-ansicolorしてね


さあ試してみるよ..
&gt;|bash|
 % ruby russian_roulette.rb Charlie Fox Henry
 --- Welcome to Russian Roulette ---
 Today's fighters are: Charlie, Fox, Henry
 Let's go!
 
 Fox's turn:
   Nothing happened..
 
 Charlie's turn:
   Nothing happened..
 
 Henry's turn:
   Nothing happened..
 
 Fox's turn:
   Nothing happened..
 
 Charlie's turn:
   Bang!    Charlie is dead.
 
 --- Game is over ---
 
||&lt;


[f:id:keyesberry:20111217233410p:image]


あー
チャーリーが死んじゃった..


じゃあ今度は君と僕とで勝負しようよ!
まずは僕から

&gt;|bash|
 % ruby russian_roulette.rb me you
 --- Welcome to Russian Roulette ---
 Today's fighters are: you, me
 Let's go!
 
 me's turn:
   Nothing happened..
||&lt;

ふー　セーフだったよ!
じゃあ今度は君
&gt;|bash|
 you's turn:
   Nothing happened..
||&lt;


おー　よかったね!
次は僕の番
&gt;|bash|
 me's turn:
   Bang!    me is dead.
 
 --- Game is over ---
||&lt;

</body>
</day>
<day date="2011-12-20" title="">
<body>
*p1*Rubyでデータをオブジェクト化して集計する

Javaでデータを集計する処理について書かれたブログを読んだよ


[http://d.hatena.ne.jp/irof/20111203/p1#c:title=リストを項目ごとに集計する - 日々常々](id:irof:20111203)


内容は次のようなデータがあって
|*code|*name|*value|
|A01|hoge|100|
|A01|piyo|200|
|A02|hoge|300|
|A03|hoge|400|
|A03|piyo|500|


次のような集計の結果を得たいというものだよ
|*code|*value|
|A01|300|
|A02|300|
|A03|900|


僕はRubyしか知らないからRubyでやってみるけど
RubyにはEnumerable#injectがあるから
集計処理は簡単にできるよ
ここではデータの読み込みからやってみることにするよ
先のデータがテキストファイルにあると仮定するよ


まずはデータを読み込んでlabelとdataの配列に格納しよう
&gt;|ruby|
label, *data = ARGF.map do |line|
  line.split.map(&amp;:strip).map { |d| d.match(/^[\d,]+$/) ? d.delete(',').to_i : d.intern }
end

label # =&gt; [:code, :name, :value]
data # =&gt; [[:A01, :hoge, 100], [:A01, :piyo, 200], [:A02, :hoge, 300], [:A03, :hoge, 400], [:A03, :piyo, 500]]
||&lt;
ここでは次のような処理をしているよ
+引数として渡されるデータファイルをARGFに読み込む
+データの各ラインに対して、splitでデータを分ける
+データが数値文字なら数値に変換し、それ以外ならシンボルに変換する
+先頭行の結果をlabelに、残りをdataに代入する


次にこの配列データをオブジェクト化するよ
&gt;|ruby|
Product = Struct.new(*label)

products = data.map { |d| Product.new(*d) }

products # =&gt; [#&lt;struct Product code=:A01, name=:hoge, value=100&gt;, #&lt;struct Product code=:A01, name=:piyo, value=200&gt;, #&lt;struct Product code=:A02, name=:hoge, value=300&gt;, #&lt;struct Product code=:A03, name=:hoge, value=400&gt;, #&lt;struct Product code=:A03, name=:piyo, value=500&gt;]
||&lt;
属性だけのオブジェクトを作るのはStructが便利だね


そして集計するよ
&gt;|ruby|
puts products.inject(Hash.new(0)) { |h, pr| h[pr.code] += pr.value; h }

# &gt;&gt; {:A01=&gt;300, :A02=&gt;300, :A03=&gt;900}
||&lt;
これはもう見慣れたコードだよね
ハッシュは0で初期化されるようにして
それからinjectはハッシュhを返すように


コードをまとめると次のようになるよ


&lt;script src=&quot;https://gist.github.com/1499895.js?file=account.rb&quot;&gt;&lt;/script&gt;


このコードはわりと汎用性があるんだよ
たとえば次のようなデータに適用する場合

|*date|*category|*sub|*expense|
|2011/1|食費|肉類|4,289|
|2011/1|食費|魚介類|4,036|
|2011/1|食費|野菜・果物|3,332|
|2011/1|光熱費|電気代|6,689|
|2011/1|光熱費|ガス代|4,792|
|2011/1|光熱費|水道代|4,290|
|2011/1|娯楽費|ゲーム・CD等|2,913|
|2011/1|娯楽費|入場料|191|
|2011/1|娯楽費|ピアノ|1200|
|2011/1|娯楽費|その他|1,376|
|2011/1|交通費|電車代|1,286|
|2011/1|交通費|バス代|350|
|2011/1|交通費|タクシー|1270|
|2011/1|医療費|治療代|913|
|2011/1|医療費|薬代|945|
|2011/2|食費|肉類|2,186|
|2011/2|食費|魚介類|1,111|
|2011/2|光熱費|電気代|3,645|
|2011/2|光熱費|ガス代|6,912|
|2011/2|光熱費|水道代|4,123|
|2011/2|娯楽費|ゲーム・CD等|5,900|
|2011/2|娯楽費|ピアノ|1200|
|2011/2|娯楽費|その他|3,034|
|2011/2|交通費|電車代|2,286|
|2011/2|交通費|バス代|450|
|2011/2|交通費|タクシー|0|
|2011/2|医療費|治療代|1,988|
|2011/2|医療費|薬代|650|


集計コードのラベルだけを変えればいいんだ

&gt;|ruby|
puts products.inject(Hash.new(0)) { |h, pr| h[pr.category] += pr.expense; h }

# &gt;&gt; {:食費=&gt;14954, :光熱費=&gt;30451, :娯楽費=&gt;15814, :交通費=&gt;5642, :医療費=&gt;4496}
||&lt;


月毎の支出を見たい場合はこうするよ
&gt;|ruby|
puts products.inject(Hash.new(0)) { |h, pr| h[pr.date] += pr.expense; h }

# &gt;&gt; {:&quot;2011/1&quot;=&gt;37872, :&quot;2011/2&quot;=&gt;33485}
||&lt;

Rubyは便利だね!

</body>
</day>
<day date="2011-12-21" title="">
<body>
*p1*LISPはＳ式(丸括弧)でできている、RubyはＲ式[角括弧]でできている
Rubyは許容可能なLISPと言われている


[http://d.hatena.ne.jp/masatoi/20101102/1288654204:title=なぜRubyは許容可能なLISPなのか - 翡翠はコンピュータに卵を生むか]


著者は
+RubyはLISPよりも濃い関数型言語であり
+LISPマクロでしたいことの大半はRubyでできる
という事実から
Rubyは許容可能なLISPであると結論している


しかし私は今日別の理由
つまりRubyがなぜ許容可能なLISPであるのかの
新たな解釈を発見した


私は「許容可能なLISP」とは
LISPerが「LISPの継承者と名乗っても差し支えなかろう」
と認めた言語をいうものと理解する
そしてLISPは括弧(Ｓ式)でできていることが
最大の特徴であることから
括弧を多産しないつまりこれでもかというくらいに
括弧が大量に現れない言語は
LISPerをしてLISP継承言語と認められないものと理解する


Rubyではメソッド定義や呼び出しの括弧を
省略できたりするものだから
この点からすればRubyを許容可能なLISPと
呼ぶことは到底できない


しかしそれはRubyの一側面に過ぎない
次のRubyのオブジェクト呼び出しコードを見ていただきたい
&gt;|ruby|
 R[:name][:age]['charlie'][21]['charlie'][0][:name][0,4] # =&gt; &quot;char&quot;

||&lt;


括弧括弧括弧
括弧だらけである
そしてこれは
Rubyの正しい構文に基づいて書かれており
しかもなんのトリックも施されていない
正真正銘のRubyなのである


Rubyに覚えのある方は暫し
この呼び出しを実現する
オブジェクトの実装を考えていただきたい


確かにネストした丸括弧と
シーケンシャルな角括弧という違いはあるものの
これだけ括弧を並べることができるなら
Rubyを許容可能なLISPと言っても差し支えないであろう


このような角括弧の連なり構文が可能なのは
実はRubyにおいて角括弧は
再定義可能なメソッド呼び出しに過ぎないからなのである


&gt;|ruby|
class Hash
  def [](arg)
    &quot;I don't know.&quot;
  end
end

h = {:name =&gt; 'charlie', :age =&gt; 21}
h[:name] # =&gt; &quot;I don't know.&quot;
||&lt;


つまりこれは多数のクラスが
各クラスの文脈に基づいて
角括弧メソッドを自由に定義し得るということを意味する
もちろん独自クラスにも角括弧を定義できる

&gt;|ruby|
class CALC
  def self.[](exp)
    eval exp
  end
end

CALC['40 - 32 / 2'] # =&gt; 24
||&lt;


さてそろそろ先のコードの実装を示そう
もちろん独自の角括弧メソッドの定義などはしていない

&gt;|ruby|
R = -&gt;a,b{
  _ = Struct.new(a, b)
  -&gt;x,y{ Hash[x, Array[ _[x, y] ]] }.curry
}.curry

R[:name][:age]['charlie'][21]['charlie'][0][:name][0,4] # =&gt; &quot;char&quot;

||&lt;


どうであろう
ここでも多数の角括弧が使われていることが見て取れる
しかもネストしている
ここで使われている角括弧は
Hash.[ ] Array.[ ] Struct.[]である


説明すると定数Rはカリー化された
Procオブジェクトを参照している
このProcオブジェクトは2つの引数a,bを取り
カリー化されたProcオブジェクトを返す
このProcオブジェクトは2つの引数x,yを取りハッシュを返す
ハッシュはxをkey 配列をvalueとする
配列の要素はa,bをプロパティとするStructのサブクラス_
から生成されるx,yを値とするStructオブジェクトである


そしてRの呼び出し側において
最初の4つの括弧[:name][:age]['charlie'][21]は
Proc#[]メソッドを呼んでいる
次の括弧['charlie']はHash#[]を
次の括弧[0]はArray#[]を
次の括弧[:name]はStruct#[]を
最後の括弧[0,4]はString#[]を
それぞれ呼んでいる


各角括弧の返り値を見れば理解が容易になるだろう

&gt;|ruby|
R # =&gt; #&lt;Proc:0x0000010085dc88 (lambda)&gt;
R[:name] # =&gt; #&lt;Proc:0x0000010085cec8 (lambda)&gt;
R[:name][:age] # =&gt; #&lt;Proc:0x0000010085c888 (lambda)&gt;
R[:name][:age]['charlie'] # =&gt; #&lt;Proc:0x0000010085c108 (lambda)&gt;
R[:name][:age]['charlie'][21] # =&gt; {&quot;charlie&quot;=&gt;[#&lt;struct name=&quot;charlie&quot;, age=21&gt;]}
R[:name][:age]['charlie'][21]['charlie'] # =&gt; [#&lt;struct name=&quot;charlie&quot;, age=21&gt;]
R[:name][:age]['charlie'][21]['charlie'][0] # =&gt; #&lt;struct name=&quot;charlie&quot;, age=21&gt;
R[:name][:age]['charlie'][21]['charlie'][0][:name] # =&gt; &quot;charlie&quot;
R[:name][:age]['charlie'][21]['charlie'][0][:name][0,4] # =&gt; &quot;char&quot;
||&lt;


このようなことから私は
Rubyにおける角括弧をR式と命名し
RubyがR式でできている
したがってRubyは許容可能なLISPである
と結論する次第である


以上

</body>
<comments>
<comment>
<username>m11m</username>
<body>推論が妥当でないように思われます．&lt;br&gt;媒概念不周延の虚偽と呼ばれる詭弁ではないでしょうか．</body>
<timestamp>1326350114</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;m11mさん&lt;br&gt;コメントありがとうございます。ええ、そのとおりなんです。推論が妥当であったらネタになりませんからね。</body>
<timestamp>1326355154</timestamp>
</comment>
<comment>
<username>m11m</username>
<body>ネタでしたか．&lt;br&gt;失礼しました．</body>
<timestamp>1326355721</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;m11mさん&lt;br&gt;いえ、いえ:)</body>
<timestamp>1326356917</timestamp>
</comment>
</comments>
</day>
<day date="2011-12-26" title="">
<body>
*p1*ただそこにいるだけで癒される! 原始的ソーシャルサービス HiToDaMa
一人でいるのが寂しい
でも誰かとコミュニケーションを取るのは面倒
ただ黙ってそばに居てくれる人がいればいい..
そんなときってありますよね？


そんなあなたのための
ソーシャルサービス「HiToDaMa」を作りました:)((ただのPusheのデモです^^;))


[http://hitodama.heroku.com/:title=HiToDaMa]


あなたがHiToDaMaにアクセスすると
色の付いた１つのいろは玉が生まれます
それがあなたです


もしそこに誰かが既に居たのなら
その人の玉がそこにあって
あなたの玉が追加されます


HiToDaMaであなたができることは
だれかがそこを訪れたり去ったりして
玉が増えたり減ったりする様子を眺めることと
床にとどまった玉をマウスでクリックして
それに動きを与えることだけです
並んだいろは文字から言葉を見つける
そんな遊びができるかもしれません


あなたもHiToDaMaに癒されてみませんか？


[https://github.com/melborne/HiToDaMa:title=melborne/HiToDaMa - GitHub]



</body>
</day>
<day date="2011-12-27" title="">
<body>
*p1*原始的ソーシャルサービスHiToDaMaで双方向コミュニケーションしようよ
HiToDaMaをバージョンアップしたよ


[http://hitodama.heroku.com/:title=HiToDaMa]


[f:id:keyesberry:20111227215457p:image]


HiToDaMaはPusherを使った実験的サービスだよ


顔文字玉が君でいろは玉が他のユーザだよ
誰かが君の玉をクリックすると
クリックした人のいろは玉が跳ねて
「hello!」と挨拶するよ


それに答えてその人のいろは玉をクリックすれば
相手側でも同じことが起きるから
これで双方向コミュニケーションが成立するんだよ


言葉を交わさなくても
コミュニケーションって成立するんだね


(追記:2011-12-28) HiToDaMaの仕様変更に伴い記述を直しました。
</body>
</day>
<day date="2011-12-29" title="">
<body>
*p1*RubyでExcel列名変換問題を解いて上司に対抗しよう!

社内でFizzBuzz問題のコンテストをしたら
あまり出来がよくなかったという記事があって
以前その問題をRubyで解いた投稿をしたよ


[http://d.hatena.ne.jp/keyesberry/20111009/p1:title=RubyでFizzBuzz問題を解いて上司に対抗しよう! - hp12c]


[http://d.hatena.ne.jp/JunichiIto/20111007/1317976730#20111007f1:title=FizzBuzz問題を使って社内プログラミングコンテストを開催してみた - ITは芸術だ]


でその元記事の人によれば
第２回目の社内プログラミングコンテストが
開催されたらしいんだ


[http://d.hatena.ne.jp/JunichiIto/20111102/1320253815:title=Excel列名変換問題で第２回社内プログラミングコンテストを開催してみた(前編) - ITは芸術だ]


今度はFizzBuzz問題よりも難易度の高い
Excel列名変換問題が2題出題されたよ
詳細は元記事をみて欲しいけど
簡単に言うと
Excelのアルファベットの列名を数字に変換するものと
その逆変換をするものだよ
例えば「AA」は27に「XFD」は16384になるよ


少し前の投稿で僕は
Rubyでは何でも作れて
ロシアンルーレットのためのメソッドまで
予め用意されているって紹介したよ((Array#rotate! #shuffle #cycleのことです^^;))


[http://d.hatena.ne.jp/keyesberry/20111218/p1:title=RubyのRSpecでリボルバーを作ってロシアンルーレットしようよ! - hp12c]


だから当然にRubyには
Excelのためのメソッドもあって
それらを使えば先の問題は簡単に解けちゃうんだよ:)
&gt;|ruby|
def alpha2num(alphabets)
 [*'A'..alphabets].size
end

def num2alpha(number)
 alpha = 'A'
 (number-1).times { alpha.succ! }
 alpha
end

alphabets = %w(A B Z AA AB AZ BB AAA IV ZZZ XFD)
numbers = alphabets.map { |alpha| alpha2num alpha }
  # =&gt; [1, 2, 26, 27, 28, 52, 54, 703, 256, 18278, 16384]
numbers.map { |num| num2alpha num }
  # =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;Z&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;AZ&quot;, &quot;BB&quot;, &quot;AAA&quot;, &quot;IV&quot;, &quot;ZZZ&quot;, &quot;XFD&quot;]
||&lt;


つまりRubyではアルファベットは
順位が決まった比較可能なオブジェクトで
「Z」の次は「AA」で「ZZ」の次は「AAA」
になるよう設計されているんだ
ちょっと速度上の問題はあるかもしれないけどね


でもなんかこれで解けたっていうのは
ずるっぽい感じがするから
僕も上司に恥をかかされないように
勉強中のrspecを使ってまじめに解いたから
ここに貼っておくよ


&lt;script src=&quot;https://gist.github.com/1534213.js&quot;&gt; &lt;/script&gt;

</body>
</day>
<day date="2012-01-07" title="">
<body>
*p1*Rubyで連続数字をハイフンでつなぐよ
かなり古い記事だけどRubyを使って
連続数字をハイフンでつなぐ方法が出てたよ


[http://builder.japan.zdnet.com/script/sp_ruby-doukaku-panel/20369264/:title=Rubyでどう書く？：連続した数列を範囲形式にまとめたい - builder]


要するにスペース区切りの数字列を
数字が連続する場合にその箇所をハイフンにする
という話だよ

&gt;&gt;
  &quot;1 2 3&quot; =&gt; &quot;1-3.&quot;
  &quot;1 2 3 5 7 8&quot; =&gt; &quot;1-3, 5, 7-8.&quot;
  &quot;1 3 4 5 7&quot; =&gt; &quot;1, 3-5, 7.&quot;
&lt;&lt;

解答例が出てたけどなんかしっくり来なかったので
自分なりの違う方法を考えてみたよ


まず数字文字列を数字の配列に変換するよ
&gt;|ruby|
str = &quot;1 3 4 5 7&quot;
nums = str.scan(/\d+/).map(&amp;:to_i) # =&gt; [1, 3, 4, 5, 7]
||&lt;


次にこれを
配列のインデックスに対応付けて配置し直すよ
&gt;|ruby|
nums.inject([]) { |arr, n| arr[n-1] = n; arr } # =&gt; [1, nil, 3, 4, 5, nil, 7]
||&lt;
これで数字が連続しないところにはnilが入るよ


次にnilのところで配列を分けるよ
&gt;|ruby|
nums = nums.chunk { |n| !n.nil? || nil }.to_a # =&gt; [[true, [1]], [true, [3, 4, 5]], [true, [7]]]
||&lt;
Enumerable#chunkを使うよ
そのブロックでは要素がnilの場合はnilを返すようにして
その要素を捨てるよ


次に各要素の長さに応じた加工を施して文字列にするよ
&gt;|ruby|
nums = nums.map { |_, gr| gr.size&gt;1 ? &quot;#{gr.first}-#{gr.last}&quot; : &quot;#{gr.first}&quot; } # =&gt; [&quot;1&quot;, &quot;3-5&quot;, &quot;7&quot;]
||&lt;


最後にこれをつないで完成だよ
&gt;|ruby|
nums.join(', ') + '.' # =&gt; &quot;1, 3-5, 7.&quot;
||&lt;


まとめると次のようになるよ


&lt;script src=&quot;https://gist.github.com/1573258.js?file=hyphenize.rb&quot;&gt;&lt;/script&gt;


やっぱりRubyは便利だね!


id:smilerubyさんから
Enumerable#slice_beforeを使った例を頂いたので
併せて載せておくよ
&gt;|ruby|
def hyphenize(str)
 nums = str.scan(/\d+/).map(&amp;:to_i).sort
 nums.slice_before(num: nums.first) { |e, prev|
   prev[:num], prevprev = e, prev[:num]
   prevprev.succ != prev[:num]
 }.map{ |e| e.minmax.uniq * '-' } * ', ' + '.'
end

hyphenize(&quot;1 3 4 5 7&quot;) # =&gt; &quot;1, 3-5, 7.&quot;
||&lt;
e.minmax.uniq*'-'がステキだよね!


(追記:2012-1-7) id:smilerubyさんの案を参考に一部を訂正、追記しました。

</body>
<comments>
<comment>
<username>smileruby</username>
<body>Enumerable#slice_beforeも&lt;br&gt;&lt;br&gt;def hyphenize(str)&lt;br&gt;  nums = str.scan(/&#92;d+/).map(&amp;:to_i).sort&lt;br&gt;  nums.slice_before(num: nums.first) { |e, prev|&lt;br&gt;    prev[:num], prevprev = e, prev[:num]&lt;br&gt;    prevprev.succ != prev[:num]&lt;br&gt;  }.map{ |e| e.minmax.uniq * &#39;-&#39; } * &#39;, &#39; + &#39;.&#39;&lt;br&gt;end&lt;br&gt;&lt;br&gt;同じような例題がEnumerable#slice_beforeのヘルプの例になってますねw&lt;br&gt;http://rurema.clear-code.com/1.9.3/method/Enumerable/i/slice_before.html</body>
<timestamp>1325907966</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;smilerubyさん&lt;br&gt;コメントどうもです! slice_beforeなんて技があったのですね. それにしてもe.mimmax.uniq*&#39;-&#39;はステキすぎます. それとstr.scan(/&#92;d+/)が正しいですね. 訂正しておきます.</body>
<timestamp>1325909328</timestamp>
</comment>
<comment>
<username>smileruby</username>
<body>追記ありがとうございます。&lt;br&gt;slice_beforeは前に同じような例題（日付バージョン）をやった時に覚えましたが、このパターンの処理の時にしか使ったことがありませんｗ&lt;br&gt;とはいえ、1.9で導入されたchunkやslice_before等のメソッドを使わずに実装するのは面倒なので、この手のメソッドが用意されているRubyは便利ですよね！</body>
<timestamp>1325912571</timestamp>
</comment>
</comments>
</day>
<day date="2012-01-09" title="">
<body>
*p1*新ソートアルゴリズム「配列挿入ソート」だ!

(追記:2012-1-10) id:m11m さんのコメントによりこのソートはバケットソート(([http://ja.wikipedia.org/wiki/%E3%83%90%E3%82%B1%E3%83%83%E3%83%88%E3%82%BD%E3%83%BC%E3%83%88:title=バケットソート - Wikipedia]))と呼ばれる既知のソートアルゴリズムであることがわかりました ^^;　追記によりお詫び申し上げます


(追記:2012-1-12) 記事に対するアクセスが異常なので調べてみると、dankogai氏のネタにされていたという名誉を受けていたことが判明しました^^; 光栄です
 [http://blog.livedoor.jp/dankogai/archives/51764496.html:title=404 Blog Not Found:algorithm - bucket sort - 比較しなければソートは相当速い]

------------------------------------
以前にスリープソートという
ソートアルゴリズムが発見されたよね


[http://d.hatena.ne.jp/gfx/20110519/1305810786:title=常識を覆すソートアルゴリズム！その名も&quot;sleep sort&quot;！ - Islands in the byte stream]


で僕はこれに対抗してランニングソート
っていうアルゴリズムを見つけたんだよ
まあ失敗したんだけど..


[http://d.hatena.ne.jp/keyesberry/20110628/p1:title=sleep sortに対抗してrunning sortだ！（Ruby版｜失敗に終わる編） - hp12c]


で今回また新たなソートアルゴリズムを発見したから
みんなに紹介するよ


その名も「配列挿入ソート」!


これはいわば挿入ソートの簡易版だよ


まずはRubyで挿入ソートを書いてみるよ
だいたいこんな感じになるよ
&gt;|ruby|
class Array
  def insert_sort
    inject([]) { |mem, var| mem.insert_with_order(var) }
  end

  def insert_with_order(item)
    pos = find_index { |n| item &lt;= n } || length
    insert(pos, item)
  end
end

require &quot;mathn&quot;

l = Prime.take(10).sort_by { rand } # =&gt; [7, 2, 3, 11, 17, 19, 29, 5, 23, 13]

l.insert_sort # =&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
||&lt;


これに対して配列挿入ソートはこうだよ
&gt;|ruby|
class Array
  def array_insert_sort
    inject([]) { |mem, var| mem[var] = var; mem }.compact
  end
end

require &quot;mathn&quot;

l = Prime.take(10).sort_by { rand } # =&gt; [7, 2, 3, 11, 17, 19, 29, 5, 23, 13]

l.array_insert_sort # =&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
||&lt;
なんてことはない
ただ要素を配列のインデックスに対応付けて
配置し直しただけだよ
この前投稿した[http://d.hatena.ne.jp/keyesberry/20120107/p1:title=Rubyで連続数字をハイフンでつなぐよ]
のときに気が付いたんだ


でちょっと改良すれば文字のソートにも対応できるんだよ
&gt;|ruby|
class Array
  def array_insert_sort
    inject([]) { |mem, var| mem[var.ord] = var; mem }.compact
  end
end

require &quot;mathn&quot;

l = Prime.take(10).sort_by { rand } # =&gt; [13, 3, 29, 5, 17, 2, 11, 7, 19, 23]
l.array_insert_sort # =&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

c = &quot;The quick brown fox jumps over the lazy dog&quot;.scan(/\w/) # =&gt; [&quot;T&quot;, &quot;h&quot;, &quot;e&quot;, &quot;q&quot;, &quot;u&quot;, &quot;i&quot;, &quot;c&quot;, &quot;k&quot;, &quot;b&quot;, &quot;r&quot;, &quot;o&quot;, &quot;w&quot;, &quot;n&quot;, &quot;f&quot;, &quot;o&quot;, &quot;x&quot;, &quot;j&quot;, &quot;u&quot;, &quot;m&quot;, &quot;p&quot;, &quot;s&quot;, &quot;o&quot;, &quot;v&quot;, &quot;e&quot;, &quot;r&quot;, &quot;t&quot;, &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;a&quot;, &quot;z&quot;, &quot;y&quot;, &quot;d&quot;, &quot;o&quot;, &quot;g&quot;]

c.array_insert_sort # =&gt; [&quot;T&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
||&lt;


まあ文字列と重複要素には使えないけどね..


念のため実行速度を見てみるね
比較対象はRuby標準のsort
挿入ソート　クイックソートだよ
クイックソートの実装は次の通りだよ
&gt;|ruby|
class Array
  def quick_sort
    return self if length &lt;= 1
    base = pop
    smaller, bigger = partition { |e| e &lt; base }
    push base
    smaller.quick_sort + [base] + bigger.quick_sort
  end
end
||&lt;


さあベンチマークを取るよ
&gt;|ruby|
require &quot;benchmark&quot;

Benchmark.bmbm do |bm|
  l = Prime.take(10000).sort_by { rand }
  bm.report { l.sort }
  bm.report { l.quick_sort }
  bm.report { l.insert_sort }
  bm.report { l.array_insert_sort }
end

# &gt;&gt; Rehearsal ------------------------------------
# &gt;&gt;    0.000000   0.000000   0.000000 (  0.002726)
# &gt;&gt;    0.050000   0.000000   0.050000 (  0.049841)
# &gt;&gt;    3.560000   0.000000   3.560000 (  3.565532)
# &gt;&gt;    0.010000   0.010000   0.020000 (  0.007513)
# &gt;&gt; --------------------------- total: 3.630000sec
# &gt;&gt; 
# &gt;&gt;        user     system      total        real
# &gt;&gt;    0.000000   0.000000   0.000000 (  0.002579)
# &gt;&gt;    0.050000   0.000000   0.050000 (  0.049816)
# &gt;&gt;    3.550000   0.000000   3.550000 (  3.561074)
# &gt;&gt;    0.010000   0.000000   0.010000 (  0.006725)
||&lt;
こりゃ素晴らしい!

</body>
<comments>
<comment>
<username>m11m</username>
<body>このアルゴリズムをバケットソート，あるいはビンソートと呼びます．</body>
<timestamp>1326168199</timestamp>
</comment>
<comment>
<username>keyesberry</username>
<body>&gt;m11mさん&lt;br&gt;コメントありがとうございます。既知のアルゴリズムだったとは無知を晒してしまいました。^^;情報ありがたいです。</body>
<timestamp>1326172267</timestamp>
</comment>
</comments>
</day>
<day date="2012-01-12" title="">
<body>
*p1*Rubyで富豪的プログラミングで８クイーンに挑戦そして玉砕
８クイーンというパズル問題があるよ


簡単に説明すると8x8のチェス盤があって
ここに飛車角の動きをする8つのクイーンを
互いが取り合わない位置に配置する問題だよ


[http://ja.wikipedia.org/wiki/%E3%82%A8%E3%82%A4%E3%83%88%E3%83%BB%E3%82%AF%E3%82%A4%E3%83%BC%E3%83%B3:title=エイト・クイーン - Wikipedia]


８クイーンの組合せは全部で92通りあるそうだよ
それでループとか再帰とか
バックトラックとか動的計画とかの
アルゴリズムの手法を駆使して
その解法をプログラミングするというのが
プログラマーたちの頭の体操になっているんだ
ちょっと検索すれば大量の模範解答が得られるよ


で　僕もRubyを使って
この問題を解いてみようと思うんだけど
どうもこの手のアルゴリズムが
僕は嫌いというか苦手みたいで
解法を試行錯誤したり
他の人の書いた模範解答を解読する気が
どうしても起きないんだよ
まあ僕の能力不足としか言いようがないんだけど..


それでも暫くその理由を考えてみたら
なんとなく原因が分かったんだよ
それはこの手の問題では
問と実装コードとの間に大きな隔たりがあるってことなんだ
つまり問と実装コードとの間には
「実装者の工夫の大きな塊」が存在していて
それが問と実装コードとの隔たりを大きくしてる
そう僕は感じるんだ


で　この「工夫の大きな塊」は
その実装者毎にまちまちで
結果実装コードはその実装者固有のものになっている
これは言い換えれば
８クイーン問題をうまく抽象化できていない
とも言えると思うんだけど


できれば僕は自分の働きをできるだけ小さくして
Rubyにもっともっと働いて欲しいと願ってるんだけど..


そんなわけで..


問と実装コードとの間の隔たりをできるだけ小さくした
抽象度の高い富豪的プログラミングで
エイトクイーンに挑戦してみたよ:)
まあ最初から玉砕するのは分かってるんだけどね..


ここではチェス盤のサイズとクイーンの数を
８に限定しない実装を試みるよ
クラス名をQueenSolverとして初期化時に
盤サイズとクイーン数を指定できるようにしよう
そしてsolveメソッドで解答の組合せを出力するよ
&gt;|ruby|
# queen_solver.rb
class QueenSolver
  def initialize(nth=8, queens=8)
    @nth = nth
    @queens = queens
  end
  
  def solve

  end
end

QueenSolver.new.solve # =&gt; 
||&lt;


さてsolveの中身なんだけど
ここでは富豪的アプローチでいくから
すべての可能な配置の組み合わせを用意して
そこから条件を満たさないつまり
一対でも衝突のあるクイーンのある組を取り除くことで
有効な組み合わせを見つけ出すよ


だからsolveメソッドの中身は
こんな感じになるよ
&gt;|ruby|
class QueenSolver

  def solve
    all_combinations.reject do |pattern|
      pattern.combination(2).any? { |a, b| conflict?(a, b) }
    end
  end
end
||&lt;


all_combinationsですべての組合せを作って
そこからrejectで不適合なパターンの組を除くんだ
rejectのブロックではそのパターン中のクイーン相互の衝突を見て
その一つでも衝突があったらそのパターンを除外するよ
そのためにcombinationしてるよ


で　あとはsolveの補助関数としての
all_combinationsとconflict?を定義すればいいよ
まずはall_combinationsから


ここでちょっと
盤サイズ3x3　クイーン数2の簡単な例を考えてみるよ
盤の座標は次の9つになるよね
&gt;|ruby|
 [[0,0],[0,1],[0,2],
  [1,0],[1,1],[1,2],
  [2,0],[2,1],[2,2]]
||&lt;

この盤における2つのクイーンの配置の組合せは
9C2となって36通りあるよ
&gt;&gt;
9C2 = 9! / 2(9-2)! = 36
&lt;&lt;


この考えに従ってall_combinationsをRubyで表現すると
次のようになるんだ
&gt;|ruby|
class QueenSolver

  def all_combinations
    board_coordinates.combination(@queens)
  end
end
||&lt;


で盤の座標board_coordinatesは
repeated_permutationを使って次のように書けるよ
&gt;|ruby|
class QueenSolver

  def all_combinations
    board_coordinates.combination(@queens)
  end

  def board_coordinates
    [*0..@nth-1].repeated_permutation(2).to_a
  end
end

qs = QueenSolver.new(3,2)
qs.board_coordinates # =&gt; [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]
qs.all_combinations.to_a # =&gt; [[[0, 0], [0, 1]], [[0, 0], [0, 2]], [[0, 0], [1, 0]], [[0, 0], [1, 1]], [[0, 0], [1, 2]], [[0, 0], [2, 0]], [[0, 0], [2, 1]], [[0, 0], [2, 2]], [[0, 1], [0, 2]], [[0, 1], [1, 0]], [[0, 1], [1, 1]], [[0, 1], [1, 2]], [[0, 1], [2, 0]], [[0, 1], [2, 1]], [[0, 1], [2, 2]], [[0, 2], [1, 0]], [[0, 2], [1, 1]], [[0, 2], [1, 2]], [[0, 2], [2, 0]], [[0, 2], [2, 1]], [[0, 2], [2, 2]], [[1, 0], [1, 1]], [[1, 0], [1, 2]], [[1, 0], [2, 0]], [[1, 0], [2, 1]], [[1, 0], [2, 2]], [[1, 1], [1, 2]], [[1, 1], [2, 0]], [[1, 1], [2, 1]], [[1, 1], [2, 2]], [[1, 2], [2, 0]], [[1, 2], [2, 1]], [[1, 2], [2, 2]], [[2, 0], [2, 1]], [[2, 0], [2, 2]], [[2, 1], [2, 2]]]
||&lt;


次にconflict?を定義しよう
クイーンは飛車角の動きをするから
縦　横　斜めの何れかでの衝突をもって
適合の判定をするよ
&gt;|ruby|
class QueenSolver

  def conflict?(a, b)
    conflict_x?(a, b) || conflict_y?(a, b) || conflict_cross?(a, b)
  end
end
||&lt;


conflict_x?とconflict_y?は
クイーンのxまたはy座標を比較すればいいから簡単だね
conflict_cross?の判定にはちょっと工夫がいるけど
それはx-y座標の和と差を比較することで判定できるんだよ
だからこれらのコードは次のようになるよ
&gt;|ruby|
class QueenSolver

  def conflict_x?(a, b)
    a[0] == b[0]
  end

  def conflict_y?(a, b)
    a[1] == b[1]
  end

  def conflict_cross?(a, b)
    a.inject(:-) == b.inject(:-) || a.inject(:+) == b.inject(:+)
  end
end
||&lt;


さあこれでQueenSolverの完成だよ
コードを再掲するよ


&lt;script src=&quot;https://gist.github.com/1597459.js?file=queen_solver.rb&quot;&gt;&lt;/script&gt;


さてちゃんと動作するかテストするよ
Wikipediaによれば2クイーンと3クイーンには解がなくて
4には2つ　5には10　6には4つの解があるそうだよ


&lt;script src=&quot;https://gist.github.com/1597459.js?file=queen_solver_spec.rb&quot;&gt;&lt;/script&gt;


まずは2x2から4x4のテスト
&gt;|ruby|
% rspec queen_solver_spec.rb -c -fd -l5
Run filtered including {:line_number=&gt;5}

QueenSolver
  solve 2x2 to 4x4
    solve 2x2
    solve 3x2
    solve 3x3
    solve 4x4
Finished in 0.02028 seconds
4 examples, 0 failures
||&lt;

うまくいってるね!


次は5x5
&gt;|ruby|
% rspec queen_solver_spec.rb -c -fd -l31
Run filtered including {:line_number=&gt;31}

QueenSolver  solve 5x5
Finished in 0.37836 seconds
1 example, 0 failures
||&lt;

これもパスした


次は6x6
&gt;|ruby|
% rspec queen_solver_spec.rb -c -fd -l35
Run filtered including {:line_number=&gt;35}

QueenSolver  solve 6x6
Finished in 15.05 seconds
1 example, 0 failures
||&lt;

これもOKだよ
ただ実行時間が15秒と結構掛かってるね..


さあ
いよいよエイトクイーン8x8をテストするよ
&gt;|ruby|
% rspec queen_solver_spec.rb -c -fd -l39
Run filtered including {:line_number=&gt;39}

QueenSolver

.....
||&lt;

やっぱり帰ってこない!


8x8におけるall_combinationsの数は
64C8だから..
&gt;|ruby|
64C8 = 64! / 8!(64-8)! = 4426165368
||&lt;
44億パターン!


あと3年くらい経ったらこれくらいの計算は
Rubyでもさっと解けるようになるのかな..

</body>
</day>
<day date="2012-01-13" title="">
<body>
*p1*10のチェスクイズでRubyの配列組み換えメソッドを覚えよう! - 10 Chess Quizzes to know Recombination Methods of Ruby Array

Rubyには与えられた配列を別の配列のかたちに
組み換えるようなメソッドがいくつかあるよ
それらはすごく便利だけど
リファレンスでは別々に説明されてるから
まとまった知識としてはちょっと記憶しづらいよね


1つのテーマに沿って
それらのメソッドが解説されていたら
もう少し理解が進む気がするんだ


そんなわけで..


3x3のミニチェスボードをテーマとして
Rubyの配列メソッドを使って簡単に解ける
チェスクイズを10問作ってみたよ


最初に問題をまとめて書いて
解答例は下の方に置くから
時間のある人は解答例を見ないで
挑戦してみてね:)


さあ始めるよ

**----------------------------- 問   題 -----------------------------
**Q1. [0, 1, 2]の配列を基に、座標[0, 0]から始まる3x3のチェスボードの座標リストboardを作りなさい
&gt;|ruby|
出力例: board # =&gt; [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]
||&lt;


**Q2. 今度は[:a, :b, :c]と[1, 2, 3]の配列を基に、x座標が:a、y座標が1から始まる3x3のチェスボードの座標リストexcel_boardを作りなさい
&gt;|ruby|
出力例: excel_board # =&gt; [[:a, 1], [:a, 2], [:a, 3], [:b, 1], [:b, 2], [:b, 3], [:c, 1], [:c, 2], [:c, 3]]
||&lt;


**Q3. Q1のboardを基に、その列ごとに分けられた座標リストboard_by_colを作りなさい
&gt;|ruby|
出力例: board_by_col # =&gt; [[[0, 0], [0, 1], [0, 2]], [[1, 0], [1, 1], [1, 2]], [[2, 0], [2, 1], [2, 2]]]
||&lt;


**Q4. Q1のboardを基に、その行ごとに分けられた座標リストboard_by_rowを作りなさい
&gt;|ruby|
出力例: board_by_row # =&gt; [[[0, 0], [1, 0], [2, 0]], [[0, 1], [1, 1], [2, 1]], [[0, 2], [1, 2], [2, 2]]]
||&lt;


**Q5. 今度はQ3のboard_by_colを基にboard_by_rowを作りなさい


**Q6. Q3のboard_by_colを基に、その各列を一旦3つの変数col1, col2, col3に格納し、それらを使ってboard_by_rowを作りなさい
&gt;|ruby|
出力例: 
col1 # =&gt; [[0, 0], [0, 1], [0, 2]]
col2 # =&gt; [[1, 0], [1, 1], [1, 2]]
col3 # =&gt; [[2, 0], [2, 1], [2, 2]]
board_by_row # =&gt; [[[0, 0], [1, 0], [2, 0]], [[0, 1], [1, 1], [2, 1]], [[0, 2], [1, 2], [2, 2]]]
||&lt;


**Q7. Q1のboard上に2つのコマを配置するすべての組合せの座標リストpiece_combinationsを作りなさい
&gt;|ruby|
出力例: piece_combinations # =&gt; [[[0, 0], [0, 1]], [[0, 0], [0, 2]], [[0, 0], [1, 0]], [[0, 0], [1, 1]], [[0, 0], [1, 2]], [[0, 0], [2, 0]], [[0, 0], [2, 1]], [[0, 0], [2, 2]], [[0, 1], [0, 2]], [[0, 1], [1, 0]], [[0, 1], [1, 1]], [[0, 1], [1, 2]], [[0, 1], [2, 0]], [[0, 1], [2, 1]], [[0, 1], [2, 2]], [[0, 2], [1, 0]], [[0, 2], [1, 1]], [[0, 2], [1, 2]], [[0, 2], [2, 0]], [[0, 2], [2, 1]], [[0, 2], [2, 2]], [[1, 0], [1, 1]], [[1, 0], [1, 2]], [[1, 0], [2, 0]], [[1, 0], [2, 1]], [[1, 0], [2, 2]], [[1, 1], [1, 2]], [[1, 1], [2, 0]], [[1, 1], [2, 1]], [[1, 1], [2, 2]], [[1, 2], [2, 0]], [[1, 2], [2, 1]], [[1, 2], [2, 2]], [[2, 0], [2, 1]], [[2, 0], [2, 2]], [[2, 1], [2, 2]]]
||&lt;


**Q8. 盤上の3つのコマ:rook, :bishop, :queenから2つを順番に取るとき、その取り方の組合せリストcapturesを作りなさい
&gt;|ruby|
出力例: captures # =&gt; [[:rook, :bishop], [:rook, :queen], [:bishop, :rook], [:bishop, :queen], [:queen, :rook], [:queen, :bishop]]
||&lt;


**Q9. Q8のcapturesを基に、:bishopを含む組合せのリストbishopsと、:bishopを含まない組合せのリストremainsを作りなさい
&gt;|ruby|
出力例:
bishops # =&gt; [[:rook, :bishop], [:bishop, :rook], [:bishop, :queen], [:queen, :bishop]]
remains # =&gt; [[:rook, :queen], [:queen, :rook]]
||&lt;


**Q10. 盤上の3つのコマ:rook, :bishop, :queenの何れかを移動させる機会が2回があるとき、動かすコマの組合せリストmovesを作りなさい
&gt;|ruby|
出力例: moves # =&gt; [[:rook, :rook], [:rook, :bishop], [:rook, :queen], [:bishop, :bishop], [:bishop, :queen], [:queen, :queen]]
||&lt;


以上で問題は終わりだよ


下に配列の組み換えメソッド群を使った
解答例を書くよ










**----------------------------- 解 答 例 -----------------------------
**Q1. [0, 1, 2]の配列を基に、座標[0, 0]から始まる3x3のチェスボードの座標リストboardを作りなさい
**A1. Array#repeated_permutationを使う
&gt;|ruby|
  board = [0, 1, 2].repeated_permutation(2).to_a # =&gt; [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]
||&lt;
遠い昔に数学の順列・組合せで3P2とか6C2とか習ったと思うけど、permutationというのはそのP、つまり順列のことだよ。3P2は3個のものから2個を取るときに、その順序も意味を持つ取り方の組合せになるよ。でrepeated_はさらに同じものを繰り返しとることを許す組合せなんだ。repeated_permutation自体はEnumeratorを返すから最後にto_aして配列化するよ。


**Q2. 今度は[:a, :b, :c]と[1, 2, 3]の配列を基に、x座標が:a、y座標が1から始まる3x3のチェスボードの座標リストexcel_boardを作りなさい
**A2. Array#productを使う
&gt;|ruby|
  [:a, :b, :c].product([1, 2, 3]) # =&gt; [[:a, 1], [:a, 2], [:a, 3], [:b, 1], [:b, 2], [:b, 3], [:c, 1], [:c, 2], [:c, 3]]
||&lt;
Array#productは集合同士の掛け算をするよ。こういうのをデカルト積(cartesian product)というらしいよ。productは2以上の配列を引数に取れるから、それで3以上の配列のデカルト積を作ることができるよ。ちなみにQ1はこのproductを使っても求めることができるよね([0,1,2].product([0,1,2]))。repeated_permutationと異なって、productは配列を返すよ。


**Q3. Q1のboardを基に、その列ごとに分けられた座標リストboard_by_colを作りなさい
**A3. Enumerable#group_byを使う
&gt;|ruby|
  board_by_col = board.group_by(&amp;:first).values # =&gt; [[[0, 0], [0, 1], [0, 2]], [[1, 0], [1, 1], [1, 2]], [[2, 0], [2, 1], [2, 2]]]
||&lt;
任意の集合をブロックに与えた条件(ここでは&amp;:first)で分けるときはEnumerable#group_byが便利だよ。group_byの返り値は条件をキー、その該当グループを値とするHashになるから、最後にvaluesで値だけ取ってるよ。このメソッドは例えば、単語リストをその語長別に整理するような場合に重宝するんだ。


**Q4. Q1のboardを基に、その行ごとに分けられた座標リストboard_by_rowを作りなさい
**A4. Enumerable#group_byを使う
&gt;|ruby|
  board_by_row = board.group_by(&amp;:last).values # =&gt; [[[0, 0], [1, 0], [2, 0]], [[0, 1], [1, 1], [2, 1]], [[0, 2], [1, 2], [2, 2]]]
||&lt;


**Q5. 今度はQ3のboard_by_colを基にboard_by_rowを作りなさい
**A5. Array#transposeを使う
&gt;|ruby|
  board_by_row = board_by_col.transpose # =&gt; [[[0, 0], [1, 0], [2, 0]], [[0, 1], [1, 1], [2, 1]], [[0, 2], [1, 2], [2, 2]]]
||&lt;
Array#transposeはまさに行と列を入れ換えるためのメソッドだよ。こういうのを行列の転置というそうだよ。


**Q6. Q3のboard_by_colを基に、その各列を一旦3つの変数col1, col2, col3に格納し、それらを使ってboard_by_rowを作りなさい
**A6. Array#zipを使う
&gt;|ruby|
  col1, col2, col3 = board_by_col
  col1 # =&gt; [[0, 0], [0, 1], [0, 2]]
  col2 # =&gt; [[1, 0], [1, 1], [1, 2]]
  col3 # =&gt; [[2, 0], [2, 1], [2, 2]]
  col1.zip(col2, col3) # =&gt; [[[0, 0], [1, 0], [2, 0]], [[0, 1], [1, 1], [2, 1]], [[0, 2], [1, 2], 
||&lt;
transposeの親戚がArray#zipだよ。zipはジップロックのように複数の配列を1つにまとめるんだけど、Rubyのzipはただまとめるだけじゃなく、transposeと同じように縦方向にまとめるんだよ。あっ、ジッパーを上から下に閉めるようだからzipなのか!


**Q7. Q1のboard上に2つのコマを配置するすべての組合せの座標リストpiece_combinationsを作りなさい
**A7. Array#combinationを使う
&gt;|ruby|
  piece_combinations = board.combination(2).to_a # =&gt; [[[0, 0], [0, 1]], [[0, 0], [0, 2]], [[0, 0], [1, 0]], [[0, 0], [1, 1]], [[0, 0], [1, 2]], [[0, 0], [2, 0]], [[0, 0], [2, 1]], [[0, 0], [2, 2]], [[0, 1], [0, 2]], [[0, 1], [1, 0]], [[0, 1], [1, 1]], [[0, 1], [1, 2]], [[0, 1], [2, 0]], [[0, 1], [2, 1]], [[0, 1], [2, 2]], [[0, 2], [1, 0]], [[0, 2], [1, 1]], [[0, 2], [1, 2]], [[0, 2], [2, 0]], [[0, 2], [2, 1]], [[0, 2], [2, 2]], [[1, 0], [1, 1]], [[1, 0], [1, 2]], [[1, 0], [2, 0]], [[1, 0], [2, 1]], [[1, 0], [2, 2]], [[1, 1], [1, 2]], [[1, 1], [2, 0]], [[1, 1], [2, 1]], [[1, 1], [2, 2]], [[1, 2], [2, 0]], [[1, 2], [2, 1]], [[1, 2], [2, 2]], [[2, 0], [2, 1]], [[2, 0], [2, 2]], [[2, 1], [2, 2]]]
||&lt;
順列・組合せの組合せを実現するメソッドがArray#combinationだよ。つまりQ7は9C2を聞いていて、その組み合わせ数は9!/2!(9-2)! = 36通りになるよね。


**Q8. 盤上の3つのコマ:rook, :bishop, :queenから2つを順番に取るとき、その取り方の組合せリストcapturesを作りなさい
**A8. Array#permutationを使う
&gt;|ruby|
  captures = [:rook, :bishop, :queen].permutation(2).to_a # =&gt; [[:rook, :bishop], [:rook, :queen], [:bishop, :rook], [:bishop, :queen], [:queen, :rook], [:queen, :bishop]]
||&lt;
コマの取り方の順番にも意味があるから、これは順列の問題だよ。3P2 = 3!/(3-2)!で6通りの組合せができるよ。


**Q9. Q8のcapturesを基に、:bishopを含む組合せのリストbishopsと、:bishopを含まない組合せのリストremainsを作りなさい
**A9. Enumerable#partitionを使う
&gt;|ruby|
  bishops, remains = captures.partition { |pieces| pieces.include? :bishop }
  bishops # =&gt; [[:rook, :bishop], [:bishop, :rook], [:bishop, :queen], [:queen, :bishop]]
  remains # =&gt; [[:rook, :queen], [:queen, :rook]]
||&lt;
配列をきっちり2つのグループに分けるときはEnumerable#partitionが使えるよ。配列の配列が返るから、これを多重代入で受ければいいんだ。もちろん先のEnumerable#group_byも使えるけど、ちょっと手数が増えるかな。


**Q10. 盤上の3つのコマ:rook, :bishop, :queenの何れかを移動させる機会が2回があるとき、動かすコマの組合せリストmovesを作りなさい
**A10. Array#repeated_combinationを使う
&gt;|ruby|
  [:rook, :bishop, :queen].repeated_combination(2).to_a # =&gt; [[:rook, :rook], [:rook, :bishop], [:rook, :queen], [:bishop, :bishop], [:bishop, :queen], [:queen, :queen]]
||&lt;
同じコマを2度動かすこともあるから、combinationじゃなくrepeated_combinationを使うよ。


ここで出てきたメソッドは次のとおりだよ
&gt;|
Array:
  combination, repeated_combination, permutation,
  repeated_permutation, product, transpose, zip

Enumerable:
  group_by, partition
|&lt;


これらのメソッドが使えなければ
上の問題を解くのは結構厄介だと思うよ
頭の体操としてはやりがいがあるかも知れないけど..
(挑戦者待ってます..)


(追記:2012-1-15)解答に解説を追加しました。

&lt;script src=&quot;https://gist.github.com/1613681.js?file=array_recombinations.rb&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2012-01-18" title="">
<body>
*p1*10のチェスクイズをRubyの配列組み換えメソッドを使わないで解いたよ
Rubyの配列組み換えメソッド群の使い方を覚えるために
前回10のチェスクイズを考えたよ


[http://d.hatena.ne.jp/keyesberry/20120113/p1:title=10のチェスクイズでRubyの配列組み換えメソッドを覚えよう! - 10 Chess Quizzes to know Recombination Methods of Ruby Array - hp12c]


Array#permutationとかcombinationとかの
組み換えメソッド群を使えば
このクイズは簡単に解けるけど
これらのメソッドの使用を禁止したら
解くのは結構厄介かなと思ったんだけど
やってみたら簡単だったんで
拍子抜けしちゃったよ^^;


一応結果だけここに貼っておくね..


&lt;script src=&quot;https://gist.github.com/1613681.js?file=another_answers_without_array_recombinations.rb&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2012-01-21" title="">
<body>
*p1*あなたのプログラムを使って宇宙人の種族を答えよ!
図書館で「数学の秘密の本棚」という
数学パズルやエピソードなどを集めた本を借りたよ


[asin:4797356014:detail]


その一番最初に「宇宙人との遭遇」という
論理パズル問題が出ていたんだ


要約すると次のようなものだよ
&gt;&gt;

ある惑星に着いた宇宙船の船長クワークの前に
３人の宇宙人が現れた
その惑星には嘘つきのギバリッシュという種族と
正直なベラシータという種族がいる


彼らの名前をアルフィ　ベティ　ゲンマとして
クワーク船長がそれぞれにその種族について聞くと
彼らは以下のように答えた


+アルフィ「ベティはギバリッシュだよ」
+ベティ「アルフィとゲンマは同じ種族だよ」
+ゲンマ「ベティはベラシータだよ」


これらの答えだけでクワーク船長は
それぞれの種族が分かったという
さて彼らの種族は？
&lt;&lt;


可能性のある組合せが８組しか無いから
ちょっと考えれば答えが出るんだけど
それじゃつまらないよね..


そんなわけで..


この問題をみんなでプログラムで解いてみようよ!


宇宙人の名前は Alfy Betty Gemma
種族は Veracitor Gibberish だよ
答えが出たらこのブログに
「◯◯を使って宇宙人の種族を答えたよ!」とかのタイトルで
トラックバックしてくれるとうれしいよ


僕の要約じゃ問に不安がある人は
先のアマゾンのリンクを辿ってほしい
この問題は最初の問題で運のいいことに
なか見検索で読めるんだよ!


僕はもちろんRubyで解いてるよ


[https://gist.github.com/1652697:title=僕の答え ― Gist]


</body>
</day>
<day date="2012-01-22" title="">
<body>
*p1*RubyでPrime Palindromeを解く -CodeEval
id:rochefortさんに倣って[http://www.codeeval.com/:title=CodeEval]の
prime Palindrome問題を解いてみました
僕はEnumeratorを使って


回文の素数で１０００以下で最大のものを出力

&lt;script src=&quot;https://gist.github.com/1656338.js?file=prime_palindrome.rb&quot;&gt;&lt;/script&gt;


僕もCodeEvalって登録してみようかな
</body>
</day>
<day date="2012-01-24" title="">
<body>
*p1*RubyでSum of Primesを解く-CodeEval

これもEnumeratorを使って


最初の1000個の素数の合計


&lt;script src=&quot;https://gist.github.com/1656338.js?file=sum_prime.rb&quot;&gt;&lt;/script&gt;


id:rochefortさんのを見たら
&gt;|ruby|
def prime?(n)
  !(2..n/2).any? { |i| (n%i).zero? }
end
||&lt;
となっていてなるほどー!


*p2*RubyでFizz Buzzを解く -CodeEval
CodeEvalに登録したのでやって見たよ
Proc#curryを使って


与えられた整数でFizzBuzz


&lt;script src=&quot;https://gist.github.com/1656338.js?file=fizz_buzz.rb&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2012-01-25" title="">
<body>
*p10*RubyでSelf Describing Numbersを解く -CodeEval
String#countを使って


各桁の数字がその桁の出現回数を表すとき
自己表現数(self describing number)という
&lt;script src=&quot;https://gist.github.com/1656338.js?file=self_describing_numbers.rb&quot;&gt;&lt;/script&gt;

*p11*RubyでHappy Numbersを解く -CodeEval
再帰を使って


各桁の二乗を足し続けて1になればHappy
&lt;script src=&quot;https://gist.github.com/1656338.js?file=happy_numbers.rb&quot;&gt;&lt;/script&gt;


*p12*RubyでRightmost Charを解く -CodeEval
String#rindexで


文字列中の指定文字の位置(最右)
&lt;script src=&quot;https://gist.github.com/1656338.js?file=rightmost.rb&quot;&gt;&lt;/script&gt;


*p13*RubyでSet Intersectionを解く -CodeEval
Array#&amp;で


左右の数字列の重複
&lt;script src=&quot;https://gist.github.com/1656338.js?file=intersection.rb&quot;&gt;&lt;/script&gt;

*p14*RubyでUnique Elementsを解く -CodeEval
Array#uniqで


重複数字を除去
&lt;script src=&quot;https://gist.github.com/1656338.js?file=dupes.rb&quot;&gt;&lt;/script&gt;


*p15*RubyでFile Sizeを解く -CodeEval
File.sizeで


ファイルサイズ
&lt;script src=&quot;https://gist.github.com/1656338.js?file=filesize.rb&quot;&gt;&lt;/script&gt;


*p16*RubyでOdd Numbersを解く -CodeEval
Enumerable#selectで


1から99の中の奇数
&lt;script src=&quot;https://gist.github.com/1656338.js?file=oddnums.rb&quot;&gt;&lt;/script&gt;


*p5*RubyでSum of Integers from Fileを解く -CodeEval
Enumerable#injectを使って


各行の数字の合計
&lt;script src=&quot;https://gist.github.com/1656338.js?file=sumint.rb&quot;&gt;&lt;/script&gt;


*p6*RubyでMultiplication Tablesを解く -CodeEval
printfで揃える


九九のテーブルを作る
&lt;script src=&quot;https://gist.github.com/1656338.js?file=tables.rb&quot;&gt;&lt;/script&gt;


*p7*RubyでFibonacci Seriesを解く -CodeEval
メモ化を使って


n番目のフィボナッチ数
&lt;script src=&quot;https://gist.github.com/1656338.js?file=fibonacci.rb&quot;&gt;&lt;/script&gt;


(追記:2012-2-2)
id:rochefortさんによるメモ化
&gt;|ruby|
def fib(n)
  @cache ||= []
  @cache[n] ||= (n&lt;2)? n : fib(n-2) + fib(n-1);
end
||&lt;
[http://d.hatena.ne.jp/rochefort/20120202/p1:title=Fibonacci Series - うんたらかんたら日記]
なるほどこちらのほうが見やすいです


でこれにならって修正版
&gt;|ruby|
@mem = { -2 =&gt; -1, -1 =&gt; 1 }
fib = -&gt;n { @mem[n] ||= fib[n-1] + fib[n-2] }
||&lt;

*p8*RubyでSum of Digitsを解く -CodeEval

各桁の合計
&lt;script src=&quot;https://gist.github.com/1656338.js?file=sum_digits.rb&quot;&gt;&lt;/script&gt;


*p9*RubyでLowercaseを解く -CodeEval
String#downcaseで


全部小文字化
&lt;script src=&quot;https://gist.github.com/1656338.js?file=lowercase.rb&quot;&gt;&lt;/script&gt;


*p4*RubyでBit Positionsを解く -CodeEval
Integer#to_s(2)で


1つ目の数字のビットにおける2つの位置の一致を見る
&lt;script src=&quot;https://gist.github.com/1656338.js?file=position.rb&quot;&gt;&lt;/script&gt;


*p3*RubyでMultiples of a Numberを解く -CodeEval
またまたEnumeratorを使って


1つ目の数字より大きい2つ目の数字の最小の倍数
&lt;script src=&quot;https://gist.github.com/1656338.js?file=multiples.rb&quot;&gt;&lt;/script&gt;

*p2*RubyでReverse wordsを解く -CodeEval
ふつうにArray#reverseを使って


単語の語順を入れ換える
&lt;script src=&quot;https://gist.github.com/1656338.js?file=reverse_words.rb&quot;&gt;&lt;/script&gt;


*p1*Rubyで実働時間を測って顧客にタイムチャージしよう!
仕事の生産性を上げるためには時間管理は重要です
きちっとした時間管理ができてこそ
プロフェッショナルと言えるでしょう
欧米の弁護士の報酬は多くはタイムチャージとなっていて
彼らは案件ごとの実働時間をカウントして
それに自分の単価を掛けて顧客に請求します


やっぱり
プロフェッショナルのやることは違いますね^^;


したがってあなたが
プロフェッショナルと認められるようになるためには
たとえあなたの報酬がその労働時間に依存していなくとも
案件ごとに使った時間をきっちりと数えて
あなたの報酬額と実働時間の関係を
常日頃から意識することが重要です..


そんなわけで..


私もプロフェッショナルを目指して
今日から実働時間を計測したいと思います:)


実働時間の計測には次のステップが必要です
+案件ごとの開始・終了時間を毎日記録する
+案件ごとに時間を集計する


**案件ごとの開始・終了時間を毎日記録する
案件に対する実働時間というのは
一日のうちでも小間切れになるので
これを記録するのはなかなか面倒です
よって時間の記録をできるだけ
簡単に行えるようにする必要があります


そうなるとやっぱりテキストファイルに
単純なフォーマットで記録するのがいいです
例えばこんな感じで
&gt;|
&lt;案件名&gt;
  &lt;開始日時&gt; - &lt;終了日時&gt;
  &lt;開始日時&gt; - &lt;終了日時&gt;
  &lt;開始日時&gt; - &lt;終了日時&gt;
  &lt;開始日時&gt; - &lt;終了日時&gt;

&lt;案件名&gt;
  &lt;開始日時&gt; - &lt;終了日時&gt;
  &lt;開始日時&gt; - &lt;終了日時&gt;
  &lt;開始日時&gt; - &lt;終了日時&gt;
  &lt;開始日時&gt; - &lt;終了日時&gt;
|&lt;


日時の入力は面倒ですが
私はVimを使うので.vimrcに
以下を追加して省力化します

&gt;|bash|
&quot; insert timestamp
map &lt;D-F2&gt; &lt;ESC&gt;:r !date&lt;CR&gt;
||&lt;
これでcmd+F2で日時が打てるようになります


こんなイメージです
&gt;|
AA123
  Sat Jan 21 08:57:36 JST 2012 - Sat Jan 21 12:00:00 JST 2012
  Sat Jan 21 14:24:14 JST 2012 - Sat Jan 21 15:10:17 JST 2012
  Sun Jan 22 07:33:36 JST 2012 - Sun Jan 22 10:47:47 JST 2012
  Sun Jan 22 14:22:24 JST 2012 - Sun Jan 22 18:39:39 JST 2012
  Tue Jan 24 10:13:54 JST 2012 - Tue Jan 24 12:07:55 JST 2012
  Tue Jan 24 13:08:44 JST 2012 - Tue Jan 24 15:19:13 JST 2012
  Tue Jan 24 16:38:05 JST 2012 - Tue Jan 24 18:15:15 JST 2012

Project-XYZ
  Sat Feb 11 08:57:36 JST 2012 - Sat Feb 11 11:00:00 JST 2012
  Sat Feb 11 18:11:36 JST 2012 - Sat Feb 11 19:00:00 JST 2012
  Sun Feb 12 08:33:36 JST 2012 - Sun Feb 12 10:47:47 JST 2012
  Sat Feb 13 12:44:14 JST 2012 - Sat Feb 13 18:30:17 JST 2012
  Sat Feb 13 22:24:24 JST 2012 - Sat Feb 14 01:50:07 JST 2012
|&lt;


**案件ごとに時間を集計する
さあ仕事が終わったら上のファイルを
Rubyに読み込ませて集計しましょう


次のような出力が見やすくていいですね
&gt;|text|
AA123:
&amp;#160;&amp;#160;&amp;#160;2012-01-21: 02:48
&amp;#160;&amp;#160;&amp;#160;2012-01-22: 03:31
&amp;#160;&amp;#160;&amp;#160;2012-01-24: 06:41
&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;Total: 13:01
--------------------
Project-XYZ:
&amp;#160;&amp;#160;&amp;#160;2012-01-21: 02:02
&amp;#160;&amp;#160;&amp;#160;2012-01-22: 02:14
&amp;#160;&amp;#160;&amp;#160;2012-01-23: 03:46
&amp;#160;&amp;#160;&amp;#160;2012-01-24: 02:54
&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;Total: 10:56
--------------------
||&lt;


次のような方針にしましょう
+ファイルを案件ごとに分ける
+日時のラインをパースして日にちごとの時間に集計する
+フォーマットを用意して集計データを出力する


**ファイルを案件ごとに分ける
split_by_projectメソッドを定義します

&gt;|ruby|
def split_by_project(lines, time_pattern=/JST/)
  lines.map(&amp;:chomp)
       .reject(&amp;:empty?)
       .chunk { |line| !line.match(time_pattern) }
       .each_slice(2)
       .map { |(_,names), (_,timelines)|  [names.last, timelines] }
end
||&lt;
このメソッドは
読み込んだファイルの各行に対し
改行を除去し(chomp)
空行を除去し(empty?)
日時の行の前後で行分割し(chunk)
案件名と日時行をセットとし(each_slice(2))
最後に
案件名と日時行の配列を返します(map)


chunkでは日時行を識別するために
/JST/をパターンとしていますが
第２引数に任意のパターンを取ることができます


出力は次のようになります
&gt;|ruby|
split_by_project(ARGF) # =&gt; [[&quot;AA123&quot;, [&quot; Sat Jan 21 08:57:36 JST 2012 - Sat Jan 21 12:00:00 JST 2012&quot;, &quot; Sat Jan 21 14:24:14 JST 2012 - Sat Jan 21 15:10:17 JST 2012&quot;, &quot; Sun Jan 22 07:33:36 JST 2012 - Sun Jan 22 10:47:47 JST 2012&quot;, &quot; Sun Jan 22 14:22:24 JST 2012 - Sun Jan 22 18:39:39 JST 2012&quot;, &quot; Tue Jan 24 10:13:54 JST 2012 - Tue Jan 24 12:07:55 JST 2012&quot;, &quot; Tue Jan 24 13:08:44 JST 2012 - Tue Jan 24 15:19:13 JST 2012&quot;, &quot; Tue Jan 24 16:38:05 JST 2012 - Tue Jan 24 18:15:15 JST 2012&quot;]], [&quot;Project-XYZ&quot;, [&quot; Sat Feb 11 08:57:36 JST 2012 - Sat Feb 11 11:00:00 JST 2012&quot;, &quot; Sat Feb 11 18:11:36 JST 2012 - Sat Feb 11 19:00:00 JST 2012&quot;, &quot; Sun Feb 12 08:33:36 JST 2012 - Sun Feb 12 10:47:47 JST 2012&quot;, &quot; Sat Feb 13 12:44:14 JST 2012 - Sat Feb 13 18:30:17 JST 2012&quot;, &quot; Sat Feb 13 22:24:24 JST 2012 - Sat Feb 14 01:50:07 JST 2012&quot;]]]
||&lt;


**日時のラインをパースして日にちごとの時間に集計する
次にparse_and_arrange_timelinesメソッドを定義します
&gt;|ruby|
require 'date'

def parse_and_arrange_timelines(timelines, spliters=%w(- =&gt;))
  timelines.map { |line|
           from, to = line.split(/\s*#{spliters.join('|')}\s*/)
                          .map { |str| DateTime.parse str }
           [from.to_date.to_s, to-from]
  }.inject(Hash.new(0)) { |h, (date, lap)| h[date] += lap; h }
end
||&lt;
このメソッドは
split_by_projectで生成された日時行を
開始日時と終了日時に分けて(split)
DateTimeオブジェクトに変換し(DateTime.parse)
日付のラベルと経過時間の配列とし(map)
さらに
日付ごとの経過時間に集計します(inject)


ここでは規定のspliterを'-', '=&gt;'としていますが
第２引数に任意のspliterを取ることができます


出力は次のようになります
&gt;|ruby|
timelines = split_by_project(DATA)[0][1] # =&gt; [&quot;  Sat Jan 21 08:57:36 JST 2012 - Sat Jan 21 12:00:00 JST 2012&quot;, &quot;  Sat Jan 21 14:24:14 JST 2012 - Sat Jan 21 15:10:17 JST 2012&quot;, &quot;  Sun Jan 22 07:33:36 JST 2012 - Sun Jan 22 10:47:47 JST 2012&quot;, &quot;  Sun Jan 22 14:22:24 JST 2012 - Sun Jan 22 18:39:39 JST 2012&quot;, &quot;  Tue Jan 24 10:13:54 JST 2012 - Tue Jan 24 12:07:55 JST 2012&quot;, &quot;  Tue Jan 24 13:08:44 JST 2012 - Tue Jan 24 15:19:13 JST 2012&quot;, &quot;  Tue Jan 24 16:38:05 JST 2012 - Tue Jan 24 18:15:15 JST 2012&quot;]

parse_and_arrange_timelines(timelines) # =&gt; {&quot;2012-01-21&quot;=&gt;(1523/9600), &quot;2012-01-22&quot;=&gt;(13543/43200), &quot;2012-01-24&quot;=&gt;(205/864)}
||&lt;
経過時間はRationalで表されています


**フォーマットを用意して集計データを出力する
最後に
出力用のフォーマットメソッドformat_forを用意します

&gt;|ruby|
 require &quot;term/ansicolor&quot;

 def format_for(name, times_by_date, w=20)
   times = times_by_date.map { |date, fractime| [date, frac2time(fractime)] }
   total = frac2time times_by_date.map(&amp;:last).inject(:+)
   [
     &quot;#{name}:&quot;.cyan,
     times.map { |date, time| &quot;#{date}: #{time}&quot;.rjust(w) }.sort,
     &quot;Total: #{total}&quot;.rjust(w).magenta,
     &quot;-&quot;*w
   ]
 end

 def frac2time(fractime, opt=[:h,:m])
   label = [:h, :m, :s, :f]
   hmsf = Date.send(:day_fraction_to_time, fractime)
   Hash[label.zip hmsf].select { |k, v| opt.include? k }
                       .values.map { |v| format &quot;%02d&quot;, v }.join(':')
 end
||&lt;


このメソッドは案件名と日付ごとの集計時間を取って
経過時間をhr:min:secのフォーマットに変換し(frac2time)
総経過時間を計算し(total)
rjustを使って出力用にフォーマットします
折角ですからterm-ansicolorで色付けしています


さあこれらをまとめて実働時間を集計する
worktime.rbの完成です!


&lt;script src=&quot;https://gist.github.com/1670234.js?file=worktime.rb&quot;&gt;&lt;/script&gt;


出力はこんな感じになります!
[f:id:keyesberry:20120125210748p:image]


これであなたも私も
プロフェッショナル道まっしぐらですね!

</body>
</day>
<day date="2012-01-26" title="">
<body>
*p1*Rubyで序数を生成する
id:Naruhodiusさんに倣って僕もやってみました:)
&gt;|ruby|
class Integer
  def ordinalize
    suffix =
      if (fd=abs%10).between?(1,3) &amp;&amp; !abs.between?(11,13)
        %w(_ st nd rd)[fd]
      else
        'th'
      end
    &quot;#{self}&quot; + suffix
  end
end

(-25..25).map(&amp;:ordinalize) # =&gt; [&quot;-25th&quot;, &quot;-24th&quot;, &quot;-23rd&quot;, &quot;-22nd&quot;, &quot;-21st&quot;, &quot;-20th&quot;, &quot;-19th&quot;, &quot;-18th&quot;, &quot;-17th&quot;, &quot;-16th&quot;, &quot;-15th&quot;, &quot;-14th&quot;, &quot;-13th&quot;, &quot;-12th&quot;, &quot;-11th&quot;, &quot;-10th&quot;, &quot;-9th&quot;, &quot;-8th&quot;, &quot;-7th&quot;, &quot;-6th&quot;, &quot;-5th&quot;, &quot;-4th&quot;, &quot;-3rd&quot;, &quot;-2nd&quot;, &quot;-1st&quot;, &quot;0th&quot;, &quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;, &quot;4th&quot;, &quot;5th&quot;, &quot;6th&quot;, &quot;7th&quot;, &quot;8th&quot;, &quot;9th&quot;, &quot;10th&quot;, &quot;11th&quot;, &quot;12th&quot;, &quot;13th&quot;, &quot;14th&quot;, &quot;15th&quot;, &quot;16th&quot;, &quot;17th&quot;, &quot;18th&quot;, &quot;19th&quot;, &quot;20th&quot;, &quot;21st&quot;, &quot;22nd&quot;, &quot;23rd&quot;, &quot;24th&quot;, &quot;25th&quot;]
||&lt;


ActiveSupport::Inflector::Inflectionsに
ordinalizeメソッドというのがあるみたいですね


http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html#method-i-ordinalize

</body>
</day>
<day date="2012-01-27" title="">
<body>
*p1*RubyでCash Registerを解く-CodeEval
ループで繰り返し引いて
丸め誤差の問題でちょっと..
整数化してやったほうがいいの？


お釣りをコインとお札で
&lt;script src=&quot;https://gist.github.com/1662022.js?file=cash_register.rb&quot;&gt;&lt;/script&gt;


Double Squaresを残してModerate終了
できそうもない..

*p2*RubyでPrime Numbersを解く-CodeEval
Enumeratorをtake_whileして


指定数までの素数列
&lt;script src=&quot;https://gist.github.com/1662022.js?file=prime_less.rb&quot;&gt;&lt;/script&gt;

*p3*RubyでReverse and Addを解く-CodeEval
回文になるまでループして


数字をひっくり返して足すことを繰り返して
回文になる回数
&lt;script src=&quot;https://gist.github.com/1662022.js?file=reverse_add.rb&quot;&gt;&lt;/script&gt;

*p4*RubyでJolly Jumpersを解く-CodeEval
Array#each_consを使って


並びの数字の差が3 2 1となってるものを
Jolly Jumperというらしい
&lt;script src=&quot;https://gist.github.com/1662022.js?file=jolly_jumpers.rb&quot;&gt;&lt;/script&gt;


*p5*RubyでArray Absurdityを解く-CodeEval
余計な条件がよくわからない..


数字列中の重複を見つける
&lt;script src=&quot;https://gist.github.com/1662022.js?file=array_absurdity.rb&quot;&gt;&lt;/script&gt;


*p6*RubyでEmail Validationを解く-CodeEval
本気じゃないよね？
適当なところで


メールアドレスの正規表現
&lt;script src=&quot;https://gist.github.com/1662022.js?file=email_regex.rb&quot;&gt;&lt;/script&gt;
*p7*RubyでNumber Pairsを解く-CodeEval
Array#combinationを使って


数字列から合計が指定数になる数字のペアを見つける
&lt;script src=&quot;https://gist.github.com/1662022.js?file=number_pairs.rb&quot;&gt;&lt;/script&gt;


*p8*RubyでTrailing Stringを解く-CodeEval
ワンライナーで:)


文字列中のサブ文字列を見つける
&lt;script src=&quot;https://gist.github.com/1662022.js?file=sameend.rb&quot;&gt;&lt;/script&gt;



*p9*RubyでDecimal To Binaryを解く-CodeEval


10進数を2進数に
&lt;script src=&quot;https://gist.github.com/1662022.js?file=dec2bin.rb&quot;&gt;&lt;/script&gt;


*p10*RubyでSum of integersを解く-CodeEval
ループで全組合せを作ってArray#max


数字の並びにおける連続する数字群の最大値
&lt;script src=&quot;https://gist.github.com/1662022.js?file=largest_sum.rb&quot;&gt;&lt;/script&gt;



*p11*RubyでNumber of Onesを解く-CodeEval
String#countで


数字の２進表現の1ビットの数
&lt;script src=&quot;https://gist.github.com/1662022.js?file=num_of_ones.rb&quot;&gt;&lt;/script&gt;

*p12*RubyでEndiannessを解く-CodeEval
Array#packを使って


システムのエンディアン
&lt;script src=&quot;https://gist.github.com/1662022.js?file=endian.rb&quot;&gt;&lt;/script&gt;


*p13*RubyでRemove Charactersを解く-CodeEval
String#deleteで


文字列から指定文字を除く
&lt;script src=&quot;https://gist.github.com/1662022.js?file=remove_chars.rb&quot;&gt;&lt;/script&gt;



*p14*RubyでFirst Non-Repeated Characterを解く-CodeEval
Enumerable#detectで


文字列中の繰り返さない最初の文字
&lt;script src=&quot;https://gist.github.com/1662022.js?file=nrc.rb&quot;&gt;&lt;/script&gt;

*p15*RubyでLowest Common Ancestorを解く-CodeEval
いやいやもっと簡単な方法があるはずだ


バイナリーツリーの共通の親を見つける
&lt;script src=&quot;https://gist.github.com/1662022.js?file=lca.rb&quot;&gt;&lt;/script&gt;

*p16*RubyでMth to last elementを解く-CodeEval


アルファベットの並びにおける位置
&lt;script src=&quot;https://gist.github.com/1662022.js?file=m2last.rb&quot;&gt;&lt;/script&gt;


*p17*RubyでStack Implementationを解く-CodeEval
どうすりゃいいのか


スタックを実装する
&lt;script src=&quot;https://gist.github.com/1662022.js?file=stack.rb&quot;&gt;&lt;/script&gt;

*p18*RubyでPangramsを解く-CodeEval
Array#-を使って


文字列がパングラムか判定する
&lt;script src=&quot;https://gist.github.com/1662022.js?file=pangrams.rb&quot;&gt;&lt;/script&gt;


*p19*RubyでDetecting Cyclesを解く-CodeEval
ループを使って
綺麗にかけない..


文字の並び中の繰り返しを見つける
&lt;script src=&quot;https://gist.github.com/1662022.js?file=cycle_detection.rb&quot;&gt;&lt;/script&gt;


*p20*RubyでLongest Linesを解く-CodeEval
ワンライナーで:)


先頭行の数だけ後続行から最長文字列を選ぶ
&lt;script src=&quot;https://gist.github.com/1662022.js?file=longestlines.rb&quot;&gt;&lt;/script&gt;


</body>
</day>
<day date="2012-02-03" title="">
<body>
*p4*RubyでString Searchingを解く-CodeEval
正規表現で半ば強引に


文字列に対する部分文字列の一致を見る
但し部分文字列中の*は0以上の文字にマッチ
&lt;script src=&quot;https://gist.github.com/1697463.js?file=substring.rb&quot;&gt;&lt;/script&gt;

*p1*RubyでString Permutationsを解く-CodeEval
Array#permutationを使って


単語文字の全順列
&lt;script src=&quot;https://gist.github.com/1697463.js?file=str_perm.rb&quot;&gt;&lt;/script&gt;


*p2*RubyでPrefix expressionsを解く-CodeEval
ほんとは構文解析して解くことが
期待されてるんだろうけど
正規表現で行けたので..


いわゆるポーランド記法の電卓
&lt;script src=&quot;https://gist.github.com/1697463.js?file=prefix.rb&quot;&gt;&lt;/script&gt;


*p3*RubyでLongest Common Subsequenceを解く-CodeEval
StringScannerを使って再帰的に
どこかにバグがあるようで50点^^;


２つのアルファベット列に共通する最長の並び
並びは連続していなくてもいい
&lt;script src=&quot;https://gist.github.com/1697463.js?file=lcs.rb&quot;&gt;&lt;/script&gt;


Hardになって急に難しくなってる..

</body>
</day>
<day date="2012-02-04" title="">
<body>
*p5*RubyでPalindromic Rangesを解く-CodeEval
またまたArray#permutationのお世話に..


与えられた2数を最小値と最大値とする
数字の並びにおける並びの組を考える
回文数が偶数個の組の数を答える
&lt;script src=&quot;https://gist.github.com/1697463.js?file=int_palindrome.rb&quot;&gt;&lt;/script&gt;


*p3*RubyでFollowing Integerを解く-CodeEval
Array#permutationを使って力技!


与えられた数の各桁の並び替えの組合せを
昇順に並べたとき与えられた数の次ぎに来る数を答える
但し各数には任意個数の0を挟める
&lt;script src=&quot;https://gist.github.com/1697463.js?file=next_number.rb&quot;&gt;&lt;/script&gt;


*p4*RubyでUgly Numbersを解く-CodeEval
ってまだ解けてません^^;
下のコードだと一応解答は得られるんだけど
5秒以上掛かるってことで0点です..


気にせず先に..


一桁の素数(2,3,5,7)で割れる数をUgly Numberという
D桁の数字の桁の間に+か-を挟むと3^D-1個の数字ができる
Ugly Numberの個数を求める
&lt;script src=&quot;https://gist.github.com/1697463.js?file=ugly_numbers.rb&quot;&gt;&lt;/script&gt;


*p2*RubyでString Listを解く-CodeEval
Array#repeated_permutationで^^;


文字列中の文字の全順列
&lt;script src=&quot;https://gist.github.com/1697463.js?file=string_list.rb&quot;&gt;&lt;/script&gt;

*p1*RubyでMessage Decodingを解く-CodeEval
まず問題を解読するのが大変orz..
どう見てもエレガントな解法じゃない..
特にheaderのsequenceを作る方法がヒドイ
どなたかスマートな解法を教えて下さい


文字列からなるheaderを使って01からなるmessageを解読する
headerの各文字はその位置にマッピングされた
01からなるkeyに対応付けられている
messageは複数のkeyを含む複数のsegmentからできていて
各segmentの最初の3桁がそのsegment内のkeyの長さを表す
&lt;script src=&quot;https://gist.github.com/1697463.js?file=message_decoding.rb&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2012-02-08" title="">
<body>
*p1*第2弾!知って得する12のRubyのトリビアな記法 ~ 12 Trivia Notations you should know in Ruby

半年くらい前にちょっとトリビアだけど
知っていると意外と便利なRubyの記法を21個紹介したよ


[http://d.hatena.ne.jp/keyesberry/20110622/p1:title=知って得する21のRubyのトリビアな記法 ~ 21 Trivia Notations you should know in Ruby - hp12c][http://d.hatena.ne.jp/keyesberry/20110622/p1:bookmark]


今回はその第2弾だよ!
ちょっと数が少ないけど
知らないものがあったらへーとかほーとか
得したとか言ってもらえるとうれしいよ


**1.Enumerator#with_index
任意のリストを標準出力するときに
連番を同時に振るとしたら
普通はEnumerable#each_with_indexを使うよね

&gt;|ruby|
names = Module.constants.take(10)
names.each_with_index { |name, i| puts &quot;%d: %s&quot; % [i+1, name] } # =&gt; [:Object, :Module, :Class, :Kernel, :NilClass, :NIL, :Data, :TrueClass, :TRUE, :FalseClass]
# &gt;&gt; 1: Object
# &gt;&gt; 2: Module
# &gt;&gt; 3: Class
# &gt;&gt; 4: Kernel
# &gt;&gt; 5: NilClass
# &gt;&gt; 6: NIL
# &gt;&gt; 7: Data
# &gt;&gt; 8: TrueClass
# &gt;&gt; 9: TRUE
# &gt;&gt; 10: FalseClass
||&lt;

でも'i+1'ってのがイマイチ..って人いる？
そんな人にはEnumerator#with_indexがあるよ
&gt;|ruby|
names = Module.constants.take(10)
names.each.with_index(1) { |name, i| puts &quot;%d: %s&quot; % [i, name] } # =&gt; [:Object, :Module, :Class, :Kernel, :NilClass, :NIL, :Data, :TrueClass, :TRUE, :FalseClass]
# &gt;&gt; 1: Object
# &gt;&gt; 2: Module
# &gt;&gt; 3: Class
# &gt;&gt; 4: Kernel
# &gt;&gt; 5: NilClass
# &gt;&gt; 6: NIL
# &gt;&gt; 7: Data
# &gt;&gt; 8: TrueClass
# &gt;&gt; 9: TRUE
# &gt;&gt; 10: FalseClass
||&lt;
with_indexはindexのoffsetを引数に取れるよ
comparableなオブジェクトが
取れたらもっとよかったのにね


**2.Integer#times
timesは処理を特定回数だけ
繰り返したいときに使うよね
&gt;|ruby|
you_said = 'てぶくろ'
6.times { puts you_said.reverse! } # =&gt; 6
# &gt;&gt; ろくぶて
# &gt;&gt; てぶくろ
# &gt;&gt; ろくぶて
# &gt;&gt; てぶくろ
# &gt;&gt; ろくぶて
# &gt;&gt; てぶくろ
||&lt;

timesはブロックを渡さないとEnumeratorを返すよ
だから
複数のオブジェクトを生成するようなことにも使えるんだよ
20個のRGBカラーサンプルを作ってみるよ
&gt;|ruby|
20.times.map { [rand(256), rand(256), rand(256)] } # =&gt; [[45, 190, 194], [94, 43, 125], [6, 104, 181], [144, 92, 114], [34, 161, 214], [96, 69, 241], [216, 246, 133], [6, 237, 131], [194, 95, 214], [177, 252, 202], [184, 149, 142], [184, 166, 45], [41, 108, 115], [176, 100, 138], [124, 213, 89], [173, 123, 34], [137, 31, 47], [54, 92, 186], [118, 239, 217], [150, 184, 240]]
||&lt;


**3.String#succ / Integer#succ
ExcelのAから始まる横のラベルを
作りたいんだけどどうする？って問題が最近あったよ
RubyにはString#succまたはnext
があるからこれは簡単だよ
&gt;|ruby|
col = '@'
60.times.map { col = col.succ } # =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;AC&quot;, &quot;AD&quot;, &quot;AE&quot;, &quot;AF&quot;, &quot;AG&quot;, &quot;AH&quot;, &quot;AI&quot;, &quot;AJ&quot;, &quot;AK&quot;, &quot;AL&quot;, &quot;AM&quot;, &quot;AN&quot;, &quot;AO&quot;, &quot;AP&quot;, &quot;AQ&quot;, &quot;AR&quot;, &quot;AS&quot;, &quot;AT&quot;, &quot;AU&quot;, &quot;AV&quot;, &quot;AW&quot;, &quot;AX&quot;, &quot;AY&quot;, &quot;AZ&quot;, &quot;BA&quot;, &quot;BB&quot;, &quot;BC&quot;, &quot;BD&quot;, &quot;BE&quot;, &quot;BF&quot;, &quot;BG&quot;, &quot;BH&quot;]
||&lt;


**4.Comparable.between?
値が一定範囲内にあるかどうかで
処理を切り分けたいことってあるよね？
たぶん普通はこうするよ
&gt;|ruby|
pos = 48
status =
  if 0 &lt;= pos &amp;&amp; pos &lt;= 50
    :you_are_in
  else
    :you_are_out
  end
status # =&gt; :you_are_in
||&lt;

でCoffeeScriptを見て悔しがるんだよね
でも安心していいよ
Rubyにはbetween?があるんだから
&gt;|ruby|
pos = 48
status =
  if pos.between?(0, 50)
    :you_are_in
  else
    :you_are_out
  end
status # =&gt; :you_are_in


pos = 'D'
grade =
  if pos.between?('A', 'C')
    :you_are_good!
  else
    :try_again!
  end
grade # =&gt; :try_again!
||&lt;

もっとも僕はcase派ですが..
&gt;|ruby|
pos = 48
status =
  case pos
  when 0..50
    :you_are_in
  else
    :you_are_out
  end
status # =&gt; :you_are_in
||&lt;


**5.Array#uniq
配列の全要素が同じかどうかを
調べたいときはどうする？
そんなときはArray#uniqが使えるよ
&gt;|ruby|
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1].uniq.size==1 # =&gt; true
[1, 1, 1, 1, 1, 1, 1, 2, 1, 1].uniq.size==1 # =&gt; false
%w(street retest setter tester).uniq { |w| w.chars.sort }.size==1 # =&gt; true
||&lt;


**6.BasicObject#instance_eval
instance_evalはオブジェクトの生成を
DSL風にするときに良く使われているよね

&gt;|ruby|
class Person
  def initialize(&amp;blk)
    instance_eval(&amp;blk)
  end

  def name(name)
    @name = name
  end

  def age(age)
    @age = age
  end

  def job(job)
    @job = job
  end

  def profile
    [@name, @age, @job] * '-'
  end
end

t = Person.new do
  name 'Charlie'
  age  13
  job  :programmer
end

t.profile # =&gt; &quot;Charlie-13-programmer&quot;
||&lt;

でも
このコンテキストを一時的に切り替えるって機能は
DSL以外でも便利に使えるんだ
例えばテストの結果の平均値を求めてみるよ
普通はこう書くよね
&gt;|ruby|
scores = [56, 87, 49, 75, 90, 63, 65]
scores.inject(:+) / scores.size # =&gt; 69
||&lt;

短いコードで変数scoresが3回も..
instance_evalを使うと
scoreを消すことができるんだ
&gt;|ruby|
[56, 87, 49, 75, 90, 63, 65].instance_eval { inject(:+) / size } # =&gt; 69
||&lt;

さらに標準偏差sdを求めるよ
まず普通に
&gt;|ruby|
scores = [56, 87, 49, 75, 90, 63, 65]
avg = scores.inject(:+) / scores.size
sigmas = scores.map { |n| (avg - n)**2 }
sd = Math.sqrt(sigmas.inject(:+) / scores.size) # =&gt; 14.247806848775006
||&lt;

instance_evalで
&gt;|ruby|
scores = [56, 87, 49, 75, 90, 63, 65]
sd = scores.instance_eval do
  avg = inject(:+) / size
  sigmas = map { |n| (avg - n)**2 }
  Math.sqrt(sigmas.inject(:+) / size)
end
sd # =&gt; 14.247806848775006
||&lt;
中間的な変数をブロック内に閉じ込められるし
ブロックで式がまとまって見やすくない？


**7.Array#first/last
Array#first/lastは個数の引数を取れるよ
&gt;|ruby|
[*1..100].instance_eval { first(5) + last(5) } # =&gt; [1, 2, 3, 4, 5, 96, 97, 98, 99, 100]
||&lt;


**8.正規表現:名前付き参照
正規表現中で()を使うと部分マッチを捕捉できるよね
でそれに名前を付けたいときは?&lt;pattern&gt;を使えばいいよ
&gt;|ruby|
langs = &quot;python lisp ruby haskell erlang scala&quot;
m = langs.match(/(?&lt;lang&gt;\w+)/) # =&gt; #&lt;MatchData &quot;python&quot; lang:&quot;python&quot;&gt;
m['lang'] # =&gt; &quot;python&quot;
||&lt;

で正規表現リテラルを左辺にした場合は
これをローカル変数として持ち出せるんだよ
&gt;|ruby|
langs = &quot;python lisp ruby haskell erlang scala&quot;
if /(?&lt;most_fun_lang&gt;r\w+)/ =~ langs
  printf &quot;you should learn %s!&quot;, most_fun_lang
end
# &gt;&gt; you should learn ruby!
||&lt;
って正規表現てトリビアだらけだから
こんなこと言ってもしょうがないか..


**9.正規表現:POSIXブラケット
Ruby1.9では\wは日本語にマッチしなくなったよね
だから1.9で日本語にもマッチさせたいときは
POSIXブラケットでwordを使うといいかもね
&gt;|ruby|
need_japanese = &quot;this-日本語*is*_really_/\\変わってる!&quot;
need_japanese.scan(/\w+/) # =&gt; [&quot;this&quot;, &quot;is&quot;, &quot;_really_&quot;]
need_japanese.scan(/[[:word:]]+/) # =&gt; [&quot;this&quot;, &quot;日本語&quot;, &quot;is&quot;, &quot;_really_&quot;, &quot;変わってる&quot;]
||&lt;


**10.String#match
もう一つ正規表現を^^;
String#matchはMatchDataオブジェクトを返すから
次のように使えるよね
&gt;|ruby|
date = &quot;2012february14&quot;
m = date.match(/\D+/)
mon, day, year = m.to_s.capitalize, m.post_match, m.pre_match
&quot;#{mon} #{day}, #{year}&quot; # =&gt; &quot;February 14, 2012&quot;
||&lt;

でもmatchはブロックを取れるので
次のようにしてもいいよ
&gt;|ruby|
date = &quot;2012february14&quot;
mon, day, year = date.match(/\D+/) { |m| [m.to_s.capitalize, m.post_match, m.pre_match] }
&quot;#{mon} #{day}, #{year}&quot; # =&gt; &quot;February 14, 2012&quot;
||&lt;


**11.String#unpack
数字列を決まった長さ基準で区切りたいときはどうする？
正規表現を使うのかな
&gt;|ruby|
a_day = '20120214'
a_day.match(/(.{4})(.{2})(.{2})/).captures # =&gt; [&quot;2012&quot;, &quot;02&quot;, &quot;14&quot;]
||&lt;

String#unpackを使うともっと簡単かもね((@no6vさんより https://twitter.com/no6v/statuses/104161174823780352))
&gt;|ruby|
a_day = '20120214'
a_day.unpack('A4A2A2') # =&gt; [&quot;2012&quot;, &quot;02&quot;, &quot;14&quot;]
||&lt;


**12.DATA.rewind
DATAは__END__以降をFileとしたオブジェクトだよ
だからrewindクラスメソッドが使えるんだけど
これは__END__の最初の行に戻るんじゃなくて
ファイルのトップに戻るんだよ

だからこれを使えば
なんちゃってQuineができるんだ
&gt;|ruby|
#!/usr/bin/env ruby
require &quot;g&quot;
def evaluate(str)
  op = %w(\+ \* \/)
  digit = /-*\d+/
  if m = str.match(/(#{op})\s+(#{digit})\s+(#{digit})/)
    op, a, b = m.captures
    inner = a.to_i.send(op, b.to_i)
    str = m.pre_match + inner.to_s + m.post_match
    evaluate(str)
  else
    str
  end
end

g evaluate(&quot;+ * 3 4 5&quot;)

DATA.rewind
puts DATA.to_a
__END__
||&lt;
このコードを実行すると
evaluateの結果がgrowl出力されると共に
このコード自身が標準出力されるよ



今回はこれで終わりだよ


ほんとは21個溜めてから出したかったんだけど
今朝Peter Cooperさんのビデオを見てたら
同じトリビアが出てたから慌てて出してるんだよ^^;


[http://rubyreloaded.com/trickshots/:title=Ruby Trick Shots: A Video of 24 Ruby Tips and Tricks]

</body>
</day>
<day date="2012-02-09" title="">
<body>
*p1*RubyでFizzBuzz問題に終止符を打つ!
FizzBuzz問題はプログラマーが最初に出会う問題だよ
FizzBuzzの解法はプログラマーの数ほどあると言われているよ
でもいつまでもFizzBuzz問題に関わってたら
本当に解決しなければならない問題を解決できないよ


だから僕がFizzBuzz問題に終止符を打つよ!


つまり決定版というべき
FizzBuzzオブジェクトが一つあれば
もうみんながFizzBuzz問題に
頭を悩ませなくても済むはずなんだ


さあ!
&gt;|ruby|
class FB
  module Core
    def fb
      -&gt;base,n{ (n%base).zero? }.curry
    end
  end

  {FB:15, F:3, B:5}.each do |name, base|
    k = Class.new do
      extend Core
      define_singleton_method(:===) do |n|
        fb[base, n]
      end
    end
    const_set(name, k)
  end
  extend Core
end

def fizzbuzz(n)
  case n
  when FB::FB; :FizzBuzz
  when FB::F; :Fizz
  when FB::B; :Buzz
  else n
  end
end

(1..100).map { |i| fizzbuzz i } # =&gt; [1, 2, :Fizz, 4, :Buzz, :Fizz, 7, 8, :Fizz, :Buzz, 11, :Fizz, 13, 14, :FizzBuzz, 16, 17, :Fizz, 19, :Buzz, :Fizz, 22, 23, :Fizz, :Buzz, 26, :Fizz, 28, 29, :FizzBuzz, 31, 32, :Fizz, 34, :Buzz, :Fizz, 37, 38, :Fizz, :Buzz, 41, :Fizz, 43, 44, :FizzBuzz, 46, 47, :Fizz, 49, :Buzz, :Fizz, 52, 53, :Fizz, :Buzz, 56, :Fizz, 58, 59, :FizzBuzz, 61, 62, :Fizz, 64, :Buzz, :Fizz, 67, 68, :Fizz, :Buzz, 71, :Fizz, 73, 74, :FizzBuzz, 76, 77, :Fizz, 79, :Buzz, :Fizz, 82, 83, :Fizz, :Buzz, 86, :Fizz, 88, 89, :FizzBuzz, 91, 92, :Fizz, 94, :Buzz, :Fizz, 97, 98, :Fizz, :Buzz]
||&lt;

FB::FBクラスはfizzbuzzを
FB::Fクラスはfizzを
FB::Bクラスはbuzzをそれぞれ判定するクラスオブジェクトだよ
各クラスは===クラスメソッドでfizzbuzzの判定をするから
case式における比較判定にそのまま使えるんだ


またFBクラスのfbクラスメソッドは
次のように使えるよ
&gt;|ruby|
fizzbuzz = FB.fb[15]
fizz = FB.fb[3]

fizzbuzz[15] # =&gt; true
fizzbuzz[16] # =&gt; false
fizz[6] # =&gt; true
fizz[7] # =&gt; false
||&lt;


また一つFizzBuzzを増やしただけだった..
ゴメンナサイm(__)m

</body>
</day>
<day date="2012-02-10" title="">
<body>
*p2*RubyでTelephone Wordsを解く-CodeEval
Array#productを使って^^;


与えられた7桁の電話番号に対する
各数字に割り当てられたアルファベットでの全組み合わせ
&lt;script src=&quot;https://gist.github.com/1697463.js?file=telephone_words.rb&quot;&gt;&lt;/script&gt;

*p1*RubyでClosest Pairを解く-CodeEval
Enumerable#chunkでsetを分けて
Array#combinationで


与えられた複数の座標間の最短を求める
&lt;script src=&quot;https://gist.github.com/1697463.js?file=closest_pair.rb&quot;&gt;&lt;/script&gt;
</body>
</day>
<day date="2012-02-11" title="">
<body>
*p1*RubyのEnumerable#mapをもっと便利にしたいよ
次のような名前のリストがあって
&gt;|ruby|
langs = [&quot;ruby&quot;, &quot;python&quot;, &quot;lisp&quot;, &quot;haskell&quot;]
||&lt;
名前の先頭を大文字にするとしたら
君ならどうする？


そう普通Enumerable#mapを使って
次のようにするよね
&gt;|ruby|
langs = [&quot;ruby&quot;, &quot;python&quot;, &quot;lisp&quot;, &quot;haskell&quot;]

langs.map { |lang| lang.capitalize } # =&gt; [&quot;Ruby&quot;, &quot;Python&quot;, &quot;Lisp&quot;, &quot;Haskell&quot;]
||&lt;

Enumerable#mapってほんと死ぬほど便利だよ
僕はRubyの魅力の80％は
mapが占めてるんじゃないかって
たまに感じることがあるよ.. :)


でもただ先の例で
大文字にするだけなのにブロックって
ちょっと大げさすぎると思わない？


もちろんそうなんだよ
そう思うRubyistが沢山いたから
mapは次のように書けるようにもなってるんだ
&gt;|ruby|
langs = [&quot;ruby&quot;, &quot;python&quot;, &quot;lisp&quot;, &quot;haskell&quot;]

langs.map(&amp;:capitalize) # =&gt; [&quot;Ruby&quot;, &quot;Python&quot;, &quot;Lisp&quot;, &quot;Haskell&quot;]
||&lt;

シンボルに&amp;を付けてmapに渡すと
暗黙的にSymbol#to_procが呼ばれて
そこで配列の各要素にcapitalizeが適用されるよ
この記法のお陰でmapは一層使い勝手が良くなってるよ


じゃあ今度は先の言語名のリストから
その「言語使いのリスト」に変換してほしいんだけど..
つまり言語名の後に'ist'を付けてほしいんだ((怒らないで!))


そう次のようにするよね
&gt;|ruby|
langs = [&quot;ruby&quot;, &quot;python&quot;, &quot;lisp&quot;, &quot;haskell&quot;].map(&amp;:capitalize)

langs.map { |lang| lang + 'ist' } # =&gt; [&quot;Rubyist&quot;, &quot;Pythonist&quot;, &quot;Lispist&quot;, &quot;Haskellist&quot;]
||&lt;

これって悔しいよね
'ist'を足すだけなのに
またブロックを書かなきゃいけない


同じように次のような場合も
ブロックを書かなきゃいけない
&gt;|ruby|
[1, 2, 3].map { |i| i + 10 } # =&gt; [11, 12, 13]

(1..5).map { |i| i**2 } # =&gt; [1, 4, 9, 16, 25]

[[1,2,3,4], [5,6,7,8], [9,10,11,12]].map { |arr| arr.last(2) } # =&gt; [[3, 4], [7, 8], [11, 12]]

[&quot;ruby&quot;, &quot;python&quot;, &quot;lisp&quot;, &quot;haskell&quot;].map { |lang| lang[-2, 2] } # =&gt; [&quot;by&quot;, &quot;on&quot;, &quot;sp&quot;, &quot;ll&quot;]
||&lt;


僕はすごく悔しいよ..


そんなわけで..


Enumerable#mappを考えたよ!
&gt;|ruby|
module Enumerable
  def mapp(op=nil, *args, &amp;blk)
    op ? map { |e| op.intern.to_proc[e, *args]} : map(&amp;blk)
  end
end

langs.mapp(:+, 'ist') # =&gt; [&quot;Rubyist&quot;, &quot;Pythonist&quot;, &quot;Lispist&quot;, &quot;Haskellist&quot;]
||&lt;
つまりmappでは引数にメソッドと
その引数が取れるんだ


&gt;|ruby|
[1, 2, 3].mapp(:+, 10) # =&gt; [11, 12, 13]

(1..5).mapp(:**, 2) # =&gt; [1, 4, 9, 16, 25]

[[1,2,3,4], [5,6,7,8], [9,10,11,12]].mapp(:last, 2) # =&gt; [[3, 4], [7, 8], [11, 12]]

[&quot;ruby&quot;, &quot;python&quot;, &quot;lisp&quot;, &quot;haskell&quot;].mapp(:[], -2, 2) # =&gt; [&quot;by&quot;, &quot;on&quot;, &quot;sp&quot;, &quot;ll&quot;]
||&lt;


ブロックを渡せばmapに処理を投げるから
mapの代わりとしても使えるよ
&gt;|ruby|
[1, 2, 3].mapp { |i| i + 10 } # =&gt; [11, 12, 13]

(1..5).mapp { |i| i**2 } # =&gt; [1, 4, 9, 16, 25]

[[1,2,3,4], [5,6,7,8], [9,10,11,12]].mapp { |arr| arr.last(2) } # =&gt; [[3, 4], [7, 8], [11, 12]]

[&quot;ruby&quot;, &quot;python&quot;, &quot;lisp&quot;, &quot;haskell&quot;].mapp { |lang| lang[-2, 2] } # =&gt; [&quot;by&quot;, &quot;on&quot;, &quot;sp&quot;, &quot;ll&quot;]
||&lt;


誰でも考えそうだから
既出のアイディアだったらゴメンね


って
もっと高度なことをまめさんがしてました^^;
[http://d.hatena.ne.jp/ku-ma-me/20090312/p1:title=map が面倒なので DelegateMap - まめめも]


まあ折角書いたから..
ゴメンナサイm(__)m


関連記事:[http://d.hatena.ne.jp/keyesberry/20080917/p1:title=RubyのSymbol#to_procを考えた人になってみる - hp12c]


(追記:2012-2-14)Twitterを通してすごい荒業を知ったよ((https://twitter.com/tmaeda/statuses/168380640734085120))
&gt;|ruby|
 [1,2,3].map(&amp;1.method(:+)) #=&gt; [2,3,4]
||&lt;
スゴイね!
でもメソッド呼び出しのオブジェクトが
引数と入れ替わっちゃってるから:+, :*くらいしか
用途がなさそうだけどね..

</body>
</day>
<day date="2012-02-13" title="">
<body>
*p1*RubyでType Aheadを解く-CodeEval
一応パスしたけど75点^^;
Trigramのアルゴリズムが怪しいので
多分そこが問題
まあ良として先に


N-gramを使って特定ワードの
次ぎに来るワードの確率リストを出力
&lt;script src=&quot;https://gist.github.com/1697463.js?file=type_ahead.rb&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2012-02-14" title="">
<body>
*p2*RubyでRepeated Substringを解く-CodeEval
バグ入りで80点^^;
入出力情報少なすぎてバグ特定できない..
まあいっか
str.gsub(substr).to_aという技を閃いた


文字列中に繰り返し現れる最長の部分文字列
&lt;script src=&quot;https://gist.github.com/1697463.js?file=repeated_substr.rb&quot;&gt;&lt;/script&gt;


*p1*RubyでSpiral Printingを解く-CodeEval
もっと賢いやり方があると思う
座標系を回転させるとか
でもまあ一応パスということで..
EnumeratorでSpiralSequenceを作って


2次元配列の要素をスパイラルな順序で出力
&lt;script src=&quot;https://gist.github.com/1697463.js?file=spiral_printing.rb&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2012-02-16" title="">
<body>
*p1*RubyでText Dollarを解く-CodeEval
なんか想像以上に手こずったよ^^;
case式内が見苦しい..
もっと簡単なやり方あるんだろうな
Integer#dollarizeを定義してみた


数字を英語のドル表記に変換
&lt;script src=&quot;https://gist.github.com/1697463.js?file=print_check.rb&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2012-02-18" title="">
<body>
*p1*RubyでLevenshtein Distanceを解く-CodeEval
できません..
アルゴリズム的にはできてるんだけど(('causes'の解答が一致した))
答えを得るのに1時間とかorz..
5秒で答えなきゃいけないのに
あとグローバル変数を使ってしまった


どうも高速化は苦手です
そこに注力する気がなかなか起きない..


レーベンシュタイン距離が1の語同士をfriendとして
与えられた辞書におけるhelloの語から始まる
friendの輪に含まれるすべての語の数を答える
&lt;script src=&quot;https://gist.github.com/1697463.js?file=levenshtein_distance.rb&quot;&gt;&lt;/script&gt;

</body>
</day>
<day date="2012-02-23" title="">
<body>
*p1*Rubyの四則演算をもっと便利にしたいよ!
この間RubyのEnumerable#mapを便利にした
Enumerable#mappを紹介したよ


[http://d.hatena.ne.jp/keyesberry/20120211/p1:title=RubyのEnumerable#mapをもっと便利にしたいよ - hp12c]

&gt;|ruby|
module Enumerable
  def mapp(op=nil, *args, &amp;blk)
    op ? map { |e| op.intern.to_proc[e, *args]} : map(&amp;blk)
  end
end

langs = [&quot;Ruby&quot;, &quot;Python&quot;, &quot;Lisp&quot;, &quot;Haskell&quot;]
langs.mapp(:+, 'ist') # =&gt; [&quot;Rubyist&quot;, &quot;Pythonist&quot;, &quot;Lispist&quot;, &quot;Haskellist&quot;]

[1, 2, 3].mapp(:+, 10) # =&gt; [11, 12, 13]

(1..5).mapp(:**, 2) # =&gt; [1, 4, 9, 16, 25]

[[1,2,3,4], [5,6,7,8], [9,10,11,12]].mapp(:last, 2) # =&gt; [[3, 4], [7, 8], [11, 12]]

[&quot;ruby&quot;, &quot;python&quot;, &quot;lisp&quot;, &quot;haskell&quot;].mapp(:[], -2, 2) # =&gt; [&quot;by&quot;, &quot;on&quot;, &quot;sp&quot;, &quot;ll&quot;]
||&lt;


で今日またこれに関連して
別のアイディアを思いついたよ
&gt;&gt;
それはここまで来たらもうmappは
要らないんじゃないかってことなんだ
&lt;&lt;


つまり四則演算に限定されちゃうけど
以下の構文でmapp相当のことができたら((this is footnote))
面白いと思ったんだ
&gt;|ruby|
%w(Ruby Python Lisp Haskel) + 'ist' # =&gt; [&quot;Rubyist&quot;, &quot;Pythonist&quot;, &quot;Lispist&quot;, &quot;Haskelist&quot;]

[1, 2, 3, 4] + 10 # =&gt; [11, 12, 13, 14]
[1, 2, 3, 4] + 5.5 # =&gt; [6.5, 7.5, 8.5, 9.5]
[1, 2, 3, 4] - 10 # =&gt; [-9, -8, -7, -6]
[1, 2, 3, 4] * 2 # =&gt; [2, 4, 6, 8]
[1, 2, 3, 4] / 2.0 # =&gt; [0.5, 1.0, 1.5, 2.0]
[1, 2, 3, 4] ** 2 # =&gt; [1, 4, 9, 16]
||&lt;

割と違和感がないと思うんだけどどうかな？


実装はこんな感じだよ
&gt;|ruby|
class Array
  {:+ =&gt; :plus, :- =&gt; :minus, :* =&gt; :multi}.each do |op, rep|
    alias :&quot;__#{rep}__&quot; :&quot;#{op}&quot;
    define_method(op) do |other|
      case other
      when String, Numeric
        map { |elm| elm.send(op, other) }
      else
        self.send(&quot;__#{rep}__&quot;, other)
      end
    end
  end

  %w(/ **).each do |op|
    define_method(op) do |other|
      map { |elm| elm.send(op, other) }
    end
  end
end
||&lt;

まあ元のArray#*(Integer)が死んじゃうんだけど..


ちなみにネストした配列でも有効だよ
&gt;|ruby|
[[1,2],[3,4]] ** 2 # =&gt; [[1, 4], [9, 16]]
[%w(child neighbor), %w(brother false)] + 'hood' # =&gt; [[&quot;childhood&quot;, &quot;neighborhood&quot;], [&quot;brotherhood&quot;, &quot;falsehood&quot;]]
||&lt;


ついでに逆も定義してみるよ
&gt;|ruby|
class String
  alias :__plus__ :+
  def +(other)
    case other
    when Array
      other.map { |o| self + o }
    else
      self.__plus__(other)
    end
  end
end

'ruby' + 'ist' # =&gt; &quot;rubyist&quot;
'ruby' + ['ist', 'er', 'mate'] # =&gt; [&quot;rubyist&quot;, &quot;rubyer&quot;, &quot;rubymate&quot;]
||&lt;


まあネタ止まりかな..

</body>
</day>
</diary>
